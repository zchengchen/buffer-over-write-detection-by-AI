[
    {
        "commit_sha": "077e305de7e7f7a960d0ad440e7ed66f3da5a5ce",
        "commit_index": "Commit 190",
        "commit_diff": "Diff:\n@@ -471,3 +471,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\n ff3afd1ce6a6b65057741df442adfaa71a0e2588 release-1.23.3\n+ac779115ed6ee4f3039e9aea414a54e560450ee2 release-1.23.4\nDiff:\n@@ -5,6 +5,20 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.24.0\" date=\"2023-04-11\">\n+\n+<change>\n+<para lang=\"ru\">\n+Стабильная ветка 1.24.x.\n+</para>\n+<para lang=\"en\">\n+1.24.x stable branch.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.4\" date=\"2023-03-28\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023004\n-#define NGINX_VERSION      \"1.23.4\"\n+#define nginx_version      1024000\n+#define NGINX_VERSION      \"1.24.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "63751b71887b4514116a67075d82b1d1ad715b16",
        "commit_index": "Commit 189",
        "commit_diff": "Diff:\n@@ -5,6 +5,163 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.4\" date=\"2023-03-28\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь протокол TLSv1.3 разрешён по умолчанию.\n+</para>\n+<para lang=\"en\">\n+now TLSv1.3 protocol is enabled by default.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx выдаёт предупреждение\n+при переопределении параметров listen-сокета, задающих используемые протоколы.\n+</para>\n+<para lang=\"en\">\n+now nginx issues a warning\n+if protocol parameters of a listening socket are redefined.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь, если клиент использует pipelining,\n+nginx закрывает соединения с ожиданием дополнительных данных (lingering close).\n+</para>\n+<para lang=\"en\">\n+now nginx closes connections with lingering\n+if pipelining was used by the client.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+поддержка byte ranges для ответов модуля ngx_http_gzip_static_module.\n+</para>\n+<para lang=\"en\">\n+byte ranges support in the ngx_http_gzip_static_module.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+диапазоны портов в директиве listen не работали;\n+ошибка появилась в 1.23.3.<br/>\n+Спасибо Валентину Бартеневу.\n+</para>\n+<para lang=\"en\">\n+port ranges in the \"listen\" directive did not work;\n+the bug had appeared in 1.23.3.<br/>\n+Thanks to Valentin Bartenev.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+для обработки запроса мог быть выбран неверный location,\n+если в конфигурации использовался\n+префиксный location длиннее 255 символов.\n+</para>\n+<para lang=\"en\">\n+incorrect location might be chosen to process a request\n+if a prefix location longer than 255 characters\n+was used in the configuration.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+не-ASCII символы в именах файлов на Windows\n+не поддерживались модулями ngx_http_autoindex_module и\n+ngx_http_dav_module, а также директивой include.\n+</para>\n+<para lang=\"en\">\n+non-ASCII characters in file names on Windows were not supported\n+by the ngx_http_autoindex_module, the ngx_http_dav_module,\n+and the \"include\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL\n+\"data length too long\", \"length too short\", \"bad legacy version\",\n+\"no shared signature algorithms\", \"bad digest length\",\n+\"missing sigalgs extension\", \"encrypted length too long\",\n+\"bad length\", \"bad key update\", \"mixed handshake and non handshake data\",\n+\"ccs received early\", \"data between ccs and finished\",\n+\"packet length too long\", \"too many warn alerts\", \"record too small\",\n+и \"got a fin before a ccs\"\n+понижен с уровня crit до info.\n+</para>\n+<para lang=\"en\">\n+the logging level of the\n+\"data length too long\", \"length too short\", \"bad legacy version\",\n+\"no shared signature algorithms\", \"bad digest length\",\n+\"missing sigalgs extension\", \"encrypted length too long\",\n+\"bad length\", \"bad key update\", \"mixed handshake and non handshake data\",\n+\"ccs received early\", \"data between ccs and finished\",\n+\"packet length too long\", \"too many warn alerts\", \"record too small\",\n+and \"got a fin before a ccs\" SSL errors\n+has been lowered from \"crit\" to \"info\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2 и директивы error_page\n+для перенаправления ошибок с кодом 400\n+могла происходить утечка сокетов.\n+</para>\n+<para lang=\"en\">\n+a socket leak might occur\n+when using HTTP/2 and the \"error_page\" directive\n+to redirect errors with code 400.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+сообщения об ошибках записи в syslog\n+не содержали информации о том, что\n+ошибки происходили в процессе записи в syslog.<br/>\n+Спасибо Safar Safarly.\n+</para>\n+<para lang=\"en\">\n+messages about logging to syslog errors\n+did not contain information\n+that the errors happened while logging to syslog.<br/>\n+Thanks to Safar Safarly.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании zlib-ng\n+в логах появлялись сообщения \"gzip filter failed to use preallocated memory\".\n+</para>\n+<para lang=\"en\">\n+\"gzip filter failed to use preallocated memory\" alerts appeared in logs\n+when using zlib-ng.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+in the mail proxy server.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.3\" date=\"2022-12-13\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1s\n+OPENSSL =\topenssl-1.1.1t\n ZLIB =\t\tzlib-1.2.13\n PCRE =\t\tpcre2-10.39\n \nDiff:\n@@ -57,6 +57,7 @@ typedef struct {\n     unsigned             nomem:1;\n     unsigned             buffering:1;\n     unsigned             zlib_ng:1;\n+    unsigned             state_allocated:1;\n \n     size_t               zin;\n     size_t               zout;\n@@ -514,17 +515,19 @@ ngx_http_gzip_filter_memory(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)\n     } else {\n         /*\n          * Another zlib variant, https://github.com/zlib-ng/zlib-ng.\n-         * It forces window bits to 13 for fast compression level,\n-         * uses 16-byte padding in one of window-sized buffers, and\n-         * uses 128K hash.\n+         * It used to force window bits to 13 for fast compression level,\n+         * uses (64 + sizeof(void*)) additional space on all allocations\n+         * for alignment, 16-byte padding in one of window-sized buffers,\n+         * and 128K hash.\n          */\n \n         if (conf->level == 1) {\n             wbits = ngx_max(wbits, 13);\n         }\n \n         ctx->allocated = 8192 + 16 + (1 << (wbits + 2))\n-                         + 131072 + (1 << (memlevel + 8));\n+                         + 131072 + (1 << (memlevel + 8))\n+                         + 4 * (64 + sizeof(void*));\n         ctx->zlib_ng = 1;\n     }\n }\n@@ -926,13 +929,16 @@ ngx_http_gzip_filter_alloc(void *opaque, u_int items, u_int size)\n \n     alloc = items * size;\n \n-    if (items == 1 && alloc % 512 != 0 && alloc < 8192) {\n-\n+    if (items == 1 && alloc % 512 != 0 && alloc < 8192\n+        && !ctx->state_allocated)\n+    {\n         /*\n          * The zlib deflate_state allocation, it takes about 6K,\n          * we allocate 8K.  Other allocations are divisible by 512.\n          */\n \n+        ctx->state_allocated = 1;\n+\n         alloc = 8192;\n     }\n \n"
    },
    {
        "commit_sha": "e1ec19c5e30a501ccf6276e3802cb1a5f1ae9845",
        "commit_index": "Commit 188",
        "commit_diff": "Diff:\n@@ -4473,8 +4473,9 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->upstream.ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                                 (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                                  |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                                  |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\nDiff:\n@@ -3734,8 +3734,9 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->upstream.ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                                 (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                                  |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                                  |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\nDiff:\n@@ -632,8 +632,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->reject_handshake, prev->reject_handshake, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n-                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                         (NGX_CONF_BITMASK_SET\n+                          |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                          |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n                          NGX_SSL_BUFSIZE);\nDiff:\n@@ -1875,8 +1875,9 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->upstream.ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                                 (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                                  |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                                  |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\nDiff:\n@@ -360,8 +360,9 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                          prev->prefer_server_ciphers, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n-                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                         (NGX_CONF_BITMASK_SET\n+                          |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                          |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);\n     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);\nDiff:\n@@ -2163,8 +2163,9 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                              (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                               |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                              (NGX_CONF_BITMASK_SET\n+                               |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                               |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers, \"DEFAULT\");\n \nDiff:\n@@ -703,8 +703,9 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                          prev->prefer_server_ciphers, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n-                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                         (NGX_CONF_BITMASK_SET\n+                          |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                          |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);\n     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);\n"
    },
    {
        "commit_sha": "21cb208116270515efcfaa302cd2b4c92a8a940f",
        "commit_index": "Commit 187",
        "commit_diff": "Diff:\n@@ -18,6 +18,7 @@\n static char *ngx_syslog_parse_args(ngx_conf_t *cf, ngx_syslog_peer_t *peer);\n static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer);\n static void ngx_syslog_cleanup(void *data);\n+static u_char *ngx_syslog_log_error(ngx_log_t *log, u_char *buf, size_t len);\n \n \n static char  *facilities[] = {\n@@ -67,7 +68,7 @@ ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer)\n     }\n \n     peer->hostname = &cf->cycle->hostname;\n-    peer->log = &cf->cycle->new_log;\n+    peer->logp = &cf->cycle->new_log;\n \n     peer->conn.fd = (ngx_socket_t) -1;\n \n@@ -289,6 +290,13 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n {\n     ssize_t  n;\n \n+    if (peer->log.handler == NULL) {\n+        peer->log = *peer->logp;\n+        peer->log.handler = ngx_syslog_log_error;\n+        peer->log.data = peer;\n+        peer->log.action = \"logging to syslog\";\n+    }\n+\n     if (peer->conn.fd == (ngx_socket_t) -1) {\n         if (ngx_syslog_init_peer(peer) != NGX_OK) {\n             return NGX_ERROR;\n@@ -306,7 +314,7 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n     if (n == NGX_ERROR) {\n \n         if (ngx_close_socket(peer->conn.fd) == -1) {\n-            ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+            ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                           ngx_close_socket_n \" failed\");\n         }\n \n@@ -324,25 +332,25 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n \n     fd = ngx_socket(peer->server.sockaddr->sa_family, SOCK_DGRAM, 0);\n     if (fd == (ngx_socket_t) -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_socket_n \" failed\");\n         return NGX_ERROR;\n     }\n \n     if (ngx_nonblocking(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_nonblocking_n \" failed\");\n         goto failed;\n     }\n \n     if (connect(fd, peer->server.sockaddr, peer->server.socklen) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       \"connect() failed\");\n         goto failed;\n     }\n \n     peer->conn.fd = fd;\n-    peer->conn.log = peer->log;\n+    peer->conn.log = &peer->log;\n \n     /* UDP sockets are always ready to write */\n     peer->conn.write->ready = 1;\n@@ -352,7 +360,7 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n failed:\n \n     if (ngx_close_socket(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n \n@@ -373,7 +381,30 @@ ngx_syslog_cleanup(void *data)\n     }\n \n     if (ngx_close_socket(peer->conn.fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n }\n+\n+\n+static u_char *\n+ngx_syslog_log_error(ngx_log_t *log, u_char *buf, size_t len)\n+{\n+    u_char             *p;\n+    ngx_syslog_peer_t  *peer;\n+\n+    p = buf;\n+\n+    if (log->action) {\n+        p = ngx_snprintf(buf, len, \" while %s\", log->action);\n+        len -= p - buf;\n+    }\n+\n+    peer = log->data;\n+\n+    if (peer) {\n+        p = ngx_snprintf(p, len, \", server: %V\", &peer->server.name);\n+    }\n+\n+    return p;\n+}\nDiff:\n@@ -18,7 +18,8 @@ typedef struct {\n     ngx_addr_t         server;\n     ngx_connection_t   conn;\n \n-    ngx_log_t         *log;\n+    ngx_log_t          log;\n+    ngx_log_t         *logp;\n \n     unsigned           busy:1;\n     unsigned           nohostname:1;\nDiff:\n@@ -327,7 +327,9 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos < s->buffer->last) {\n+        if (s->buffer->pos < s->buffer->last\n+            || s->connection->read->ready)\n+        {\n             ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n@@ -486,7 +488,9 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos < s->buffer->last) {\n+        if (s->buffer->pos < s->buffer->last\n+            || s->connection->read->ready)\n+        {\n             ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n@@ -821,7 +825,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos < s->buffer->last) {\n+        if (s->buffer->pos < s->buffer->last\n+            || s->connection->read->ready)\n+        {\n             ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n"
    },
    {
        "commit_sha": "1de21562711ac3c6dd6dd3e1aa33d4d48a567cd5",
        "commit_index": "Commit 186",
        "commit_diff": "Diff:\n@@ -66,6 +66,9 @@ ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer)\n         ngx_str_set(&peer->tag, \"nginx\");\n     }\n \n+    peer->hostname = &cf->cycle->hostname;\n+    peer->log = &cf->cycle->new_log;\n+\n     peer->conn.fd = (ngx_socket_t) -1;\n \n     peer->conn.read = &ngx_syslog_dummy_event;\n@@ -243,7 +246,7 @@ ngx_syslog_add_header(ngx_syslog_peer_t *peer, u_char *buf)\n     }\n \n     return ngx_sprintf(buf, \"<%ui>%V %V %V: \", pri, &ngx_cached_syslog_time,\n-                       &ngx_cycle->hostname, &peer->tag);\n+                       peer->hostname, &peer->tag);\n }\n \n \n@@ -292,9 +295,6 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n         }\n     }\n \n-    /* log syslog socket events with valid log */\n-    peer->conn.log = ngx_cycle->log;\n-\n     if (ngx_send) {\n         n = ngx_send(&peer->conn, buf, len);\n \n@@ -306,7 +306,7 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n     if (n == NGX_ERROR) {\n \n         if (ngx_close_socket(peer->conn.fd) == -1) {\n-            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+            ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                           ngx_close_socket_n \" failed\");\n         }\n \n@@ -324,24 +324,25 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n \n     fd = ngx_socket(peer->server.sockaddr->sa_family, SOCK_DGRAM, 0);\n     if (fd == (ngx_socket_t) -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_socket_n \" failed\");\n         return NGX_ERROR;\n     }\n \n     if (ngx_nonblocking(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_nonblocking_n \" failed\");\n         goto failed;\n     }\n \n     if (connect(fd, peer->server.sockaddr, peer->server.socklen) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       \"connect() failed\");\n         goto failed;\n     }\n \n     peer->conn.fd = fd;\n+    peer->conn.log = peer->log;\n \n     /* UDP sockets are always ready to write */\n     peer->conn.write->ready = 1;\n@@ -351,7 +352,7 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n failed:\n \n     if (ngx_close_socket(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n \n@@ -372,7 +373,7 @@ ngx_syslog_cleanup(void *data)\n     }\n \n     if (ngx_close_socket(peer->conn.fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n }\nDiff:\n@@ -9,14 +9,19 @@\n \n \n typedef struct {\n-    ngx_uint_t        facility;\n-    ngx_uint_t        severity;\n-    ngx_str_t         tag;\n-\n-    ngx_addr_t        server;\n-    ngx_connection_t  conn;\n-    unsigned          busy:1;\n-    unsigned          nohostname:1;\n+    ngx_uint_t         facility;\n+    ngx_uint_t         severity;\n+    ngx_str_t          tag;\n+\n+    ngx_str_t         *hostname;\n+\n+    ngx_addr_t         server;\n+    ngx_connection_t   conn;\n+\n+    ngx_log_t         *log;\n+\n+    unsigned           busy:1;\n+    unsigned           nohostname:1;\n } ngx_syslog_peer_t;\n \n \nDiff:\n@@ -1794,14 +1794,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n \n     /* TODO Optimization: validate headers while parsing. */\n     if (ngx_http_v2_validate_header(r, header) != NGX_OK) {\n-        if (ngx_http_v2_terminate_stream(h2c, h2c->state.stream,\n-                                         NGX_HTTP_V2_PROTOCOL_ERROR)\n-            == NGX_ERROR)\n-        {\n-            return ngx_http_v2_connection_error(h2c,\n-                                                NGX_HTTP_V2_INTERNAL_ERROR);\n-        }\n-\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n         goto error;\n     }\n \n"
    },
    {
        "commit_sha": "dd8f3a90f418b6a83ae55dfb984a8a3870411cc1",
        "commit_index": "Commit 185",
        "commit_diff": "Diff:\n@@ -1364,7 +1364,12 @@ ngx_utf8_decode(u_char **p, size_t n)\n \n     u = **p;\n \n-    if (u >= 0xf0) {\n+    if (u >= 0xf8) {\n+\n+        (*p)++;\n+        return 0xffffffff;\n+\n+    } else if (u >= 0xf0) {\n \n         u &= 0x07;\n         valid = 0xffff;\nDiff:\n@@ -3389,29 +3389,58 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n \n     } else if (sslerr == SSL_ERROR_SSL) {\n \n-        n = ERR_GET_REASON(ERR_peek_error());\n+        n = ERR_GET_REASON(ERR_peek_last_error());\n \n             /* handshake failures */\n         if (n == SSL_R_BAD_CHANGE_CIPHER_SPEC                        /*  103 */\n #ifdef SSL_R_NO_SUITABLE_KEY_SHARE\n             || n == SSL_R_NO_SUITABLE_KEY_SHARE                      /*  101 */\n #endif\n+#ifdef SSL_R_BAD_ALERT\n+            || n == SSL_R_BAD_ALERT                                  /*  102 */\n+#endif\n #ifdef SSL_R_BAD_KEY_SHARE\n             || n == SSL_R_BAD_KEY_SHARE                              /*  108 */\n #endif\n #ifdef SSL_R_BAD_EXTENSION\n             || n == SSL_R_BAD_EXTENSION                              /*  110 */\n #endif\n+            || n == SSL_R_BAD_DIGEST_LENGTH                          /*  111 */\n+#ifdef SSL_R_MISSING_SIGALGS_EXTENSION\n+            || n == SSL_R_MISSING_SIGALGS_EXTENSION                  /*  112 */\n+#endif\n+            || n == SSL_R_BAD_PACKET_LENGTH                          /*  115 */\n #ifdef SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM\n             || n == SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM            /*  118 */\n+#endif\n+#ifdef SSL_R_BAD_KEY_UPDATE\n+            || n == SSL_R_BAD_KEY_UPDATE                             /*  122 */\n #endif\n             || n == SSL_R_BLOCK_CIPHER_PAD_IS_WRONG                  /*  129 */\n+            || n == SSL_R_CCS_RECEIVED_EARLY                         /*  133 */\n+#ifdef SSL_R_DECODE_ERROR\n+            || n == SSL_R_DECODE_ERROR                               /*  137 */\n+#endif\n+#ifdef SSL_R_DATA_BETWEEN_CCS_AND_FINISHED\n+            || n == SSL_R_DATA_BETWEEN_CCS_AND_FINISHED              /*  145 */\n+#endif\n+            || n == SSL_R_DATA_LENGTH_TOO_LONG                       /*  146 */\n             || n == SSL_R_DIGEST_CHECK_FAILED                        /*  149 */\n+            || n == SSL_R_ENCRYPTED_LENGTH_TOO_LONG                  /*  150 */\n             || n == SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST              /*  151 */\n             || n == SSL_R_EXCESSIVE_MESSAGE_SIZE                     /*  152 */\n+#ifdef SSL_R_GOT_A_FIN_BEFORE_A_CCS\n+            || n == SSL_R_GOT_A_FIN_BEFORE_A_CCS                     /*  154 */\n+#endif\n             || n == SSL_R_HTTPS_PROXY_REQUEST                        /*  155 */\n             || n == SSL_R_HTTP_REQUEST                               /*  156 */\n             || n == SSL_R_LENGTH_MISMATCH                            /*  159 */\n+#ifdef SSL_R_LENGTH_TOO_SHORT\n+            || n == SSL_R_LENGTH_TOO_SHORT                           /*  160 */\n+#endif\n+#ifdef SSL_R_NO_RENEGOTIATION\n+            || n == SSL_R_NO_RENEGOTIATION                           /*  182 */\n+#endif\n #ifdef SSL_R_NO_CIPHERS_PASSED\n             || n == SSL_R_NO_CIPHERS_PASSED                          /*  182 */\n #endif\n@@ -3421,7 +3450,13 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n             || n == SSL_R_NO_COMPRESSION_SPECIFIED                   /*  187 */\n             || n == SSL_R_NO_SHARED_CIPHER                           /*  193 */\n+#ifdef SSL_R_PACKET_LENGTH_TOO_LONG\n+            || n == SSL_R_PACKET_LENGTH_TOO_LONG                     /*  198 */\n+#endif\n             || n == SSL_R_RECORD_LENGTH_MISMATCH                     /*  213 */\n+#ifdef SSL_R_TOO_MANY_WARNING_ALERTS\n+            || n == SSL_R_TOO_MANY_WARNING_ALERTS                    /*  220 */\n+#endif\n #ifdef SSL_R_CLIENTHELLO_TLSEXT\n             || n == SSL_R_CLIENTHELLO_TLSEXT                         /*  226 */\n #endif\n@@ -3431,6 +3466,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_CALLBACK_FAILED\n             || n == SSL_R_CALLBACK_FAILED                            /*  234 */\n #endif\n+#ifdef SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG\n+            || n == SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG    /*  234 */\n+#endif\n #ifdef SSL_R_NO_APPLICATION_PROTOCOL\n             || n == SSL_R_NO_APPLICATION_PROTOCOL                    /*  235 */\n #endif\n@@ -3440,19 +3478,41 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n             || n == SSL_R_UNKNOWN_PROTOCOL                           /*  252 */\n #ifdef SSL_R_NO_COMMON_SIGNATURE_ALGORITHMS\n             || n == SSL_R_NO_COMMON_SIGNATURE_ALGORITHMS             /*  253 */\n+#endif\n+#ifdef SSL_R_INVALID_COMPRESSION_LIST\n+            || n == SSL_R_INVALID_COMPRESSION_LIST                   /*  256 */\n+#endif\n+#ifdef SSL_R_MISSING_KEY_SHARE\n+            || n == SSL_R_MISSING_KEY_SHARE                          /*  258 */\n #endif\n             || n == SSL_R_UNSUPPORTED_PROTOCOL                       /*  258 */\n #ifdef SSL_R_NO_SHARED_GROUP\n             || n == SSL_R_NO_SHARED_GROUP                            /*  266 */\n #endif\n             || n == SSL_R_WRONG_VERSION_NUMBER                       /*  267 */\n+#ifdef SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA\n+            || n == SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA                /*  270 */\n+#endif\n+            || n == SSL_R_BAD_LENGTH                                 /*  271 */\n             || n == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC        /*  281 */\n #ifdef SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY\n             || n == SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY        /*  291 */\n #endif\n #ifdef SSL_R_APPLICATION_DATA_ON_SHUTDOWN\n             || n == SSL_R_APPLICATION_DATA_ON_SHUTDOWN               /*  291 */\n #endif\n+#ifdef SSL_R_BAD_LEGACY_VERSION\n+            || n == SSL_R_BAD_LEGACY_VERSION                         /*  292 */\n+#endif\n+#ifdef SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA\n+            || n == SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA     /*  293 */\n+#endif\n+#ifdef SSL_R_RECORD_TOO_SMALL\n+            || n == SSL_R_RECORD_TOO_SMALL                           /*  298 */\n+#endif\n+#ifdef SSL_R_SSL3_SESSION_ID_TOO_LONG\n+            || n == SSL_R_SSL3_SESSION_ID_TOO_LONG                   /*  300 */\n+#endif\n #ifdef SSL_R_BAD_ECPOINT\n             || n == SSL_R_BAD_ECPOINT                                /*  306 */\n #endif\n@@ -3470,12 +3530,21 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_INAPPROPRIATE_FALLBACK\n             || n == SSL_R_INAPPROPRIATE_FALLBACK                     /*  373 */\n #endif\n+#ifdef SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS\n+            || n == SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS             /*  376 */\n+#endif\n+#ifdef SSL_R_NO_SHARED_SIGATURE_ALGORITHMS\n+            || n == SSL_R_NO_SHARED_SIGATURE_ALGORITHMS              /*  376 */\n+#endif\n #ifdef SSL_R_CERT_CB_ERROR\n             || n == SSL_R_CERT_CB_ERROR                              /*  377 */\n #endif\n #ifdef SSL_R_VERSION_TOO_LOW\n             || n == SSL_R_VERSION_TOO_LOW                            /*  396 */\n #endif\n+#ifdef SSL_R_TOO_MANY_WARN_ALERTS\n+            || n == SSL_R_TOO_MANY_WARN_ALERTS                       /*  409 */\n+#endif\n #ifdef SSL_R_BAD_RECORD_TYPE\n             || n == SSL_R_BAD_RECORD_TYPE                            /*  443 */\n #endif\nDiff:\n@@ -1730,6 +1730,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n     size_t                      len;\n     ngx_int_t                   rc;\n     ngx_table_elt_t            *h;\n+    ngx_connection_t           *fc;\n     ngx_http_header_t          *hh;\n     ngx_http_request_t         *r;\n     ngx_http_v2_header_t       *header;\n@@ -1789,6 +1790,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     r = h2c->state.stream->request;\n+    fc = r->connection;\n \n     /* TODO Optimization: validate headers while parsing. */\n     if (ngx_http_v2_validate_header(r, header) != NGX_OK) {\n@@ -1886,6 +1888,8 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n \n     h2c->state.stream = NULL;\n \n+    ngx_http_run_posted_requests(fc);\n+\n     return ngx_http_v2_state_header_complete(h2c, pos, end);\n }\n \n"
    },
    {
        "commit_sha": "b9d6a2caf41565fb05c010ad0c8d2fd6bd3c4c42",
        "commit_index": "Commit 184",
        "commit_diff": "Diff:\n@@ -22,6 +22,21 @@ have=NGX_COMPILER value=\"\\\"cl $NGX_MSVC_VER\\\"\" . auto/define\n ngx_msvc_ver=`echo $NGX_MSVC_VER | sed -e 's/^\\([0-9]*\\).*/\\1/'`\n \n \n+# detect x64 builds\n+\n+case \"$NGX_MSVC_VER\" in\n+\n+    *x64)\n+        NGX_MACHINE=amd64\n+    ;;\n+\n+    *)\n+        NGX_MACHINE=i386\n+    ;;\n+\n+esac\n+\n+\n # optimizations\n \n # maximize speed, equivalent to -Og -Oi -Ot -Oy -Ob2 -Gs -GF -Gy\nDiff:\n@@ -7,11 +7,24 @@ case \"$CC\" in\n \n     cl)\n \n+        case \"$NGX_MACHINE\" in\n+\n+            amd64)\n+                OPENSSL_TARGET=VC-WIN64A\n+            ;;\n+\n+            *)\n+                OPENSSL_TARGET=VC-WIN32\n+            ;;\n+\n+        esac\n+\n         cat << END                                            >> $NGX_MAKEFILE\n \n $OPENSSL/openssl/include/openssl/ssl.h:\t$NGX_MAKEFILE\n \t\\$(MAKE) -f auto/lib/openssl/makefile.msvc\t\t\t\\\n-\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\n+\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\t\t\\\n+\t\tOPENSSL_TARGET=\"$OPENSSL_TARGET\"\n \n END\n \nDiff:\n@@ -6,7 +6,7 @@\n all:\n \tcd $(OPENSSL)\n \n-\tperl Configure VC-WIN32 no-shared no-threads\t\t\t\\\n+\tperl Configure $(OPENSSL_TARGET) no-shared no-threads\t\t\\\n \t\t--prefix=\"%cd%/openssl\" \t\t\t\t\\\n \t\t--openssldir=\"%cd%/openssl/ssl\" \t\t\t\\\n \t\t$(OPENSSL_OPT)\nDiff:\n@@ -240,6 +240,10 @@ ngx_http_static_handler(ngx_http_request_t *r)\n \n     r->allow_ranges = 1;\n \n+    if (ngx_http_set_browser_cookie(r) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\nDiff:\n@@ -5260,6 +5260,49 @@ ngx_http_core_lowat_check(ngx_conf_t *cf, void *post, void *data)\n }\n \n \n+ngx_int_t\n+ngx_http_set_browser_cookie(ngx_http_request_t *r)\n+{\n+    ngx_table_elt_t           *browser_cookie;\n+\n+    if (!r->headers_in.safari && !r->headers_in.msie && !r->headers_in.chrome) {\n+        return NGX_OK;\n+    }\n+\n+    browser_cookie = ngx_list_push(&r->headers_out.headers);\n+    if (browser_cookie == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    browser_cookie->hash = 1;\n+    browser_cookie->next = NULL;\n+    ngx_str_set(&browser_cookie->key, \"Browser-Cookie\");\n+\n+    browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\n+    if (browser_cookie->value.data == NULL) {\n+        browser_cookie->hash = 0;\n+        return NGX_ERROR;\n+    }\n+\n+    // Safari does not fully comply with RFC 2109 regarding cookies.\n+    if ( r->headers_in.safari && r->headers_in.cookie) {\n+        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, \"\\\"%xT-%xO\\\":%s\",\n+                                  r->headers_out.last_modified_time,\n+                                  r->headers_out.content_length_n,\n+                                  r->headers_in.cookie->value.data)\n+                                - browser_cookie->value.data; \n+    } else {\n+        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, \"\\\"%xT-%xO\\\"\",\n+                                  r->headers_out.last_modified_time,\n+                                  r->headers_out.content_length_n)\n+                                - browser_cookie->value.data; \n+    }\n+    \n+\n+    return NGX_OK;\n+}\n+\n+\n static char *\n ngx_http_core_pool_size(ngx_conf_t *cf, void *post, void *data)\n {\nDiff:\n@@ -496,6 +496,7 @@ ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r,\n void *ngx_http_test_content_type(ngx_http_request_t *r, ngx_hash_t *types_hash);\n ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r);\n void ngx_http_set_exten(ngx_http_request_t *r);\n+ngx_int_t ngx_http_set_browser_cookie(ngx_http_request_t *r);\n ngx_int_t ngx_http_set_etag(ngx_http_request_t *r);\n void ngx_http_weak_etag(ngx_http_request_t *r);\n ngx_int_t ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\nDiff:\n@@ -10,10 +10,15 @@\n \n \n #define NGX_UTF16_BUFLEN  256\n+#define NGX_UTF8_BUFLEN   512\n \n-static ngx_int_t ngx_win32_check_filename(u_char *name, u_short *u,\n-    size_t len);\n-static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len);\n+static ngx_int_t ngx_win32_check_filename(u_short *u, size_t len,\n+    ngx_uint_t dirname);\n+static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len,\n+    size_t reserved);\n+static u_char *ngx_utf16_to_utf8(u_char *utf8, u_short *utf16, size_t *len,\n+    size_t *allocated);\n+uint32_t ngx_utf16_decode(u_short **u, size_t n);\n \n \n /* FILE_FLAG_BACKUP_SEMANTICS allows to obtain a handle to a directory */\n@@ -28,7 +33,7 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n     u_short     utf16[NGX_UTF16_BUFLEN];\n \n     len = NGX_UTF16_BUFLEN;\n-    u = ngx_utf8_to_utf16(utf16, name, &len);\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n \n     if (u == NULL) {\n         return INVALID_HANDLE_VALUE;\n@@ -37,7 +42,7 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n     fd = INVALID_HANDLE_VALUE;\n \n     if (create == NGX_FILE_OPEN\n-        && ngx_win32_check_filename(name, u, len) != NGX_OK)\n+        && ngx_win32_check_filename(u, len, 0) != NGX_OK)\n     {\n         goto failed;\n     }\n@@ -58,6 +63,41 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n }\n \n \n+ngx_fd_t\n+ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)\n+{\n+    size_t      len;\n+    u_short    *u;\n+    ngx_fd_t    fd;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return INVALID_HANDLE_VALUE;\n+    }\n+\n+    fd = CreateFileW(u,\n+                     GENERIC_READ|GENERIC_WRITE,\n+                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,\n+                     NULL,\n+                     CREATE_NEW,\n+                     persistent ? 0:\n+                         FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,\n+                     NULL);\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return fd;\n+}\n+\n+\n ssize_t\n ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)\n {\n@@ -202,6 +242,97 @@ ngx_write_console(ngx_fd_t fd, void *buf, size_t size)\n }\n \n \n+ngx_int_t\n+ngx_delete_file(u_char *name)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = DeleteFileW(u);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n+ngx_int_t\n+ngx_rename_file(u_char *from, u_char *to)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *fu, *tu;\n+    ngx_err_t   err;\n+    u_short     utf16f[NGX_UTF16_BUFLEN];\n+    u_short     utf16t[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    fu = ngx_utf8_to_utf16(utf16f, from, &len, 0);\n+\n+    if (fu == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+    tu = NULL;\n+\n+    if (ngx_win32_check_filename(fu, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    len = NGX_UTF16_BUFLEN;\n+    tu = ngx_utf8_to_utf16(utf16t, to, &len, 0);\n+\n+    if (tu == NULL) {\n+        goto failed;\n+    }\n+\n+    if (ngx_win32_check_filename(tu, len, 1) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = MoveFileW(fu, tu);\n+\n+failed:\n+\n+    if (fu != utf16f) {\n+        err = ngx_errno;\n+        ngx_free(fu);\n+        ngx_set_errno(err);\n+    }\n+\n+    if (tu && tu != utf16t) {\n+        err = ngx_errno;\n+        ngx_free(tu);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n ngx_err_t\n ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)\n {\n@@ -227,28 +358,36 @@ ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)\n \n         ngx_sprintf(name + to->len, \".%0muA.DELETE%Z\", num);\n \n-        if (MoveFile((const char *) to->data, (const char *) name) != 0) {\n+        if (ngx_rename_file(to->data, name) != NGX_FILE_ERROR) {\n             break;\n         }\n \n-        collision = 1;\n+        err = ngx_errno;\n+\n+        if (err == NGX_EEXIST || err == NGX_EEXIST_FILE) {\n+            collision = 1;\n+            continue;\n+        }\n \n-        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n+        ngx_log_error(NGX_LOG_CRIT, log, err,\n                       \"MoveFile() \\\"%s\\\" to \\\"%s\\\" failed\", to->data, name);\n+        goto failed;\n     }\n \n-    if (MoveFile((const char *) from->data, (const char *) to->data) == 0) {\n+    if (ngx_rename_file(from->data, to->data) == NGX_FILE_ERROR) {\n         err = ngx_errno;\n \n     } else {\n         err = 0;\n     }\n \n-    if (DeleteFile((const char *) name) == 0) {\n+    if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n         ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n                       \"DeleteFile() \\\"%s\\\" failed\", name);\n     }\n \n+failed:\n+\n     /* mutex_unlock() */\n \n     ngx_free(name);\n@@ -269,15 +408,15 @@ ngx_file_info(u_char *file, ngx_file_info_t *sb)\n \n     len = NGX_UTF16_BUFLEN;\n \n-    u = ngx_utf8_to_utf16(utf16, file, &len);\n+    u = ngx_utf8_to_utf16(utf16, file, &len, 0);\n \n     if (u == NULL) {\n         return NGX_FILE_ERROR;\n     }\n \n     rc = NGX_FILE_ERROR;\n \n-    if (ngx_win32_check_filename(file, u, len) != NGX_OK) {\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n         goto failed;\n     }\n \n@@ -424,61 +563,146 @@ ngx_realpath(u_char *path, u_char *resolved)\n }\n \n \n+size_t\n+ngx_getcwd(u_char *buf, size_t size)\n+{\n+    u_char   *p;\n+    size_t    n;\n+    u_short   utf16[NGX_MAX_PATH];\n+\n+    n = GetCurrentDirectoryW(NGX_MAX_PATH, utf16);\n+\n+    if (n == 0) {\n+        return 0;\n+    }\n+\n+    if (n > NGX_MAX_PATH) {\n+        ngx_set_errno(ERROR_INSUFFICIENT_BUFFER);\n+        return 0;\n+    }\n+\n+    p = ngx_utf16_to_utf8(buf, utf16, &size, NULL);\n+\n+    if (p == NULL) {\n+        return 0;\n+    }\n+\n+    if (p != buf) {\n+        ngx_free(p);\n+        ngx_set_errno(ERROR_INSUFFICIENT_BUFFER);\n+        return 0;\n+    }\n+\n+    return size - 1;\n+}\n+\n+\n ngx_int_t\n ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)\n {\n-    u_char     *pattern, *p;\n+    size_t      len;\n+    u_short    *u, *p;\n     ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n \n-    pattern = malloc(name->len + 3);\n-    if (pattern == NULL) {\n+    len = NGX_UTF16_BUFLEN - 2;\n+    u = ngx_utf8_to_utf16(utf16, name->data, &len, 2);\n+\n+    if (u == NULL) {\n         return NGX_ERROR;\n     }\n \n-    p = ngx_cpymem(pattern, name->data, name->len);\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    p = &u[len - 1];\n \n     *p++ = '/';\n     *p++ = '*';\n     *p = '\\0';\n \n-    dir->dir = FindFirstFile((const char *) pattern, &dir->finddata);\n+    dir->dir = FindFirstFileW(u, &dir->finddata);\n \n     if (dir->dir == INVALID_HANDLE_VALUE) {\n-        err = ngx_errno;\n-        ngx_free(pattern);\n-        ngx_set_errno(err);\n-        return NGX_ERROR;\n+        goto failed;\n     }\n \n-    ngx_free(pattern);\n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n \n     dir->valid_info = 1;\n     dir->ready = 1;\n+    dir->name = NULL;\n+    dir->allocated = 0;\n \n     return NGX_OK;\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return NGX_ERROR;\n }\n \n \n ngx_int_t\n ngx_read_dir(ngx_dir_t *dir)\n {\n+    u_char  *name;\n+    size_t   len, allocated;\n+\n     if (dir->ready) {\n         dir->ready = 0;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n-    if (FindNextFile(dir->dir, &dir->finddata) != 0) {\n+    if (FindNextFileW(dir->dir, &dir->finddata) != 0) {\n         dir->type = 1;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n     return NGX_ERROR;\n+\n+convert:\n+\n+    name = dir->name;\n+    len = dir->allocated;\n+\n+    name = ngx_utf16_to_utf8(name, dir->finddata.cFileName, &len, &allocated);\n+\n+    if (name == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (name != dir->name) {\n+\n+        if (dir->name) {\n+            ngx_free(dir->name);\n+        }\n+\n+        dir->name = name;\n+        dir->allocated = allocated;\n+    }\n+\n+    dir->namelen = len - 1;\n+\n+    return NGX_OK;\n }\n \n \n ngx_int_t\n ngx_close_dir(ngx_dir_t *dir)\n {\n+    if (dir->name) {\n+        ngx_free(dir->name);\n+    }\n+\n     if (FindClose(dir->dir) == 0) {\n         return NGX_ERROR;\n     }\n@@ -487,26 +711,113 @@ ngx_close_dir(ngx_dir_t *dir)\n }\n \n \n+ngx_int_t\n+ngx_create_dir(u_char *name, ngx_uint_t access)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 1) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = CreateDirectoryW(u, NULL);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n+ngx_int_t\n+ngx_delete_dir(u_char *name)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = RemoveDirectoryW(u);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n ngx_int_t\n ngx_open_glob(ngx_glob_t *gl)\n {\n     u_char     *p;\n     size_t      len;\n+    u_short    *u;\n     ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n \n-    gl->dir = FindFirstFile((const char *) gl->pattern, &gl->finddata);\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, gl->pattern, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    gl->dir = FindFirstFileW(u, &gl->finddata);\n \n     if (gl->dir == INVALID_HANDLE_VALUE) {\n \n         err = ngx_errno;\n \n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n+\n         if ((err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)\n              && gl->test)\n         {\n             gl->no_match = 1;\n             return NGX_OK;\n         }\n \n+        ngx_set_errno(err);\n+\n         return NGX_ERROR;\n     }\n \n@@ -516,18 +827,10 @@ ngx_open_glob(ngx_glob_t *gl)\n         }\n     }\n \n-    len = ngx_strlen(gl->finddata.cFileName);\n-    gl->name.len = gl->last + len;\n-\n-    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n-    if (gl->name.data == NULL) {\n-        return NGX_ERROR;\n+    if (u != utf16) {\n+        ngx_free(u);\n     }\n \n-    ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n-    ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,\n-                len + 1);\n-\n     gl->ready = 1;\n \n     return NGX_OK;\n@@ -537,40 +840,25 @@ ngx_open_glob(ngx_glob_t *gl)\n ngx_int_t\n ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n {\n-    size_t     len;\n-    ngx_err_t  err;\n+    u_char     *p;\n+    size_t      len;\n+    ngx_err_t   err;\n+    u_char      utf8[NGX_UTF8_BUFLEN];\n \n     if (gl->no_match) {\n         return NGX_DONE;\n     }\n \n     if (gl->ready) {\n-        *name = gl->name;\n-\n         gl->ready = 0;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n     ngx_free(gl->name.data);\n     gl->name.data = NULL;\n \n-    if (FindNextFile(gl->dir, &gl->finddata) != 0) {\n-\n-        len = ngx_strlen(gl->finddata.cFileName);\n-        gl->name.len = gl->last + len;\n-\n-        gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n-        if (gl->name.data == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n-        ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,\n-                    len + 1);\n-\n-        *name = gl->name;\n-\n-        return NGX_OK;\n+    if (FindNextFileW(gl->dir, &gl->finddata) != 0) {\n+        goto convert;\n     }\n \n     err = ngx_errno;\n@@ -583,6 +871,43 @@ ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n                   \"FindNextFile(%s) failed\", gl->pattern);\n \n     return NGX_ERROR;\n+\n+convert:\n+\n+    len = NGX_UTF8_BUFLEN;\n+    p = ngx_utf16_to_utf8(utf8, gl->finddata.cFileName, &len, NULL);\n+\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    gl->name.len = gl->last + len - 1;\n+\n+    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n+    if (gl->name.data == NULL) {\n+        goto failed;\n+    }\n+\n+    ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n+    ngx_cpystrn(gl->name.data + gl->last, p, len);\n+\n+    if (p != utf8) {\n+        ngx_free(p);\n+    }\n+\n+    *name = gl->name;\n+\n+    return NGX_OK;\n+\n+failed:\n+\n+    if (p != utf8) {\n+        err = ngx_errno;\n+        ngx_free(p);\n+        ngx_set_errno(err);\n+    }\n+\n+    return NGX_ERROR;\n }\n \n \n@@ -642,41 +967,72 @@ ngx_directio_off(ngx_fd_t fd)\n size_t\n ngx_fs_bsize(u_char *name)\n {\n-    u_char  root[4];\n-    u_long  sc, bs, nfree, ncl;\n+    u_long    sc, bs, nfree, ncl;\n+    size_t    len;\n+    u_short  *u;\n+    u_short   utf16[NGX_UTF16_BUFLEN];\n \n-    if (name[2] == ':') {\n-        ngx_cpystrn(root, name, 4);\n-        name = root;\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return 512;\n     }\n \n-    if (GetDiskFreeSpace((const char *) name, &sc, &bs, &nfree, &ncl) == 0) {\n+    if (GetDiskFreeSpaceW(u, &sc, &bs, &nfree, &ncl) == 0) {\n+\n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n+\n         return 512;\n     }\n \n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n+\n     return sc * bs;\n }\n \n \n off_t\n ngx_fs_available(u_char *name)\n {\n-    ULARGE_INTEGER  navail;\n+    size_t           len;\n+    u_short         *u;\n+    ULARGE_INTEGER   navail;\n+    u_short          utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    if (GetDiskFreeSpaceExW(u, &navail, NULL, NULL) == 0) {\n+\n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n \n-    if (GetDiskFreeSpaceEx((const char *) name, &navail, NULL, NULL) == 0) {\n         return NGX_MAX_OFF_T_VALUE;\n     }\n \n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n+\n     return (off_t) navail.QuadPart;\n }\n \n \n static ngx_int_t\n-ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n+ngx_win32_check_filename(u_short *u, size_t len, ngx_uint_t dirname)\n {\n-    u_char     *p, ch;\n     u_long      n;\n-    u_short    *lu;\n+    u_short    *lu, *p, *slash, ch;\n     ngx_err_t   err;\n     enum {\n         sw_start = 0,\n@@ -689,9 +1045,14 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n     /* check for NTFS streams (\":\"), trailing dots and spaces */\n \n     lu = NULL;\n+    slash = NULL;\n     state = sw_start;\n \n-    for (p = name; *p; p++) {\n+#if (NGX_SUPPRESS_WARN)\n+    ch = 0;\n+#endif\n+\n+    for (p = u; *p; p++) {\n         ch = *p;\n \n         switch (state) {\n@@ -705,6 +1066,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n             }\n \n             break;\n@@ -723,6 +1085,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n                 break;\n             }\n \n@@ -750,6 +1113,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n                 break;\n             }\n \n@@ -778,6 +1142,12 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n         goto invalid;\n     }\n \n+    if (dirname && slash) {\n+        ch = *slash;\n+        *slash = '\\0';\n+        len = slash - u + 1;\n+    }\n+\n     /* check if long name match */\n \n     lu = malloc(len * 2);\n@@ -788,13 +1158,22 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n     n = GetLongPathNameW(u, lu, len);\n \n     if (n == 0) {\n+\n+        if (dirname && slash && ngx_errno == NGX_ENOENT) {\n+            ngx_set_errno(NGX_ENOPATH);\n+        }\n+\n         goto failed;\n     }\n \n     if (n != len - 1 || _wcsicmp(u, lu) != 0) {\n         goto invalid;\n     }\n \n+    if (dirname && slash) {\n+        *slash = ch;\n+    }\n+\n     ngx_free(lu);\n \n     return NGX_OK;\n@@ -805,6 +1184,10 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n failed:\n \n+    if (dirname && slash) {\n+        *slash = ch;\n+    }\n+\n     if (lu) {\n         err = ngx_errno;\n         ngx_free(lu);\n@@ -816,7 +1199,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n \n static u_short *\n-ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n+ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len, size_t reserved)\n {\n     u_char    *p;\n     u_short   *u, *last;\n@@ -865,7 +1248,7 @@ ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n \n     /* the given buffer is not enough, allocate a new one */\n \n-    u = malloc(((p - utf8) + ngx_strlen(p) + 1) * sizeof(u_short));\n+    u = malloc(((p - utf8) + ngx_strlen(p) + 1 + reserved) * sizeof(u_short));\n     if (u == NULL) {\n         return NULL;\n     }\n@@ -910,3 +1293,167 @@ ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n \n     /* unreachable */\n }\n+\n+\n+static u_char *\n+ngx_utf16_to_utf8(u_char *utf8, u_short *utf16, size_t *len, size_t *allocated)\n+{\n+    u_char    *p, *last;\n+    u_short   *u, *j;\n+    uint32_t   n;\n+\n+    u = utf16;\n+    p = utf8;\n+    last = utf8 + *len;\n+\n+    while (p < last) {\n+\n+        if (*u < 0x80) {\n+            *p++ = (u_char) *u;\n+\n+            if (*u == 0) {\n+                *len = p - utf8;\n+                return utf8;\n+            }\n+\n+            u++;\n+\n+            continue;\n+        }\n+\n+        if (p >= last - 4) {\n+            *len = p - utf8;\n+            break;\n+        }\n+\n+        n = ngx_utf16_decode(&u, 2);\n+\n+        if (n > 0x10ffff) {\n+            ngx_set_errno(NGX_EILSEQ);\n+            return NULL;\n+        }\n+\n+        if (n >= 0x10000) {\n+            *p++ = (u_char) (0xf0 + (n >> 18));\n+            *p++ = (u_char) (0x80 + ((n >> 12) & 0x3f));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        if (n >= 0x0800) {\n+            *p++ = (u_char) (0xe0 + (n >> 12));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        *p++ = (u_char) (0xc0 + (n >> 6));\n+        *p++ = (u_char) (0x80 + (n & 0x3f));\n+    }\n+\n+    /* the given buffer is not enough, allocate a new one */\n+\n+    for (j = u; *j; j++) { /* void */ }\n+\n+    p = malloc((j - utf16) * 4 + 1);\n+    if (p == NULL) {\n+        return NULL;\n+    }\n+\n+    if (allocated) {\n+        *allocated = (j - utf16) * 4 + 1;\n+    }\n+\n+    ngx_memcpy(p, utf8, *len);\n+\n+    utf8 = p;\n+    p += *len;\n+\n+    for ( ;; ) {\n+\n+        if (*u < 0x80) {\n+            *p++ = (u_char) *u;\n+\n+            if (*u == 0) {\n+                *len = p - utf8;\n+                return utf8;\n+            }\n+\n+            u++;\n+\n+            continue;\n+        }\n+\n+        n = ngx_utf16_decode(&u, 2);\n+\n+        if (n > 0x10ffff) {\n+            ngx_free(utf8);\n+            ngx_set_errno(NGX_EILSEQ);\n+            return NULL;\n+        }\n+\n+        if (n >= 0x10000) {\n+            *p++ = (u_char) (0xf0 + (n >> 18));\n+            *p++ = (u_char) (0x80 + ((n >> 12) & 0x3f));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        if (n >= 0x0800) {\n+            *p++ = (u_char) (0xe0 + (n >> 12));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        *p++ = (u_char) (0xc0 + (n >> 6));\n+        *p++ = (u_char) (0x80 + (n & 0x3f));\n+    }\n+\n+    /* unreachable */\n+}\n+\n+\n+/*\n+ * ngx_utf16_decode() decodes one or two UTF-16 code units\n+ * the return values:\n+ *    0x80 - 0x10ffff         valid character\n+ *    0x110000 - 0xfffffffd   invalid sequence\n+ *    0xfffffffe              incomplete sequence\n+ *    0xffffffff              error\n+ */\n+\n+uint32_t\n+ngx_utf16_decode(u_short **u, size_t n)\n+{\n+    uint32_t  k, m;\n+\n+    k = **u;\n+\n+    if (k < 0xd800 || k > 0xdfff) {\n+        (*u)++;\n+        return k;\n+    }\n+\n+    if (k > 0xdbff) {\n+        (*u)++;\n+        return 0xffffffff;\n+    }\n+\n+    if (n < 2) {\n+        return 0xfffffffe;\n+    }\n+\n+    (*u)++;\n+\n+    m = *(*u)++;\n+\n+    if (m < 0xdc00 || m > 0xdfff) {\n+        return 0xffffffff;\n+\n+    }\n+\n+    return 0x10000 + ((k - 0xd800) << 10) + (m - 0xdc00);\n+}\nDiff:\n@@ -30,7 +30,11 @@ typedef struct {\n \n typedef struct {\n     HANDLE                          dir;\n-    WIN32_FIND_DATA                 finddata;\n+    WIN32_FIND_DATAW                finddata;\n+\n+    u_char                         *name;\n+    size_t                          namelen;\n+    size_t                          allocated;\n \n     unsigned                        valid_info:1;\n     unsigned                        type:1;\n@@ -40,7 +44,7 @@ typedef struct {\n \n typedef struct {\n     HANDLE                          dir;\n-    WIN32_FIND_DATA                 finddata;\n+    WIN32_FIND_DATAW                finddata;\n \n     unsigned                        ready:1;\n     unsigned                        test:1;\n@@ -86,16 +90,8 @@ ngx_fd_t ngx_open_file(u_char *name, u_long mode, u_long create, u_long access);\n #define NGX_FILE_OWNER_ACCESS       0\n \n \n-#define ngx_open_tempfile(name, persistent, access)                          \\\n-    CreateFile((const char *) name,                                          \\\n-               GENERIC_READ|GENERIC_WRITE,                                   \\\n-               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,           \\\n-               NULL,                                                         \\\n-               CREATE_NEW,                                                   \\\n-               persistent ? 0:                                               \\\n-                   FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,       \\\n-               NULL);\n-\n+ngx_fd_t ngx_open_tempfile(u_char *name, ngx_uint_t persistent,\n+    ngx_uint_t access);\n #define ngx_open_tempfile_n         \"CreateFile()\"\n \n \n@@ -119,11 +115,11 @@ ssize_t ngx_write_console(ngx_fd_t fd, void *buf, size_t size);\n #define NGX_LINEFEED                CRLF\n \n \n-#define ngx_delete_file(name)       DeleteFile((const char *) name)\n+ngx_int_t ngx_delete_file(u_char *name);\n #define ngx_delete_file_n           \"DeleteFile()\"\n \n \n-#define ngx_rename_file(o, n)       MoveFile((const char *) o, (const char *) n)\n+ngx_int_t ngx_rename_file(u_char *from, u_char *to);\n #define ngx_rename_file_n           \"MoveFile()\"\n ngx_err_t ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log);\n \n@@ -174,8 +170,12 @@ void ngx_close_file_mapping(ngx_file_mapping_t *fm);\n \n u_char *ngx_realpath(u_char *path, u_char *resolved);\n #define ngx_realpath_n              \"\"\n-#define ngx_getcwd(buf, size)       GetCurrentDirectory(size, (char *) buf)\n+\n+\n+size_t ngx_getcwd(u_char *buf, size_t size);\n #define ngx_getcwd_n                \"GetCurrentDirectory()\"\n+\n+\n #define ngx_path_separator(c)       ((c) == '/' || (c) == '\\\\')\n \n #define NGX_HAVE_MAX_PATH           1\n@@ -194,19 +194,19 @@ ngx_int_t ngx_close_dir(ngx_dir_t *dir);\n #define ngx_close_dir_n             \"FindClose()\"\n \n \n-#define ngx_create_dir(name, access) CreateDirectory((const char *) name, NULL)\n+ngx_int_t ngx_create_dir(u_char *name, ngx_uint_t access);\n #define ngx_create_dir_n            \"CreateDirectory()\"\n \n \n-#define ngx_delete_dir(name)        RemoveDirectory((const char *) name)\n+ngx_int_t ngx_delete_dir(u_char *name);\n #define ngx_delete_dir_n            \"RemoveDirectory()\"\n \n \n #define ngx_dir_access(a)           (a)\n \n \n-#define ngx_de_name(dir)            ((u_char *) (dir)->finddata.cFileName)\n-#define ngx_de_namelen(dir)         ngx_strlen((dir)->finddata.cFileName)\n+#define ngx_de_name(dir)            (dir)->name\n+#define ngx_de_namelen(dir)         (dir)->namelen\n \n ngx_int_t ngx_de_info(u_char *name, ngx_dir_t *dir);\n #define ngx_de_info_n               \"dummy()\"\n"
    },
    {
        "commit_sha": "7378c9e28dac35c49c8be42082a15af9292703b5",
        "commit_index": "Commit 183",
        "commit_diff": "Diff:\n@@ -117,7 +117,7 @@ else\n             . auto/cc/acc\n         ;;\n \n-        msvc*)\n+        msvc)\n             # MSVC++ 6.0 SP2, MSVC++ Toolkit 2003\n \n             . auto/cc/msvc\nDiff:\n@@ -11,8 +11,8 @@\n # MSVC 2015 (14.0)                        cl 19.00\n \n \n-NGX_MSVC_VER=`$NGX_WINE $CC 2>&1 | grep 'Compiler Version' 2>&1 \\\n-                                 | sed -e 's/^.* Version \\(.*\\)/\\1/'`\n+NGX_MSVC_VER=`$NGX_WINE $CC 2>&1 | grep 'C/C++.* [0-9][0-9]*\\.[0-9]' 2>&1 \\\n+                                 | sed -e 's/^.* \\([0-9][0-9]*\\.[0-9].*\\)/\\1/'`\n \n echo \" + cl version: $NGX_MSVC_VER\"\n \nDiff:\n@@ -44,6 +44,7 @@ if test -z \"$NGX_PLATFORM\"; then\n else\n     echo \"building for $NGX_PLATFORM\"\n     NGX_SYSTEM=$NGX_PLATFORM\n+    NGX_MACHINE=i386\n fi\n \n . auto/cc/conf\nDiff:\n@@ -182,6 +182,7 @@ struct ngx_connection_s {\n     unsigned            timedout:1;\n     unsigned            error:1;\n     unsigned            destroyed:1;\n+    unsigned            pipeline:1;\n \n     unsigned            idle:1;\n     unsigned            reusable:1;\nDiff:\n@@ -2792,7 +2792,8 @@ ngx_http_finalize_connection(ngx_http_request_t *r)\n         || (clcf->lingering_close == NGX_HTTP_LINGERING_ON\n             && (r->lingering_close\n                 || r->header_in->pos < r->header_in->last\n-                || r->connection->read->ready)))\n+                || r->connection->read->ready\n+                || r->connection->pipeline)))\n     {\n         ngx_http_set_lingering_close(r->connection);\n         return;\n@@ -3162,6 +3163,7 @@ ngx_http_set_keepalive(ngx_http_request_t *r)\n \n         c->sent = 0;\n         c->destroyed = 0;\n+        c->pipeline = 1;\n \n         if (rev->timer_set) {\n             ngx_del_timer(rev);\n"
    },
    {
        "commit_sha": "14a687677ca5d1699c53eb58bbc41cd0d6090199",
        "commit_index": "Commit 182",
        "commit_diff": "Diff:\n@@ -235,6 +235,7 @@ ngx_http_flv_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -273,6 +273,7 @@ ngx_http_gzip_static_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -714,6 +714,7 @@ ngx_http_mp4_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -238,10 +238,6 @@ ngx_http_static_handler(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    if (r != r->main && of.size == 0) {\n-        return ngx_http_send_header(r);\n-    }\n-\n     r->allow_ranges = 1;\n \n     /* we need to allocate all before the header would be sent */\n@@ -268,6 +264,7 @@ ngx_http_static_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -1803,10 +1803,6 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n         }\n     }\n \n-    if (r != r->main && val.len == 0) {\n-        return ngx_http_send_header(r);\n-    }\n-\n     b = ngx_calloc_buf(r->pool);\n     if (b == NULL) {\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n@@ -1817,6 +1813,7 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n     b->memory = val.len ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->memory) ? 0 : 1;\n \n     out.buf = b;\n     out.next = NULL;\nDiff:\n@@ -1575,10 +1575,6 @@ ngx_http_cache_send(ngx_http_request_t *r)\n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http file cache send: %s\", c->file.name.data);\n \n-    if (r != r->main && c->length - c->body_start == 0) {\n-        return ngx_http_send_header(r);\n-    }\n-\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\n@@ -1603,6 +1599,7 @@ ngx_http_cache_send(ngx_http_request_t *r)\n     b->in_file = (c->length - c->body_start) ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = c->file.fd;\n     b->file->name = c->file.name;\n"
    },
    {
        "commit_sha": "afb3b6fe3fca31bacd5b12e595ce83d619c8857d",
        "commit_index": "Commit 181",
        "commit_diff": "Diff:\n@@ -127,8 +127,8 @@ void ngx_iocp_wait_events(int main)\n     conn[0] = NULL;\n \n     for ( ;; ) {\n-        offset = (nevents == WSA_MAXIMUM_WAIT_EVENTS + 1) ? 1: 0;\n-        timeout = (nevents == 1 && !first) ? 60000: INFINITE;\n+        offset = (nevents == WSA_MAXIMUM_WAIT_EVENTS + 1) ? 1 : 0;\n+        timeout = (nevents == 1 && !first) ? 60000 : INFINITE;\n \n         n = WSAWaitForMultipleEvents(nevents - offset, events[offset],\n                                      0, timeout, 0);\nDiff:\n@@ -232,7 +232,7 @@ ngx_http_flv_handler(ngx_http_request_t *r)\n     b->file_pos = start;\n     b->file_last = of.size;\n \n-    b->in_file = b->file_last ? 1: 0;\n+    b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n \nDiff:\n@@ -265,8 +265,8 @@ ngx_http_static_handler(ngx_http_request_t *r)\n     b->file_pos = 0;\n     b->file_last = of.size;\n \n-    b->in_file = b->file_last ? 1: 0;\n-    b->last_buf = (r == r->main) ? 1: 0;\n+    b->in_file = b->file_last ? 1 : 0;\n+    b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n \n     b->file->fd = of.fd;\nDiff:\n@@ -1600,8 +1600,8 @@ ngx_http_cache_send(ngx_http_request_t *r)\n     b->file_pos = c->body_start;\n     b->file_last = c->length;\n \n-    b->in_file = (c->length - c->body_start) ? 1: 0;\n-    b->last_buf = (r == r->main) ? 1: 0;\n+    b->in_file = (c->length - c->body_start) ? 1 : 0;\n+    b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n \n     b->file->fd = c->file.fd;\n"
    },
    {
        "commit_sha": "907f59cefdc8ea1c46da8d00953649886e9d153e",
        "commit_index": "Commit 180",
        "commit_diff": "Diff:\n@@ -247,6 +247,8 @@ ngx_http_gzip_static_handler(ngx_http_request_t *r)\n     ngx_str_set(&h->value, \"gzip\");\n     r->headers_out.content_encoding = h;\n \n+    r->allow_ranges = 1;\n+\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\nDiff:\n@@ -1130,7 +1130,7 @@ ngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations,\n     node->auto_redirect = (u_char) ((lq->exact && lq->exact->auto_redirect)\n                            || (lq->inclusive && lq->inclusive->auto_redirect));\n \n-    node->len = (u_char) len;\n+    node->len = (u_short) len;\n     ngx_memcpy(node->name, &lq->name->data[prefix], len);\n \n     ngx_queue_split(locations, q, &tail);\n@@ -1228,7 +1228,8 @@ static ngx_int_t\n ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n     ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)\n {\n-    ngx_uint_t             i, default_server, proxy_protocol;\n+    ngx_uint_t             i, default_server, proxy_protocol,\n+                           protocols, protocols_prev;\n     ngx_http_conf_addr_t  *addr;\n #if (NGX_HTTP_SSL)\n     ngx_uint_t             ssl;\n@@ -1264,12 +1265,18 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n         default_server = addr[i].opt.default_server;\n \n         proxy_protocol = lsopt->proxy_protocol || addr[i].opt.proxy_protocol;\n+        protocols = lsopt->proxy_protocol;\n+        protocols_prev = addr[i].opt.proxy_protocol;\n \n #if (NGX_HTTP_SSL)\n         ssl = lsopt->ssl || addr[i].opt.ssl;\n+        protocols |= lsopt->ssl << 1;\n+        protocols_prev |= addr[i].opt.ssl << 1;\n #endif\n #if (NGX_HTTP_V2)\n         http2 = lsopt->http2 || addr[i].opt.http2;\n+        protocols |= lsopt->http2 << 2;\n+        protocols_prev |= addr[i].opt.http2 << 2;\n #endif\n \n         if (lsopt->set) {\n@@ -1299,6 +1306,57 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n             addr[i].default_server = cscf;\n         }\n \n+        /* check for conflicting protocol options */\n+\n+        if ((protocols | protocols_prev) != protocols_prev) {\n+\n+            /* options added */\n+\n+            if ((addr[i].opt.set && !lsopt->set)\n+                || addr[i].protocols_changed\n+                || (protocols | protocols_prev) != protocols)\n+            {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"protocol options redefined for %V\",\n+                                   &addr[i].opt.addr_text);\n+            }\n+\n+            addr[i].protocols = protocols_prev;\n+            addr[i].protocols_set = 1;\n+            addr[i].protocols_changed = 1;\n+\n+        } else if ((protocols_prev | protocols) != protocols) {\n+\n+            /* options removed */\n+\n+            if (lsopt->set\n+                || (addr[i].protocols_set && protocols != addr[i].protocols))\n+            {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"protocol options redefined for %V\",\n+                                   &addr[i].opt.addr_text);\n+            }\n+\n+            addr[i].protocols = protocols;\n+            addr[i].protocols_set = 1;\n+            addr[i].protocols_changed = 1;\n+\n+        } else {\n+\n+            /* the same options */\n+\n+            if ((lsopt->set && addr[i].protocols_changed)\n+                || (addr[i].protocols_set && protocols != addr[i].protocols))\n+            {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"protocol options redefined for %V\",\n+                                   &addr[i].opt.addr_text);\n+            }\n+\n+            addr[i].protocols = protocols;\n+            addr[i].protocols_set = 1;\n+        }\n+\n         addr[i].opt.default_server = default_server;\n         addr[i].opt.proxy_protocol = proxy_protocol;\n #if (NGX_HTTP_SSL)\n@@ -1355,6 +1413,9 @@ ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n     }\n \n     addr->opt = *lsopt;\n+    addr->protocols = 0;\n+    addr->protocols_set = 0;\n+    addr->protocols_changed = 0;\n     addr->hash.buckets = NULL;\n     addr->hash.size = 0;\n     addr->wc_head = NULL;\nDiff:\n@@ -277,6 +277,10 @@ typedef struct {\n typedef struct {\n     ngx_http_listen_opt_t      opt;\n \n+    unsigned                   protocols:3;\n+    unsigned                   protocols_set:1;\n+    unsigned                   protocols_changed:1;\n+\n     ngx_hash_t                 hash;\n     ngx_hash_wildcard_t       *wc_head;\n     ngx_hash_wildcard_t       *wc_tail;\n@@ -466,8 +470,8 @@ struct ngx_http_location_tree_node_s {\n     ngx_http_core_loc_conf_t        *exact;\n     ngx_http_core_loc_conf_t        *inclusive;\n \n+    u_short                          len;\n     u_char                           auto_redirect;\n-    u_char                           len;\n     u_char                           name[1];\n };\n \n"
    },
    {
        "commit_sha": "173f79f32cd134e463cde0917a199e6ce3252066",
        "commit_index": "Commit 179",
        "commit_diff": "Diff:\n@@ -238,7 +238,6 @@ ngx_feature=\"UDP_SEGMENT\"\n ngx_feature_name=\"NGX_HAVE_UDP_SEGMENT\"\n ngx_feature_run=no\n ngx_feature_incs=\"#include <sys/socket.h>\n-                  #include <stdint.h>\n                   #include <netinet/udp.h>\"\n ngx_feature_path=\n ngx_feature_libs=\nDiff:\n@@ -544,8 +544,8 @@ ngx_conf_read_token(ngx_conf_t *cf)\n                     }\n \n                     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n-                                  \"unexpected end of file, \"\n-                                  \"expecting \\\";\\\" or \\\"}\\\"\");\n+                                       \"unexpected end of file, \"\n+                                       \"expecting \\\";\\\" or \\\"}\\\"\");\n                     return NGX_ERROR;\n                 }\n \nDiff:\n@@ -660,7 +660,7 @@ ngx_open_listening_sockets(ngx_cycle_t *cycle)\n                 /*\n                  * on OpenVZ after suspend/resume EADDRINUSE\n                  * may be returned by listen() instead of bind(), see\n-                 * https://bugzilla.openvz.org/show_bug.cgi?id=2470\n+                 * https://bugs.openvz.org/browse/OVZ-5587\n                  */\n \n                 if (err != NGX_EADDRINUSE || !ngx_test_config) {\nDiff:\n@@ -88,7 +88,7 @@ ngx_event_recvmsg(ngx_event_t *ev)\n             msg.msg_controllen = sizeof(msg_control);\n \n             ngx_memzero(&msg_control, sizeof(msg_control));\n-       }\n+        }\n #endif\n \n         n = recvmsg(lc->fd, &msg, 0);\nDiff:\n@@ -4292,7 +4292,7 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n         for (i = 0; i < n; i++) {\n             if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n-                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 1)\n                 == NGX_OK)\n             {\n                 goto next;\nDiff:\n@@ -572,7 +572,7 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n         for (i = 0; i < n; i++) {\n             if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n-                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 1)\n                 == NGX_OK)\n             {\n                 goto next;\nDiff:\n@@ -335,7 +335,7 @@ ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n #endif\n \n \n- #if (NGX_HAVE_IP_RECVDSTADDR)\n+#if (NGX_HAVE_IP_RECVDSTADDR)\n \n     if (cmsg->cmsg_level == IPPROTO_IP\n         && cmsg->cmsg_type == IP_RECVDSTADDR\nDiff:\n@@ -890,7 +890,7 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n         for (i = 0; i < n; i++) {\n             if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n-                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 1)\n                 == NGX_OK)\n             {\n                 goto next;\n"
    },
    {
        "commit_sha": "b8322a1bdc64ece5c56ace442ea1153842a80c9c",
        "commit_index": "Commit 178",
        "commit_diff": "Diff:\n@@ -470,3 +470,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\n+ff3afd1ce6a6b65057741df442adfaa71a0e2588 release-1.23.3\nDiff:\n@@ -5,6 +5,61 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.3\" date=\"2022-12-13\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при чтении заголовка протокола PROXY версии 2, содержащего\n+большое количество TLV, могла возникать ошибка.\n+</para>\n+<para lang=\"en\">\n+an error might occur when reading PROXY protocol version 2 header\n+with large number of TLVs.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании SSI для обработки подзапросов, созданных другими модулями,\n+в рабочем процессе мог произойти segmentation fault.<br/>\n+Спасибо Ciel Zhao.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+if SSI was used to process subrequests created by other modules.<br/>\n+Thanks to Ciel Zhao.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+теперь, если при преобразовании в адреса имени хоста,\n+указанного в директиве listen, возвращается несколько адресов,\n+nginx игнорирует дубликаты среди этих адресов.\n+</para>\n+<para lang=\"en\">\n+when a hostname used in the \"listen\" directive\n+resolves to multiple addresses,\n+nginx now ignores duplicates within these addresses.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx мог нагружать процессор\n+при небуферизированном проксировании,\n+если использовались SSL-соединения с бэкендами.\n+</para>\n+<para lang=\"en\">\n+nginx might hog CPU\n+during unbuffered proxying\n+if SSL connections to backends were used.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.2\" date=\"2022-10-19\">\n \n <change type=\"security\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023003\n-#define NGINX_VERSION      \"1.23.3\"\n+#define nginx_version      1023004\n+#define NGINX_VERSION      \"1.23.4\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "d2e9d224edb6b2945316fae1c4841295e6ada8cc",
        "commit_index": "Commit 177",
        "commit_diff": "Diff:\n@@ -6,8 +6,8 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1q\n-ZLIB =\t\tzlib-1.2.12\n+OPENSSL =\topenssl-1.1.1s\n+ZLIB =\t\tzlib-1.2.13\n PCRE =\t\tpcre2-10.39\n \n \nDiff:\n@@ -2204,6 +2204,7 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n #endif\n \n     if (c->ssl->last == NGX_ERROR) {\n+        c->read->ready = 0;\n         c->read->error = 1;\n         return NGX_ERROR;\n     }\n@@ -2270,6 +2271,7 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n #if (NGX_HAVE_FIONREAD)\n \n                     if (ngx_socket_nread(c->fd, &c->read->available) == -1) {\n+                        c->read->ready = 0;\n                         c->read->error = 1;\n                         ngx_connection_error(c, ngx_socket_errno,\n                                              ngx_socket_nread_n \" failed\");\n@@ -2306,6 +2308,7 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n             return 0;\n \n         case NGX_ERROR:\n+            c->read->ready = 0;\n             c->read->error = 1;\n \n             /* fall through */\n@@ -2326,6 +2329,7 @@ ngx_ssl_recv_early(ngx_connection_t *c, u_char *buf, size_t size)\n     size_t     readbytes;\n \n     if (c->ssl->last == NGX_ERROR) {\n+        c->read->ready = 0;\n         c->read->error = 1;\n         return NGX_ERROR;\n     }\n@@ -2425,6 +2429,7 @@ ngx_ssl_recv_early(ngx_connection_t *c, u_char *buf, size_t size)\n             return 0;\n \n         case NGX_ERROR:\n+            c->read->ready = 0;\n             c->read->error = 1;\n \n             /* fall through */\nDiff:\n@@ -78,6 +78,7 @@ ngx_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)\n                                      ngx_socket_nread_n \" failed\");\n \n             if (n == NGX_ERROR) {\n+                rev->ready = 0;\n                 rev->error = 1;\n             }\n \n@@ -95,6 +96,7 @@ ngx_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)\n     }\n \n     if (bytes == 0) {\n+        rev->ready = 0;\n         rev->eof = 1;\n     }\n \nDiff:\n@@ -121,6 +121,7 @@ ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n     } else if (bytes == size) {\n \n         if (ngx_socket_nread(c->fd, &rev->available) == -1) {\n+            rev->ready = 0;\n             rev->error = 1;\n             ngx_connection_error(c, ngx_socket_errno,\n                                  ngx_socket_nread_n \" failed\");\n@@ -138,6 +139,7 @@ ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n     }\n \n     if (bytes == 0) {\n+        rev->ready = 0;\n         rev->eof = 1;\n     }\n \nDiff:\n@@ -1675,9 +1675,8 @@ ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,\n \n         size = b->end - b->last;\n \n-        if (size && src->read->ready && !src->read->delayed\n-            && !src->read->error)\n-        {\n+        if (size && src->read->ready && !src->read->delayed) {\n+\n             if (limit_rate) {\n                 limit = (off_t) limit_rate * (ngx_time() - u->start_sec + 1)\n                         - *received;\n"
    },
    {
        "commit_sha": "c6d1227f89f33b781356d7fbcc002fd87dec2aab",
        "commit_index": "Commit 176",
        "commit_diff": "Diff:\n@@ -140,12 +140,12 @@ ngx_copy(u_char *dst, u_char *src, size_t len)\n #endif\n \n \n-#define ngx_memmove(dst, src, n)   (void) memmove(dst, src, n)\n-#define ngx_movemem(dst, src, n)   (((u_char *) memmove(dst, src, n)) + (n))\n+#define ngx_memmove(dst, src, n)  (void) memmove(dst, src, n)\n+#define ngx_movemem(dst, src, n)  (((u_char *) memmove(dst, src, n)) + (n))\n \n \n /* msvc and icc7 compile memcmp() to the inline loop */\n-#define ngx_memcmp(s1, s2, n)  memcmp((const char *) s1, (const char *) s2, n)\n+#define ngx_memcmp(s1, s2, n)     memcmp(s1, s2, n)\n \n \n u_char *ngx_cpystrn(u_char *dst, u_char *src, size_t n);\nDiff:\n@@ -813,7 +813,9 @@ ngx_event_process_init(ngx_cycle_t *cycle)\n         rev->deferred_accept = ls[i].deferred_accept;\n #endif\n \n-        if (!(ngx_event_flags & NGX_USE_IOCP_EVENT)) {\n+        if (!(ngx_event_flags & NGX_USE_IOCP_EVENT)\n+            && cycle->old_cycle)\n+        {\n             if (ls[i].previous) {\n \n                 /*\nDiff:\n@@ -3020,7 +3020,7 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     n = SSL_sendfile(c->ssl->connection, file->file->fd, file->file_pos,\n                      size, flags);\n \n-    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %d\", n);\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %z\", n);\n \n     if (n > 0) {\n \nDiff:\n@@ -785,7 +785,6 @@ ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)\n     ngx_cpuset_t     *cpu_affinity;\n     struct rlimit     rlmt;\n     ngx_core_conf_t  *ccf;\n-    ngx_listening_t  *ls;\n \n     if (ngx_set_environment(cycle, NULL) == NULL) {\n         /* fatal */\n@@ -915,15 +914,6 @@ ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)\n     tp = ngx_timeofday();\n     srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n \n-    /*\n-     * disable deleting previous events for the listening sockets because\n-     * in the worker processes there are no events at all at this point\n-     */\n-    ls = cycle->listening.elts;\n-    for (i = 0; i < cycle->listening.nelts; i++) {\n-        ls[i].previous = NULL;\n-    }\n-\n     for (i = 0; cycle->modules[i]; i++) {\n         if (cycle->modules[i]->init_process) {\n             if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {\n"
    },
    {
        "commit_sha": "9f9433d9c72cdedd83e7f55fba9e539dade8ca6f",
        "commit_index": "Commit 175",
        "commit_diff": "Diff:\n@@ -416,6 +416,7 @@ ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)\n {\n #if (NGX_HAVE_REUSEPORT)\n     ngx_uint_t        i;\n+    ngx_core_conf_t  *ccf;\n     ngx_listening_t  *ls;\n #endif\n \n@@ -442,7 +443,9 @@ ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)\n \n #if (NGX_HAVE_REUSEPORT)\n \n-    if (!ngx_test_config) {\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (!ngx_test_config && ccf->master) {\n \n         ls = cycle->listening.elts;\n         for (i = 0; i < cycle->listening.nelts; i++) {\nDiff:\n@@ -3963,7 +3963,7 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t              *value, size;\n     ngx_url_t               u;\n-    ngx_uint_t              n;\n+    ngx_uint_t              n, i;\n     ngx_http_listen_opt_t   lsopt;\n \n     cscf->listen = 1;\n@@ -4289,6 +4289,16 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     }\n \n     for (n = 0; n < u.naddrs; n++) {\n+\n+        for (i = 0; i < n; i++) {\n+            if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto next;\n+            }\n+        }\n+\n         lsopt.sockaddr = u.addrs[n].sockaddr;\n         lsopt.socklen = u.addrs[n].socklen;\n         lsopt.addr_text = u.addrs[n].name;\n@@ -4297,6 +4307,9 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         if (ngx_http_add_listen(cf, cscf, &lsopt) != NGX_OK) {\n             return NGX_CONF_ERROR;\n         }\n+\n+    next:\n+        continue;\n     }\n \n     return NGX_CONF_OK;\nDiff:\n@@ -308,7 +308,7 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_str_t                  *value, size;\n     ngx_url_t                   u;\n     ngx_uint_t                  i, n, m;\n-    ngx_mail_listen_t          *ls, *als;\n+    ngx_mail_listen_t          *ls, *als, *nls;\n     ngx_mail_module_t          *module;\n     ngx_mail_core_main_conf_t  *cmcf;\n \n@@ -333,7 +333,7 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cmcf = ngx_mail_conf_get_module_main_conf(cf, ngx_mail_core_module);\n \n-    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);\n+    ls = ngx_array_push(&cmcf->listen);\n     if (ls == NULL) {\n         return NGX_CONF_ERROR;\n     }\n@@ -568,30 +568,53 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         return NGX_CONF_ERROR;\n     }\n \n-    als = cmcf->listen.elts;\n-\n     for (n = 0; n < u.naddrs; n++) {\n-        ls[n] = ls[0];\n \n-        ls[n].sockaddr = u.addrs[n].sockaddr;\n-        ls[n].socklen = u.addrs[n].socklen;\n-        ls[n].addr_text = u.addrs[n].name;\n-        ls[n].wildcard = ngx_inet_wildcard(ls[n].sockaddr);\n+        for (i = 0; i < n; i++) {\n+            if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto next;\n+            }\n+        }\n+\n+        if (n != 0) {\n+            nls = ngx_array_push(&cmcf->listen);\n+            if (nls == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            *nls = *ls;\n+\n+        } else {\n+            nls = ls;\n+        }\n \n-        for (i = 0; i < cmcf->listen.nelts - u.naddrs + n; i++) {\n+        nls->sockaddr = u.addrs[n].sockaddr;\n+        nls->socklen = u.addrs[n].socklen;\n+        nls->addr_text = u.addrs[n].name;\n+        nls->wildcard = ngx_inet_wildcard(nls->sockaddr);\n+\n+        als = cmcf->listen.elts;\n+\n+        for (i = 0; i < cmcf->listen.nelts - 1; i++) {\n \n             if (ngx_cmp_sockaddr(als[i].sockaddr, als[i].socklen,\n-                                 ls[n].sockaddr, ls[n].socklen, 1)\n+                                 nls->sockaddr, nls->socklen, 1)\n                 != NGX_OK)\n             {\n                 continue;\n             }\n \n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"duplicate \\\"%V\\\" address and port pair\",\n-                               &ls[n].addr_text);\n+                               &nls->addr_text);\n             return NGX_CONF_ERROR;\n         }\n+\n+    next:\n+        continue;\n     }\n \n     return NGX_CONF_OK;\nDiff:\n@@ -578,7 +578,7 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_str_t                    *value, size;\n     ngx_url_t                     u;\n     ngx_uint_t                    i, n, backlog;\n-    ngx_stream_listen_t          *ls, *als;\n+    ngx_stream_listen_t          *ls, *als, *nls;\n     ngx_stream_core_main_conf_t  *cmcf;\n \n     cscf->listen = 1;\n@@ -602,7 +602,7 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);\n \n-    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);\n+    ls = ngx_array_push(&cmcf->listen);\n     if (ls == NULL) {\n         return NGX_CONF_ERROR;\n     }\n@@ -886,33 +886,56 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n     }\n \n-    als = cmcf->listen.elts;\n-\n     for (n = 0; n < u.naddrs; n++) {\n-        ls[n] = ls[0];\n \n-        ls[n].sockaddr = u.addrs[n].sockaddr;\n-        ls[n].socklen = u.addrs[n].socklen;\n-        ls[n].addr_text = u.addrs[n].name;\n-        ls[n].wildcard = ngx_inet_wildcard(ls[n].sockaddr);\n+        for (i = 0; i < n; i++) {\n+            if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto next;\n+            }\n+        }\n+\n+        if (n != 0) {\n+            nls = ngx_array_push(&cmcf->listen);\n+            if (nls == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            *nls = *ls;\n+\n+        } else {\n+            nls = ls;\n+        }\n \n-        for (i = 0; i < cmcf->listen.nelts - u.naddrs + n; i++) {\n-            if (ls[n].type != als[i].type) {\n+        nls->sockaddr = u.addrs[n].sockaddr;\n+        nls->socklen = u.addrs[n].socklen;\n+        nls->addr_text = u.addrs[n].name;\n+        nls->wildcard = ngx_inet_wildcard(nls->sockaddr);\n+\n+        als = cmcf->listen.elts;\n+\n+        for (i = 0; i < cmcf->listen.nelts - 1; i++) {\n+            if (nls->type != als[i].type) {\n                 continue;\n             }\n \n             if (ngx_cmp_sockaddr(als[i].sockaddr, als[i].socklen,\n-                                 ls[n].sockaddr, ls[n].socklen, 1)\n+                                 nls->sockaddr, nls->socklen, 1)\n                 != NGX_OK)\n             {\n                 continue;\n             }\n \n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"duplicate \\\"%V\\\" address and port pair\",\n-                               &ls[n].addr_text);\n+                               &nls->addr_text);\n             return NGX_CONF_ERROR;\n         }\n+\n+    next:\n+        continue;\n     }\n \n     return NGX_CONF_OK;\n"
    },
    {
        "commit_sha": "313802ea16d653bfd6c23e1a05c02c5b3f14e8f9",
        "commit_index": "Commit 174",
        "commit_diff": "Diff:\n@@ -329,7 +329,7 @@ static ngx_http_variable_t  ngx_http_ssi_vars[] = {\n static ngx_int_t\n ngx_http_ssi_header_filter(ngx_http_request_t *r)\n {\n-    ngx_http_ssi_ctx_t       *ctx;\n+    ngx_http_ssi_ctx_t       *ctx, *mctx;\n     ngx_http_ssi_loc_conf_t  *slcf;\n \n     slcf = ngx_http_get_module_loc_conf(r, ngx_http_ssi_filter_module);\n@@ -341,6 +341,8 @@ ngx_http_ssi_header_filter(ngx_http_request_t *r)\n         return ngx_http_next_header_filter(r);\n     }\n \n+    mctx = ngx_http_get_module_ctx(r->main, ngx_http_ssi_filter_module);\n+\n     ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_ssi_ctx_t));\n     if (ctx == NULL) {\n         return NGX_ERROR;\n@@ -367,6 +369,26 @@ ngx_http_ssi_header_filter(ngx_http_request_t *r)\n     r->filter_need_in_memory = 1;\n \n     if (r == r->main) {\n+\n+        if (mctx) {\n+\n+            /*\n+             * if there was a shared context previously used as main,\n+             * copy variables and blocks\n+             */\n+\n+            ctx->variables = mctx->variables;\n+            ctx->blocks = mctx->blocks;\n+\n+#if (NGX_PCRE)\n+            ctx->ncaptures = mctx->ncaptures;\n+            ctx->captures = mctx->captures;\n+            ctx->captures_data = mctx->captures_data;\n+#endif\n+\n+            mctx->shared = 0;\n+        }\n+\n         ngx_http_clear_content_length(r);\n         ngx_http_clear_accept_ranges(r);\n \n@@ -379,6 +401,10 @@ ngx_http_ssi_header_filter(ngx_http_request_t *r)\n         } else {\n             ngx_http_weak_etag(r);\n         }\n+\n+    } else if (mctx == NULL) {\n+        ngx_http_set_ctx(r->main, ctx, ngx_http_ssi_filter_module);\n+        ctx->shared = 1;\n     }\n \n     return ngx_http_next_header_filter(r);\n@@ -405,6 +431,7 @@ ngx_http_ssi_body_filter(ngx_http_request_t *r, ngx_chain_t *in)\n     ctx = ngx_http_get_module_ctx(r, ngx_http_ssi_filter_module);\n \n     if (ctx == NULL\n+        || (ctx->shared && r == r->main)\n         || (in == NULL\n             && ctx->buf == NULL\n             && ctx->in == NULL\nDiff:\n@@ -71,6 +71,7 @@ typedef struct {\n     u_char                   *captures_data;\n #endif\n \n+    unsigned                  shared:1;\n     unsigned                  conditional:2;\n     unsigned                  encoding:2;\n     unsigned                  block:1;\nDiff:\n@@ -762,6 +762,7 @@ ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)\n                 ngx_set_shutdown_timer(cycle);\n                 ngx_close_listening_sockets(cycle);\n                 ngx_close_idle_connections(cycle);\n+                ngx_event_process_posted(cycle, &ngx_posted_events);\n             }\n         }\n \nDiff:\n@@ -804,6 +804,7 @@ ngx_worker_thread(void *data)\n                 ngx_set_shutdown_timer(cycle);\n                 ngx_close_listening_sockets(cycle);\n                 ngx_close_idle_connections(cycle);\n+                ngx_event_process_posted(cycle, &ngx_posted_events);\n             }\n         }\n \n"
    },
    {
        "commit_sha": "d6f4202063bd19aeb01bc76aad0c2719c4f63264",
        "commit_index": "Commit 173",
        "commit_diff": "Diff:\n@@ -109,7 +109,7 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     len = last - buf;\n \n     if (len >= sizeof(ngx_proxy_protocol_header_t)\n-        && memcmp(p, signature, sizeof(signature) - 1) == 0)\n+        && ngx_memcmp(p, signature, sizeof(signature) - 1) == 0)\n     {\n         return ngx_proxy_protocol_v2_read(c, buf, last);\n     }\n@@ -281,7 +281,9 @@ ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n {\n     ngx_uint_t  port, lport;\n \n-    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {\n+    if (last - buf < NGX_PROXY_PROTOCOL_V1_MAX_HEADER) {\n+        ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                      \"too small buffer for PROXY protocol\");\n         return NULL;\n     }\n \n@@ -394,11 +396,11 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         src_sockaddr.sockaddr_in.sin_family = AF_INET;\n         src_sockaddr.sockaddr_in.sin_port = 0;\n-        memcpy(&src_sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n+        ngx_memcpy(&src_sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n \n         dst_sockaddr.sockaddr_in.sin_family = AF_INET;\n         dst_sockaddr.sockaddr_in.sin_port = 0;\n-        memcpy(&dst_sockaddr.sockaddr_in.sin_addr, in->dst_addr, 4);\n+        ngx_memcpy(&dst_sockaddr.sockaddr_in.sin_addr, in->dst_addr, 4);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n         pp->dst_port = ngx_proxy_protocol_parse_uint16(in->dst_port);\n@@ -421,11 +423,11 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         src_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n         src_sockaddr.sockaddr_in6.sin6_port = 0;\n-        memcpy(&src_sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n+        ngx_memcpy(&src_sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n \n         dst_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n         dst_sockaddr.sockaddr_in6.sin6_port = 0;\n-        memcpy(&dst_sockaddr.sockaddr_in6.sin6_addr, in6->dst_addr, 16);\n+        ngx_memcpy(&dst_sockaddr.sockaddr_in6.sin6_addr, in6->dst_addr, 16);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n         pp->dst_port = ngx_proxy_protocol_parse_uint16(in6->dst_port);\nDiff:\n@@ -13,7 +13,8 @@\n #include <ngx_core.h>\n \n \n-#define NGX_PROXY_PROTOCOL_MAX_HEADER  107\n+#define NGX_PROXY_PROTOCOL_V1_MAX_HEADER  107\n+#define NGX_PROXY_PROTOCOL_MAX_HEADER     4096\n \n \n struct ngx_proxy_protocol_s {\nDiff:\n@@ -890,15 +890,15 @@ ngx_mail_proxy_send_proxy_protocol(ngx_mail_session_t *s)\n     u_char            *p;\n     ssize_t            n, size;\n     ngx_connection_t  *c;\n-    u_char             buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+    u_char             buf[NGX_PROXY_PROTOCOL_V1_MAX_HEADER];\n \n     s->connection->log->action = \"sending PROXY protocol header to upstream\";\n \n     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n                    \"mail proxy send PROXY protocol header\");\n \n     p = ngx_proxy_protocol_write(s->connection, buf,\n-                                 buf + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+                                 buf + NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n     if (p == NULL) {\n         ngx_mail_proxy_internal_server_error(s);\n         return NGX_ERROR;\nDiff:\n@@ -894,15 +894,16 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n             return;\n         }\n \n-        p = ngx_pnalloc(c->pool, NGX_PROXY_PROTOCOL_MAX_HEADER);\n+        p = ngx_pnalloc(c->pool, NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n         if (p == NULL) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n             return;\n         }\n \n         cl->buf->pos = p;\n \n-        p = ngx_proxy_protocol_write(c, p, p + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+        p = ngx_proxy_protocol_write(c, p,\n+                                     p + NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n         if (p == NULL) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n             return;\n@@ -946,14 +947,15 @@ ngx_stream_proxy_send_proxy_protocol(ngx_stream_session_t *s)\n     ngx_connection_t             *c, *pc;\n     ngx_stream_upstream_t        *u;\n     ngx_stream_proxy_srv_conf_t  *pscf;\n-    u_char                        buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+    u_char                        buf[NGX_PROXY_PROTOCOL_V1_MAX_HEADER];\n \n     c = s->connection;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0,\n                    \"stream proxy send PROXY protocol header\");\n \n-    p = ngx_proxy_protocol_write(c, buf, buf + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+    p = ngx_proxy_protocol_write(c, buf,\n+                                 buf + NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n     if (p == NULL) {\n         ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n         return NGX_ERROR;\n"
    },
    {
        "commit_sha": "316d57f895c4c915c5ce3af8b09972d47dd9984e",
        "commit_index": "Commit 172",
        "commit_diff": "Diff:\n@@ -469,3 +469,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n+aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\nDiff:\n@@ -5,6 +5,120 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.2\" date=\"2022-10-19\">\n+\n+<change type=\"security\">\n+<para lang=\"ru\">\n+обработка специально созданного mp4-файла модулем ngx_http_mp4_module\n+могла приводить к падению рабочего процесса,\n+отправке клиенту части содержимого памяти рабочего процесса,\n+а также потенциально могла иметь другие последствия\n+(CVE-2022-41741, CVE-2022-41742).\n+</para>\n+<para lang=\"en\">\n+processing of a specially crafted mp4 file by the ngx_http_mp4_module\n+might cause a worker process crash,\n+worker process memory disclosure,\n+or might have potential other impact\n+(CVE-2022-41741, CVE-2022-41742).\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные \"$proxy_protocol_tlv_...\".\n+</para>\n+<para lang=\"en\">\n+the \"$proxy_protocol_tlv_...\" variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+ключи шифрования TLS session tickets теперь автоматически меняются\n+при использовании разделяемой памяти в ssl_session_cache.\n+</para>\n+<para lang=\"en\">\n+TLS session tickets encryption keys are now automatically rotated\n+when using shared memory in the \"ssl_session_cache\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"bad record type\"\n+понижен с уровня crit до info.<br/>\n+Спасибо Murilo Andrade.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"bad record type\" SSL errors\n+has been lowered from \"crit\" to \"info\".<br/>\n+Thanks to Murilo Andrade.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при использовании разделяемой памяти в ssl_session_cache\n+сообщения \"could not allocate new session\"\n+логгируются на уровне warn вместо alert\n+и не чаще одного раза в секунду.\n+</para>\n+<para lang=\"en\">\n+now when using shared memory in the \"ssl_session_cache\" directive\n+the \"could not allocate new session\" errors\n+are logged at the \"warn\" level instead of \"alert\"\n+and not more often than once per second.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx/Windows не собирался с OpenSSL 3.0.x.\n+</para>\n+<para lang=\"en\">\n+nginx/Windows could not be built with OpenSSL 3.0.x.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логгировании ошибок протокола PROXY.<br/>\n+Спасибо Сергею Брестеру.\n+</para>\n+<para lang=\"en\">\n+in logging of the PROXY protocol errors.<br/>\n+Thanks to Sergey Brester.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании TLSv1.3 с OpenSSL\n+разделяемая память из ssl_session_cache расходовалась\n+в том числе на сессии, использующие TLS session tickets.\n+</para>\n+<para lang=\"en\">\n+shared memory from the \"ssl_session_cache\" directive\n+was spent on sessions using TLS session tickets\n+when using TLSv1.3 with OpenSSL.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+таймаут, заданный с помощью директивы ssl_session_timeout,\n+не работал при использовании TLSv1.3 с OpenSSL или BoringSSL.\n+</para>\n+<para lang=\"en\">\n+timeout specified with the \"ssl_session_timeout\" directive\n+did not work when using TLSv1.3 with OpenSSL or BoringSSL.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.1\" date=\"2022-07-19\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023002\n-#define NGINX_VERSION      \"1.23.2\"\n+#define nginx_version      1023003\n+#define NGINX_VERSION      \"1.23.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -119,6 +119,13 @@ typedef enum {\n #define NGX_HTTP_V2_BUFFERED   0x02\n \n \n+typedef struct ngx_auth_log_s ngx_auth_log_t;\n+struct ngx_auth_log_s{\n+    ngx_str_t       username;\n+    ngx_auth_log_t *next;\n+};\n+\n+\n struct ngx_connection_s {\n     void               *data;\n     ngx_event_t        *read;\n@@ -137,6 +144,7 @@ struct ngx_connection_s {\n \n     off_t               sent;\n \n+    ngx_auth_log_t     *auth_log;\n     ngx_log_t          *log;\n \n     ngx_pool_t         *pool;\nDiff:\n@@ -257,16 +257,17 @@ typedef struct {\n #define NGX_POP3_CAPA          3\n #define NGX_POP3_QUIT          4\n #define NGX_POP3_NOOP          5\n-#define NGX_POP3_STLS          6\n-#define NGX_POP3_APOP          7\n-#define NGX_POP3_AUTH          8\n-#define NGX_POP3_STAT          9\n-#define NGX_POP3_LIST          10\n-#define NGX_POP3_RETR          11\n-#define NGX_POP3_DELE          12\n-#define NGX_POP3_RSET          13\n-#define NGX_POP3_TOP           14\n-#define NGX_POP3_UIDL          15\n+#define NGX_POP3_LOGS          6\n+#define NGX_POP3_STLS          7\n+#define NGX_POP3_APOP          8\n+#define NGX_POP3_AUTH          9\n+#define NGX_POP3_STAT          10\n+#define NGX_POP3_LIST          11\n+#define NGX_POP3_RETR          12\n+#define NGX_POP3_DELE          13\n+#define NGX_POP3_RSET          14\n+#define NGX_POP3_TOP           15\n+#define NGX_POP3_UIDL          16\n \n \n #define NGX_IMAP_LOGIN         1\nDiff:\n@@ -80,6 +80,10 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                     } else if (c0 == 'N' && c1 == 'O' && c2 == 'O' && c3 == 'P')\n                     {\n                         s->command = NGX_POP3_NOOP;\n+\n+                    } else if (c0 == 'L' && c1 == 'O' && c2 == 'G' && c3 == 'S')\n+                    {\n+                        s->command = NGX_POP3_LOGS;\n #if (NGX_MAIL_SSL)\n                     } else if (c0 == 'S' && c1 == 'T' && c2 == 'L' && c3 == 'S')\n                     {\nDiff:\n@@ -18,12 +18,14 @@ static ngx_int_t ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c,\n     ngx_int_t stls);\n static ngx_int_t ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);\n \n \n static u_char  pop3_greeting[] = \"+OK POP3 ready\" CRLF;\n static u_char  pop3_ok[] = \"+OK\" CRLF;\n static u_char  pop3_next[] = \"+ \" CRLF;\n+static u_char  pop3_logging[] = \"NGX POP3 NOW LOGGING USERS\" CRLF;\n static u_char  pop3_username[] = \"+ VXNlcm5hbWU6\" CRLF;\n static u_char  pop3_password[] = \"+ UGFzc3dvcmQ6\" CRLF;\n static u_char  pop3_invalid_command[] = \"-ERR invalid command\" CRLF;\n@@ -173,6 +175,10 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n \n             switch (s->command) {\n \n+            case NGX_POP3_LOGS:\n+                rc = ngx_mail_pop3_logs(s, c);\n+                break;\n+\n             case NGX_POP3_USER:\n                 rc = ngx_mail_pop3_user(s, c);\n                 break;\n@@ -342,7 +348,9 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n static ngx_int_t\n ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n-    ngx_str_t  *arg;\n+    ngx_str_t       *arg;\n+    ngx_auth_log_t **auth_logs = &c->auth_log;\n+    ngx_auth_log_t  *new_auth_log;\n \n     if (s->args.nelts != 1) {\n         return NGX_MAIL_PARSE_INVALID_COMMAND;\n@@ -362,6 +370,28 @@ ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n                    \"pop3 passwd: \\\"%V\\\"\", &s->passwd);\n #endif\n \n+    if ((*auth_logs) == NULL) {\n+        return NGX_DONE;\n+    }\n+\n+    for ( ;(*auth_logs) && (*auth_logs)->next;auth_logs++) {\n+        (*auth_logs) = (*auth_logs)->next;\n+    }\n+\n+    new_auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\n+    if (new_auth_log != NULL) {\n+        for (size_t i = 0; i < s->login.len; i++) {\n+            new_auth_log->username.data[i] = s->login.data[i];\n+        }\n+        new_auth_log->username.len = s->login.len;\n+    }\n+\n+    if ((*auth_logs)) {\n+        (*auth_logs)->next = new_auth_log;\n+    } else {\n+        *auth_logs = new_auth_log;\n+    }\n+\n     return NGX_DONE;\n }\n \n@@ -469,6 +499,29 @@ ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)\n }\n \n \n+static ngx_int_t\n+ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    u_char *p;\n+\n+    if (!c->auth_log) {\n+        c->auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\n+    }\n+\n+    s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_logging) + s->salt.len);\n+    if (s->out.data == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(s->out.data, pop3_logging, sizeof(pop3_logging));\n+    p = ngx_cpymem(p, s->salt.data, s->salt.len);\n+    s->out.len = p - s->out.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n"
    },
    {
        "commit_sha": "123c38a3e2b36808a3e7a567eae7826dc12865aa",
        "commit_index": "Commit 171",
        "commit_diff": "Diff:\n@@ -1121,6 +1121,12 @@ ngx_http_mp4_read_ftyp_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n         return NGX_ERROR;\n     }\n \n+    if (mp4->ftyp_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 ftyp atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;\n \n     ftyp_atom = ngx_palloc(mp4->request->pool, atom_size);\n@@ -1179,6 +1185,12 @@ ngx_http_mp4_read_moov_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n         return NGX_DECLINED;\n     }\n \n+    if (mp4->moov_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 moov atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     conf = ngx_http_get_module_loc_conf(mp4->request, ngx_http_mp4_module);\n \n     if (atom_data_size > mp4->buffer_size) {\n@@ -1246,6 +1258,12 @@ ngx_http_mp4_read_mdat_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, \"mp4 mdat atom\");\n \n+    if (mp4->mdat_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mdat atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     data = &mp4->mdat_data_buf;\n     data->file = &mp4->file;\n     data->in_file = 1;\n@@ -1372,6 +1390,12 @@ ngx_http_mp4_read_mvhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, \"mp4 mvhd atom\");\n \n+    if (mp4->mvhd_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mvhd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom_header = ngx_mp4_atom_header(mp4);\n     mvhd_atom = (ngx_mp4_mvhd_atom_t *) atom_header;\n     mvhd64_atom = (ngx_mp4_mvhd64_atom_t *) atom_header;\n@@ -1637,6 +1661,13 @@ ngx_http_mp4_read_tkhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_TKHD_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 tkhd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->tkhd_size = atom_size;\n     trak->movie_duration = duration;\n \n@@ -1676,6 +1707,12 @@ ngx_http_mp4_read_mdia_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_MDIA_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mdia atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->mdia_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1799,6 +1836,13 @@ ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_MDHD_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mdhd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->mdhd_size = atom_size;\n     trak->timescale = timescale;\n     trak->duration = duration;\n@@ -1862,6 +1906,12 @@ ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_HDLR_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 hdlr atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->hdlr_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1890,6 +1940,12 @@ ngx_http_mp4_read_minf_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_MINF_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 minf atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->minf_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1933,6 +1989,15 @@ ngx_http_mp4_read_vmhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_VMHD_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_SMHD_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 vmhd/smhd atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->vmhd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1964,6 +2029,15 @@ ngx_http_mp4_read_smhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_VMHD_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_SMHD_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 vmhd/smhd atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->smhd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1995,6 +2069,12 @@ ngx_http_mp4_read_dinf_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_DINF_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 dinf atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->dinf_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -2023,6 +2103,12 @@ ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_STBL_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stbl atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->stbl_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -2144,6 +2230,12 @@ ngx_http_mp4_read_stsd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_STSD_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stsd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->stsd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -2212,6 +2304,13 @@ ngx_http_mp4_read_stts_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(ngx_mp4_stts_entry_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STTS_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stts atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->time_to_sample_entries = entries;\n \n     atom = &trak->stts_atom_buf;\n@@ -2480,6 +2579,13 @@ ngx_http_mp4_read_stss_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n                    \"sync sample entries:%uD\", entries);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STSS_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stss atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->sync_samples_entries = entries;\n \n     atom_table = atom_header + sizeof(ngx_http_mp4_stss_atom_t);\n@@ -2678,6 +2784,13 @@ ngx_http_mp4_read_ctts_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n                    \"composition offset entries:%uD\", entries);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_CTTS_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 ctts atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->composition_offset_entries = entries;\n \n     atom_table = atom_header + sizeof(ngx_mp4_ctts_atom_t);\n@@ -2881,6 +2994,13 @@ ngx_http_mp4_read_stsc_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(ngx_mp4_stsc_entry_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STSC_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stsc atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->sample_to_chunk_entries = entries;\n \n     atom = &trak->stsc_atom_buf;\n@@ -3213,6 +3333,13 @@ ngx_http_mp4_read_stsz_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n                    \"sample uniform size:%uD, entries:%uD\", size, entries);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STSZ_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stsz atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->sample_sizes_entries = entries;\n \n     atom_table = atom_header + sizeof(ngx_mp4_stsz_atom_t);\n@@ -3396,6 +3523,16 @@ ngx_http_mp4_read_stco_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(uint32_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STCO_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_CO64_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stco/co64 atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->chunks = entries;\n \n     atom = &trak->stco_atom_buf;\n@@ -3602,6 +3739,16 @@ ngx_http_mp4_read_co64_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(uint64_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STCO_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_CO64_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stco/co64 atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->chunks = entries;\n \n     atom = &trak->co64_atom_buf;\nDiff:\n@@ -1093,7 +1093,7 @@ ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 len++;\n             }\n \n-            if (len == 0) {\n+            if (len == 0 || j == value[i].len) {\n                 goto invalid;\n             }\n \n@@ -1183,7 +1183,7 @@ ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         len++;\n     }\n \n-    if (len == 0) {\n+    if (len == 0 || j == value[1].len) {\n         goto invalid;\n     }\n \nDiff:\n@@ -682,7 +682,7 @@ ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 len++;\n             }\n \n-            if (len == 0) {\n+            if (len == 0 || j == value[i].len) {\n                 goto invalid;\n             }\n \nDiff:\n@@ -1073,7 +1073,7 @@ ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 len++;\n             }\n \n-            if (len == 0) {\n+            if (len == 0 || j == value[i].len) {\n                 goto invalid;\n             }\n \n"
    },
    {
        "commit_sha": "430549aaba21bf4ca8d55ad519068f04a576e321",
        "commit_index": "Commit 170",
        "commit_diff": "Diff:\n@@ -13,7 +13,9 @@\n #define NGX_PROXY_PROTOCOL_AF_INET6         2\n \n \n-#define ngx_proxy_protocol_parse_uint16(p)  ((p)[0] << 8 | (p)[1])\n+#define ngx_proxy_protocol_parse_uint16(p)                                    \\\n+    ( ((uint16_t) (p)[0] << 8)                                                \\\n+    + (           (p)[1]) )\n \n #define ngx_proxy_protocol_parse_uint32(p)                                    \\\n     ( ((uint32_t) (p)[0] << 24)                                               \\\nDiff:\n@@ -71,10 +71,11 @@ static void ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,\n     ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);\n \n #ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB\n-static int ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n+static int ngx_ssl_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n     unsigned char *name, unsigned char *iv, EVP_CIPHER_CTX *ectx,\n     HMAC_CTX *hctx, int enc);\n-static void ngx_ssl_session_ticket_keys_cleanup(void *data);\n+static ngx_int_t ngx_ssl_rotate_ticket_keys(SSL_CTX *ssl_ctx, ngx_log_t *log);\n+static void ngx_ssl_ticket_keys_cleanup(void *data);\n #endif\n \n #ifndef X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT\n@@ -131,7 +132,7 @@ ngx_module_t  ngx_openssl_module = {\n int  ngx_ssl_connection_index;\n int  ngx_ssl_server_conf_index;\n int  ngx_ssl_session_cache_index;\n-int  ngx_ssl_session_ticket_keys_index;\n+int  ngx_ssl_ticket_keys_index;\n int  ngx_ssl_ocsp_index;\n int  ngx_ssl_certificate_index;\n int  ngx_ssl_next_certificate_index;\n@@ -208,9 +209,9 @@ ngx_ssl_init(ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n-    ngx_ssl_session_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL,\n-                                                                 NULL, NULL);\n-    if (ngx_ssl_session_ticket_keys_index == -1) {\n+    ngx_ssl_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,\n+                                                         NULL);\n+    if (ngx_ssl_ticket_keys_index == -1) {\n         ngx_ssl_error(NGX_LOG_ALERT, log, 0,\n                       \"SSL_CTX_get_ex_new_index() failed\");\n         return NGX_ERROR;\n@@ -1083,6 +1084,53 @@ ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)\n         }\n     }\n \n+#endif\n+\n+#ifdef TLS1_3_VERSION\n+\n+    if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP\n+        && SSL_version(ssl_conn) == TLS1_3_VERSION)\n+    {\n+        time_t        now, time, timeout, conf_timeout;\n+        SSL_SESSION  *sess;\n+\n+        /*\n+         * OpenSSL with TLSv1.3 updates the session creation time on\n+         * session resumption and keeps the session timeout unmodified,\n+         * making it possible to maintain the session forever, bypassing\n+         * client certificate expiration and revocation.  To make sure\n+         * session timeouts are actually used, we now update the session\n+         * creation time and reduce the session timeout accordingly.\n+         *\n+         * BoringSSL with TLSv1.3 ignores configured session timeouts\n+         * and uses a hardcoded timeout instead, 7 days.  So we update\n+         * session timeout to the configured value as soon as a session\n+         * is created.\n+         */\n+\n+        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);\n+        sess = SSL_get0_session(ssl_conn);\n+\n+        if (!c->ssl->session_timeout_set && sess) {\n+            c->ssl->session_timeout_set = 1;\n+\n+            now = ngx_time();\n+            time = SSL_SESSION_get_time(sess);\n+            timeout = SSL_SESSION_get_timeout(sess);\n+            conf_timeout = SSL_CTX_get_timeout(c->ssl->session_ctx);\n+\n+            timeout = ngx_min(timeout, conf_timeout);\n+\n+            if (now - time >= timeout) {\n+                SSL_SESSION_set1_id_context(sess, (unsigned char *) \"\", 0);\n+\n+            } else {\n+                SSL_SESSION_set_time(sess, now);\n+                SSL_SESSION_set_timeout(sess, timeout - (now - time));\n+            }\n+        }\n+    }\n+\n #endif\n \n     if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP) {\n@@ -3770,6 +3818,12 @@ ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n \n     ngx_queue_init(&cache->expire_queue);\n \n+    cache->ticket_keys[0].expire = 0;\n+    cache->ticket_keys[1].expire = 0;\n+    cache->ticket_keys[2].expire = 0;\n+\n+    cache->fail_time = 0;\n+\n     len = sizeof(\" in SSL session shared cache \\\"\\\"\") + shm_zone->shm.name.len;\n \n     shpool->log_ctx = ngx_slab_alloc(shpool, len);\n@@ -3788,16 +3842,16 @@ ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n \n /*\n  * The length of the session id is 16 bytes for SSLv2 sessions and\n- * between 1 and 32 bytes for SSLv3/TLSv1, typically 32 bytes.\n- * It seems that the typical length of the external ASN1 representation\n- * of a session is 118 or 119 bytes for SSLv3/TSLv1.\n+ * between 1 and 32 bytes for SSLv3 and TLS, typically 32 bytes.\n+ * Typical length of the external ASN1 representation of a session\n+ * is about 150 bytes plus SNI server name.\n  *\n- * Thus on 32-bit platforms we allocate separately an rbtree node,\n- * a session id, and an ASN1 representation, they take accordingly\n- * 64, 32, and 128 bytes.\n+ * On 32-bit platforms we allocate an rbtree node, a session id, and\n+ * an ASN1 representation in a single allocation, it typically takes\n+ * 256 bytes.\n  *\n  * On 64-bit platforms we allocate separately an rbtree node + session_id,\n- * and an ASN1 representation, they take accordingly 128 and 128 bytes.\n+ * and an ASN1 representation, they take accordingly 128 and 256 bytes.\n  *\n  * OpenSSL's i2d_SSL_SESSION() and d2i_SSL_SESSION are slow,\n  * so they are outside the code locked by shared pool mutex\n@@ -3807,7 +3861,8 @@ static int\n ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n {\n     int                       len;\n-    u_char                   *p, *id, *cached_sess, *session_id;\n+    u_char                   *p, *session_id;\n+    size_t                    n;\n     uint32_t                  hash;\n     SSL_CTX                  *ssl_ctx;\n     unsigned int              session_id_length;\n@@ -3818,17 +3873,42 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n     ngx_ssl_session_cache_t  *cache;\n     u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];\n \n+#ifdef TLS1_3_VERSION\n+\n+    /*\n+     * OpenSSL tries to save TLSv1.3 sessions into session cache\n+     * even when using tickets for stateless session resumption,\n+     * \"because some applications just want to know about the creation\n+     * of a session\"; do not cache such sessions\n+     */\n+\n+    if (SSL_version(ssl_conn) == TLS1_3_VERSION\n+        && (SSL_get_options(ssl_conn) & SSL_OP_NO_TICKET) == 0)\n+    {\n+        return 0;\n+    }\n+\n+#endif\n+\n     len = i2d_SSL_SESSION(sess, NULL);\n \n     /* do not cache too big session */\n \n-    if (len > (int) NGX_SSL_MAX_SESSION_SIZE) {\n+    if (len > NGX_SSL_MAX_SESSION_SIZE) {\n         return 0;\n     }\n \n     p = buf;\n     i2d_SSL_SESSION(sess, &p);\n \n+    session_id = (u_char *) SSL_SESSION_get_id(sess, &session_id_length);\n+\n+    /* do not cache sessions with too long session id */\n+\n+    if (session_id_length > 32) {\n+        return 0;\n+    }\n+\n     c = ngx_ssl_get_connection(ssl_conn);\n \n     ssl_ctx = c->ssl->session_ctx;\n@@ -3842,65 +3922,48 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n     /* drop one or two expired sessions */\n     ngx_ssl_expire_sessions(cache, shpool, 1);\n \n-    cached_sess = ngx_slab_alloc_locked(shpool, len);\n-\n-    if (cached_sess == NULL) {\n-\n-        /* drop the oldest non-expired session and try once more */\n-\n-        ngx_ssl_expire_sessions(cache, shpool, 0);\n-\n-        cached_sess = ngx_slab_alloc_locked(shpool, len);\n-\n-        if (cached_sess == NULL) {\n-            sess_id = NULL;\n-            goto failed;\n-        }\n-    }\n+#if (NGX_PTR_SIZE == 8)\n+    n = sizeof(ngx_ssl_sess_id_t);\n+#else\n+    n = offsetof(ngx_ssl_sess_id_t, session) + len;\n+#endif\n \n-    sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n+    sess_id = ngx_slab_alloc_locked(shpool, n);\n \n     if (sess_id == NULL) {\n \n         /* drop the oldest non-expired session and try once more */\n \n         ngx_ssl_expire_sessions(cache, shpool, 0);\n \n-        sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n+        sess_id = ngx_slab_alloc_locked(shpool, n);\n \n         if (sess_id == NULL) {\n             goto failed;\n         }\n     }\n \n-    session_id = (u_char *) SSL_SESSION_get_id(sess, &session_id_length);\n-\n #if (NGX_PTR_SIZE == 8)\n \n-    id = sess_id->sess_id;\n-\n-#else\n-\n-    id = ngx_slab_alloc_locked(shpool, session_id_length);\n+    sess_id->session = ngx_slab_alloc_locked(shpool, len);\n \n-    if (id == NULL) {\n+    if (sess_id->session == NULL) {\n \n         /* drop the oldest non-expired session and try once more */\n \n         ngx_ssl_expire_sessions(cache, shpool, 0);\n \n-        id = ngx_slab_alloc_locked(shpool, session_id_length);\n+        sess_id->session = ngx_slab_alloc_locked(shpool, len);\n \n-        if (id == NULL) {\n+        if (sess_id->session == NULL) {\n             goto failed;\n         }\n     }\n \n #endif\n \n-    ngx_memcpy(cached_sess, buf, len);\n-\n-    ngx_memcpy(id, session_id, session_id_length);\n+    ngx_memcpy(sess_id->session, buf, len);\n+    ngx_memcpy(sess_id->id, session_id, session_id_length);\n \n     hash = ngx_crc32_short(session_id, session_id_length);\n \n@@ -3910,9 +3973,7 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n \n     sess_id->node.key = hash;\n     sess_id->node.data = (u_char) session_id_length;\n-    sess_id->id = id;\n     sess_id->len = len;\n-    sess_id->session = cached_sess;\n \n     sess_id->expire = ngx_time() + SSL_CTX_get_timeout(ssl_ctx);\n \n@@ -3926,18 +3987,17 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n \n failed:\n \n-    if (cached_sess) {\n-        ngx_slab_free_locked(shpool, cached_sess);\n-    }\n-\n     if (sess_id) {\n         ngx_slab_free_locked(shpool, sess_id);\n     }\n \n     ngx_shmtx_unlock(&shpool->mutex);\n \n-    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n-                  \"could not allocate new session%s\", shpool->log_ctx);\n+    if (cache->fail_time != ngx_time()) {\n+        cache->fail_time = ngx_time();\n+        ngx_log_error(NGX_LOG_WARN, c->log, 0,\n+                      \"could not allocate new session%s\", shpool->log_ctx);\n+    }\n \n     return 0;\n }\n@@ -4023,9 +4083,10 @@ ngx_ssl_get_cached_session(ngx_ssl_conn_t *ssl_conn,\n \n             ngx_rbtree_delete(&cache->session_rbtree, node);\n \n+            ngx_explicit_memzero(sess_id->session, sess_id->len);\n+\n+#if (NGX_PTR_SIZE == 8)\n             ngx_slab_free_locked(shpool, sess_id->session);\n-#if (NGX_PTR_SIZE == 4)\n-            ngx_slab_free_locked(shpool, sess_id->id);\n #endif\n             ngx_slab_free_locked(shpool, sess_id);\n \n@@ -4113,9 +4174,10 @@ ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)\n \n             ngx_rbtree_delete(&cache->session_rbtree, node);\n \n+            ngx_explicit_memzero(sess_id->session, sess_id->len);\n+\n+#if (NGX_PTR_SIZE == 8)\n             ngx_slab_free_locked(shpool, sess_id->session);\n-#if (NGX_PTR_SIZE == 4)\n-            ngx_slab_free_locked(shpool, sess_id->id);\n #endif\n             ngx_slab_free_locked(shpool, sess_id);\n \n@@ -4162,9 +4224,10 @@ ngx_ssl_expire_sessions(ngx_ssl_session_cache_t *cache,\n \n         ngx_rbtree_delete(&cache->session_rbtree, &sess_id->node);\n \n+        ngx_explicit_memzero(sess_id->session, sess_id->len);\n+\n+#if (NGX_PTR_SIZE == 8)\n         ngx_slab_free_locked(shpool, sess_id->session);\n-#if (NGX_PTR_SIZE == 4)\n-        ngx_slab_free_locked(shpool, sess_id->id);\n #endif\n         ngx_slab_free_locked(shpool, sess_id);\n     }\n@@ -4218,23 +4281,25 @@ ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,\n ngx_int_t\n ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n {\n-    u_char                         buf[80];\n-    size_t                         size;\n-    ssize_t                        n;\n-    ngx_str_t                     *path;\n-    ngx_file_t                     file;\n-    ngx_uint_t                     i;\n-    ngx_array_t                   *keys;\n-    ngx_file_info_t                fi;\n-    ngx_pool_cleanup_t            *cln;\n-    ngx_ssl_session_ticket_key_t  *key;\n-\n-    if (paths == NULL) {\n+    u_char                 buf[80];\n+    size_t                 size;\n+    ssize_t                n;\n+    ngx_str_t             *path;\n+    ngx_file_t             file;\n+    ngx_uint_t             i;\n+    ngx_array_t           *keys;\n+    ngx_file_info_t        fi;\n+    ngx_pool_cleanup_t    *cln;\n+    ngx_ssl_ticket_key_t  *key;\n+\n+    if (paths == NULL\n+        && SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_session_cache_index) == NULL)\n+    {\n         return NGX_OK;\n     }\n \n-    keys = ngx_array_create(cf->pool, paths->nelts,\n-                            sizeof(ngx_ssl_session_ticket_key_t));\n+    keys = ngx_array_create(cf->pool, paths ? paths->nelts : 3,\n+                            sizeof(ngx_ssl_ticket_key_t));\n     if (keys == NULL) {\n         return NGX_ERROR;\n     }\n@@ -4244,9 +4309,41 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n         return NGX_ERROR;\n     }\n \n-    cln->handler = ngx_ssl_session_ticket_keys_cleanup;\n+    cln->handler = ngx_ssl_ticket_keys_cleanup;\n     cln->data = keys;\n \n+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_ticket_keys_index, keys) == 0) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set_ex_data() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (SSL_CTX_set_tlsext_ticket_key_cb(ssl->ctx, ngx_ssl_ticket_key_callback)\n+        == 0)\n+    {\n+        ngx_log_error(NGX_LOG_WARN, cf->log, 0,\n+                      \"nginx was built with Session Tickets support, however, \"\n+                      \"now it is linked dynamically to an OpenSSL library \"\n+                      \"which has no tlsext support, therefore Session Tickets \"\n+                      \"are not available\");\n+        return NGX_OK;\n+    }\n+\n+    if (paths == NULL) {\n+\n+        /* placeholder for keys in shared memory */\n+\n+        key = ngx_array_push_n(keys, 3);\n+        key[0].shared = 1;\n+        key[0].expire = 0;\n+        key[1].shared = 1;\n+        key[1].expire = 0;\n+        key[2].shared = 1;\n+        key[2].expire = 0;\n+\n+        return NGX_OK;\n+    }\n+\n     path = paths->elts;\n     for (i = 0; i < paths->nelts; i++) {\n \n@@ -4301,6 +4398,9 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n             goto failed;\n         }\n \n+        key->shared = 0;\n+        key->expire = 1;\n+\n         if (size == 48) {\n             key->size = 48;\n             ngx_memcpy(key->name, buf, 16);\n@@ -4322,25 +4422,6 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n         ngx_explicit_memzero(&buf, 80);\n     }\n \n-    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_session_ticket_keys_index, keys)\n-        == 0)\n-    {\n-        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n-                      \"SSL_CTX_set_ex_data() failed\");\n-        return NGX_ERROR;\n-    }\n-\n-    if (SSL_CTX_set_tlsext_ticket_key_cb(ssl->ctx,\n-                                         ngx_ssl_session_ticket_key_callback)\n-        == 0)\n-    {\n-        ngx_log_error(NGX_LOG_WARN, cf->log, 0,\n-                      \"nginx was built with Session Tickets support, however, \"\n-                      \"now it is linked dynamically to an OpenSSL library \"\n-                      \"which has no tlsext support, therefore Session Tickets \"\n-                      \"are not available\");\n-    }\n-\n     return NGX_OK;\n \n failed:\n@@ -4357,29 +4438,33 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n \n \n static int\n-ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n+ngx_ssl_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n     unsigned char *name, unsigned char *iv, EVP_CIPHER_CTX *ectx,\n     HMAC_CTX *hctx, int enc)\n {\n-    size_t                         size;\n-    SSL_CTX                       *ssl_ctx;\n-    ngx_uint_t                     i;\n-    ngx_array_t                   *keys;\n-    ngx_connection_t              *c;\n-    ngx_ssl_session_ticket_key_t  *key;\n-    const EVP_MD                  *digest;\n-    const EVP_CIPHER              *cipher;\n+    size_t                 size;\n+    SSL_CTX               *ssl_ctx;\n+    ngx_uint_t             i;\n+    ngx_array_t           *keys;\n+    ngx_connection_t      *c;\n+    ngx_ssl_ticket_key_t  *key;\n+    const EVP_MD          *digest;\n+    const EVP_CIPHER      *cipher;\n \n     c = ngx_ssl_get_connection(ssl_conn);\n     ssl_ctx = c->ssl->session_ctx;\n \n+    if (ngx_ssl_rotate_ticket_keys(ssl_ctx, c->log) != NGX_OK) {\n+        return -1;\n+    }\n+\n #ifdef OPENSSL_NO_SHA256\n     digest = EVP_sha1();\n #else\n     digest = EVP_sha256();\n #endif\n \n-    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_ticket_keys_index);\n+    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_ticket_keys_index);\n     if (keys == NULL) {\n         return -1;\n     }\n@@ -4390,7 +4475,7 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         /* encrypt session ticket */\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket encrypt, key: \\\"%*xs\\\" (%s session)\",\n+                       \"ssl ticket encrypt, key: \\\"%*xs\\\" (%s session)\",\n                        (size_t) 16, key[0].name,\n                        SSL_session_reused(ssl_conn) ? \"reused\" : \"new\");\n \n@@ -4437,15 +4522,15 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         }\n \n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*xs\\\" not found\",\n+                       \"ssl ticket decrypt, key: \\\"%*xs\\\" not found\",\n                        (size_t) 16, name);\n \n         return 0;\n \n     found:\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*xs\\\"%s\",\n+                       \"ssl ticket decrypt, key: \\\"%*xs\\\"%s\",\n                        (size_t) 16, key[i].name, (i == 0) ? \" (default)\" : \"\");\n \n         if (key[i].size == 48) {\n@@ -4482,7 +4567,7 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n \n         /* renew if non-default key */\n \n-        if (i != 0) {\n+        if (i != 0 && key[i].expire) {\n             return 2;\n         }\n \n@@ -4491,13 +4576,142 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n }\n \n \n+static ngx_int_t\n+ngx_ssl_rotate_ticket_keys(SSL_CTX *ssl_ctx, ngx_log_t *log)\n+{\n+    time_t                    now, expire;\n+    ngx_array_t              *keys;\n+    ngx_shm_zone_t           *shm_zone;\n+    ngx_slab_pool_t          *shpool;\n+    ngx_ssl_ticket_key_t     *key;\n+    ngx_ssl_session_cache_t  *cache;\n+    u_char                    buf[80];\n+\n+    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_ticket_keys_index);\n+    if (keys == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    key = keys->elts;\n+\n+    if (!key[0].shared) {\n+        return NGX_OK;\n+    }\n+\n+    /*\n+     * if we don't need to update expiration of the current key\n+     * and the previous key is still needed, don't sync with shared\n+     * memory to save some work; in the worst case other worker process\n+     * will switch to the next key, but this process will still be able\n+     * to decrypt tickets encrypted with it\n+     */\n+\n+    now = ngx_time();\n+    expire = now + SSL_CTX_get_timeout(ssl_ctx);\n+\n+    if (key[0].expire >= expire && key[1].expire >= now) {\n+        return NGX_OK;\n+    }\n+\n+    shm_zone = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_cache_index);\n+\n+    cache = shm_zone->data;\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+\n+    ngx_shmtx_lock(&shpool->mutex);\n+\n+    key = cache->ticket_keys;\n+\n+    if (key[0].expire == 0) {\n+\n+        /* initialize the current key */\n+\n+        if (RAND_bytes(buf, 80) != 1) {\n+            ngx_ssl_error(NGX_LOG_ALERT, log, 0, \"RAND_bytes() failed\");\n+            ngx_shmtx_unlock(&shpool->mutex);\n+            return NGX_ERROR;\n+        }\n+\n+        key[0].shared = 1;\n+        key[0].expire = expire;\n+        key[0].size = 80;\n+        ngx_memcpy(key[0].name, buf, 16);\n+        ngx_memcpy(key[0].hmac_key, buf + 16, 32);\n+        ngx_memcpy(key[0].aes_key, buf + 48, 32);\n+\n+        ngx_explicit_memzero(&buf, 80);\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, log, 0,\n+                       \"ssl ticket key: \\\"%*xs\\\"\",\n+                       (size_t) 16, key[0].name);\n+\n+        /*\n+         * copy the current key to the next key, as initialization of\n+         * the previous key will replace the current key with the next\n+         * key\n+         */\n+\n+        key[2] = key[0];\n+    }\n+\n+    if (key[1].expire < now) {\n+\n+        /*\n+         * if the previous key is no longer needed (or not initialized),\n+         * replace it with the current key, replace the current key with\n+         * the next key, and generate new next key\n+         */\n+\n+        key[1] = key[0];\n+        key[0] = key[2];\n+\n+        if (RAND_bytes(buf, 80) != 1) {\n+            ngx_ssl_error(NGX_LOG_ALERT, log, 0, \"RAND_bytes() failed\");\n+            ngx_shmtx_unlock(&shpool->mutex);\n+            return NGX_ERROR;\n+        }\n+\n+        key[2].shared = 1;\n+        key[2].expire = 0;\n+        key[2].size = 80;\n+        ngx_memcpy(key[2].name, buf, 16);\n+        ngx_memcpy(key[2].hmac_key, buf + 16, 32);\n+        ngx_memcpy(key[2].aes_key, buf + 48, 32);\n+\n+        ngx_explicit_memzero(&buf, 80);\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, log, 0,\n+                       \"ssl ticket key: \\\"%*xs\\\"\",\n+                       (size_t) 16, key[2].name);\n+    }\n+\n+    /*\n+     * update expiration of the current key: it is going to be needed\n+     * at least till the session being created expires\n+     */\n+\n+    if (expire > key[0].expire) {\n+        key[0].expire = expire;\n+    }\n+\n+    /* sync keys to the worker process memory */\n+\n+    ngx_memcpy(keys->elts, cache->ticket_keys,\n+               2 * sizeof(ngx_ssl_ticket_key_t));\n+\n+    ngx_shmtx_unlock(&shpool->mutex);\n+\n+    return NGX_OK;\n+}\n+\n+\n static void\n-ngx_ssl_session_ticket_keys_cleanup(void *data)\n+ngx_ssl_ticket_keys_cleanup(void *data)\n {\n     ngx_array_t  *keys = data;\n \n     ngx_explicit_memzero(keys->elts,\n-                         keys->nelts * sizeof(ngx_ssl_session_ticket_key_t));\n+                         keys->nelts * sizeof(ngx_ssl_ticket_key_t));\n }\n \n #else\nDiff:\n@@ -114,6 +114,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    no_send_shutdown:1;\n     unsigned                    shutdown_without_free:1;\n     unsigned                    handshake_buffer_set:1;\n+    unsigned                    session_timeout_set:1;\n     unsigned                    try_early_data:1;\n     unsigned                    in_early:1;\n     unsigned                    in_ocsp:1;\n@@ -134,35 +135,35 @@ typedef struct ngx_ssl_sess_id_s  ngx_ssl_sess_id_t;\n \n struct ngx_ssl_sess_id_s {\n     ngx_rbtree_node_t           node;\n-    u_char                     *id;\n     size_t                      len;\n-    u_char                     *session;\n     ngx_queue_t                 queue;\n     time_t                      expire;\n+    u_char                      id[32];\n #if (NGX_PTR_SIZE == 8)\n-    void                       *stub;\n-    u_char                      sess_id[32];\n+    u_char                     *session;\n+#else\n+    u_char                      session[1];\n #endif\n };\n \n \n typedef struct {\n-    ngx_rbtree_t                session_rbtree;\n-    ngx_rbtree_node_t           sentinel;\n-    ngx_queue_t                 expire_queue;\n-} ngx_ssl_session_cache_t;\n-\n-\n-#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB\n-\n-typedef struct {\n-    size_t                      size;\n     u_char                      name[16];\n     u_char                      hmac_key[32];\n     u_char                      aes_key[32];\n-} ngx_ssl_session_ticket_key_t;\n+    time_t                      expire;\n+    unsigned                    size:8;\n+    unsigned                    shared:1;\n+} ngx_ssl_ticket_key_t;\n \n-#endif\n+\n+typedef struct {\n+    ngx_rbtree_t                session_rbtree;\n+    ngx_rbtree_node_t           sentinel;\n+    ngx_queue_t                 expire_queue;\n+    ngx_ssl_ticket_key_t        ticket_keys[3];\n+    time_t                      fail_time;\n+} ngx_ssl_session_cache_t;\n \n \n #define NGX_SSL_SSLv2    0x0002\n@@ -204,10 +205,12 @@ ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n     ngx_uint_t depth, ngx_shm_zone_t *shm_zone);\n ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n+\n ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n+\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\n ngx_array_t *ngx_ssl_preserve_passwords(ngx_conf_t *cf,\n     ngx_array_t *passwords);\n@@ -314,7 +317,7 @@ void ngx_ssl_cleanup_ctx(void *data);\n extern int  ngx_ssl_connection_index;\n extern int  ngx_ssl_server_conf_index;\n extern int  ngx_ssl_session_cache_index;\n-extern int  ngx_ssl_session_ticket_keys_index;\n+extern int  ngx_ssl_ticket_keys_index;\n extern int  ngx_ssl_ocsp_index;\n extern int  ngx_ssl_certificate_index;\n extern int  ngx_ssl_next_certificate_index;\n"
    },
    {
        "commit_sha": "8b43418aaef75db3dd09dca5b8ad5932f2877e41",
        "commit_index": "Commit 169",
        "commit_diff": "Diff:\n@@ -15,6 +15,12 @@\n \n #define ngx_proxy_protocol_parse_uint16(p)  ((p)[0] << 8 | (p)[1])\n \n+#define ngx_proxy_protocol_parse_uint32(p)                                    \\\n+    ( ((uint32_t) (p)[0] << 24)                                               \\\n+    + (           (p)[1] << 16)                                               \\\n+    + (           (p)[2] << 8)                                                \\\n+    + (           (p)[3]) )\n+\n \n typedef struct {\n     u_char                                  signature[12];\n@@ -40,12 +46,52 @@ typedef struct {\n } ngx_proxy_protocol_inet6_addrs_t;\n \n \n+typedef struct {\n+    u_char                                  type;\n+    u_char                                  len[2];\n+} ngx_proxy_protocol_tlv_t;\n+\n+\n+typedef struct {\n+    u_char                                  client;\n+    u_char                                  verify[4];\n+} ngx_proxy_protocol_tlv_ssl_t;\n+\n+\n+typedef struct {\n+    ngx_str_t                               name;\n+    ngx_uint_t                              type;\n+} ngx_proxy_protocol_tlv_entry_t;\n+\n+\n static u_char *ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p,\n     u_char *last, ngx_str_t *addr);\n static u_char *ngx_proxy_protocol_read_port(u_char *p, u_char *last,\n     in_port_t *port, u_char sep);\n static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n+static ngx_int_t ngx_proxy_protocol_lookup_tlv(ngx_connection_t *c,\n+    ngx_str_t *tlvs, ngx_uint_t type, ngx_str_t *value);\n+\n+\n+static ngx_proxy_protocol_tlv_entry_t  ngx_proxy_protocol_tlv_entries[] = {\n+    { ngx_string(\"alpn\"),       0x01 },\n+    { ngx_string(\"authority\"),  0x02 },\n+    { ngx_string(\"unique_id\"),  0x05 },\n+    { ngx_string(\"ssl\"),        0x20 },\n+    { ngx_string(\"netns\"),      0x30 },\n+    { ngx_null_string,          0x00 }\n+};\n+\n+\n+static ngx_proxy_protocol_tlv_entry_t  ngx_proxy_protocol_tlv_ssl_entries[] = {\n+    { ngx_string(\"version\"),    0x21 },\n+    { ngx_string(\"cn\"),         0x22 },\n+    { ngx_string(\"cipher\"),     0x23 },\n+    { ngx_string(\"sig_alg\"),    0x24 },\n+    { ngx_string(\"key_alg\"),    0x25 },\n+    { ngx_null_string,          0x00 }\n+};\n \n \n u_char *\n@@ -418,11 +464,147 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n                    &pp->src_addr, pp->src_port, &pp->dst_addr, pp->dst_port);\n \n     if (buf < end) {\n-        ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                       \"PROXY protocol v2 %z bytes of tlv ignored\", end - buf);\n+        pp->tlvs.data = ngx_pnalloc(c->pool, end - buf);\n+        if (pp->tlvs.data == NULL) {\n+            return NULL;\n+        }\n+\n+        ngx_memcpy(pp->tlvs.data, buf, end - buf);\n+        pp->tlvs.len = end - buf;\n     }\n \n     c->proxy_protocol = pp;\n \n     return end;\n }\n+\n+\n+ngx_int_t\n+ngx_proxy_protocol_get_tlv(ngx_connection_t *c, ngx_str_t *name,\n+    ngx_str_t *value)\n+{\n+    u_char                          *p;\n+    size_t                           n;\n+    uint32_t                         verify;\n+    ngx_str_t                        ssl, *tlvs;\n+    ngx_int_t                        rc, type;\n+    ngx_proxy_protocol_tlv_ssl_t    *tlv_ssl;\n+    ngx_proxy_protocol_tlv_entry_t  *te;\n+\n+    if (c->proxy_protocol == NULL) {\n+        return NGX_DECLINED;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol v2 get tlv \\\"%V\\\"\", name);\n+\n+    te = ngx_proxy_protocol_tlv_entries;\n+    tlvs = &c->proxy_protocol->tlvs;\n+\n+    p = name->data;\n+    n = name->len;\n+\n+    if (n >= 4 && p[0] == 's' && p[1] == 's' && p[2] == 'l' && p[3] == '_') {\n+\n+        rc = ngx_proxy_protocol_lookup_tlv(c, tlvs, 0x20, &ssl);\n+        if (rc != NGX_OK) {\n+            return rc;\n+        }\n+\n+        if (ssl.len < sizeof(ngx_proxy_protocol_tlv_ssl_t)) {\n+            return NGX_ERROR;\n+        }\n+\n+        p += 4;\n+        n -= 4;\n+\n+        if (n == 6 && ngx_strncmp(p, \"verify\", 6) == 0) {\n+\n+            tlv_ssl = (ngx_proxy_protocol_tlv_ssl_t *) ssl.data;\n+            verify = ngx_proxy_protocol_parse_uint32(tlv_ssl->verify);\n+\n+            value->data = ngx_pnalloc(c->pool, NGX_INT32_LEN);\n+            if (value->data == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            value->len = ngx_sprintf(value->data, \"%uD\", verify)\n+                         - value->data;\n+            return NGX_OK;\n+        }\n+\n+        ssl.data += sizeof(ngx_proxy_protocol_tlv_ssl_t);\n+        ssl.len -= sizeof(ngx_proxy_protocol_tlv_ssl_t);\n+\n+        te = ngx_proxy_protocol_tlv_ssl_entries;\n+        tlvs = &ssl;\n+    }\n+\n+    if (n >= 2 && p[0] == '0' && p[1] == 'x') {\n+\n+        type = ngx_hextoi(p + 2, n - 2);\n+        if (type == NGX_ERROR) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                          \"invalid PROXY protocol TLV \\\"%V\\\"\", name);\n+            return NGX_ERROR;\n+        }\n+\n+        return ngx_proxy_protocol_lookup_tlv(c, tlvs, type, value);\n+    }\n+\n+    for ( /* void */ ; te->type; te++) {\n+        if (te->name.len == n && ngx_strncmp(te->name.data, p, n) == 0) {\n+            return ngx_proxy_protocol_lookup_tlv(c, tlvs, te->type, value);\n+        }\n+    }\n+\n+    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                  \"unknown PROXY protocol TLV \\\"%V\\\"\", name);\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+static ngx_int_t\n+ngx_proxy_protocol_lookup_tlv(ngx_connection_t *c, ngx_str_t *tlvs,\n+    ngx_uint_t type, ngx_str_t *value)\n+{\n+    u_char                    *p;\n+    size_t                     n, len;\n+    ngx_proxy_protocol_tlv_t  *tlv;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol v2 lookup tlv:%02xi\", type);\n+\n+    p = tlvs->data;\n+    n = tlvs->len;\n+\n+    while (n) {\n+        if (n < sizeof(ngx_proxy_protocol_tlv_t)) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0, \"broken PROXY protocol TLV\");\n+            return NGX_ERROR;\n+        }\n+\n+        tlv = (ngx_proxy_protocol_tlv_t *) p;\n+        len = ngx_proxy_protocol_parse_uint16(tlv->len);\n+\n+        p += sizeof(ngx_proxy_protocol_tlv_t);\n+        n -= sizeof(ngx_proxy_protocol_tlv_t);\n+\n+        if (n < len) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0, \"broken PROXY protocol TLV\");\n+            return NGX_ERROR;\n+        }\n+\n+        if (tlv->type == type) {\n+            value->data = p;\n+            value->len = len;\n+            return NGX_OK;\n+        }\n+\n+        p += len;\n+        n -= len;\n+    }\n+\n+    return NGX_DECLINED;\n+}\nDiff:\n@@ -21,13 +21,16 @@ struct ngx_proxy_protocol_s {\n     ngx_str_t           dst_addr;\n     in_port_t           src_port;\n     in_port_t           dst_port;\n+    ngx_str_t           tlvs;\n };\n \n \n u_char *ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n u_char *ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n+ngx_int_t ngx_proxy_protocol_get_tlv(ngx_connection_t *c, ngx_str_t *name,\n+    ngx_str_t *value);\n \n \n #endif /* _NGX_PROXY_PROTOCOL_H_INCLUDED_ */\nDiff:\n@@ -65,6 +65,8 @@ static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_http_variable_proxy_protocol_tlv(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r,\n@@ -218,6 +220,10 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n       ngx_http_variable_proxy_protocol_port,\n       offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n+    { ngx_string(\"proxy_protocol_tlv_\"), NULL,\n+      ngx_http_variable_proxy_protocol_tlv,\n+      0, NGX_HTTP_VAR_PREFIX, 0 },\n+\n     { ngx_string(\"server_addr\"), NULL, ngx_http_variable_server_addr, 0, 0, 0 },\n \n     { ngx_string(\"server_port\"), NULL, ngx_http_variable_server_port, 0, 0, 0 },\n@@ -1396,6 +1402,39 @@ ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n }\n \n \n+static ngx_int_t\n+ngx_http_variable_proxy_protocol_tlv(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    ngx_str_t *name = (ngx_str_t *) data;\n+\n+    ngx_int_t  rc;\n+    ngx_str_t  tlv, value;\n+\n+    tlv.len = name->len - (sizeof(\"proxy_protocol_tlv_\") - 1);\n+    tlv.data = name->data + sizeof(\"proxy_protocol_tlv_\") - 1;\n+\n+    rc = ngx_proxy_protocol_get_tlv(r->connection, &tlv, &value);\n+\n+    if (rc == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (rc == NGX_DECLINED) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = value.len;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = value.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_variable_server_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\nDiff:\n@@ -23,6 +23,8 @@ static ngx_int_t ngx_stream_variable_proxy_protocol_addr(\n     ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_stream_variable_proxy_protocol_port(\n     ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_stream_variable_proxy_protocol_tlv(\n+    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_stream_variable_server_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_stream_variable_server_port(ngx_stream_session_t *s,\n@@ -79,6 +81,10 @@ static ngx_stream_variable_t  ngx_stream_core_variables[] = {\n       ngx_stream_variable_proxy_protocol_port,\n       offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n+    { ngx_string(\"proxy_protocol_tlv_\"), NULL,\n+      ngx_stream_variable_proxy_protocol_tlv,\n+      0, NGX_STREAM_VAR_PREFIX, 0 },\n+\n     { ngx_string(\"server_addr\"), NULL,\n       ngx_stream_variable_server_addr, 0, 0, 0 },\n \n@@ -621,6 +627,39 @@ ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n }\n \n \n+static ngx_int_t\n+ngx_stream_variable_proxy_protocol_tlv(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data)\n+{\n+    ngx_str_t *name = (ngx_str_t *) data;\n+\n+    ngx_int_t  rc;\n+    ngx_str_t  tlv, value;\n+\n+    tlv.len = name->len - (sizeof(\"proxy_protocol_tlv_\") - 1);\n+    tlv.data = name->data + sizeof(\"proxy_protocol_tlv_\") - 1;\n+\n+    rc = ngx_proxy_protocol_get_tlv(s->connection, &tlv, &value);\n+\n+    if (rc == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (rc == NGX_DECLINED) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = value.len;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = value.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_stream_variable_server_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n"
    },
    {
        "commit_sha": "4b09bf140afd5d8cfa4cae9ccf9909de8c450613",
        "commit_index": "Commit 168",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@\n all:\n \tcd $(OPENSSL)\n \n-\tperl Configure VC-WIN32 no-shared\t\t\t\t\\\n+\tperl Configure VC-WIN32 no-shared no-threads\t\t\t\\\n \t\t--prefix=\"%cd%/openssl\" \t\t\t\t\\\n \t\t--openssldir=\"%cd%/openssl/ssl\" \t\t\t\\\n \t\t$(OPENSSL_OPT)\nDiff:\n@@ -139,8 +139,14 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n invalid:\n \n+    for (p = buf; p < last; p++) {\n+        if (*p == CR || *p == LF) {\n+            break;\n+        }\n+    }\n+\n     ngx_log_error(NGX_LOG_ERR, c->log, 0,\n-                  \"broken header: \\\"%*s\\\"\", (size_t) (last - buf), buf);\n+                  \"broken header: \\\"%*s\\\"\", (size_t) (p - buf), buf);\n \n     return NULL;\n }\nDiff:\n@@ -1428,7 +1428,7 @@ ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)\n \n #ifdef SSL_CTRL_SET_ECDH_AUTO\n     /* not needed in OpenSSL 1.1.0+ */\n-    SSL_CTX_set_ecdh_auto(ssl->ctx, 1);\n+    (void) SSL_CTX_set_ecdh_auto(ssl->ctx, 1);\n #endif\n \n     if (ngx_strcmp(name->data, \"auto\") == 0) {\n"
    },
    {
        "commit_sha": "301acbd6759301723308e567e8068a323db95266",
        "commit_index": "Commit 167",
        "commit_diff": "Diff:\n@@ -231,9 +231,8 @@ ngx_iocp_del_connection(ngx_connection_t *c, ngx_uint_t flags)\n }\n \n \n-static\n-ngx_int_t ngx_iocp_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,\n-    ngx_uint_t flags)\n+static ngx_int_t\n+ngx_iocp_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n {\n     int                rc;\n     u_int              key;\n@@ -356,7 +355,7 @@ ngx_iocp_create_conf(ngx_cycle_t *cycle)\n \n     cf = ngx_palloc(cycle->pool, sizeof(ngx_iocp_conf_t));\n     if (cf == NULL) {\n-        return NGX_CONF_ERROR;\n+        return NULL;\n     }\n \n     cf->threads = NGX_CONF_UNSET;\nDiff:\n@@ -1426,7 +1426,7 @@ ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)\n \n     SSL_CTX_set_options(ssl->ctx, SSL_OP_SINGLE_ECDH_USE);\n \n-#if SSL_CTRL_SET_ECDH_AUTO\n+#ifdef SSL_CTRL_SET_ECDH_AUTO\n     /* not needed in OpenSSL 1.1.0+ */\n     SSL_CTX_set_ecdh_auto(ssl->ctx, 1);\n #endif\n@@ -1769,7 +1769,7 @@ ngx_ssl_handshake(ngx_connection_t *c)\n #endif\n #endif\n \n-#ifdef BIO_get_ktls_send\n+#if (defined BIO_get_ktls_send && !NGX_WIN32)\n \n         if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n             ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n@@ -1914,7 +1914,7 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->read->ready = 1;\n         c->write->ready = 1;\n \n-#ifdef BIO_get_ktls_send\n+#if (defined BIO_get_ktls_send && !NGX_WIN32)\n \n         if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n             ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n@@ -2943,7 +2943,7 @@ ngx_ssl_write_early(ngx_connection_t *c, u_char *data, size_t size)\n static ssize_t\n ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n {\n-#ifdef BIO_get_ktls_send\n+#if (defined BIO_get_ktls_send && !NGX_WIN32)\n \n     int        sslerr, flags;\n     ssize_t    n;\nDiff:\n@@ -80,8 +80,6 @@ typedef long  time_t;\n \n #pragma warning(default:4201)\n \n-/* disable some \"-W4\" level warnings */\n-\n /* 'type cast': from function pointer to data pointer */\n #pragma warning(disable:4054)\n \n@@ -106,6 +104,9 @@ typedef long  time_t;\n /* array is too small to include a terminating null character */\n #pragma warning(disable:4295)\n \n+/* conversion from 'type1' to 'type2' of greater size */\n+#pragma warning(disable:4306)\n+\n #endif\n \n \n"
    },
    {
        "commit_sha": "60965eca2c30d1d6c3770b193f559654475de0a5",
        "commit_index": "Commit 166",
        "commit_diff": "Diff:\n@@ -468,3 +468,4 @@ bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n+a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\nDiff:\n@@ -5,6 +5,72 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.1\" date=\"2022-07-19\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+оптимизация использования памяти\n+в конфигурациях с SSL-проксированием.\n+</para>\n+<para lang=\"en\">\n+memory usage optimization\n+in configurations with SSL proxying.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь с помощью параметра \"ipv4=off\" директивы \"resolver\"\n+можно запретить поиск IPv4-адресов при преобразовании имён в адреса.\n+</para>\n+<para lang=\"en\">\n+looking up of IPv4 addresses while resolving now can be disabled\n+with the \"ipv4=off\" parameter of the \"resolver\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"bad key share\", \"bad extension\",\n+\"bad cipher\" и \"bad ecpoint\"\n+понижен с уровня crit до info.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"bad key share\", \"bad extension\",\n+\"bad cipher\", and \"bad ecpoint\" SSL errors\n+has been lowered from \"crit\" to \"info\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при возврате диапазонов\n+nginx не удалял строку заголовка \"Content-Range\",\n+если она присутствовала в исходном ответе бэкенда.\n+</para>\n+<para lang=\"en\">\n+while returning byte ranges\n+nginx did not remove the \"Content-Range\" header line\n+if it was present in the original backend response.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+проксированный ответ мог быть отправлен не полностью\n+при переконфигурации на Linux;\n+ошибка появилась в 1.17.5.\n+</para>\n+<para lang=\"en\">\n+a proxied response might be truncated\n+during reconfiguration on Linux;\n+the bug had appeared in 1.17.5.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.0\" date=\"2022-06-21\">\n \n <change>\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023001\n-#define NGINX_VERSION      \"1.23.1\"\n+#define nginx_version      1023002\n+#define NGINX_VERSION      \"1.23.2\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -3422,6 +3422,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n #ifdef SSL_R_VERSION_TOO_LOW\n             || n == SSL_R_VERSION_TOO_LOW                            /*  396 */\n+#endif\n+#ifdef SSL_R_BAD_RECORD_TYPE\n+            || n == SSL_R_BAD_RECORD_TYPE                            /*  443 */\n #endif\n             || n == 1000 /* SSL_R_SSLV3_ALERT_CLOSE_NOTIFY */\n #ifdef SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE\n"
    },
    {
        "commit_sha": "d030af5eb4c64470c8fd5a87a8f6aae547580aa3",
        "commit_index": "Commit 165",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1p\n+OPENSSL =\topenssl-1.1.1q\n ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \nDiff:\n@@ -444,6 +444,10 @@ ngx_http_range_singlepart_header(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+    }\n+\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n@@ -601,6 +605,11 @@ ngx_http_range_multipart_header(ngx_http_request_t *r,\n         r->headers_out.content_length = NULL;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+        r->headers_out.content_range = NULL;\n+    }\n+\n     return ngx_http_next_header_filter(r);\n }\n \n@@ -617,6 +626,10 @@ ngx_http_range_not_satisfiable(ngx_http_request_t *r)\n         return NGX_ERROR;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+    }\n+\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\nDiff:\n@@ -28,6 +28,8 @@ static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_from(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,\n@@ -37,6 +39,8 @@ static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool,\n     ngx_uint_t alloc);\n+static ngx_int_t ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool,\n+    ngx_uint_t alloc);\n static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r,\n     ngx_str_t *host);\n static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,\n@@ -149,6 +153,10 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  offsetof(ngx_http_headers_in_t, expect),\n                  ngx_http_process_unique_header_line },\n \n+    { ngx_string(\"From\"),\n+                 offsetof(ngx_http_headers_in_t, from),\n+                 ngx_http_process_from },\n+\n     { ngx_string(\"Upgrade\"),\n                  offsetof(ngx_http_headers_in_t, upgrade),\n                  ngx_http_process_header_line },\n@@ -4028,6 +4036,144 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n }\n \n \n+static ngx_int_t\n+ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool, ngx_uint_t alloc)\n+{\n+    u_char  *f, *u, ch;\n+    size_t   i;\n+\n+    enum {\n+        sw_begin = 0,\n+        sw_username,\n+        sw_username_dot,\n+        sw_domain,\n+        sw_tld\n+    } state;\n+\n+    f = from->data;\n+\n+    state = sw_begin;\n+\n+    if (alloc) {\n+        u = ngx_palloc(pool, from->len);\n+\n+        if (u == NULL) {\n+            return NGX_ERROR;\n+        }\n+    } else {\n+        u = from->data;\n+    }\n+\n+    for (i = 0; i < from->len; i++) {\n+        ch = f[i];\n+\n+        switch (state) {\n+\n+        case sw_begin:\n+            if (isalnum(ch) || ch == '-' || ch == '_') {\n+                state = sw_username;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+            } else {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_username_dot:\n+            if (isalnum(ch) || ch == '-' || ch == '_') {\n+                *u++ = ch;\n+                state = sw_username;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+                u -= 2;\n+                for ( ;; ) {\n+                    if (*u == '.') {\n+                        u++;\n+                        break;\n+                    }\n+\n+                    u--;\n+                }\n+            } else {\n+                return NGX_DECLINED;\n+            }\n+            break;\n+\n+        case sw_username:\n+            if (ch == '@') {\n+                state = sw_domain;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+            } else if (!isalnum(ch) && ch != '-' && ch != '_' && ch != '+') {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_domain:\n+            if (ch == '.') {\n+                state = sw_tld;\n+            } else if (!isalnum(ch) && ch != '-') {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_tld:\n+            if (!isalpha(ch)) {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        default:\n+\n+            return NGX_DECLINED;\n+        }\n+    }\n+\n+    if (state == sw_tld) {\n+        *u = '\\0';\n+\n+        if (alloc) {\n+            from->data = u;\n+        }\n+        return NGX_OK;\n+    } else {\n+        return NGX_DECLINED;\n+    }\n+}\n+\n+static ngx_int_t\n+ngx_http_process_from(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    ngx_str_t  from;\n+\n+    if (r->headers_in.from) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate from header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.from->key,\n+                      &r->headers_in.from->value);\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    r->headers_in.from = h;\n+\n+    from = h->value;\n+\n+    if (ngx_http_validate_from(&from, r->pool, 1) != NGX_OK) {\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_trace_handler(ngx_http_request_t *r)\n {\nDiff:\n@@ -192,6 +192,7 @@ typedef struct {\n     ngx_table_elt_t                  *user_agent;\n     ngx_table_elt_t                  *prefer;\n     ngx_table_elt_t                  *referer;\n+    ngx_table_elt_t                  *from;\n     ngx_table_elt_t                  *content_length;\n     ngx_table_elt_t                  *content_range;\n     ngx_table_elt_t                  *content_type;\nDiff:\n@@ -46,6 +46,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n                 return 0;\n \n             } else {\n+                rev->ready = 0;\n                 return NGX_AGAIN;\n             }\n         }\n@@ -63,6 +64,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n                        rev->pending_eof, rev->available);\n \n         if (rev->available == 0 && !rev->pending_eof) {\n+            rev->ready = 0;\n             return NGX_AGAIN;\n         }\n     }\n"
    },
    {
        "commit_sha": "95b087ac81a251dcd9ad663ca9b9ffee659783c8",
        "commit_index": "Commit 164",
        "commit_diff": "Diff:\n@@ -157,6 +157,8 @@ ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)\n     cln->handler = ngx_resolver_cleanup;\n     cln->data = r;\n \n+    r->ipv4 = 1;\n+\n     ngx_rbtree_init(&r->name_rbtree, &r->name_sentinel,\n                     ngx_resolver_rbtree_insert_value);\n \n@@ -225,6 +227,23 @@ ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)\n         }\n \n #if (NGX_HAVE_INET6)\n+        if (ngx_strncmp(names[i].data, \"ipv4=\", 5) == 0) {\n+\n+            if (ngx_strcmp(&names[i].data[5], \"on\") == 0) {\n+                r->ipv4 = 1;\n+\n+            } else if (ngx_strcmp(&names[i].data[5], \"off\") == 0) {\n+                r->ipv4 = 0;\n+\n+            } else {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid parameter: %V\", &names[i]);\n+                return NULL;\n+            }\n+\n+            continue;\n+        }\n+\n         if (ngx_strncmp(names[i].data, \"ipv6=\", 5) == 0) {\n \n             if (ngx_strcmp(&names[i].data[5], \"on\") == 0) {\n@@ -273,6 +292,14 @@ ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)\n         }\n     }\n \n+#if (NGX_HAVE_INET6)\n+    if (r->ipv4 + r->ipv6 == 0) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"\\\"ipv4\\\" and \\\"ipv6\\\" cannot both be \\\"off\\\"\");\n+        return NULL;\n+    }\n+#endif\n+\n     if (n && r->connections.nelts == 0) {\n         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"no name servers defined\");\n         return NULL;\n@@ -836,7 +863,7 @@ ngx_resolve_name_locked(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx,\n         r->last_connection = 0;\n     }\n \n-    rn->naddrs = (u_short) -1;\n+    rn->naddrs = r->ipv4 ? (u_short) -1 : 0;\n     rn->tcp = 0;\n #if (NGX_HAVE_INET6)\n     rn->naddrs6 = r->ipv6 ? (u_short) -1 : 0;\n@@ -1263,7 +1290,7 @@ ngx_resolver_send_query(ngx_resolver_t *r, ngx_resolver_node_t *rn)\n         rec->log.action = \"resolving\";\n     }\n \n-    if (rn->naddrs == (u_short) -1) {\n+    if (rn->query && rn->naddrs == (u_short) -1) {\n         rc = rn->tcp ? ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen)\n                      : ngx_resolver_send_udp_query(r, rec, rn->query, rn->qlen);\n \n@@ -1765,10 +1792,13 @@ ngx_resolver_process_response(ngx_resolver_t *r, u_char *buf, size_t n,\n              q = ngx_queue_next(q))\n         {\n             rn = ngx_queue_data(q, ngx_resolver_node_t, queue);\n-            qident = (rn->query[0] << 8) + rn->query[1];\n \n-            if (qident == ident) {\n-                goto dns_error_name;\n+            if (rn->query) {\n+                qident = (rn->query[0] << 8) + rn->query[1];\n+\n+                if (qident == ident) {\n+                    goto dns_error_name;\n+                }\n             }\n \n #if (NGX_HAVE_INET6)\n@@ -3645,7 +3675,7 @@ ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,\n     len = sizeof(ngx_resolver_hdr_t) + nlen + sizeof(ngx_resolver_qs_t);\n \n #if (NGX_HAVE_INET6)\n-    p = ngx_resolver_alloc(r, r->ipv6 ? len * 2 : len);\n+    p = ngx_resolver_alloc(r, len * (r->ipv4 + r->ipv6));\n #else\n     p = ngx_resolver_alloc(r, len);\n #endif\n@@ -3658,19 +3688,21 @@ ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,\n \n #if (NGX_HAVE_INET6)\n     if (r->ipv6) {\n-        rn->query6 = p + len;\n+        rn->query6 = r->ipv4 ? (p + len) : p;\n     }\n #endif\n \n     query = (ngx_resolver_hdr_t *) p;\n \n-    ident = ngx_random();\n+    if (r->ipv4) {\n+        ident = ngx_random();\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,\n-                   \"resolve: \\\"%V\\\" A %i\", name, ident & 0xffff);\n+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,\n+                       \"resolve: \\\"%V\\\" A %i\", name, ident & 0xffff);\n \n-    query->ident_hi = (u_char) ((ident >> 8) & 0xff);\n-    query->ident_lo = (u_char) (ident & 0xff);\n+        query->ident_hi = (u_char) ((ident >> 8) & 0xff);\n+        query->ident_lo = (u_char) (ident & 0xff);\n+    }\n \n     /* recursion query */\n     query->flags_hi = 1; query->flags_lo = 0;\n@@ -3731,7 +3763,9 @@ ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,\n \n     p = rn->query6;\n \n-    ngx_memcpy(p, rn->query, rn->qlen);\n+    if (r->ipv4) {\n+        ngx_memcpy(p, rn->query, rn->qlen);\n+    }\n \n     query = (ngx_resolver_hdr_t *) p;\n \nDiff:\n@@ -175,8 +175,10 @@ struct ngx_resolver_s {\n     ngx_queue_t               srv_expire_queue;\n     ngx_queue_t               addr_expire_queue;\n \n+    unsigned                  ipv4:1;\n+\n #if (NGX_HAVE_INET6)\n-    ngx_uint_t                ipv6;                 /* unsigned  ipv6:1; */\n+    unsigned                  ipv6:1;\n     ngx_rbtree_t              addr6_rbtree;\n     ngx_rbtree_node_t         addr6_sentinel;\n     ngx_queue_t               addr6_resend_queue;\nDiff:\n@@ -3343,6 +3343,12 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_NO_SUITABLE_KEY_SHARE\n             || n == SSL_R_NO_SUITABLE_KEY_SHARE                      /*  101 */\n #endif\n+#ifdef SSL_R_BAD_KEY_SHARE\n+            || n == SSL_R_BAD_KEY_SHARE                              /*  108 */\n+#endif\n+#ifdef SSL_R_BAD_EXTENSION\n+            || n == SSL_R_BAD_EXTENSION                              /*  110 */\n+#endif\n #ifdef SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM\n             || n == SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM            /*  118 */\n #endif\n@@ -3357,6 +3363,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n             || n == SSL_R_NO_CIPHERS_PASSED                          /*  182 */\n #endif\n             || n == SSL_R_NO_CIPHERS_SPECIFIED                       /*  183 */\n+#ifdef SSL_R_BAD_CIPHER\n+            || n == SSL_R_BAD_CIPHER                                 /*  186 */\n+#endif\n             || n == SSL_R_NO_COMPRESSION_SPECIFIED                   /*  187 */\n             || n == SSL_R_NO_SHARED_CIPHER                           /*  193 */\n             || n == SSL_R_RECORD_LENGTH_MISMATCH                     /*  213 */\n@@ -3391,6 +3400,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_APPLICATION_DATA_ON_SHUTDOWN\n             || n == SSL_R_APPLICATION_DATA_ON_SHUTDOWN               /*  291 */\n #endif\n+#ifdef SSL_R_BAD_ECPOINT\n+            || n == SSL_R_BAD_ECPOINT                                /*  306 */\n+#endif\n #ifdef SSL_R_RENEGOTIATE_EXT_TOO_LONG\n             || n == SSL_R_RENEGOTIATE_EXT_TOO_LONG                   /*  335 */\n             || n == SSL_R_RENEGOTIATION_ENCODING_ERR                 /*  336 */\n"
    },
    {
        "commit_sha": "e68835a484fc2445c2193ede5f7f4939b162f41d",
        "commit_index": "Commit 163",
        "commit_diff": "Diff:\n@@ -209,6 +209,8 @@ static char *ngx_http_grpc_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n static char *ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n     void *data);\n+static ngx_int_t ngx_http_grpc_merge_ssl(ngx_conf_t *cf,\n+    ngx_http_grpc_loc_conf_t *conf, ngx_http_grpc_loc_conf_t *prev);\n static ngx_int_t ngx_http_grpc_set_ssl(ngx_conf_t *cf,\n     ngx_http_grpc_loc_conf_t *glcf);\n #endif\n@@ -562,7 +564,7 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n         ctx->host = glcf->host;\n \n #if (NGX_HTTP_SSL)\n-        u->ssl = (glcf->upstream.ssl != NULL);\n+        u->ssl = glcf->ssl;\n \n         if (u->ssl) {\n             ngx_str_set(&u->schema, \"grpcs://\");\n@@ -4463,6 +4465,10 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_HTTP_SSL)\n \n+    if (ngx_http_grpc_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,\n                               prev->upstream.ssl_session_reuse, 1);\n \n@@ -4524,7 +4530,7 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->grpc_values = prev->grpc_values;\n \n #if (NGX_HTTP_SSL)\n-        conf->upstream.ssl = prev->upstream.ssl;\n+        conf->ssl = prev->ssl;\n #endif\n     }\n \n@@ -4874,16 +4880,62 @@ ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n \n \n static ngx_int_t\n-ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n+ngx_http_grpc_merge_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *conf,\n+    ngx_http_grpc_loc_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->upstream.ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->upstream.ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->upstream.ssl) {\n+            conf->upstream.ssl = prev->upstream.ssl;\n+            return NGX_OK;\n+        }\n \n-    glcf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (glcf->upstream.ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->upstream.ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    glcf->upstream.ssl->log = cf->log;\n+    conf->upstream.ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->upstream.ssl\n+     * in the \"http\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->upstream.ssl = conf->upstream.ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (glcf->upstream.ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(glcf->upstream.ssl, glcf->ssl_protocols, NULL)\n         != NGX_OK)\nDiff:\n@@ -236,6 +236,8 @@ static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf,\n     ngx_http_proxy_rewrite_t *pr, ngx_str_t *regex, ngx_uint_t caseless);\n \n #if (NGX_HTTP_SSL)\n+static ngx_int_t ngx_http_proxy_merge_ssl(ngx_conf_t *cf,\n+    ngx_http_proxy_loc_conf_t *conf, ngx_http_proxy_loc_conf_t *prev);\n static ngx_int_t ngx_http_proxy_set_ssl(ngx_conf_t *cf,\n     ngx_http_proxy_loc_conf_t *plcf);\n #endif\n@@ -959,7 +961,7 @@ ngx_http_proxy_handler(ngx_http_request_t *r)\n         ctx->vars = plcf->vars;\n         u->schema = plcf->vars.schema;\n #if (NGX_HTTP_SSL)\n-        u->ssl = (plcf->upstream.ssl != NULL);\n+        u->ssl = plcf->ssl;\n #endif\n \n     } else {\n@@ -3724,6 +3726,10 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_HTTP_SSL)\n \n+    if (ngx_http_proxy_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,\n                               prev->upstream.ssl_session_reuse, 1);\n \n@@ -3857,7 +3863,7 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->proxy_values = prev->proxy_values;\n \n #if (NGX_HTTP_SSL)\n-        conf->upstream.ssl = prev->upstream.ssl;\n+        conf->ssl = prev->ssl;\n #endif\n     }\n \n@@ -4923,16 +4929,62 @@ ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n \n \n static ngx_int_t\n-ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n+ngx_http_proxy_merge_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *conf,\n+    ngx_http_proxy_loc_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->upstream.ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->upstream.ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->upstream.ssl) {\n+            conf->upstream.ssl = prev->upstream.ssl;\n+            return NGX_OK;\n+        }\n \n-    plcf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (plcf->upstream.ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->upstream.ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    plcf->upstream.ssl->log = cf->log;\n+    conf->upstream.ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->upstream.ssl\n+     * in the \"http\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->upstream.ssl = conf->upstream.ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (plcf->upstream.ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(plcf->upstream.ssl, plcf->ssl_protocols, NULL)\n         != NGX_OK)\nDiff:\n@@ -96,6 +96,8 @@ static char *ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n static char *ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n     void *data);\n+static ngx_int_t ngx_http_uwsgi_merge_ssl(ngx_conf_t *cf,\n+    ngx_http_uwsgi_loc_conf_t *conf, ngx_http_uwsgi_loc_conf_t *prev);\n static ngx_int_t ngx_http_uwsgi_set_ssl(ngx_conf_t *cf,\n     ngx_http_uwsgi_loc_conf_t *uwcf);\n #endif\n@@ -668,7 +670,7 @@ ngx_http_uwsgi_handler(ngx_http_request_t *r)\n     if (uwcf->uwsgi_lengths == NULL) {\n \n #if (NGX_HTTP_SSL)\n-        u->ssl = (uwcf->upstream.ssl != NULL);\n+        u->ssl = uwcf->ssl;\n \n         if (u->ssl) {\n             ngx_str_set(&u->schema, \"suwsgi://\");\n@@ -1865,6 +1867,10 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_HTTP_SSL)\n \n+    if (ngx_http_uwsgi_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,\n                               prev->upstream.ssl_session_reuse, 1);\n \n@@ -1927,7 +1933,7 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->uwsgi_values = prev->uwsgi_values;\n \n #if (NGX_HTTP_SSL)\n-        conf->upstream.ssl = prev->upstream.ssl;\n+        conf->ssl = prev->ssl;\n #endif\n     }\n \n@@ -2455,16 +2461,62 @@ ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n \n \n static ngx_int_t\n-ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n+ngx_http_uwsgi_merge_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *conf,\n+    ngx_http_uwsgi_loc_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->upstream.ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->upstream.ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->upstream.ssl) {\n+            conf->upstream.ssl = prev->upstream.ssl;\n+            return NGX_OK;\n+        }\n \n-    uwcf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (uwcf->upstream.ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->upstream.ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    uwcf->upstream.ssl->log = cf->log;\n+    conf->upstream.ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->upstream.ssl\n+     * in the \"http\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->upstream.ssl = conf->upstream.ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (uwcf->upstream.ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(uwcf->upstream.ssl, uwcf->ssl_protocols, NULL)\n         != NGX_OK)\nDiff:\n@@ -103,6 +103,8 @@ static void ngx_stream_proxy_ssl_handshake(ngx_connection_t *pc);\n static void ngx_stream_proxy_ssl_save_session(ngx_connection_t *c);\n static ngx_int_t ngx_stream_proxy_ssl_name(ngx_stream_session_t *s);\n static ngx_int_t ngx_stream_proxy_ssl_certificate(ngx_stream_session_t *s);\n+static ngx_int_t ngx_stream_proxy_merge_ssl(ngx_conf_t *cf,\n+    ngx_stream_proxy_srv_conf_t *conf, ngx_stream_proxy_srv_conf_t *prev);\n static ngx_int_t ngx_stream_proxy_set_ssl(ngx_conf_t *cf,\n     ngx_stream_proxy_srv_conf_t *pscf);\n \n@@ -801,7 +803,7 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n \n #if (NGX_STREAM_SSL)\n \n-    if (pc->type == SOCK_STREAM && pscf->ssl) {\n+    if (pc->type == SOCK_STREAM && pscf->ssl_enable) {\n \n         if (u->proxy_protocol) {\n             if (ngx_stream_proxy_send_proxy_protocol(s) != NGX_OK) {\n@@ -2150,6 +2152,10 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_STREAM_SSL)\n \n+    if (ngx_stream_proxy_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->ssl_enable, prev->ssl_enable, 0);\n \n     ngx_conf_merge_value(conf->ssl_session_reuse,\n@@ -2199,16 +2205,62 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n #if (NGX_STREAM_SSL)\n \n static ngx_int_t\n-ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n+ngx_stream_proxy_merge_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *conf,\n+    ngx_stream_proxy_srv_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->ssl) {\n+            conf->ssl = prev->ssl;\n+            return NGX_OK;\n+        }\n \n-    pscf->ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (pscf->ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    pscf->ssl->log = cf->log;\n+    conf->ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->ssl\n+     * in the \"stream\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->ssl = conf->ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (pscf->ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(pscf->ssl, pscf->ssl_protocols, NULL) != NGX_OK) {\n         return NGX_ERROR;\n"
    },
    {
        "commit_sha": "d5faf9e668e8322fc75c7a775fd4b7e928128d67",
        "commit_index": "Commit 162",
        "commit_diff": "Diff:\n@@ -467,3 +467,4 @@ bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\n d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n+5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\nDiff:\n@@ -5,6 +5,107 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.0\" date=\"2022-06-21\">\n+\n+<change>\n+<para lang=\"ru\">\n+Изменение во внутреннем API:\n+теперь строки заголовков представлены связными списками.\n+</para>\n+<para lang=\"en\">\n+Change in internal API:\n+now header lines are represented as linked lists.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx объединяет произвольные строки заголовков с одинаковыми именами\n+при отправке на FastCGI-, SCGI- и uwsgi-бэкенды,\n+в методе $r->header_in() модуля ngx_http_perl_module,\n+и при доступе через переменные \"$http_...\", \"$sent_http_...\",\n+\"$sent_trailer_...\", \"$upstream_http_...\" и \"$upstream_trailer_...\".\n+</para>\n+<para lang=\"en\">\n+now nginx combines arbitrary header lines with identical names\n+when sending to FastCGI, SCGI, and uwsgi backends,\n+in the $r->header_in() method of the ngx_http_perl_module,\n+and during lookup of the \"$http_...\", \"$sent_http_...\",\n+\"$sent_trailer_...\", \"$upstream_http_...\", and \"$upstream_trailer_...\"\n+variables.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если в заголовке ответа бэкенда было несколько строк \"Vary\",\n+при кэшировании nginx учитывал только последнюю из них.\n+</para>\n+<para lang=\"en\">\n+if there were multiple \"Vary\" header lines in the backend response,\n+nginx only used the last of them when caching.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если в заголовке ответа бэкенда было несколько строк \"WWW-Authenticate\"\n+и использовался перехват ошибок с кодом 401 от бэкенда\n+или директива auth_request,\n+nginx пересылал клиенту только первую из этих строк.\n+</para>\n+<para lang=\"en\">\n+if there were multiple \"WWW-Authenticate\" header lines in the backend response\n+and errors with code 401 were intercepted\n+or the \"auth_request\" directive was used,\n+nginx only sent the first of the header lines to the client.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"application data after close notify\"\n+понижен с уровня crit до info.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"application data after close notify\" SSL errors\n+has been lowered from \"crit\" to \"info\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+соединения могли зависать, если nginx был собран на Linux 2.6.17 и новее,\n+а использовался на системах без поддержки EPOLLRDHUP, в частности, на\n+системах с эмуляцией epoll;\n+ошибка появилась в 1.17.5.<br/>\n+Спасибо Marcus Ball.\n+</para>\n+<para lang=\"en\">\n+connections might hang if nginx was built on Linux 2.6.17 or newer,\n+but was used on systems without EPOLLRDHUP support, notably with epoll\n+emulation layers;\n+the bug had appeared in 1.17.5.<br/>\n+Thanks to Marcus Ball.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не кэшировал ответ,\n+если строка заголовка ответа \"Expires\" запрещала кэширование,\n+а последующая строка заголовка \"Cache-Control\" разрешала кэширование.\n+</para>\n+<para lang=\"en\">\n+nginx did not cache the response\n+if the \"Expires\" response header line disabled caching,\n+but following \"Cache-Control\" header line enabled caching.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.6\" date=\"2022-01-25\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023000\n-#define NGINX_VERSION      \"1.23.0\"\n+#define nginx_version      1023001\n+#define NGINX_VERSION      \"1.23.1\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "b37d8ebd02f4db669af98c0a1ddd01fcf1d87890",
        "commit_index": "Commit 161",
        "commit_diff": "Diff:\n@@ -111,19 +111,14 @@ syn keyword ngxDirectiveControl contained set\n syn keyword ngxDirectiveError contained error_page\n syn keyword ngxDirectiveError contained post_action\n \n-syn keyword ngxDirectiveDeprecated contained limit_zone\n syn keyword ngxDirectiveDeprecated contained proxy_downstream_buffer\n syn keyword ngxDirectiveDeprecated contained proxy_upstream_buffer\n-syn keyword ngxDirectiveDeprecated contained spdy_chunk_size\n-syn keyword ngxDirectiveDeprecated contained spdy_headers_comp\n-syn keyword ngxDirectiveDeprecated contained spdy_keepalive_timeout\n-syn keyword ngxDirectiveDeprecated contained spdy_max_concurrent_streams\n-syn keyword ngxDirectiveDeprecated contained spdy_pool_size\n-syn keyword ngxDirectiveDeprecated contained spdy_recv_buffer_size\n-syn keyword ngxDirectiveDeprecated contained spdy_recv_timeout\n-syn keyword ngxDirectiveDeprecated contained spdy_streams_index_size\n syn keyword ngxDirectiveDeprecated contained ssl\n-syn keyword ngxDirectiveDeprecated contained upstream_conf\n+syn keyword ngxDirectiveDeprecated contained http2_idle_timeout\n+syn keyword ngxDirectiveDeprecated contained http2_max_field_size\n+syn keyword ngxDirectiveDeprecated contained http2_max_header_size\n+syn keyword ngxDirectiveDeprecated contained http2_max_requests\n+syn keyword ngxDirectiveDeprecated contained http2_recv_timeout\n \n syn keyword ngxDirective contained absolute_redirect\n syn keyword ngxDirective contained accept_mutex\n@@ -152,6 +147,7 @@ syn keyword ngxDirective contained auth_http_timeout\n syn keyword ngxDirective contained auth_jwt\n syn keyword ngxDirective contained auth_jwt_claim_set\n syn keyword ngxDirective contained auth_jwt_header_set\n+syn keyword ngxDirective contained auth_jwt_key_cache\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n@@ -309,17 +305,12 @@ syn keyword ngxDirective contained hls_mp4_buffer_size\n syn keyword ngxDirective contained hls_mp4_max_buffer_size\n syn keyword ngxDirective contained http2_body_preread_size\n syn keyword ngxDirective contained http2_chunk_size\n-syn keyword ngxDirective contained http2_idle_timeout\n syn keyword ngxDirective contained http2_max_concurrent_pushes\n syn keyword ngxDirective contained http2_max_concurrent_streams\n-syn keyword ngxDirective contained http2_max_field_size\n-syn keyword ngxDirective contained http2_max_header_size\n-syn keyword ngxDirective contained http2_max_requests\n syn keyword ngxDirective contained http2_pool_size\n syn keyword ngxDirective contained http2_push\n syn keyword ngxDirective contained http2_push_preload\n syn keyword ngxDirective contained http2_recv_buffer_size\n-syn keyword ngxDirective contained http2_recv_timeout\n syn keyword ngxDirective contained http2_streams_index_size\n syn keyword ngxDirective contained if_modified_since\n syn keyword ngxDirective contained ignore_invalid_headers\n@@ -339,14 +330,17 @@ syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n+syn keyword ngxDirective contained js_fetch_buffer_size\n syn keyword ngxDirective contained js_fetch_ciphers\n+syn keyword ngxDirective contained js_fetch_max_response_buffer_size\n syn keyword ngxDirective contained js_fetch_protocols\n+syn keyword ngxDirective contained js_fetch_timeout\n syn keyword ngxDirective contained js_fetch_trusted_certificate\n+syn keyword ngxDirective contained js_fetch_verify\n syn keyword ngxDirective contained js_fetch_verify_depth\n syn keyword ngxDirective contained js_filter\n syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n-syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n syn keyword ngxDirective contained js_set\n@@ -391,7 +385,6 @@ syn keyword ngxDirective contained max_ranges\n syn keyword ngxDirective contained memcached_bind\n syn keyword ngxDirective contained memcached_buffer_size\n syn keyword ngxDirective contained memcached_connect_timeout\n-syn keyword ngxDirective contained memcached_force_ranges\n syn keyword ngxDirective contained memcached_gzip_flag\n syn keyword ngxDirective contained memcached_next_upstream\n syn keyword ngxDirective contained memcached_next_upstream_timeout\n@@ -645,7 +638,6 @@ syn keyword ngxDirective contained status\n syn keyword ngxDirective contained status_format\n syn keyword ngxDirective contained status_zone\n syn keyword ngxDirective contained sticky\n-syn keyword ngxDirective contained sticky_cookie_insert\n syn keyword ngxDirective contained stub_status\n syn keyword ngxDirective contained sub_filter\n syn keyword ngxDirective contained sub_filter_last_modified\n@@ -774,62 +766,14 @@ syn keyword ngxDirective contained zone_sync_ssl_verify\n syn keyword ngxDirective contained zone_sync_ssl_verify_depth\n syn keyword ngxDirective contained zone_sync_timeout\n \n-\" 3rd party modules list taken from\n-\" https://github.com/freebsd/freebsd-ports/blob/master/www/nginx-devel/Makefile\n-\" -----------------------------------------------------------------------------\n-\n-\" Accept Language\n-\" https://github.com/giom/nginx_accept_language_module\n-syn keyword ngxDirectiveThirdParty contained set_from_accept_language\n-\n-\" Digest Authentication\n-\" https://github.com/atomx/nginx-http-auth-digest\n-syn keyword ngxDirectiveThirdParty contained auth_digest\n-syn keyword ngxDirectiveThirdParty contained auth_digest_drop_time\n-syn keyword ngxDirectiveThirdParty contained auth_digest_evasion_time\n-syn keyword ngxDirectiveThirdParty contained auth_digest_expires\n-syn keyword ngxDirectiveThirdParty contained auth_digest_maxtries\n-syn keyword ngxDirectiveThirdParty contained auth_digest_replays\n-syn keyword ngxDirectiveThirdParty contained auth_digest_shm_size\n-syn keyword ngxDirectiveThirdParty contained auth_digest_timeout\n-syn keyword ngxDirectiveThirdParty contained auth_digest_user_file\n-\n-\" SPNEGO Authentication\n-\" https://github.com/stnoonan/spnego-http-auth-nginx-module\n-syn keyword ngxDirectiveThirdParty contained auth_gss\n-syn keyword ngxDirectiveThirdParty contained auth_gss_allow_basic_fallback\n-syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n-syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal_regex\n-syn keyword ngxDirectiveThirdParty contained auth_gss_constrained_delegation\n-syn keyword ngxDirectiveThirdParty contained auth_gss_delegate_credentials\n-syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n-syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n-syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n-syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n-syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n-syn keyword ngxDirectiveThirdParty contained auth_gss_service_ccache\n-syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n-\n-\" LDAP Authentication\n-\" https://github.com/kvspb/nginx-auth-ldap\n-syn keyword ngxDirectiveThirdParty contained auth_ldap\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_enabled\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_expiration_time\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_size\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_servers\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_servers_size\n-syn keyword ngxDirectiveThirdParty contained ldap_server\n \n-\" PAM Authentication\n-\" https://github.com/sto/ngx_http_auth_pam_module\n-syn keyword ngxDirectiveThirdParty contained auth_pam\n-syn keyword ngxDirectiveThirdParty contained auth_pam_service_name\n-syn keyword ngxDirectiveThirdParty contained auth_pam_set_pam_env\n+\" 3rd party modules list taken from\n+\" https://github.com/freebsd/freebsd-ports/blob/main/www/nginx-devel/Makefile.extmod\n+\" ----------------------------------------------------------------------------------\n \n-\" AJP protocol proxy\n-\" https://github.com/yaoweibin/nginx_ajp_module\n-syn keyword ngxDirectiveThirdParty contained ajp_buffers\n+\" https://github.com/msva/nginx_ajp_module\n syn keyword ngxDirectiveThirdParty contained ajp_buffer_size\n+syn keyword ngxDirectiveThirdParty contained ajp_buffers\n syn keyword ngxDirectiveThirdParty contained ajp_busy_buffers_size\n syn keyword ngxDirectiveThirdParty contained ajp_cache\n syn keyword ngxDirectiveThirdParty contained ajp_cache_key\n@@ -850,11 +794,13 @@ syn keyword ngxDirectiveThirdParty contained ajp_keep_conn\n syn keyword ngxDirectiveThirdParty contained ajp_max_data_packet_size\n syn keyword ngxDirectiveThirdParty contained ajp_max_temp_file_size\n syn keyword ngxDirectiveThirdParty contained ajp_next_upstream\n+syn keyword ngxDirectiveThirdParty contained ajp_param\n syn keyword ngxDirectiveThirdParty contained ajp_pass\n syn keyword ngxDirectiveThirdParty contained ajp_pass_header\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_body\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_headers\n syn keyword ngxDirectiveThirdParty contained ajp_read_timeout\n+syn keyword ngxDirectiveThirdParty contained ajp_script_url\n syn keyword ngxDirectiveThirdParty contained ajp_secret\n syn keyword ngxDirectiveThirdParty contained ajp_send_lowat\n syn keyword ngxDirectiveThirdParty contained ajp_send_timeout\n@@ -865,7 +811,12 @@ syn keyword ngxDirectiveThirdParty contained ajp_temp_path\n syn keyword ngxDirectiveThirdParty contained ajp_upstream_fail_timeout\n syn keyword ngxDirectiveThirdParty contained ajp_upstream_max_fails\n \n-\" AWS proxy\n+\" https://github.com/openresty/array-var-nginx-module\n+syn keyword ngxDirectiveThirdParty contained array_join\n+syn keyword ngxDirectiveThirdParty contained array_map\n+syn keyword ngxDirectiveThirdParty contained array_map_op\n+syn keyword ngxDirectiveThirdParty contained array_split\n+\n \" https://github.com/anomalizer/ngx_aws_auth\n syn keyword ngxDirectiveThirdParty contained aws_access_key\n syn keyword ngxDirectiveThirdParty contained aws_endpoint\n@@ -874,7 +825,18 @@ syn keyword ngxDirectiveThirdParty contained aws_s3_bucket\n syn keyword ngxDirectiveThirdParty contained aws_sign\n syn keyword ngxDirectiveThirdParty contained aws_signing_key\n \n-\" embedding Clojure or Java or Groovy programs\n+\" https://github.com/google/ngx_brotli\n+syn keyword ngxDirectiveThirdParty contained brotli\n+syn keyword ngxDirectiveThirdParty contained brotli_buffers\n+syn keyword ngxDirectiveThirdParty contained brotli_comp_level\n+syn keyword ngxDirectiveThirdParty contained brotli_min_length\n+syn keyword ngxDirectiveThirdParty contained brotli_static\n+syn keyword ngxDirectiveThirdParty contained brotli_types\n+syn keyword ngxDirectiveThirdParty contained brotli_window\n+\n+\" https://github.com/torden/ngx_cache_purge\n+syn keyword ngxDirectiveThirdParty contained cache_purge_response_type\n+\n \" https://github.com/nginx-clojure/nginx-clojure\n syn keyword ngxDirectiveThirdParty contained access_handler_code\n syn keyword ngxDirectiveThirdParty contained access_handler_name\n@@ -892,8 +854,8 @@ syn keyword ngxDirectiveThirdParty contained content_handler_property\n syn keyword ngxDirectiveThirdParty contained content_handler_type\n syn keyword ngxDirectiveThirdParty contained handler_code\n syn keyword ngxDirectiveThirdParty contained handler_name\n-syn keyword ngxDirectiveThirdParty contained handlers_lazy_init\n syn keyword ngxDirectiveThirdParty contained handler_type\n+syn keyword ngxDirectiveThirdParty contained handlers_lazy_init\n syn keyword ngxDirectiveThirdParty contained header_filter_code\n syn keyword ngxDirectiveThirdParty contained header_filter_name\n syn keyword ngxDirectiveThirdParty contained header_filter_property\n@@ -921,18 +883,20 @@ syn keyword ngxDirectiveThirdParty contained rewrite_handler_type\n syn keyword ngxDirectiveThirdParty contained shared_map\n syn keyword ngxDirectiveThirdParty contained write_page_size\n \n+\" https://github.com/AirisX/nginx_cookie_flag_module\n+syn keyword ngxDirectiveThirdParty contained set_cookie_flag\n \n-\" Certificate Transparency\n \" https://github.com/grahamedgecombe/nginx-ct\n syn keyword ngxDirectiveThirdParty contained ssl_ct\n syn keyword ngxDirectiveThirdParty contained ssl_ct_static_scts\n \n-\" ngx_echo\n \" https://github.com/openresty/echo-nginx-module\n+syn keyword ngxDirectiveThirdParty contained echo\n syn keyword ngxDirectiveThirdParty contained echo_abort_parent\n syn keyword ngxDirectiveThirdParty contained echo_after_body\n syn keyword ngxDirectiveThirdParty contained echo_before_body\n syn keyword ngxDirectiveThirdParty contained echo_blocking_sleep\n+syn keyword ngxDirectiveThirdParty contained echo_duplicate\n syn keyword ngxDirectiveThirdParty contained echo_end\n syn keyword ngxDirectiveThirdParty contained echo_exec\n syn keyword ngxDirectiveThirdParty contained echo_flush\n@@ -942,36 +906,131 @@ syn keyword ngxDirectiveThirdParty contained echo_location_async\n syn keyword ngxDirectiveThirdParty contained echo_read_request_body\n syn keyword ngxDirectiveThirdParty contained echo_request_body\n syn keyword ngxDirectiveThirdParty contained echo_reset_timer\n+syn keyword ngxDirectiveThirdParty contained echo_sleep\n syn keyword ngxDirectiveThirdParty contained echo_status\n syn keyword ngxDirectiveThirdParty contained echo_subrequest\n syn keyword ngxDirectiveThirdParty contained echo_subrequest_async\n \n-\" FastDFS\n-\" https://github.com/happyfish100/fastdfs-nginx-module\n-syn keyword ngxDirectiveThirdParty contained ngx_fastdfs_module\n+\" https://github.com/openresty/drizzle-nginx-module\n+syn keyword ngxDirectiveThirdParty contained drizzle_buffer_size\n+syn keyword ngxDirectiveThirdParty contained drizzle_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_dbname\n+syn keyword ngxDirectiveThirdParty contained drizzle_keepalive\n+syn keyword ngxDirectiveThirdParty contained drizzle_module_header\n+syn keyword ngxDirectiveThirdParty contained drizzle_pass\n+syn keyword ngxDirectiveThirdParty contained drizzle_query\n+syn keyword ngxDirectiveThirdParty contained drizzle_recv_cols_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_recv_rows_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_send_query_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_server\n+syn keyword ngxDirectiveThirdParty contained drizzle_status\n+\n+\" https://github.com/ZigzagAK/ngx_dynamic_upstream\n+syn keyword ngxDirectiveThirdParty contained dns_add_down\n+syn keyword ngxDirectiveThirdParty contained dns_ipv6\n+syn keyword ngxDirectiveThirdParty contained dns_update\n+syn keyword ngxDirectiveThirdParty contained dynamic_state_file\n+syn keyword ngxDirectiveThirdParty contained dynamic_upstream\n+\n+\" https://github.com/ZigzagAK/ngx_dynamic_healthcheck\n+syn keyword ngxDirectiveThirdParty contained check\n+syn keyword ngxDirectiveThirdParty contained check_disable_host\n+syn keyword ngxDirectiveThirdParty contained check_exclude_host\n+syn keyword ngxDirectiveThirdParty contained check_persistent\n+syn keyword ngxDirectiveThirdParty contained check_request_body\n+syn keyword ngxDirectiveThirdParty contained check_request_headers\n+syn keyword ngxDirectiveThirdParty contained check_request_uri\n+syn keyword ngxDirectiveThirdParty contained check_response_body\n+syn keyword ngxDirectiveThirdParty contained check_response_codes\n+syn keyword ngxDirectiveThirdParty contained healthcheck\n+syn keyword ngxDirectiveThirdParty contained healthcheck_buffer_size\n+syn keyword ngxDirectiveThirdParty contained healthcheck_disable_host\n+syn keyword ngxDirectiveThirdParty contained healthcheck_get\n+syn keyword ngxDirectiveThirdParty contained healthcheck_persistent\n+syn keyword ngxDirectiveThirdParty contained healthcheck_request_body\n+syn keyword ngxDirectiveThirdParty contained healthcheck_request_headers\n+syn keyword ngxDirectiveThirdParty contained healthcheck_request_uri\n+syn keyword ngxDirectiveThirdParty contained healthcheck_response_body\n+syn keyword ngxDirectiveThirdParty contained healthcheck_response_codes\n+syn keyword ngxDirectiveThirdParty contained healthcheck_status\n+syn keyword ngxDirectiveThirdParty contained healthcheck_update\n+\n+\" https://github.com/openresty/encrypted-session-nginx-module\n+syn keyword ngxDirectiveThirdParty contained encrypted_session_expires\n+syn keyword ngxDirectiveThirdParty contained encrypted_session_iv\n+syn keyword ngxDirectiveThirdParty contained encrypted_session_key\n+syn keyword ngxDirectiveThirdParty contained set_decrypt_session\n+syn keyword ngxDirectiveThirdParty contained set_encrypt_session\n+\n+\" https://github.com/calio/form-input-nginx-module\n+syn keyword ngxDirectiveThirdParty contained set_form_input\n+syn keyword ngxDirectiveThirdParty contained set_form_input_multi\n+\n+\" https://github.com/nieoding/nginx-gridfs\n+syn keyword ngxDirectiveThirdParty contained gridfs\n+syn keyword ngxDirectiveThirdParty contained mongo\n \n-\" ngx_headers_more\n \" https://github.com/openresty/headers-more-nginx-module\n syn keyword ngxDirectiveThirdParty contained more_clear_headers\n syn keyword ngxDirectiveThirdParty contained more_clear_input_headers\n syn keyword ngxDirectiveThirdParty contained more_set_headers\n syn keyword ngxDirectiveThirdParty contained more_set_input_headers\n \n-\" NGINX WebDAV missing commands support (PROPFIND & OPTIONS)\n+\" https://github.com/dvershinin/nginx_accept_language_module\n+syn keyword ngxDirectiveThirdParty contained set_from_accept_language\n+\n+\" https://github.com/atomx/nginx-http-auth-digest\n+syn keyword ngxDirectiveThirdParty contained auth_digest\n+syn keyword ngxDirectiveThirdParty contained auth_digest_drop_time\n+syn keyword ngxDirectiveThirdParty contained auth_digest_evasion_time\n+syn keyword ngxDirectiveThirdParty contained auth_digest_expires\n+syn keyword ngxDirectiveThirdParty contained auth_digest_maxtries\n+syn keyword ngxDirectiveThirdParty contained auth_digest_replays\n+syn keyword ngxDirectiveThirdParty contained auth_digest_shm_size\n+syn keyword ngxDirectiveThirdParty contained auth_digest_timeout\n+syn keyword ngxDirectiveThirdParty contained auth_digest_user_file\n+\n+\" https://github.com/stnoonan/spnego-http-auth-nginx-module\n+syn keyword ngxDirectiveThirdParty contained auth_gss\n+syn keyword ngxDirectiveThirdParty contained auth_gss_allow_basic_fallback\n+syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n+syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal_regex\n+syn keyword ngxDirectiveThirdParty contained auth_gss_constrained_delegation\n+syn keyword ngxDirectiveThirdParty contained auth_gss_delegate_credentials\n+syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n+syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n+syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n+syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n+syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n+syn keyword ngxDirectiveThirdParty contained auth_gss_service_ccache\n+syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n+\n+\" https://github.com/kvspb/nginx-auth-ldap\n+syn keyword ngxDirectiveThirdParty contained auth_ldap\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_enabled\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_expiration_time\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_size\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_servers\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_servers_size\n+syn keyword ngxDirectiveThirdParty contained ldap_server\n+\n+\" https://github.com/sto/ngx_http_auth_pam_module\n+syn keyword ngxDirectiveThirdParty contained auth_pam\n+syn keyword ngxDirectiveThirdParty contained auth_pam_service_name\n+syn keyword ngxDirectiveThirdParty contained auth_pam_set_pam_env\n+\n \" https://github.com/arut/nginx-dav-ext-module\n syn keyword ngxDirectiveThirdParty contained dav_ext_lock\n syn keyword ngxDirectiveThirdParty contained dav_ext_lock_zone\n syn keyword ngxDirectiveThirdParty contained dav_ext_methods\n \n-\" ngx_eval\n \" https://github.com/openresty/nginx-eval-module\n syn keyword ngxDirectiveThirdParty contained eval\n syn keyword ngxDirectiveThirdParty contained eval_buffer_size\n syn keyword ngxDirectiveThirdParty contained eval_escalate\n syn keyword ngxDirectiveThirdParty contained eval_override_content_type\n syn keyword ngxDirectiveThirdParty contained eval_subrequest_in_memory\n \n-\" Fancy Index\n \" https://github.com/aperezdc/ngx-fancyindex\n syn keyword ngxDirectiveThirdParty contained fancyindex\n syn keyword ngxDirectiveThirdParty contained fancyindex_css_href\n@@ -988,40 +1047,29 @@ syn keyword ngxDirectiveThirdParty contained fancyindex_show_dotfiles\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_path\n syn keyword ngxDirectiveThirdParty contained fancyindex_time_format\n \n-\" Footer filter\n \" https://github.com/alibaba/nginx-http-footer-filter\n syn keyword ngxDirectiveThirdParty contained footer\n syn keyword ngxDirectiveThirdParty contained footer_types\n \n-\" ngx_http_geoip2_module\n \" https://github.com/leev/ngx_http_geoip2_module\n syn keyword ngxDirectiveThirdParty contained geoip2\n syn keyword ngxDirectiveThirdParty contained geoip2_proxy\n syn keyword ngxDirectiveThirdParty contained geoip2_proxy_recursive\n \n-\" A version of the Nginx HTTP stub status module that outputs in JSON format\n-\" https://github.com/nginx-modules/nginx-json-status-module\n-syn keyword ngxDirectiveThirdParty contained json_status\n-syn keyword ngxDirectiveThirdParty contained json_status_type\n-\n-\" MogileFS client for nginx\n-\" https://github.com/vkholodkov/nginx-mogilefs-module\n-syn keyword ngxDirectiveThirdParty contained mogilefs_class\n-syn keyword ngxDirectiveThirdParty contained mogilefs_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained mogilefs_domain\n-syn keyword ngxDirectiveThirdParty contained mogilefs_methods\n-syn keyword ngxDirectiveThirdParty contained mogilefs_noverify\n-syn keyword ngxDirectiveThirdParty contained mogilefs_pass\n-syn keyword ngxDirectiveThirdParty contained mogilefs_read_timeout\n-syn keyword ngxDirectiveThirdParty contained mogilefs_send_timeout\n-syn keyword ngxDirectiveThirdParty contained mogilefs_tracker\n-\n-\" Ancient nginx plugin; probably not useful to anyone\n+\" https://github.com/ip2location/ip2location-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2location_database\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+\n+\" https://github.com/ip2location/ip2proxy-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n+\n \" https://github.com/kr/nginx-notice\n syn keyword ngxDirectiveThirdParty contained notice\n syn keyword ngxDirectiveThirdParty contained notice_type\n \n-\" nchan\n \" https://github.com/slact/nchan\n syn keyword ngxDirectiveThirdParty contained nchan_access_control_allow_credentials\n syn keyword ngxDirectiveThirdParty contained nchan_access_control_allow_origin\n@@ -1034,8 +1082,8 @@ syn keyword ngxDirectiveThirdParty contained nchan_benchmark_publisher_distribut\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscriber_distribution\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscribers_per_channel\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_time\n-syn keyword ngxDirectiveThirdParty contained nchan_channel_events_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_channel_event_string\n+syn keyword ngxDirectiveThirdParty contained nchan_channel_events_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group_accounting\n syn keyword ngxDirectiveThirdParty contained nchan_channel_id\n@@ -1074,18 +1122,39 @@ syn keyword ngxDirectiveThirdParty contained nchan_pubsub\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_location\n syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_backoff\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_jitter\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_max\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_min\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_max_failing_time\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_backoff\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_jitter\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_max\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_min\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_command_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_connect_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_discovered_ip_range_blacklist\n syn keyword ngxDirectiveThirdParty contained nchan_redis_fakesub_timer_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_idle_channel_cache_timeout\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_load_scripts_unconditionally\n syn keyword ngxDirectiveThirdParty contained nchan_redis_namespace\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_node_connect_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_nostore_fastpublish\n syn keyword ngxDirectiveThirdParty contained nchan_redis_optimize_target\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass_inheritable\n syn keyword ngxDirectiveThirdParty contained nchan_redis_password\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ping_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_publish_msgpacked_max_size\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_backoff\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_jitter\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_max\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_min\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_retry_commands\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_retry_commands_max_wait\n syn keyword ngxDirectiveThirdParty contained nchan_redis_server\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_ciphers\n@@ -1113,10 +1182,10 @@ syn keyword ngxDirectiveThirdParty contained nchan_store_messages\n syn keyword ngxDirectiveThirdParty contained nchan_stub_status\n syn keyword ngxDirectiveThirdParty contained nchan_sub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_existing_channels_only\n+syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_message_id\n-syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info\n@@ -1145,7 +1214,6 @@ syn keyword ngxDirectiveThirdParty contained push_subscriber\n syn keyword ngxDirectiveThirdParty contained push_subscriber_concurrency\n syn keyword ngxDirectiveThirdParty contained push_subscriber_timeout\n \n-\" Push Stream\n \" https://github.com/wandenberg/nginx-push-stream-module\n syn keyword ngxDirectiveThirdParty contained push_stream_allow_connections_to_events_channel\n syn keyword ngxDirectiveThirdParty contained push_stream_allowed_origins\n@@ -1184,31 +1252,13 @@ syn keyword ngxDirectiveThirdParty contained push_stream_websocket_allow_publish\n syn keyword ngxDirectiveThirdParty contained push_stream_wildcard_channel_max_qtd\n syn keyword ngxDirectiveThirdParty contained push_stream_wildcard_channel_prefix\n \n-\" redis module\n-\" https://www.nginx.com/resources/wiki/modules/redis/\n-syn keyword ngxDirectiveThirdParty contained redis_bind\n-syn keyword ngxDirectiveThirdParty contained redis_buffer_size\n-syn keyword ngxDirectiveThirdParty contained redis_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained redis_gzip_flag\n-syn keyword ngxDirectiveThirdParty contained redis_next_upstream\n-syn keyword ngxDirectiveThirdParty contained redis_pass\n-syn keyword ngxDirectiveThirdParty contained redis_read_timeout\n-syn keyword ngxDirectiveThirdParty contained redis_send_timeout\n-\n-\" ngx_http_response\n-\" http://catap.ru/downloads/nginx/\n-syn keyword ngxDirectiveThirdParty contained response\n-syn keyword ngxDirectiveThirdParty contained response_type\n-\n-\" nginx_substitutions_filter\n \" https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n syn keyword ngxDirectiveThirdParty contained subs_buffers\n syn keyword ngxDirectiveThirdParty contained subs_filter\n syn keyword ngxDirectiveThirdParty contained subs_filter_bypass\n syn keyword ngxDirectiveThirdParty contained subs_filter_types\n syn keyword ngxDirectiveThirdParty contained subs_line_buffer_size\n \n-\" Tarantool nginx upstream module\n \" https://github.com/tarantool/nginx_upstream_module\n syn keyword ngxDirectiveThirdParty contained tnt_allowed_indexes\n syn keyword ngxDirectiveThirdParty contained tnt_allowed_spaces\n@@ -1238,44 +1288,28 @@ syn keyword ngxDirectiveThirdParty contained tnt_set_header\n syn keyword ngxDirectiveThirdParty contained tnt_update\n syn keyword ngxDirectiveThirdParty contained tnt_upsert\n \n-\" A module for nginx web server for handling file uploads using multipart/form-data encoding (RFC 1867)\n-\" https://github.com/Austinb/nginx-upload-module\n+\" https://github.com/fdintino/nginx-upload-module\n+syn keyword ngxDirectiveThirdParty contained upload_add_header\n syn keyword ngxDirectiveThirdParty contained upload_aggregate_form_field\n-syn keyword ngxDirectiveThirdParty contained upload_archive_elm\n-syn keyword ngxDirectiveThirdParty contained upload_archive_elm_separator\n-syn keyword ngxDirectiveThirdParty contained upload_archive_path\n-syn keyword ngxDirectiveThirdParty contained upload_archive_path_separator\n syn keyword ngxDirectiveThirdParty contained upload_buffer_size\n syn keyword ngxDirectiveThirdParty contained upload_cleanup\n-syn keyword ngxDirectiveThirdParty contained upload_content_type\n-syn keyword ngxDirectiveThirdParty contained upload_discard\n-syn keyword ngxDirectiveThirdParty contained upload_field_name\n-syn keyword ngxDirectiveThirdParty contained upload_file_crc32\n-syn keyword ngxDirectiveThirdParty contained upload_file_md5\n-syn keyword ngxDirectiveThirdParty contained upload_file_md5_uc\n-syn keyword ngxDirectiveThirdParty contained upload_file_name\n-syn keyword ngxDirectiveThirdParty contained upload_file_sha1\n-syn keyword ngxDirectiveThirdParty contained upload_file_sha1_uc\n-syn keyword ngxDirectiveThirdParty contained upload_file_size\n-syn keyword ngxDirectiveThirdParty contained upload_filter\n+syn keyword ngxDirectiveThirdParty contained upload_empty_fiels_names\n+syn keyword ngxDirectiveThirdParty contained upload_limit_rate\n syn keyword ngxDirectiveThirdParty contained upload_max_file_size\n syn keyword ngxDirectiveThirdParty contained upload_max_output_body_len\n syn keyword ngxDirectiveThirdParty contained upload_max_part_header_len\n+syn keyword ngxDirectiveThirdParty contained upload_merge_buffer_size\n syn keyword ngxDirectiveThirdParty contained upload_pass\n syn keyword ngxDirectiveThirdParty contained upload_pass_args\n syn keyword ngxDirectiveThirdParty contained upload_pass_form_field\n+syn keyword ngxDirectiveThirdParty contained upload_range_header_buffer_size\n+syn keyword ngxDirectiveThirdParty contained upload_resumable\n syn keyword ngxDirectiveThirdParty contained upload_set_form_field\n+syn keyword ngxDirectiveThirdParty contained upload_state_store\n syn keyword ngxDirectiveThirdParty contained upload_store\n syn keyword ngxDirectiveThirdParty contained upload_store_access\n-syn keyword ngxDirectiveThirdParty contained upload_tmp_path\n-syn keyword ngxDirectiveThirdParty contained upload_unzip\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_buffers\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_hash\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_max_file_name_len\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_window\n-syn keyword ngxDirectiveThirdParty contained upload_void_content_type\n-\n-\" nginx-upload-progress-module\n+syn keyword ngxDirectiveThirdParty contained upload_tame_arrays\n+\n \" https://github.com/masterzen/nginx-upload-progress-module\n syn keyword ngxDirectiveThirdParty contained report_uploads\n syn keyword ngxDirectiveThirdParty contained track_uploads\n@@ -1288,23 +1322,22 @@ syn keyword ngxDirectiveThirdParty contained upload_progress_jsonp_output\n syn keyword ngxDirectiveThirdParty contained upload_progress_jsonp_parameter\n syn keyword ngxDirectiveThirdParty contained upload_progress_template\n \n-\" Health checks upstreams for nginx\n \" https://github.com/yaoweibin/nginx_upstream_check_module\n-syn keyword ngxDirectiveThirdParty contained check\n syn keyword ngxDirectiveThirdParty contained check_fastcgi_param\n syn keyword ngxDirectiveThirdParty contained check_http_expect_alive\n syn keyword ngxDirectiveThirdParty contained check_http_send\n syn keyword ngxDirectiveThirdParty contained check_keepalive_requests\n syn keyword ngxDirectiveThirdParty contained check_shm_size\n syn keyword ngxDirectiveThirdParty contained check_status\n \n-\" The fair load balancer module for nginx\n-\" https://github.com/cryptofuture/nginx-upstream-fair\n+\" https://github.com/jaygooby/nginx-upstream-fair\n syn keyword ngxDirectiveThirdParty contained fair\n syn keyword ngxDirectiveThirdParty contained upstream_fair_shm_size\n \n-\" Nginx Video Thumb Extractor Module\n-\" https://github.com/wandenberg/nginx-video-thumbextractor-module\n+\" https://github.com/ayty-adrianomartins/nginx-sticky-module-ng\n+syn keyword ngxDirectiveThirdParty contained sticky_no_fallback\n+\n+\" https://github.com/Novetta/nginx-video-thumbextractor-module\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_image_height\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_image_width\n@@ -1329,43 +1362,14 @@ syn keyword ngxDirectiveThirdParty contained video_thumbextractor_tile_sample_in\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_video_filename\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_video_second\n \n-\" drizzle-nginx-module - Upstream module for talking to MySQL and Drizzle directly\n-\" https://github.com/openresty/drizzle-nginx-module\n-syn keyword ngxDirectiveThirdParty contained drizzle_buffer_size\n-syn keyword ngxDirectiveThirdParty contained drizzle_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_dbname\n-syn keyword ngxDirectiveThirdParty contained drizzle_keepalive\n-syn keyword ngxDirectiveThirdParty contained drizzle_module_header\n-syn keyword ngxDirectiveThirdParty contained drizzle_pass\n-syn keyword ngxDirectiveThirdParty contained drizzle_query\n-syn keyword ngxDirectiveThirdParty contained drizzle_recv_cols_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_recv_rows_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_send_query_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_server\n-syn keyword ngxDirectiveThirdParty contained drizzle_status\n-\n-\" ngx_dynamic_upstream\n-\" https://github.com/cubicdaiya/ngx_dynamic_upstream\n-syn keyword ngxDirectiveThirdParty contained dynamic_upstream\n-\n-\" encrypt and decrypt nginx variable values\n-\" https://github.com/openresty/encrypted-session-nginx-module\n-syn keyword ngxDirectiveThirdParty contained encrypted_session_expires\n-syn keyword ngxDirectiveThirdParty contained encrypted_session_iv\n-syn keyword ngxDirectiveThirdParty contained encrypted_session_key\n-syn keyword ngxDirectiveThirdParty contained set_decrypt_session\n-syn keyword ngxDirectiveThirdParty contained set_encrypt_session\n-\n-\" serve content directly from MongoDB's GridFS\n-\" https://github.com/mdirolf/nginx-gridfs\n-syn keyword ngxDirectiveThirdParty contained gridfs\n-syn keyword ngxDirectiveThirdParty contained mongo\n+\" https://github.com/calio/iconv-nginx-module\n+syn keyword ngxDirectiveThirdParty contained iconv_buffer_size\n+syn keyword ngxDirectiveThirdParty contained iconv_filter\n+syn keyword ngxDirectiveThirdParty contained set_iconv\n \n-\" Adds support for arithmetic operations to NGINX config\n-\" https://github.com/arut/nginx-let-module\n+\" https://github.com/baysao/nginx-let-module\n syn keyword ngxDirectiveThirdParty contained let\n \n-\" ngx_http_lua_module - Embed the power of Lua into Nginx HTTP Servers\n \" https://github.com/openresty/lua-nginx-module\n syn keyword ngxDirectiveThirdParty contained access_by_lua\n syn keyword ngxDirectiveThirdParty contained access_by_lua_block\n@@ -1431,6 +1435,8 @@ syn keyword ngxDirectiveThirdParty contained rewrite_by_lua\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_block\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_file\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_no_postpone\n+syn keyword ngxDirectiveThirdParty contained server_rewrite_by_lua_block\n+syn keyword ngxDirectiveThirdParty contained server_rewrite_by_lua_file\n syn keyword ngxDirectiveThirdParty contained set_by_lua\n syn keyword ngxDirectiveThirdParty contained set_by_lua_block\n syn keyword ngxDirectiveThirdParty contained set_by_lua_file\n@@ -1443,7 +1449,16 @@ syn keyword ngxDirectiveThirdParty contained ssl_session_fetch_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_session_store_by_lua_block\n syn keyword ngxDirectiveThirdParty contained ssl_session_store_by_lua_file\n \n-\" ngx_memc - An extended version of the standard memcached module\n+\" https://github.com/Taymindis/nginx-link-function\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_prop\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_req_header\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_ca_cert\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_call\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_download_link_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_shm_size\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_subrequest\n+\n \" https://github.com/openresty/memc-nginx-module\n syn keyword ngxDirectiveThirdParty contained memc_buffer_size\n syn keyword ngxDirectiveThirdParty contained memc_cmds_allowed\n@@ -1457,21 +1472,24 @@ syn keyword ngxDirectiveThirdParty contained memc_send_timeout\n syn keyword ngxDirectiveThirdParty contained memc_upstream_fail_timeout\n syn keyword ngxDirectiveThirdParty contained memc_upstream_max_fails\n \n-\" ModSecurity web application firewall\n-\" https://github.com/SpiderLabs/ModSecurity/tree/master\n-syn keyword ngxDirectiveThirdParty contained ModSecurityConfig\n-syn keyword ngxDirectiveThirdParty contained ModSecurityEnabled\n-syn keyword ngxDirectiveThirdParty contained pool_context_hash_size\n+\" https://github.com/SpiderLabs/ModSecurity-nginx\n+syn keyword ngxDirectiveThirdParty contained modsecurity\n+syn keyword ngxDirectiveThirdParty contained modsecurity_rules\n+syn keyword ngxDirectiveThirdParty contained modsecurity_rules_file\n+syn keyword ngxDirectiveThirdParty contained modsecurity_rules_remote\n+syn keyword ngxDirectiveThirdParty contained modsecurity_transaction_id\n \n-\" NAXSI is an open-source, high performance, low rules maintenance WAF for NGINX\n \" https://github.com/nbs-system/naxsi\n syn keyword ngxDirectiveThirdParty contained BasicRule\n syn keyword ngxDirectiveThirdParty contained CheckRule\n syn keyword ngxDirectiveThirdParty contained DeniedUrl\n+syn keyword ngxDirectiveThirdParty contained IgnoreCIDR\n+syn keyword ngxDirectiveThirdParty contained IgnoreIP\n syn keyword ngxDirectiveThirdParty contained LearningMode\n syn keyword ngxDirectiveThirdParty contained LibInjectionSql\n syn keyword ngxDirectiveThirdParty contained LibInjectionXss\n syn keyword ngxDirectiveThirdParty contained MainRule\n+syn keyword ngxDirectiveThirdParty contained NaxsiLogFile\n syn keyword ngxDirectiveThirdParty contained SecRulesDisabled\n syn keyword ngxDirectiveThirdParty contained SecRulesEnabled\n syn keyword ngxDirectiveThirdParty contained basic_rule\n@@ -1481,38 +1499,57 @@ syn keyword ngxDirectiveThirdParty contained learning_mode\n syn keyword ngxDirectiveThirdParty contained libinjection_sql\n syn keyword ngxDirectiveThirdParty contained libinjection_xss\n syn keyword ngxDirectiveThirdParty contained main_rule\n+syn keyword ngxDirectiveThirdParty contained naxsi_log\n syn keyword ngxDirectiveThirdParty contained rules_disabled\n syn keyword ngxDirectiveThirdParty contained rules_enabled\n \n-\" Phusion Passenger\n-\" https://www.phusionpassenger.com/library/config/nginx/reference/\n+\" https://github.com/opentracing-contrib/nginx-opentracing\n+syn keyword ngxDirectiveThirdParty contained opentracing\n+syn keyword ngxDirectiveThirdParty contained opentracing_fastcgi_propagate_context\n+syn keyword ngxDirectiveThirdParty contained opentracing_grpc_propagate_context\n+syn keyword ngxDirectiveThirdParty contained opentracing_load_tracer\n+syn keyword ngxDirectiveThirdParty contained opentracing_location_operation_name\n+syn keyword ngxDirectiveThirdParty contained opentracing_operation_name\n+syn keyword ngxDirectiveThirdParty contained opentracing_propagate_context\n+syn keyword ngxDirectiveThirdParty contained opentracing_tag\n+syn keyword ngxDirectiveThirdParty contained opentracing_trace_locations\n+syn keyword ngxDirectiveThirdParty contained opentracing_trust_incoming_span\n+\n+\" https://github.com/phusion/passenger\n syn keyword ngxDirectiveThirdParty contained passenger_abort_on_startup_error\n syn keyword ngxDirectiveThirdParty contained passenger_abort_websockets_on_process_shutdown\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_auth_type\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_password\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_url\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_username\n+syn keyword ngxDirectiveThirdParty contained passenger_analytics_log_group\n+syn keyword ngxDirectiveThirdParty contained passenger_analytics_log_user\n syn keyword ngxDirectiveThirdParty contained passenger_anonymous_telemetry_proxy\n syn keyword ngxDirectiveThirdParty contained passenger_app_env\n syn keyword ngxDirectiveThirdParty contained passenger_app_file_descriptor_ulimit\n syn keyword ngxDirectiveThirdParty contained passenger_app_group_name\n syn keyword ngxDirectiveThirdParty contained passenger_app_log_file\n syn keyword ngxDirectiveThirdParty contained passenger_app_rights\n syn keyword ngxDirectiveThirdParty contained passenger_app_root\n+syn keyword ngxDirectiveThirdParty contained passenger_app_start_command\n syn keyword ngxDirectiveThirdParty contained passenger_app_type\n syn keyword ngxDirectiveThirdParty contained passenger_base_uri\n syn keyword ngxDirectiveThirdParty contained passenger_buffer_response\n syn keyword ngxDirectiveThirdParty contained passenger_buffer_size\n+syn keyword ngxDirectiveThirdParty contained passenger_buffer_upload\n syn keyword ngxDirectiveThirdParty contained passenger_buffers\n syn keyword ngxDirectiveThirdParty contained passenger_busy_buffers_size\n syn keyword ngxDirectiveThirdParty contained passenger_concurrency_model\n syn keyword ngxDirectiveThirdParty contained passenger_core_file_descriptor_ulimit\n syn keyword ngxDirectiveThirdParty contained passenger_ctl\n syn keyword ngxDirectiveThirdParty contained passenger_data_buffer_dir\n+syn keyword ngxDirectiveThirdParty contained passenger_debug_log_file\n syn keyword ngxDirectiveThirdParty contained passenger_debugger\n syn keyword ngxDirectiveThirdParty contained passenger_default_group\n syn keyword ngxDirectiveThirdParty contained passenger_default_user\n+syn keyword ngxDirectiveThirdParty contained passenger_direct_instance_request_address\n syn keyword ngxDirectiveThirdParty contained passenger_disable_anonymous_telemetry\n+syn keyword ngxDirectiveThirdParty contained passenger_disable_log_prefix\n syn keyword ngxDirectiveThirdParty contained passenger_disable_security_update_check\n syn keyword ngxDirectiveThirdParty contained passenger_document_root\n syn keyword ngxDirectiveThirdParty contained passenger_dump_config_manifest\n@@ -1548,8 +1585,10 @@ syn keyword ngxDirectiveThirdParty contained passenger_nodejs\n syn keyword ngxDirectiveThirdParty contained passenger_pass_header\n syn keyword ngxDirectiveThirdParty contained passenger_pool_idle_time\n syn keyword ngxDirectiveThirdParty contained passenger_pre_start\n+syn keyword ngxDirectiveThirdParty contained passenger_preload_bundler\n syn keyword ngxDirectiveThirdParty contained passenger_python\n syn keyword ngxDirectiveThirdParty contained passenger_read_timeout\n+syn keyword ngxDirectiveThirdParty contained passenger_request_buffering\n syn keyword ngxDirectiveThirdParty contained passenger_request_queue_overflow_status_code\n syn keyword ngxDirectiveThirdParty contained passenger_resist_deployment_errors\n syn keyword ngxDirectiveThirdParty contained passenger_response_buffer_high_watermark\n@@ -1561,36 +1600,36 @@ syn keyword ngxDirectiveThirdParty contained passenger_security_update_check_pro\n syn keyword ngxDirectiveThirdParty contained passenger_set_header\n syn keyword ngxDirectiveThirdParty contained passenger_show_version_in_header\n syn keyword ngxDirectiveThirdParty contained passenger_socket_backlog\n+syn keyword ngxDirectiveThirdParty contained passenger_spawn_dir\n+syn keyword ngxDirectiveThirdParty contained passenger_spawn_exception_status_code\n syn keyword ngxDirectiveThirdParty contained passenger_spawn_method\n syn keyword ngxDirectiveThirdParty contained passenger_start_timeout\n syn keyword ngxDirectiveThirdParty contained passenger_startup_file\n syn keyword ngxDirectiveThirdParty contained passenger_stat_throttle_rate\n syn keyword ngxDirectiveThirdParty contained passenger_sticky_sessions\n+syn keyword ngxDirectiveThirdParty contained passenger_sticky_sessions_cookie_attributes\n syn keyword ngxDirectiveThirdParty contained passenger_sticky_sessions_cookie_name\n+syn keyword ngxDirectiveThirdParty contained passenger_temp_path\n syn keyword ngxDirectiveThirdParty contained passenger_thread_count\n syn keyword ngxDirectiveThirdParty contained passenger_turbocaching\n+syn keyword ngxDirectiveThirdParty contained passenger_use_global_queue\n syn keyword ngxDirectiveThirdParty contained passenger_user\n syn keyword ngxDirectiveThirdParty contained passenger_user_switching\n syn keyword ngxDirectiveThirdParty contained passenger_vary_turbocache_by_cookie\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_analytics_log_group\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_analytics_log_user\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_debug_log_file\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_use_global_queue\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rack_env\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_app_spawner_idle_time\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_env\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_framework_spawner_idle_time\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_spawn_method\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_filter\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_gateway_address\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_gateway_cert\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_gateway_port\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_key\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_proxy_address\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_support\n-\n-\" ngx_postgres is an upstream module that allows nginx to communicate directly with PostgreSQL database\n-\" https://github.com/FRiCKLE/ngx_postgres\n+syn keyword ngxDirectiveThirdParty contained rack_env\n+syn keyword ngxDirectiveThirdParty contained rails_app_spawner_idle_time\n+syn keyword ngxDirectiveThirdParty contained rails_env\n+syn keyword ngxDirectiveThirdParty contained rails_framework_spawner_idle_time\n+syn keyword ngxDirectiveThirdParty contained rails_spawn_method\n+syn keyword ngxDirectiveThirdParty contained union_station_filter\n+syn keyword ngxDirectiveThirdParty contained union_station_gateway_address\n+syn keyword ngxDirectiveThirdParty contained union_station_gateway_cert\n+syn keyword ngxDirectiveThirdParty contained union_station_gateway_port\n+syn keyword ngxDirectiveThirdParty contained union_station_key\n+syn keyword ngxDirectiveThirdParty contained union_station_proxy_address\n+syn keyword ngxDirectiveThirdParty contained union_station_support\n+\n+\" https://github.com/konstruxi/ngx_postgres\n syn keyword ngxDirectiveThirdParty contained postgres_connect_timeout\n syn keyword ngxDirectiveThirdParty contained postgres_escape\n syn keyword ngxDirectiveThirdParty contained postgres_keepalive\n@@ -1602,7 +1641,6 @@ syn keyword ngxDirectiveThirdParty contained postgres_rewrite\n syn keyword ngxDirectiveThirdParty contained postgres_server\n syn keyword ngxDirectiveThirdParty contained postgres_set\n \n-\" ngx_rds_csv - Nginx output filter module to convert Resty-DBD-Streams (RDS) to Comma-Separated Values (CSV)\n \" https://github.com/openresty/rds-csv-nginx-module\n syn keyword ngxDirectiveThirdParty contained rds_csv\n syn keyword ngxDirectiveThirdParty contained rds_csv_buffer_size\n@@ -1611,7 +1649,6 @@ syn keyword ngxDirectiveThirdParty contained rds_csv_field_name_header\n syn keyword ngxDirectiveThirdParty contained rds_csv_field_separator\n syn keyword ngxDirectiveThirdParty contained rds_csv_row_terminator\n \n-\" ngx_rds_json - an output filter that formats Resty DBD Streams generated by ngx_drizzle and others to JSON\n \" https://github.com/openresty/rds-json-nginx-module\n syn keyword ngxDirectiveThirdParty contained rds_json\n syn keyword ngxDirectiveThirdParty contained rds_json_buffer_size\n@@ -1624,7 +1661,6 @@ syn keyword ngxDirectiveThirdParty contained rds_json_root\n syn keyword ngxDirectiveThirdParty contained rds_json_success_property\n syn keyword ngxDirectiveThirdParty contained rds_json_user_property\n \n-\" ngx_redis2 - Nginx upstream module for the Redis 2.0 protocol\n \" https://github.com/openresty/redis2-nginx-module\n syn keyword ngxDirectiveThirdParty contained redis2_bind\n syn keyword ngxDirectiveThirdParty contained redis2_buffer_size\n@@ -1638,7 +1674,6 @@ syn keyword ngxDirectiveThirdParty contained redis2_raw_query\n syn keyword ngxDirectiveThirdParty contained redis2_read_timeout\n syn keyword ngxDirectiveThirdParty contained redis2_send_timeout\n \n-\" NGINX-based Media Streaming Server\n \" https://github.com/arut/nginx-rtmp-module\n syn keyword ngxDirectiveThirdParty contained ack_window\n syn keyword ngxDirectiveThirdParty contained application\n@@ -1750,7 +1785,6 @@ syn keyword ngxDirectiveThirdParty contained sync\n syn keyword ngxDirectiveThirdParty contained wait_key\n syn keyword ngxDirectiveThirdParty contained wait_video\n \n-\" ngx_set_misc - Various set_xxx directives added to nginx's rewrite module (md5/sha1, sql/json quoting, and many more)\n \" https://github.com/openresty/set-misc-nginx-module\n syn keyword ngxDirectiveThirdParty contained set_base32_alphabet\n syn keyword ngxDirectiveThirdParty contained set_base32_padding\n@@ -1770,6 +1804,7 @@ syn keyword ngxDirectiveThirdParty contained set_hmac_sha1\n syn keyword ngxDirectiveThirdParty contained set_hmac_sha256\n syn keyword ngxDirectiveThirdParty contained set_if_empty\n syn keyword ngxDirectiveThirdParty contained set_local_today\n+syn keyword ngxDirectiveThirdParty contained set_md5\n syn keyword ngxDirectiveThirdParty contained set_misc_base32_padding\n syn keyword ngxDirectiveThirdParty contained set_quote_json_str\n syn keyword ngxDirectiveThirdParty contained set_quote_pgsql_str\n@@ -1778,20 +1813,18 @@ syn keyword ngxDirectiveThirdParty contained set_random\n syn keyword ngxDirectiveThirdParty contained set_rotate\n syn keyword ngxDirectiveThirdParty contained set_secure_random_alphanum\n syn keyword ngxDirectiveThirdParty contained set_secure_random_lcalpha\n+syn keyword ngxDirectiveThirdParty contained set_sha1\n syn keyword ngxDirectiveThirdParty contained set_unescape_uri\n \n-\" nginx-sflow-module\n \" https://github.com/sflow/nginx-sflow-module\n syn keyword ngxDirectiveThirdParty contained sflow\n \n-\" Shibboleth auth request module for Nginx\n \" https://github.com/nginx-shib/nginx-http-shibboleth\n syn keyword ngxDirectiveThirdParty contained shib_request\n syn keyword ngxDirectiveThirdParty contained shib_request_set\n syn keyword ngxDirectiveThirdParty contained shib_request_use_headers\n \n-\" nginx module which adds ability to cache static files\n-\" https://github.com/FRiCKLE/ngx_slowfs_cache\n+\" https://github.com/baysao/ngx_slowfs_cache\n syn keyword ngxDirectiveThirdParty contained slowfs_big_file_size\n syn keyword ngxDirectiveThirdParty contained slowfs_cache\n syn keyword ngxDirectiveThirdParty contained slowfs_cache_key\n@@ -1801,8 +1834,7 @@ syn keyword ngxDirectiveThirdParty contained slowfs_cache_purge\n syn keyword ngxDirectiveThirdParty contained slowfs_cache_valid\n syn keyword ngxDirectiveThirdParty contained slowfs_temp_path\n \n-\" Dynamic Image Transformation Module For nginx\n-\" https://github.com/cubicdaiya/ngx_small_light\n+\" https://github.com/kawakibi/ngx_small_light\n syn keyword ngxDirectiveThirdParty contained small_light\n syn keyword ngxDirectiveThirdParty contained small_light_buffer\n syn keyword ngxDirectiveThirdParty contained small_light_getparam_mode\n@@ -1812,7 +1844,6 @@ syn keyword ngxDirectiveThirdParty contained small_light_pattern_define\n syn keyword ngxDirectiveThirdParty contained small_light_radius_max\n syn keyword ngxDirectiveThirdParty contained small_light_sigma_max\n \n-\" ngx_srcache - Transparent subrequest-based caching layout for arbitrary nginx locations\n \" https://github.com/openresty/srcache-nginx-module\n syn keyword ngxDirectiveThirdParty contained srcache_buffer\n syn keyword ngxDirectiveThirdParty contained srcache_default_expire\n@@ -1835,7 +1866,6 @@ syn keyword ngxDirectiveThirdParty contained srcache_store_ranges\n syn keyword ngxDirectiveThirdParty contained srcache_store_skip\n syn keyword ngxDirectiveThirdParty contained srcache_store_statuses\n \n-\" NGINX-based VOD Packager\n \" https://github.com/kaltura/nginx-vod-module\n syn keyword ngxDirectiveThirdParty contained vod\n syn keyword ngxDirectiveThirdParty contained vod_align_segments_to_key_frames\n@@ -1875,6 +1905,7 @@ syn keyword ngxDirectiveThirdParty contained vod_live_window_duration\n syn keyword ngxDirectiveThirdParty contained vod_manifest_duration_policy\n syn keyword ngxDirectiveThirdParty contained vod_manifest_segment_durations_mode\n syn keyword ngxDirectiveThirdParty contained vod_mapping_cache\n+syn keyword ngxDirectiveThirdParty contained vod_max_frame_count\n syn keyword ngxDirectiveThirdParty contained vod_max_frames_size\n syn keyword ngxDirectiveThirdParty contained vod_max_mapping_response_size\n syn keyword ngxDirectiveThirdParty contained vod_max_metadata_size\n@@ -1901,6 +1932,7 @@ syn keyword ngxDirectiveThirdParty contained vod_response_cache\n syn keyword ngxDirectiveThirdParty contained vod_secret_key\n syn keyword ngxDirectiveThirdParty contained vod_segment_count_policy\n syn keyword ngxDirectiveThirdParty contained vod_segment_duration\n+syn keyword ngxDirectiveThirdParty contained vod_segment_max_frame_count\n syn keyword ngxDirectiveThirdParty contained vod_segments_base_url\n syn keyword ngxDirectiveThirdParty contained vod_source_clip_map_uri\n syn keyword ngxDirectiveThirdParty contained vod_speed_param_name\n@@ -1910,7 +1942,6 @@ syn keyword ngxDirectiveThirdParty contained vod_tracks_param_name\n syn keyword ngxDirectiveThirdParty contained vod_upstream_extra_args\n syn keyword ngxDirectiveThirdParty contained vod_upstream_location\n \n-\" Nginx virtual host traffic status module\n \" https://github.com/vozlt/nginx-module-vts\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_average_method\n@@ -1934,7 +1965,6 @@ syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_limit_traffic_\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_set_by_filter\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_zone\n \n-\" xss-nginx-module - Native cross-site scripting support in nginx\n \" https://github.com/openresty/xss-nginx-module\n syn keyword ngxDirectiveThirdParty contained xss_callback_arg\n syn keyword ngxDirectiveThirdParty contained xss_check_status\n@@ -1943,527 +1973,13 @@ syn keyword ngxDirectiveThirdParty contained xss_input_types\n syn keyword ngxDirectiveThirdParty contained xss_output_type\n syn keyword ngxDirectiveThirdParty contained xss_override_status\n \n-\" Add support for array-typed variables to nginx config files\n-\" https://github.com/openresty/array-var-nginx-module\n-syn keyword ngxDirectiveThirdParty contained array_join\n-syn keyword ngxDirectiveThirdParty contained array_map\n-syn keyword ngxDirectiveThirdParty contained array_map_op\n-syn keyword ngxDirectiveThirdParty contained array_split\n-\n-\" NGINX module for Brotli compression\n-\" https://github.com/eustas/ngx_brotli\n-syn keyword ngxDirectiveThirdParty contained brotli\n-syn keyword ngxDirectiveThirdParty contained brotli_buffers\n-syn keyword ngxDirectiveThirdParty contained brotli_comp_level\n-syn keyword ngxDirectiveThirdParty contained brotli_min_length\n-syn keyword ngxDirectiveThirdParty contained brotli_static\n-syn keyword ngxDirectiveThirdParty contained brotli_types\n-syn keyword ngxDirectiveThirdParty contained brotli_window\n-\n-\" form-input-nginx-module\n-\" https://github.com/calio/form-input-nginx-module\n-syn keyword ngxDirectiveThirdParty contained set_form_input\n-syn keyword ngxDirectiveThirdParty contained set_form_input_multi\n-\n-\" character conversion nginx module using libiconv\n-\" https://github.com/calio/iconv-nginx-module\n-syn keyword ngxDirectiveThirdParty contained iconv_buffer_size\n-syn keyword ngxDirectiveThirdParty contained iconv_filter\n-syn keyword ngxDirectiveThirdParty contained set_iconv\n-\n-\" 3rd party modules list taken from\n-\" https://www.nginx.com/resources/wiki/modules/\n-\" ---------------------------------------------\n-\n-\" Nginx Module for Authenticating Akamai G2O requests\n-\" https://github.com/kaltura/nginx_mod_akamai_g2o\n-syn keyword ngxDirectiveThirdParty contained g2o\n-syn keyword ngxDirectiveThirdParty contained g2o_data_header\n-syn keyword ngxDirectiveThirdParty contained g2o_hash_function\n-syn keyword ngxDirectiveThirdParty contained g2o_key\n-syn keyword ngxDirectiveThirdParty contained g2o_log_level\n-syn keyword ngxDirectiveThirdParty contained g2o_nonce\n-syn keyword ngxDirectiveThirdParty contained g2o_sign_header\n-syn keyword ngxDirectiveThirdParty contained g2o_time_window\n-syn keyword ngxDirectiveThirdParty contained g2o_version\n-\n-\" nginx_lua_module\n-\" https://github.com/alacner/nginx_lua_module\n-syn keyword ngxDirectiveThirdParty contained lua_file\n-\n-\" Nginx Audio Track for HTTP Live Streaming\n-\" https://github.com/flavioribeiro/nginx-audio-track-for-hls-module\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track_output_format\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track_output_header\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track_rootpath\n-\n-\" A Nginx module to dump backtrace when a worker process exits abnormally\n-\" https://github.com/alibaba/nginx-backtrace\n-syn keyword ngxDirectiveThirdParty contained backtrace_log\n-syn keyword ngxDirectiveThirdParty contained backtrace_max_stack_size\n-\n-\" circle_gif module\n-\" https://github.com/evanmiller/nginx_circle_gif\n-syn keyword ngxDirectiveThirdParty contained circle_gif\n-syn keyword ngxDirectiveThirdParty contained circle_gif_max_radius\n-syn keyword ngxDirectiveThirdParty contained circle_gif_min_radius\n-syn keyword ngxDirectiveThirdParty contained circle_gif_step_radius\n-\n-\" Upstream Consistent Hash\n-\" https://github.com/replay/ngx_http_consistent_hash\n-syn keyword ngxDirectiveThirdParty contained consistent_hash\n-\n-\" Nginx module for etags on dynamic content\n-\" https://github.com/kali/nginx-dynamic-etags\n-syn keyword ngxDirectiveThirdParty contained dynamic_etags\n-\n-\" Enhanced Nginx Memcached Module\n-\" https://github.com/bpaquet/ngx_http_enhanced_memcached_module\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_allow_delete\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_allow_put\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_bind\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_buffer_size\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_flush\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_flush_namespace\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_hash_keys_with_md5\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_pass\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_read_timeout\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_send_timeout\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_stats\n-\n-\" nginx max connections queue\n-\" https://github.com/ezmobius/nginx-ey-balancer\n-syn keyword ngxDirectiveThirdParty contained max_connections_max_queue_length\n-syn keyword ngxDirectiveThirdParty contained max_connections_queue_timeout\n-\n-\" Nginx module for POST authentication and authorization\n-\" https://github.com/veruu/ngx_form_auth\n-syn keyword ngxDirectiveThirdParty contained form_auth\n-syn keyword ngxDirectiveThirdParty contained form_auth_login\n-syn keyword ngxDirectiveThirdParty contained form_auth_pam_service\n-syn keyword ngxDirectiveThirdParty contained form_auth_password\n-syn keyword ngxDirectiveThirdParty contained form_auth_remote_user\n-\n-\" ngx_http_accounting_module\n-\" https://github.com/Lax/ngx_http_accounting_module\n-syn keyword ngxDirectiveThirdParty contained accounting\n-syn keyword ngxDirectiveThirdParty contained accounting_id\n-syn keyword ngxDirectiveThirdParty contained accounting_interval\n-syn keyword ngxDirectiveThirdParty contained accounting_log\n-syn keyword ngxDirectiveThirdParty contained accounting_perturb\n-\n-\" concatenating files in a given context: CSS and JS files usually\n-\" https://github.com/alibaba/nginx-http-concat\n-syn keyword ngxDirectiveThirdParty contained concat\n-syn keyword ngxDirectiveThirdParty contained concat_delimiter\n-syn keyword ngxDirectiveThirdParty contained concat_ignore_file_error\n-syn keyword ngxDirectiveThirdParty contained concat_max_files\n-syn keyword ngxDirectiveThirdParty contained concat_types\n-syn keyword ngxDirectiveThirdParty contained concat_unique\n-\n-\" update upstreams' config by restful interface\n-\" https://github.com/yzprofile/ngx_http_dyups_module\n-syn keyword ngxDirectiveThirdParty contained dyups_interface\n-syn keyword ngxDirectiveThirdParty contained dyups_shm_zone_size\n-\n-\" add given content to the end of the response according to the condition specified\n-\" https://github.com/flygoast/ngx_http_footer_if_filter\n-syn keyword ngxDirectiveThirdParty contained footer_if\n-\n-\" NGINX HTTP Internal Redirect Module\n-\" https://github.com/flygoast/ngx_http_internal_redirect\n-syn keyword ngxDirectiveThirdParty contained internal_redirect_if\n-syn keyword ngxDirectiveThirdParty contained internal_redirect_if_no_postpone\n-\n-\" nginx-ip-blocker\n-\" https://github.com/tmthrgd/nginx-ip-blocker\n-syn keyword ngxDirectiveThirdParty contained ip_blocker\n-\n-\" IP2Location Nginx\n-\" https://github.com/chrislim2888/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_database\n-\n-\" Limit upload rate\n-\" https://github.com/cfsego/limit_upload_rate\n-syn keyword ngxDirectiveThirdParty contained limit_upload_rate\n-syn keyword ngxDirectiveThirdParty contained limit_upload_rate_after\n-syn keyword ngxDirectiveThirdParty contained limit_upload_rate_log_level\n-\n-\" limit the number of connections to upstream\n-\" https://github.com/cfsego/nginx-limit-upstream\n-syn keyword ngxDirectiveThirdParty contained limit_upstream_conn\n-syn keyword ngxDirectiveThirdParty contained limit_upstream_log_level\n-syn keyword ngxDirectiveThirdParty contained limit_upstream_zone\n-\n-\" conditional accesslog for nginx\n-\" https://github.com/cfsego/ngx_log_if\n-syn keyword ngxDirectiveThirdParty contained access_log_bypass_if\n-\n-\" log messages over ZeroMQ\n-\" https://github.com/alticelabs/nginx-log-zmq\n-syn keyword ngxDirectiveThirdParty contained log_zmq_endpoint\n-syn keyword ngxDirectiveThirdParty contained log_zmq_format\n-syn keyword ngxDirectiveThirdParty contained log_zmq_off\n-syn keyword ngxDirectiveThirdParty contained log_zmq_server\n-\n-\" simple module to uppercase/lowercase strings in the nginx config\n-\" https://github.com/replay/ngx_http_lower_upper_case\n-syn keyword ngxDirectiveThirdParty contained lower\n-syn keyword ngxDirectiveThirdParty contained upper\n-\n-\" content filter for nginx, which returns the md5 hash of the content otherwise returned\n-\" https://github.com/kainswor/nginx_md5_filter\n-syn keyword ngxDirectiveThirdParty contained md5_filter\n-\n-\" Non-blocking upstream module for Nginx to connect to MongoDB\n-\" https://github.com/simpl/ngx_mongo\n-syn keyword ngxDirectiveThirdParty contained mongo_auth\n-syn keyword ngxDirectiveThirdParty contained mongo_bind\n-syn keyword ngxDirectiveThirdParty contained mongo_buffer_size\n-syn keyword ngxDirectiveThirdParty contained mongo_buffering\n-syn keyword ngxDirectiveThirdParty contained mongo_buffers\n-syn keyword ngxDirectiveThirdParty contained mongo_busy_buffers_size\n-syn keyword ngxDirectiveThirdParty contained mongo_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained mongo_json\n-syn keyword ngxDirectiveThirdParty contained mongo_next_upstream\n-syn keyword ngxDirectiveThirdParty contained mongo_pass\n-syn keyword ngxDirectiveThirdParty contained mongo_query\n-syn keyword ngxDirectiveThirdParty contained mongo_read_timeout\n-syn keyword ngxDirectiveThirdParty contained mongo_send_timeout\n-\n-\" Nginx OCSP processing module designed for response caching\n-\" https://github.com/kyprizel/nginx_ocsp_proxy-module\n-syn keyword ngxDirectiveThirdParty contained ocsp_cache_timeout\n-syn keyword ngxDirectiveThirdParty contained ocsp_proxy\n-\n-\" Nginx OpenSSL version check at startup\n-\" https://github.com/apcera/nginx-openssl-version\n-syn keyword ngxDirectiveThirdParty contained openssl_builddate_minimum\n-syn keyword ngxDirectiveThirdParty contained openssl_version_minimum\n-\n-\" Automatic PageSpeed optimization module for Nginx\n-\" https://github.com/pagespeed/ngx_pagespeed\n-syn keyword ngxDirectiveThirdParty contained pagespeed\n-\n-\" PECL Memcache standard hashing compatible loadbalancer for Nginx\n-\" https://github.com/replay/ngx_http_php_memcache_standard_balancer\n-syn keyword ngxDirectiveThirdParty contained hash_key\n-\n-\" nginx module to parse php sessions\n-\" https://github.com/replay/ngx_http_php_session\n-syn keyword ngxDirectiveThirdParty contained php_session_parse\n-syn keyword ngxDirectiveThirdParty contained php_session_strip_formatting\n-\n-\" Nginx HTTP rDNS module\n-\" https://github.com/flant/nginx-http-rdns\n-syn keyword ngxDirectiveThirdParty contained rdns\n-syn keyword ngxDirectiveThirdParty contained rdns_allow\n-syn keyword ngxDirectiveThirdParty contained rdns_deny\n-\n-\" Streaming regular expression replacement in response bodies\n-\" https://github.com/openresty/replace-filter-nginx-module\n-syn keyword ngxDirectiveThirdParty contained replace_filter\n-syn keyword ngxDirectiveThirdParty contained replace_filter_last_modified\n-syn keyword ngxDirectiveThirdParty contained replace_filter_max_buffered_size\n-syn keyword ngxDirectiveThirdParty contained replace_filter_skip\n-syn keyword ngxDirectiveThirdParty contained replace_filter_types\n-\n-\" Link RRDtool's graphing facilities directly into nginx\n-\" https://github.com/evanmiller/mod_rrd_graph\n-syn keyword ngxDirectiveThirdParty contained rrd_graph\n-syn keyword ngxDirectiveThirdParty contained rrd_graph_root\n-\n-\" Module for nginx to proxy rtmp using http protocol\n-\" https://github.com/kwojtek/nginx-rtmpt-proxy-module\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_http_timeout\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_rtmp_timeout\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_stat\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_stylesheet\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_target\n-\n-\" Syntactically Awesome NGINX Module\n-\" https://github.com/mneudert/sass-nginx-module\n-syn keyword ngxDirectiveThirdParty contained sass_compile\n-syn keyword ngxDirectiveThirdParty contained sass_error_log\n-syn keyword ngxDirectiveThirdParty contained sass_include_path\n-syn keyword ngxDirectiveThirdParty contained sass_indent\n-syn keyword ngxDirectiveThirdParty contained sass_is_indented_syntax\n-syn keyword ngxDirectiveThirdParty contained sass_linefeed\n-syn keyword ngxDirectiveThirdParty contained sass_output_style\n-syn keyword ngxDirectiveThirdParty contained sass_precision\n-syn keyword ngxDirectiveThirdParty contained sass_source_comments\n-syn keyword ngxDirectiveThirdParty contained sass_source_map_embed\n-\n-\" Nginx Selective Cache Purge Module\n-\" https://github.com/wandenberg/nginx-selective-cache-purge-module\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_query\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_database\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_host\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_password\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_port\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_unix_socket\n-\n-\" cconv nginx module\n-\" https://github.com/liseen/set-cconv-nginx-module\n-syn keyword ngxDirectiveThirdParty contained set_cconv_to_simp\n-syn keyword ngxDirectiveThirdParty contained set_cconv_to_trad\n-syn keyword ngxDirectiveThirdParty contained set_pinyin_to_normal\n-\n-\" Nginx module that allows the setting of variables to the value of a variety of hashes\n-\" https://github.com/simpl/ngx_http_set_hash\n-syn keyword ngxDirectiveThirdParty contained set_md5\n-syn keyword ngxDirectiveThirdParty contained set_md5_upper\n-syn keyword ngxDirectiveThirdParty contained set_murmur2\n-syn keyword ngxDirectiveThirdParty contained set_murmur2_upper\n-syn keyword ngxDirectiveThirdParty contained set_sha1\n-syn keyword ngxDirectiveThirdParty contained set_sha1_upper\n-\n-\" Nginx module to set the language of a request based on a number of options\n-\" https://github.com/simpl/ngx_http_set_lang\n-syn keyword ngxDirectiveThirdParty contained lang_cookie\n-syn keyword ngxDirectiveThirdParty contained lang_get_var\n-syn keyword ngxDirectiveThirdParty contained lang_host\n-syn keyword ngxDirectiveThirdParty contained lang_list\n-syn keyword ngxDirectiveThirdParty contained lang_post_var\n-syn keyword ngxDirectiveThirdParty contained lang_referer\n-syn keyword ngxDirectiveThirdParty contained set_lang\n-syn keyword ngxDirectiveThirdParty contained set_lang_method\n-\n-\" Nginx Sorted Querystring Module\n-\" https://github.com/wandenberg/nginx-sorted-querystring-module\n-syn keyword ngxDirectiveThirdParty contained sorted_querysting_filter_parameter\n-\n-\" Nginx upstream module for Sphinx 2.x search daemon\n-\" https://github.com/reeteshranjan/sphinx2-nginx-module\n-syn keyword ngxDirectiveThirdParty contained sphinx2_bind\n-syn keyword ngxDirectiveThirdParty contained sphinx2_buffer_size\n-syn keyword ngxDirectiveThirdParty contained sphinx2_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained sphinx2_next_upstream\n-syn keyword ngxDirectiveThirdParty contained sphinx2_pass\n-syn keyword ngxDirectiveThirdParty contained sphinx2_read_timeout\n-syn keyword ngxDirectiveThirdParty contained sphinx2_send_timeout\n-\n-\" Nginx module for retrieving user attributes and groups from SSSD\n-\" https://github.com/veruu/ngx_sssd_info\n-syn keyword ngxDirectiveThirdParty contained sssd_info\n-syn keyword ngxDirectiveThirdParty contained sssd_info_attribute\n-syn keyword ngxDirectiveThirdParty contained sssd_info_attribute_separator\n-syn keyword ngxDirectiveThirdParty contained sssd_info_attributes\n-syn keyword ngxDirectiveThirdParty contained sssd_info_group\n-syn keyword ngxDirectiveThirdParty contained sssd_info_group_separator\n-syn keyword ngxDirectiveThirdParty contained sssd_info_groups\n-syn keyword ngxDirectiveThirdParty contained sssd_info_output_to\n-\n-\" An nginx module for sending statistics to statsd\n-\" https://github.com/zebrafishlabs/nginx-statsd\n-syn keyword ngxDirectiveThirdParty contained statsd_count\n-syn keyword ngxDirectiveThirdParty contained statsd_sample_rate\n-syn keyword ngxDirectiveThirdParty contained statsd_server\n-syn keyword ngxDirectiveThirdParty contained statsd_timing\n-\n-\" ngx_stream_echo - TCP/stream echo module for NGINX (a port of the ngx_http_echo module)\n-\" https://github.com/openresty/stream-echo-nginx-module\n-syn keyword ngxDirectiveThirdParty contained echo\n-syn keyword ngxDirectiveThirdParty contained echo_client_error_log_level\n-syn keyword ngxDirectiveThirdParty contained echo_discard_request\n-syn keyword ngxDirectiveThirdParty contained echo_duplicate\n-syn keyword ngxDirectiveThirdParty contained echo_flush_wait\n-syn keyword ngxDirectiveThirdParty contained echo_lingering_close\n-syn keyword ngxDirectiveThirdParty contained echo_lingering_time\n-syn keyword ngxDirectiveThirdParty contained echo_lingering_timeout\n-syn keyword ngxDirectiveThirdParty contained echo_read_buffer_size\n-syn keyword ngxDirectiveThirdParty contained echo_read_bytes\n-syn keyword ngxDirectiveThirdParty contained echo_read_line\n-syn keyword ngxDirectiveThirdParty contained echo_read_timeout\n-syn keyword ngxDirectiveThirdParty contained echo_request_data\n-syn keyword ngxDirectiveThirdParty contained echo_send_timeout\n-syn keyword ngxDirectiveThirdParty contained echo_sleep\n-\n-\" Embed the power of Lua into NGINX TCP/UDP servers\n-\" https://github.com/openresty/stream-lua-nginx-module\n-syn keyword ngxDirectiveThirdParty contained lua_add_variable\n-syn keyword ngxDirectiveThirdParty contained preread_by_lua_block\n-syn keyword ngxDirectiveThirdParty contained preread_by_lua_file\n-syn keyword ngxDirectiveThirdParty contained preread_by_lua_no_postpone\n-\n-\" nginx-upsync-module\n-\" https://github.com/weibocom/nginx-upsync-module\n-syn keyword ngxDirectiveThirdParty contained upstream_show\n-syn keyword ngxDirectiveThirdParty contained upsync\n-syn keyword ngxDirectiveThirdParty contained upsync_dump_path\n-syn keyword ngxDirectiveThirdParty contained upsync_lb\n-\n-\" Whitespace stripper for nginx\n-\" https://github.com/evanmiller/mod_strip\n-syn keyword ngxDirectiveThirdParty contained strip\n-\n-\" Split one big HTTP/Range request to multiple subrange requesets\n-\" https://github.com/Qihoo360/ngx_http_subrange_module\n-syn keyword ngxDirectiveThirdParty contained subrange\n-\n-\" summarizer-nginx-module\n-\" https://github.com/reeteshranjan/summarizer-nginx-module\n-syn keyword ngxDirectiveThirdParty contained summarizer_bind\n-syn keyword ngxDirectiveThirdParty contained summarizer_buffer_size\n-syn keyword ngxDirectiveThirdParty contained summarizer_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained summarizer_next_upstream\n-syn keyword ngxDirectiveThirdParty contained summarizer_pass\n-syn keyword ngxDirectiveThirdParty contained summarizer_read_timeout\n-syn keyword ngxDirectiveThirdParty contained summarizer_send_timeout\n-\n-\" nginx module providing API to communicate with supervisord and manage (start/stop) backends on-demand\n-\" https://github.com/FRiCKLE/ngx_supervisord\n-syn keyword ngxDirectiveThirdParty contained supervisord\n-syn keyword ngxDirectiveThirdParty contained supervisord_inherit_backend_status\n-syn keyword ngxDirectiveThirdParty contained supervisord_name\n-syn keyword ngxDirectiveThirdParty contained supervisord_start\n-syn keyword ngxDirectiveThirdParty contained supervisord_stop\n-\n-\" simple robot mitigation module using cookie based challenge/response technique. Not supported any more.\n-\" https://github.com/kyprizel/testcookie-nginx-module\n-syn keyword ngxDirectiveThirdParty contained testcookie\n-syn keyword ngxDirectiveThirdParty contained testcookie_arg\n-syn keyword ngxDirectiveThirdParty contained testcookie_deny_keepalive\n-syn keyword ngxDirectiveThirdParty contained testcookie_domain\n-syn keyword ngxDirectiveThirdParty contained testcookie_expires\n-syn keyword ngxDirectiveThirdParty contained testcookie_fallback\n-syn keyword ngxDirectiveThirdParty contained testcookie_get_only\n-syn keyword ngxDirectiveThirdParty contained testcookie_httponly_flag\n-syn keyword ngxDirectiveThirdParty contained testcookie_https_location\n-syn keyword ngxDirectiveThirdParty contained testcookie_internal\n-syn keyword ngxDirectiveThirdParty contained testcookie_max_attempts\n-syn keyword ngxDirectiveThirdParty contained testcookie_name\n-syn keyword ngxDirectiveThirdParty contained testcookie_p3p\n-syn keyword ngxDirectiveThirdParty contained testcookie_pass\n-syn keyword ngxDirectiveThirdParty contained testcookie_path\n-syn keyword ngxDirectiveThirdParty contained testcookie_port_in_redirect\n-syn keyword ngxDirectiveThirdParty contained testcookie_redirect_via_refresh\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_iv\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_key\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_status\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_template\n-syn keyword ngxDirectiveThirdParty contained testcookie_samesite\n-syn keyword ngxDirectiveThirdParty contained testcookie_secret\n-syn keyword ngxDirectiveThirdParty contained testcookie_secure_flag\n-syn keyword ngxDirectiveThirdParty contained testcookie_session\n-syn keyword ngxDirectiveThirdParty contained testcookie_whitelist\n-\n-\" ngx_http_types_filter_module\n-\" https://github.com/flygoast/ngx_http_types_filter\n-syn keyword ngxDirectiveThirdParty contained types_filter\n-syn keyword ngxDirectiveThirdParty contained types_filter_use_default\n-\n-\" A module allowing the nginx to use files embedded in a zip file\n-\" https://github.com/youzee/nginx-unzip-module\n-syn keyword ngxDirectiveThirdParty contained file_in_unzip\n-syn keyword ngxDirectiveThirdParty contained file_in_unzip_archivefile\n-syn keyword ngxDirectiveThirdParty contained file_in_unzip_extract\n-\n-\" An asynchronous domain name resolve module for nginx upstream\n-\" https://github.com/wdaike/ngx_upstream_jdomain\n-syn keyword ngxDirectiveThirdParty contained jdomain\n-\n-\" Nginx url encoding converting module\n-\" https://github.com/vozlt/nginx-module-url\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_alloc_size\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_alloc_size_x\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_from\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_phase\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_to\n-\n-\" A nginx module to match browsers and crawlers\n-\" https://github.com/alibaba/nginx-http-user-agent\n-syn keyword ngxDirectiveThirdParty contained user_agent\n-\n-\" nginx load-balancer module implementing ketama consistent hashing\n-\" https://github.com/flygoast/ngx_http_upstream_ketama_chash\n-syn keyword ngxDirectiveThirdParty contained ketama_chash\n-\n-\" nginx-sticky-module-ng\n-\" https://github.com/ayty-adrianomartins/nginx-sticky-module-ng\n-syn keyword ngxDirectiveThirdParty contained sticky_no_fallback\n-\n-\" dynamic linking and call the function of your application\n-\" https://github.com/Taymindis/nginx-link-function\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_prop\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_req_header\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_ca_cert\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_call\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_download_link_lib\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_lib\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_shm_size\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_subrequest\n-\n-\" purge content from FastCGI, proxy, SCGI and uWSGI caches\n-\" https://github.com/torden/ngx_cache_purge\n-syn keyword ngxDirectiveThirdParty contained cache_purge_response_type\n-\n-\" set the flags \"HttpOnly\", \"secure\" and \"SameSite\" for cookies\n-\" https://github.com/AirisX/nginx_cookie_flag_module\n-syn keyword ngxDirectiveThirdParty contained set_cookie_flag\n-\n-\" Embed websockify into Nginx (convert any tcp connection into websocket)\n \" https://github.com/tg123/websockify-nginx-module\n syn keyword ngxDirectiveThirdParty contained websockify_buffer_size\n syn keyword ngxDirectiveThirdParty contained websockify_connect_timeout\n syn keyword ngxDirectiveThirdParty contained websockify_pass\n syn keyword ngxDirectiveThirdParty contained websockify_read_timeout\n syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n-\" IP2Location Nginx\n-\" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_addresstype\n-syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n-syn keyword ngxDirectiveThirdParty contained ip2location_category\n-syn keyword ngxDirectiveThirdParty contained ip2location_city\n-syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n-syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n-syn keyword ngxDirectiveThirdParty contained ip2location_domain\n-syn keyword ngxDirectiveThirdParty contained ip2location_elevation\n-syn keyword ngxDirectiveThirdParty contained ip2location_iddcode\n-syn keyword ngxDirectiveThirdParty contained ip2location_isp\n-syn keyword ngxDirectiveThirdParty contained ip2location_latitude\n-syn keyword ngxDirectiveThirdParty contained ip2location_longitude\n-syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n-syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n-syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n-syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n-syn keyword ngxDirectiveThirdParty contained ip2location_region\n-syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n-syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n-syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationcode\n-syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationname\n-syn keyword ngxDirectiveThirdParty contained ip2location_zipcode\n-\n-\" IP2Proxy module for Nginx\n-\" https://github.com/ip2location/ip2proxy-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_as\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_asn\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_city\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_country_long\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_country_short\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_provider\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_region\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_threat\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n-\n-\n-\n \" highlight\n \n hi def link ngxComment Comment\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1o\n+OPENSSL =\topenssl-1.1.1p\n ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \n@@ -15,12 +15,6 @@ release: export\n \n \tmv $(TEMP)/$(NGINX)/auto/configure $(TEMP)/$(NGINX)\n \n-\t# delete incomplete sources\n-\trm $(TEMP)/$(NGINX)/src/event/ngx_event_acceptex.c\n-\trm $(TEMP)/$(NGINX)/src/event/ngx_event_connectex.c\n-\trm $(TEMP)/$(NGINX)/src/event/modules/ngx_iocp_module.*\n-\trm -r $(TEMP)/$(NGINX)/src/os/win32\n-\n \tmv $(TEMP)/$(NGINX)/docs/text/LICENSE $(TEMP)/$(NGINX)\n \tmv $(TEMP)/$(NGINX)/docs/text/README $(TEMP)/$(NGINX)\n \tmv $(TEMP)/$(NGINX)/docs/html $(TEMP)/$(NGINX)\nDiff:\n@@ -269,8 +269,7 @@ header_in(r, key)\n     u_char                     *p, *lowcase_key, *value, sep;\n     STRLEN                      len;\n     ssize_t                     size;\n-    ngx_uint_t                  i, n, hash;\n-    ngx_array_t                *a;\n+    ngx_uint_t                  i, hash;\n     ngx_list_part_t            *part;\n     ngx_table_elt_t            *h, *header, **ph;\n     ngx_http_header_t          *hh;\n"
    },
    {
        "commit_sha": "9c3890cb2b46789b257c337ff397bfae3fb2bebe",
        "commit_index": "Commit 160",
        "commit_diff": "Diff:\n@@ -1389,6 +1389,7 @@ ngx_resolver_send_tcp_query(ngx_resolver_t *r, ngx_resolver_connection_t *rec,\n \n         rec->tcp->data = rec;\n         rec->tcp->write->handler = ngx_resolver_tcp_write;\n+        rec->tcp->write->cancelable = 1;\n         rec->tcp->read->handler = ngx_resolver_tcp_read;\n         rec->tcp->read->resolver = 1;\n \nDiff:\n@@ -4906,8 +4906,9 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n         return NGX_ERROR;\n     }\n \n-    if (glcf->upstream.ssl_certificate) {\n-\n+    if (glcf->upstream.ssl_certificate\n+        && glcf->upstream.ssl_certificate->value.len)\n+    {\n         if (glcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"grpc_ssl_certificate_key\\\" is defined \"\nDiff:\n@@ -2331,7 +2331,7 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n         }\n \n         start_sample += count;\n-        start_time -= count * duration;\n+        start_time -= (uint64_t) count * duration;\n         entries--;\n         entry++;\n     }\nDiff:\n@@ -4955,8 +4955,9 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n         return NGX_ERROR;\n     }\n \n-    if (plcf->upstream.ssl_certificate) {\n-\n+    if (plcf->upstream.ssl_certificate\n+        && plcf->upstream.ssl_certificate->value.len)\n+    {\n         if (plcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\nDiff:\n@@ -2487,8 +2487,9 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n         return NGX_ERROR;\n     }\n \n-    if (uwcf->upstream.ssl_certificate) {\n-\n+    if (uwcf->upstream.ssl_certificate\n+        && uwcf->upstream.ssl_certificate->value.len)\n+    {\n         if (uwcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"uwsgi_ssl_certificate_key\\\" is defined \"\nDiff:\n@@ -1690,8 +1690,10 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,\n         }\n     }\n \n-    if (u->conf->ssl_certificate && (u->conf->ssl_certificate->lengths\n-                                     || u->conf->ssl_certificate_key->lengths))\n+    if (u->conf->ssl_certificate\n+        && u->conf->ssl_certificate->value.len\n+        && (u->conf->ssl_certificate->lengths\n+            || u->conf->ssl_certificate_key->lengths))\n     {\n         if (ngx_http_upstream_ssl_certificate(r, u, c) != NGX_OK) {\n             ngx_http_upstream_finalize_request(r, u,\nDiff:\n@@ -1069,8 +1069,10 @@ ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s)\n         }\n     }\n \n-    if (pscf->ssl_certificate && (pscf->ssl_certificate->lengths\n-                                  || pscf->ssl_certificate_key->lengths))\n+    if (pscf->ssl_certificate\n+        && pscf->ssl_certificate->value.len\n+        && (pscf->ssl_certificate->lengths\n+            || pscf->ssl_certificate_key->lengths))\n     {\n         if (ngx_stream_proxy_ssl_certificate(s) != NGX_OK) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n@@ -1735,7 +1737,7 @@ ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,\n \n                 cl->buf->temporary = (n ? 1 : 0);\n                 cl->buf->last_buf = src->read->eof;\n-                cl->buf->flush = 1;\n+                cl->buf->flush = !src->read->eof;\n \n                 (*packets)++;\n                 *received += n;\n@@ -2225,8 +2227,9 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n         return NGX_ERROR;\n     }\n \n-    if (pscf->ssl_certificate) {\n-\n+    if (pscf->ssl_certificate\n+        && pscf->ssl_certificate->value.len)\n+    {\n         if (pscf->ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\n"
    },
    {
        "commit_sha": "19923dda3764d976634dcd5bad6807dd24babb92",
        "commit_index": "Commit 159",
        "commit_diff": "Diff:\n@@ -377,6 +377,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n \n         cc = ngx_list_push(&r->headers_out.headers);\n         if (cc == NULL) {\n+            e->hash = 0;\n             return NGX_ERROR;\n         }\n \n@@ -410,6 +411,8 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n \n     e->value.data = ngx_pnalloc(r->pool, len);\n     if (e->value.data == NULL) {\n+        e->hash = 0;\n+        cc->hash = 0;\n         return NGX_ERROR;\n     }\n \n@@ -447,6 +450,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     cc->value.data = ngx_pnalloc(r->pool,\n                                  sizeof(\"max-age=\") + NGX_TIME_T_LEN + 1);\n     if (cc->value.data == NULL) {\n+        cc->hash = 0;\n         return NGX_ERROR;\n     }\n \nDiff:\n@@ -2702,6 +2702,10 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n \n             if (r->cache) {\n \n+                if (u->headers_in.no_cache || u->headers_in.expired) {\n+                    u->cacheable = 0;\n+                }\n+\n                 if (u->cacheable) {\n                     time_t  valid;\n \n@@ -2796,6 +2800,10 @@ ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)\n \n     umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);\n \n+    if (u->headers_in.no_cache || u->headers_in.expired) {\n+        u->cacheable = 0;\n+    }\n+\n     if (u->headers_in.x_accel_redirect\n         && !(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT))\n     {\n@@ -4791,18 +4799,18 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    if (r->cache->valid_sec != 0 && u->headers_in.x_accel_expires != NULL) {\n-        return NGX_OK;\n-    }\n-\n     start = h->value.data;\n     last = start + h->value.len;\n \n+    if (r->cache->valid_sec != 0 && u->headers_in.x_accel_expires != NULL) {\n+        goto extensions;\n+    }\n+\n     if (ngx_strlcasestrn(start, last, (u_char *) \"no-cache\", 8 - 1) != NULL\n         || ngx_strlcasestrn(start, last, (u_char *) \"no-store\", 8 - 1) != NULL\n         || ngx_strlcasestrn(start, last, (u_char *) \"private\", 7 - 1) != NULL)\n     {\n-        u->cacheable = 0;\n+        u->headers_in.no_cache = 1;\n         return NGX_OK;\n     }\n \n@@ -4832,13 +4840,16 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n         }\n \n         if (n == 0) {\n-            u->cacheable = 0;\n+            u->headers_in.no_cache = 1;\n             return NGX_OK;\n         }\n \n         r->cache->valid_sec = ngx_time() + n;\n+        u->headers_in.expired = 0;\n     }\n \n+extensions:\n+\n     p = ngx_strlcasestrn(start, last, (u_char *) \"stale-while-revalidate=\",\n                          23 - 1);\n \n@@ -4932,7 +4943,7 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,\n     expires = ngx_parse_http_time(h->value.data, h->value.len);\n \n     if (expires == NGX_ERROR || expires < ngx_time()) {\n-        u->cacheable = 0;\n+        u->headers_in.expired = 1;\n         return NGX_OK;\n     }\n \n@@ -4996,6 +5007,8 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n \n         default:\n             r->cache->valid_sec = ngx_time() + n;\n+            u->headers_in.no_cache = 0;\n+            u->headers_in.expired = 0;\n             return NGX_OK;\n         }\n     }\n@@ -5007,6 +5020,8 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n \n     if (n != NGX_ERROR) {\n         r->cache->valid_sec = n;\n+        u->headers_in.no_cache = 0;\n+        u->headers_in.expired = 0;\n     }\n     }\n #endif\n@@ -5183,9 +5198,6 @@ static ngx_int_t\n ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    u_char                *p;\n-    size_t                 len;\n-    ngx_str_t              vary;\n     ngx_table_elt_t      **ph;\n     ngx_http_upstream_t   *u;\n \n@@ -5198,6 +5210,10 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n+    {\n+    u_char     *p;\n+    size_t      len;\n+    ngx_str_t   vary;\n \n     if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_VARY) {\n         return NGX_OK;\n@@ -5249,7 +5265,7 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     }\n \n     r->cache->vary = vary;\n-\n+    }\n #endif\n \n     return NGX_OK;\nDiff:\n@@ -293,6 +293,8 @@ typedef struct {\n \n     unsigned                         connection_close:1;\n     unsigned                         chunked:1;\n+    unsigned                         no_cache:1;\n+    unsigned                         expired:1;\n } ngx_http_upstream_headers_in_t;\n \n \n"
    },
    {
        "commit_sha": "0c48f1ccf807945a204db1ea689f3e6734dece35",
        "commit_index": "Commit 158",
        "commit_diff": "Diff:\n@@ -101,7 +101,7 @@ ngx_module_t  ngx_http_auth_request_module = {\n static ngx_int_t\n ngx_http_auth_request_handler(ngx_http_request_t *r)\n {\n-    ngx_table_elt_t               *h, *ho;\n+    ngx_table_elt_t               *h, *ho, **ph;\n     ngx_http_request_t            *sr;\n     ngx_http_post_subrequest_t    *ps;\n     ngx_http_auth_request_ctx_t   *ctx;\n@@ -147,7 +147,9 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)\n                 h = sr->upstream->headers_in.www_authenticate;\n             }\n \n-            if (h) {\n+            ph = &r->headers_out.www_authenticate;\n+\n+            while (h) {\n                 ho = ngx_list_push(&r->headers_out.headers);\n                 if (ho == NULL) {\n                     return NGX_ERROR;\n@@ -156,7 +158,10 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)\n                 *ho = *h;\n                 ho->next = NULL;\n \n-                r->headers_out.www_authenticate = ho;\n+                *ph = ho;\n+                ph = &ho->next;\n+\n+                h = h->next;\n             }\n \n             return ctx->status;\nDiff:\n@@ -1088,6 +1088,7 @@ ngx_int_t\n ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n {\n     ngx_int_t                  rc;\n+    ngx_table_elt_t           *h;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     if (r != r->main) {\n@@ -1122,8 +1123,8 @@ ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n         if (rc == NGX_OK) {\n             r->access_code = 0;\n \n-            if (r->headers_out.www_authenticate) {\n-                r->headers_out.www_authenticate->hash = 0;\n+            for (h = r->headers_out.www_authenticate; h; h = h->next) {\n+                h->hash = 0;\n             }\n \n             r->phase_handler = ph->next;\nDiff:\n@@ -2647,7 +2647,7 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n {\n     ngx_int_t                  status;\n     ngx_uint_t                 i;\n-    ngx_table_elt_t           *h;\n+    ngx_table_elt_t           *h, *ho, **ph;\n     ngx_http_err_page_t       *err_page;\n     ngx_http_core_loc_conf_t  *clcf;\n \n@@ -2676,18 +2676,26 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n             if (status == NGX_HTTP_UNAUTHORIZED\n                 && u->headers_in.www_authenticate)\n             {\n-                h = ngx_list_push(&r->headers_out.headers);\n+                h = u->headers_in.www_authenticate;\n+                ph = &r->headers_out.www_authenticate;\n \n-                if (h == NULL) {\n-                    ngx_http_upstream_finalize_request(r, u,\n+                while (h) {\n+                    ho = ngx_list_push(&r->headers_out.headers);\n+\n+                    if (ho == NULL) {\n+                        ngx_http_upstream_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n-                    return NGX_OK;\n-                }\n+                        return NGX_OK;\n+                    }\n+\n+                    *ho = *h;\n+                    ho->next = NULL;\n \n-                *h = *u->headers_in.www_authenticate;\n-                h->next = NULL;\n+                    *ph = ho;\n+                    ph = &ho->next;\n \n-                r->headers_out.www_authenticate = h;\n+                    h = h->next;\n+                }\n             }\n \n #if (NGX_HTTP_CACHE)\n"
    },
    {
        "commit_sha": "289137ccb511b777c5440f43e85486153976c1e5",
        "commit_index": "Commit 157",
        "commit_diff": "Diff:\n@@ -2007,8 +2007,12 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n                 hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                    h->lowcase_key, h->key.len);\n \n-                if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                    return NGX_ERROR;\n+                if (hh) {\n+                    rc = hh->handler(r, h, hh->offset);\n+\n+                    if (rc != NGX_OK) {\n+                        return rc;\n+                    }\n                 }\n \n                 ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -1891,8 +1891,12 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n                 hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                    h->lowcase_key, h->key.len);\n \n-                if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                    return NGX_ERROR;\n+                if (hh) {\n+                    rc = hh->handler(r, h, hh->offset);\n+\n+                    if (rc != NGX_OK) {\n+                        return rc;\n+                    }\n                 }\n \n                 continue;\nDiff:\n@@ -1930,8 +1930,12 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n             hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                h->lowcase_key, h->key.len);\n \n-            if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                return NGX_ERROR;\n+            if (hh) {\n+                rc = hh->handler(r, h, hh->offset);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n             }\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -1114,8 +1114,12 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n             hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                h->lowcase_key, h->key.len);\n \n-            if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                return NGX_ERROR;\n+            if (hh) {\n+                rc = hh->handler(r, h, hh->offset);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n             }\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -1340,8 +1340,12 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n             hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                h->lowcase_key, h->key.len);\n \n-            if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                return NGX_ERROR;\n+            if (hh) {\n+                rc = hh->handler(r, h, hh->offset);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n             }\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -101,6 +101,9 @@ static void ngx_http_upstream_finalize_request(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t\n+    ngx_http_upstream_process_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r,\n@@ -226,7 +229,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  offsetof(ngx_http_headers_out_t, server), 0 },\n \n     { ngx_string(\"WWW-Authenticate\"),\n-                 ngx_http_upstream_process_header_line,\n+                 ngx_http_upstream_process_multi_header_lines,\n                  offsetof(ngx_http_upstream_headers_in_t, www_authenticate),\n                  ngx_http_upstream_copy_header_line, 0, 0 },\n \n@@ -236,7 +239,8 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  ngx_http_upstream_rewrite_location, 0, 0 },\n \n     { ngx_string(\"Refresh\"),\n-                 ngx_http_upstream_ignore_header_line, 0,\n+                 ngx_http_upstream_process_header_line,\n+                 offsetof(ngx_http_upstream_headers_in_t, refresh),\n                  ngx_http_upstream_rewrite_refresh, 0, 0 },\n \n     { ngx_string(\"Set-Cookie\"),\n@@ -2804,6 +2808,10 @@ ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)\n                 i = 0;\n             }\n \n+            if (h[i].hash == 0) {\n+                continue;\n+            }\n+\n             hh = ngx_hash_find(&umcf->headers_in_hash, h[i].hash,\n                                h[i].lowcase_key, h[i].key.len);\n \n@@ -2857,6 +2865,10 @@ ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)\n             i = 0;\n         }\n \n+        if (h[i].hash == 0) {\n+            continue;\n+        }\n+\n         if (ngx_hash_find(&u->conf->hide_headers_hash, h[i].hash,\n                           h[i].lowcase_key, h[i].key.len))\n         {\n@@ -4608,11 +4620,36 @@ ngx_http_upstream_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     ph = (ngx_table_elt_t **) ((char *) &r->upstream->headers_in + offset);\n \n-    if (*ph == NULL) {\n-        *ph = h;\n-        h->next = NULL;\n+    if (*ph) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &(*ph)->key, &(*ph)->value);\n+        h->hash = 0;\n+        return NGX_OK;\n     }\n \n+    *ph = h;\n+    h->next = NULL;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_upstream_process_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset)\n+{\n+    ngx_table_elt_t  **ph;\n+\n+    ph = (ngx_table_elt_t **) ((char *) &r->upstream->headers_in + offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n+    h->next = NULL;\n+\n     return NGX_OK;\n }\n \n@@ -4633,10 +4670,34 @@ ngx_http_upstream_process_content_length(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    if (u->headers_in.content_length) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.content_length->key,\n+                      &u->headers_in.content_length->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n+    if (u->headers_in.transfer_encoding) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent \\\"Content-Length\\\" and \"\n+                      \"\\\"Transfer-Encoding\\\" headers at the same time\");\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n     h->next = NULL;\n     u->headers_in.content_length = h;\n     u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);\n \n+    if (u->headers_in.content_length_n == NGX_ERROR) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent invalid \\\"Content-Length\\\" header: \"\n+                      \"\\\"%V: %V\\\"\", &h->key, &h->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n     return NGX_OK;\n }\n \n@@ -4649,6 +4710,17 @@ ngx_http_upstream_process_last_modified(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    if (u->headers_in.last_modified) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.last_modified->key,\n+                      &u->headers_in.last_modified->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     h->next = NULL;\n     u->headers_in.last_modified = h;\n     u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data,\n@@ -4818,6 +4890,18 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.expires) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.expires->key,\n+                      &u->headers_in.expires->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     u->headers_in.expires = h;\n     h->next = NULL;\n \n@@ -4859,6 +4943,18 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.x_accel_expires) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.x_accel_expires->key,\n+                      &u->headers_in.x_accel_expires->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     u->headers_in.x_accel_expires = h;\n     h->next = NULL;\n \n@@ -4919,6 +5015,18 @@ ngx_http_upstream_process_limit_rate(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.x_accel_limit_rate) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.x_accel_limit_rate->key,\n+                      &u->headers_in.x_accel_limit_rate->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     u->headers_in.x_accel_limit_rate = h;\n     h->next = NULL;\n \n@@ -4997,10 +5105,15 @@ static ngx_int_t\n ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_http_upstream_t  *u;\n+    ngx_table_elt_t      **ph;\n+    ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    u->headers_in.connection = h;\n+    ph = &u->headers_in.connection;\n+\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n     h->next = NULL;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n@@ -5021,14 +5134,37 @@ ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.transfer_encoding) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.transfer_encoding->key,\n+                      &u->headers_in.transfer_encoding->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n+    if (u->headers_in.content_length) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent \\\"Content-Length\\\" and \"\n+                      \"\\\"Transfer-Encoding\\\" headers at the same time\");\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n     u->headers_in.transfer_encoding = h;\n     h->next = NULL;\n \n-    if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n-                         (u_char *) \"chunked\", 7 - 1)\n-        != NULL)\n+    if (h->value.len == 7\n+        && ngx_strncasecmp(h->value.data, (u_char *) \"chunked\", 7) == 0)\n     {\n         u->headers_in.chunked = 1;\n+\n+    } else {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent unknown \\\"Transfer-Encoding\\\": \\\"%V\\\"\",\n+                      &h->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\n \n     return NGX_OK;\n@@ -5039,10 +5175,18 @@ static ngx_int_t\n ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_http_upstream_t  *u;\n+    u_char                *p;\n+    size_t                 len;\n+    ngx_str_t              vary;\n+    ngx_table_elt_t      **ph;\n+    ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    u->headers_in.vary = h;\n+    ph = &u->headers_in.vary;\n+\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n     h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n@@ -5051,17 +5195,52 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    if (r->cache == NULL) {\n+    if (r->cache == NULL || !u->cacheable) {\n         return NGX_OK;\n     }\n \n-    if (h->value.len > NGX_HTTP_CACHE_VARY_LEN\n-        || (h->value.len == 1 && h->value.data[0] == '*'))\n-    {\n+    if (h->value.len == 1 && h->value.data[0] == '*') {\n+        u->cacheable = 0;\n+        return NGX_OK;\n+    }\n+\n+    if (u->headers_in.vary->next) {\n+\n+        len = 0;\n+\n+        for (h = u->headers_in.vary; h; h = h->next) {\n+            len += h->value.len + 2;\n+        }\n+\n+        len -= 2;\n+\n+        p = ngx_pnalloc(r->pool, len);\n+        if (p == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        vary.len = len;\n+        vary.data = p;\n+\n+        for (h = u->headers_in.vary; h; h = h->next) {\n+            p = ngx_copy(p, h->value.data, h->value.len);\n+\n+            if (h->next == NULL) {\n+                break;\n+            }\n+\n+            *p++ = ','; *p++ = ' ';\n+        }\n+\n+    } else {\n+        vary = h->value;\n+    }\n+\n+    if (vary.len > NGX_HTTP_CACHE_VARY_LEN) {\n         u->cacheable = 0;\n     }\n \n-    r->cache->vary = h->value;\n+    r->cache->vary = vary;\n \n #endif\n \nDiff:\n@@ -280,6 +280,7 @@ typedef struct {\n \n     ngx_table_elt_t                 *last_modified;\n     ngx_table_elt_t                 *location;\n+    ngx_table_elt_t                 *refresh;\n     ngx_table_elt_t                 *www_authenticate;\n     ngx_table_elt_t                 *transfer_encoding;\n     ngx_table_elt_t                 *vary;\n"
    },
    {
        "commit_sha": "45bb315e91a02f1f707fb75ae23288c3b9585f2e",
        "commit_index": "Commit 156",
        "commit_diff": "Diff:\n@@ -339,6 +339,7 @@ ngx_http_auth_basic_set_realm(ngx_http_request_t *r, ngx_str_t *realm)\n     *p = '\"';\n \n     r->headers_out.www_authenticate->hash = 1;\n+    r->headers_out.www_authenticate->next = NULL;\n     ngx_str_set(&r->headers_out.www_authenticate->key, \"WWW-Authenticate\");\n     r->headers_out.www_authenticate->value.data = basic;\n     r->headers_out.www_authenticate->value.len = len;\nDiff:\n@@ -154,6 +154,7 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)\n                 }\n \n                 *ho = *h;\n+                ho->next = NULL;\n \n                 r->headers_out.www_authenticate = ho;\n             }\nDiff:\n@@ -1082,6 +1082,7 @@ ngx_http_dav_location(ngx_http_request_t *r)\n     }\n \n     r->headers_out.location->hash = 1;\n+    r->headers_out.location->next = NULL;\n     ngx_str_set(&r->headers_out.location->key, \"Location\");\n \n     escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\nDiff:\n@@ -280,6 +280,7 @@ ngx_http_gzip_header_filter(ngx_http_request_t *r)\n     }\n \n     h->hash = 1;\n+    h->next = NULL;\n     ngx_str_set(&h->key, \"Content-Encoding\");\n     ngx_str_set(&h->value, \"gzip\");\n     r->headers_out.content_encoding = h;\nDiff:\n@@ -242,6 +242,7 @@ ngx_http_gzip_static_handler(ngx_http_request_t *r)\n     }\n \n     h->hash = 1;\n+    h->next = NULL;\n     ngx_str_set(&h->key, \"Content-Encoding\");\n     ngx_str_set(&h->value, \"gzip\");\n     r->headers_out.content_encoding = h;\nDiff:\n@@ -362,6 +362,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n         }\n \n         r->headers_out.expires = e;\n+        e->next = NULL;\n \n         e->hash = 1;\n         ngx_str_set(&e->key, \"Expires\");\n@@ -621,6 +622,7 @@ ngx_http_set_response_header(ngx_http_request_t *r, ngx_http_header_val_t *hv,\n         }\n \n         *old = h;\n+        h->next = NULL;\n     }\n \n     h->hash = 1;\nDiff:\n@@ -401,6 +401,7 @@ ngx_http_memcached_process_header(ngx_http_request_t *r)\n             }\n \n             h->hash = 1;\n+            h->next = NULL;\n             ngx_str_set(&h->key, \"Content-Encoding\");\n             ngx_str_set(&h->value, \"gzip\");\n             r->headers_out.content_encoding = h;\nDiff:\n@@ -1965,6 +1965,7 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n                 ngx_str_set(&h->key, \"Server\");\n                 ngx_str_null(&h->value);\n                 h->lowcase_key = (u_char *) \"server\";\n+                h->next = NULL;\n             }\n \n             if (r->upstream->headers_in.date == NULL) {\n@@ -1978,6 +1979,7 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n                 ngx_str_set(&h->key, \"Date\");\n                 ngx_str_null(&h->value);\n                 h->lowcase_key = (u_char *) \"date\";\n+                h->next = NULL;\n             }\n \n             /* clear content length if response is chunked */\nDiff:\n@@ -259,6 +259,7 @@ ngx_http_range_header_filter(ngx_http_request_t *r)\n     }\n \n     r->headers_out.accept_ranges->hash = 1;\n+    r->headers_out.accept_ranges->next = NULL;\n     ngx_str_set(&r->headers_out.accept_ranges->key, \"Accept-Ranges\");\n     ngx_str_set(&r->headers_out.accept_ranges->value, \"bytes\");\n \n@@ -446,6 +447,7 @@ ngx_http_range_singlepart_header(ngx_http_request_t *r,\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n+    content_range->next = NULL;\n     ngx_str_set(&content_range->key, \"Content-Range\");\n \n     content_range->value.data = ngx_pnalloc(r->pool,\n@@ -618,6 +620,7 @@ ngx_http_range_not_satisfiable(ngx_http_request_t *r)\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n+    content_range->next = NULL;\n     ngx_str_set(&content_range->key, \"Content-Range\");\n \n     content_range->value.data = ngx_pnalloc(r->pool,\nDiff:\n@@ -195,6 +195,7 @@ ngx_http_static_handler(ngx_http_request_t *r)\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n         r->headers_out.location->value.len = len;\n         r->headers_out.location->value.data = location;\nDiff:\n@@ -573,6 +573,7 @@ header_out(r, key, value)\n     }\n \n     header->hash = 1;\n+    header->next = NULL;\n \n     if (ngx_http_perl_sv2str(aTHX_ r, &header->key, key) != NGX_OK) {\n         header->hash = 0;\nDiff:\n@@ -1007,6 +1007,7 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n \n         if (r->args.len == 0) {\n@@ -1687,6 +1688,7 @@ ngx_http_set_etag(ngx_http_request_t *r)\n     }\n \n     etag->hash = 1;\n+    etag->next = NULL;\n     ngx_str_set(&etag->key, \"ETag\");\n \n     etag->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\n@@ -1781,6 +1783,7 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n         r->headers_out.location->value = val;\n \nDiff:\n@@ -1243,6 +1243,7 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n         r->headers_out.location->value = e->buf;\n \nDiff:\n@@ -649,6 +649,7 @@ ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n     }\n \n     location->hash = 1;\n+    location->next = NULL;\n     ngx_str_set(&location->key, \"Location\");\n     location->value = uri;\n \nDiff:\n@@ -2681,6 +2681,7 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n                 }\n \n                 *h = *u->headers_in.www_authenticate;\n+                h->next = NULL;\n \n                 r->headers_out.www_authenticate = h;\n             }\n@@ -4609,6 +4610,7 @@ ngx_http_upstream_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -4631,6 +4633,7 @@ ngx_http_upstream_process_content_length(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    h->next = NULL;\n     u->headers_in.content_length = h;\n     u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);\n \n@@ -4646,6 +4649,7 @@ ngx_http_upstream_process_last_modified(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    h->next = NULL;\n     u->headers_in.last_modified = h;\n     u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data,\n                                                            h->value.len);\n@@ -4815,6 +4819,7 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     u = r->upstream;\n     u->headers_in.expires = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -4855,6 +4860,7 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n \n     u = r->upstream;\n     u->headers_in.x_accel_expires = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -4914,6 +4920,7 @@ ngx_http_upstream_process_limit_rate(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     u = r->upstream;\n     u->headers_in.x_accel_limit_rate = h;\n+    h->next = NULL;\n \n     if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE) {\n         return NGX_OK;\n@@ -4994,6 +5001,7 @@ ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     u = r->upstream;\n     u->headers_in.connection = h;\n+    h->next = NULL;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"close\", 5 - 1)\n@@ -5014,6 +5022,7 @@ ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,\n \n     u = r->upstream;\n     u->headers_in.transfer_encoding = h;\n+    h->next = NULL;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"chunked\", 7 - 1)\n@@ -5034,6 +5043,7 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n \n     u = r->upstream;\n     u->headers_in.vary = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n \n@@ -5075,6 +5085,7 @@ ngx_http_upstream_copy_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n     if (offset) {\n         ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);\n         *ph = ho;\n+        ho->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -5169,6 +5180,7 @@ ngx_http_upstream_copy_last_modified(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     r->headers_out.last_modified = ho;\n     r->headers_out.last_modified_time =\n@@ -5191,6 +5203,7 @@ ngx_http_upstream_rewrite_location(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     if (r->upstream->rewrite_redirect) {\n         rc = r->upstream->rewrite_redirect(r, ho, 0);\n@@ -5236,6 +5249,7 @@ ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     if (r->upstream->rewrite_redirect) {\n \n@@ -5281,6 +5295,7 @@ ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     if (r->upstream->rewrite_cookie) {\n         rc = r->upstream->rewrite_cookie(r, ho);\n@@ -5334,6 +5349,7 @@ ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     r->headers_out.accept_ranges = ho;\n \n"
    },
    {
        "commit_sha": "00e40de1f4e09b08ef1fd900d2bb6921370e1912",
        "commit_index": "Commit 155",
        "commit_diff": "Diff:\n@@ -272,7 +272,7 @@ header_in(r, key)\n     ngx_uint_t                  i, n, hash;\n     ngx_array_t                *a;\n     ngx_list_part_t            *part;\n-    ngx_table_elt_t            *h, **ph;\n+    ngx_table_elt_t            *h, *header, **ph;\n     ngx_http_header_t          *hh;\n     ngx_http_core_main_conf_t  *cmcf;\n \n@@ -311,47 +311,14 @@ header_in(r, key)\n \n         ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n-        if (*ph == NULL) {\n-            XSRETURN_UNDEF;\n-        }\n-\n-        if ((*ph)->next == NULL) {\n-            ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n-\n-            goto done;\n-        }\n-\n-        size = - (ssize_t) (sizeof(\"; \") - 1);\n-\n-        for (h = *ph; h; h = h->next) {\n-            size += h->value.len + sizeof(\"; \") - 1;\n-        }\n-\n-        value = ngx_pnalloc(r->pool, size);\n-        if (value == NULL) {\n-            ctx->error = 1;\n-            croak(\"ngx_pnalloc() failed\");\n-        }\n-\n-        p = value;\n-\n-        for (h = *ph; h; h = h->next) {\n-            p = ngx_copy(p, h->value.data, h->value.len);\n-\n-            if (h->next == NULL) {\n-                break;\n-            }\n-\n-            *p++ = sep; *p++ = ' ';\n-        }\n-\n-        ngx_http_perl_set_targ(value, size);\n-\n-        goto done;\n+        goto found;\n     }\n \n     /* iterate over all headers */\n \n+    sep = ',';\n+    ph = &header;\n+\n     part = &r->headers_in.headers.part;\n     h = part->elts;\n \n@@ -373,12 +340,49 @@ header_in(r, key)\n             continue;\n         }\n \n-        ngx_http_perl_set_targ(h[i].value.data, h[i].value.len);\n+        *ph = &h[i];\n+        ph = &h[i].next;\n+    }\n+\n+    *ph = NULL;\n+    ph = &header;\n \n+    found:\n+\n+    if (*ph == NULL) {\n+        XSRETURN_UNDEF;\n+    }\n+\n+    if ((*ph)->next == NULL) {\n+        ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n         goto done;\n     }\n \n-    XSRETURN_UNDEF;\n+    size = - (ssize_t) (sizeof(\"; \") - 1);\n+\n+    for (h = *ph; h; h = h->next) {\n+        size += h->value.len + sizeof(\"; \") - 1;\n+    }\n+\n+    value = ngx_pnalloc(r->pool, size);\n+    if (value == NULL) {\n+        ctx->error = 1;\n+        croak(\"ngx_pnalloc() failed\");\n+    }\n+\n+    p = value;\n+\n+    for (h = *ph; h; h = h->next) {\n+        p = ngx_copy(p, h->value.data, h->value.len);\n+\n+        if (h->next == NULL) {\n+            break;\n+        }\n+\n+        *p++ = sep; *p++ = ' ';\n+    }\n+\n+    ngx_http_perl_set_targ(value, size);\n \n     done:\n \nDiff:\n@@ -147,11 +147,6 @@ static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r,\n static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n \n-#if (NGX_HTTP_GZIP)\n-static ngx_int_t ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, ngx_uint_t offset);\n-#endif\n-\n static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n@@ -264,8 +259,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  offsetof(ngx_http_headers_out_t, expires), 1 },\n \n     { ngx_string(\"Accept-Ranges\"),\n-                 ngx_http_upstream_process_header_line,\n-                 offsetof(ngx_http_upstream_headers_in_t, accept_ranges),\n+                 ngx_http_upstream_ignore_header_line, 0,\n                  ngx_http_upstream_copy_allow_ranges,\n                  offsetof(ngx_http_headers_out_t, accept_ranges), 1 },\n \n@@ -316,12 +310,10 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  ngx_http_upstream_process_transfer_encoding, 0,\n                  ngx_http_upstream_ignore_header_line, 0, 0 },\n \n-#if (NGX_HTTP_GZIP)\n     { ngx_string(\"Content-Encoding\"),\n-                 ngx_http_upstream_process_header_line,\n-                 offsetof(ngx_http_upstream_headers_in_t, content_encoding),\n-                 ngx_http_upstream_copy_content_encoding, 0, 0 },\n-#endif\n+                 ngx_http_upstream_ignore_header_line, 0,\n+                 ngx_http_upstream_copy_header_line,\n+                 offsetof(ngx_http_headers_out_t, content_encoding), 0 },\n \n     { ngx_null_string, NULL, 0, NULL, 0, 0 }\n };\n@@ -4691,8 +4683,8 @@ static ngx_int_t\n ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_table_elt_t     **ph;\n-    ngx_http_upstream_t  *u;\n+    ngx_table_elt_t      **ph;\n+    ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n     ph = &u->headers_in.cache_control;\n@@ -4980,7 +4972,11 @@ static ngx_int_t\n ngx_http_upstream_process_charset(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    if (r->upstream->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_CHARSET) {\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+\n+    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_CHARSET) {\n         return NGX_OK;\n     }\n \n@@ -4994,13 +4990,16 @@ static ngx_int_t\n ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    r->upstream->headers_in.connection = h;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+    u->headers_in.connection = h;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"close\", 5 - 1)\n         != NULL)\n     {\n-        r->upstream->headers_in.connection_close = 1;\n+        u->headers_in.connection_close = 1;\n     }\n \n     return NGX_OK;\n@@ -5011,13 +5010,16 @@ static ngx_int_t\n ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    r->upstream->headers_in.transfer_encoding = h;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+    u->headers_in.transfer_encoding = h;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"chunked\", 7 - 1)\n         != NULL)\n     {\n-        r->upstream->headers_in.chunked = 1;\n+        u->headers_in.chunked = 1;\n     }\n \n     return NGX_OK;\n@@ -5339,29 +5341,6 @@ ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,\n }\n \n \n-#if (NGX_HTTP_GZIP)\n-\n-static ngx_int_t\n-ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, ngx_uint_t offset)\n-{\n-    ngx_table_elt_t  *ho;\n-\n-    ho = ngx_list_push(&r->headers_out.headers);\n-    if (ho == NULL) {\n-        return NGX_ERROR;\n-    }\n-\n-    *ho = *h;\n-\n-    r->headers_out.content_encoding = ho;\n-\n-    return NGX_OK;\n-}\n-\n-#endif\n-\n-\n static ngx_int_t\n ngx_http_upstream_add_variables(ngx_conf_t *cf)\n {\nDiff:\n@@ -280,15 +280,10 @@ typedef struct {\n \n     ngx_table_elt_t                 *last_modified;\n     ngx_table_elt_t                 *location;\n-    ngx_table_elt_t                 *accept_ranges;\n     ngx_table_elt_t                 *www_authenticate;\n     ngx_table_elt_t                 *transfer_encoding;\n     ngx_table_elt_t                 *vary;\n \n-#if (NGX_HTTP_GZIP)\n-    ngx_table_elt_t                 *content_encoding;\n-#endif\n-\n     ngx_table_elt_t                 *cache_control;\n     ngx_table_elt_t                 *set_cookie;\n \n"
    },
    {
        "commit_sha": "7a7c482ad578e63dda66273d8c66317d357a0950",
        "commit_index": "Commit 154",
        "commit_diff": "Diff:\n@@ -304,29 +304,11 @@ header_in(r, key)\n \n         if (hh->offset == offsetof(ngx_http_headers_in_t, cookie)) {\n             sep = ';';\n-            goto multi;\n-        }\n-#if (NGX_HTTP_X_FORWARDED_FOR)\n-        if (hh->offset == offsetof(ngx_http_headers_in_t, x_forwarded_for)) {\n-            sep = ',';\n-            goto multi;\n-        }\n-#endif\n-\n-        ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n-\n-        if (*ph) {\n-            ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n \n-            goto done;\n+        } else {\n+            sep = ',';\n         }\n \n-        XSRETURN_UNDEF;\n-\n-    multi:\n-\n-        /* Cookie, X-Forwarded-For */\n-\n         ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n         if (*ph == NULL) {\nDiff:\n@@ -26,8 +26,6 @@ static ngx_int_t ngx_http_process_white_list(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n-static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n@@ -174,7 +172,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n #if (NGX_HTTP_X_FORWARDED_FOR)\n     { ngx_string(\"X-Forwarded-For\"),\n                  offsetof(ngx_http_headers_in_t, x_forwarded_for),\n-                 ngx_http_process_multi_header_lines },\n+                 ngx_http_process_header_line },\n #endif\n \n #if (NGX_HTTP_REALIP)\n@@ -207,7 +205,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n #endif\n \n     { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookie),\n-                 ngx_http_process_multi_header_lines },\n+                 ngx_http_process_header_line },\n \n     { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n                  ngx_http_process_black_list },\n@@ -1767,10 +1765,10 @@ ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n \n-    if (*ph == NULL) {\n-        *ph = h;\n-        h->next = NULL;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n+    h->next = NULL;\n \n     return NGX_OK;\n }\n@@ -1876,13 +1874,10 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n {\n     u_char  *user_agent, *msie;\n \n-    if (r->headers_in.user_agent) {\n-        return NGX_OK;\n+    if (ngx_http_process_header_line(r, h, offset) != NGX_OK) {\n+        return NGX_ERROR;\n     }\n \n-    r->headers_in.user_agent = h;\n-    h->next = NULL;\n-\n     /* check some widespread browsers while the header is in CPU cache */\n \n     user_agent = h->value.data;\n@@ -1944,23 +1939,6 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n }\n \n \n-static ngx_int_t\n-ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,\n-    ngx_uint_t offset)\n-{\n-    ngx_table_elt_t  **ph;\n-\n-    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n-\n-    while (*ph) { ph = &(*ph)->next; }\n-\n-    *ph = h;\n-    h->next = NULL;\n-\n-    return NGX_OK;\n-}\n-\n-\n ngx_int_t\n ngx_http_process_request_header(ngx_http_request_t *r)\n {\nDiff:\n@@ -27,8 +27,6 @@ static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n-static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r,\n-    ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep);\n \n@@ -182,7 +180,7 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n #endif\n \n #if (NGX_HTTP_X_FORWARDED_FOR)\n-    { ngx_string(\"http_x_forwarded_for\"), NULL, ngx_http_variable_headers,\n+    { ngx_string(\"http_x_forwarded_for\"), NULL, ngx_http_variable_header,\n       offsetof(ngx_http_request_t, headers_in.x_forwarded_for), 0, 0 },\n #endif\n \n@@ -331,10 +329,10 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n     { ngx_string(\"sent_http_transfer_encoding\"), NULL,\n       ngx_http_variable_sent_transfer_encoding, 0, 0, 0 },\n \n-    { ngx_string(\"sent_http_cache_control\"), NULL, ngx_http_variable_headers,\n+    { ngx_string(\"sent_http_cache_control\"), NULL, ngx_http_variable_header,\n       offsetof(ngx_http_request_t, headers_out.cache_control), 0, 0 },\n \n-    { ngx_string(\"sent_http_link\"), NULL, ngx_http_variable_headers,\n+    { ngx_string(\"sent_http_link\"), NULL, ngx_http_variable_header,\n       offsetof(ngx_http_request_t, headers_out.link), 0, 0 },\n \n     { ngx_string(\"limit_rate\"), ngx_http_variable_set_limit_rate,\n@@ -817,22 +815,7 @@ static ngx_int_t\n ngx_http_variable_header(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     uintptr_t data)\n {\n-    ngx_table_elt_t  *h;\n-\n-    h = *(ngx_table_elt_t **) ((char *) r + data);\n-\n-    if (h) {\n-        v->len = h->value.len;\n-        v->valid = 1;\n-        v->no_cacheable = 0;\n-        v->not_found = 0;\n-        v->data = h->value.data;\n-\n-    } else {\n-        v->not_found = 1;\n-    }\n-\n-    return NGX_OK;\n+    return ngx_http_variable_headers_internal(r, v, data, ',');\n }\n \n \n@@ -844,14 +827,6 @@ ngx_http_variable_cookies(ngx_http_request_t *r,\n }\n \n \n-static ngx_int_t\n-ngx_http_variable_headers(ngx_http_request_t *r,\n-    ngx_http_variable_value_t *v, uintptr_t data)\n-{\n-    return ngx_http_variable_headers_internal(r, v, data, ',');\n-}\n-\n-\n static ngx_int_t\n ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep)\n"
    },
    {
        "commit_sha": "c502a1695c0e9d0345101a5f2a99ee0e3c890a4d",
        "commit_index": "Commit 153",
        "commit_diff": "Diff:\n@@ -327,15 +327,15 @@ static ngx_int_t\n ngx_http_geo_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,\n     ngx_addr_t *addr)\n {\n-    ngx_array_t  *xfwd;\n+    ngx_table_elt_t  *xfwd;\n \n     if (ngx_http_geo_real_addr(r, ctx, addr) != NGX_OK) {\n         return NGX_ERROR;\n     }\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && ctx->proxies != NULL) {\n+    if (xfwd != NULL && ctx->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, addr, xfwd, NULL,\n                                            ctx->proxies, ctx->proxy_recursive);\n     }\nDiff:\n@@ -240,16 +240,16 @@ static u_long\n ngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n {\n     ngx_addr_t           addr;\n-    ngx_array_t         *xfwd;\n+    ngx_table_elt_t     *xfwd;\n     struct sockaddr_in  *sin;\n \n     addr.sockaddr = r->connection->sockaddr;\n     addr.socklen = r->connection->socklen;\n     /* addr.name = r->connection->addr_text; */\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {\n+    if (xfwd != NULL && gcf->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,\n                                            gcf->proxies, gcf->proxy_recursive);\n     }\n@@ -292,7 +292,7 @@ static geoipv6_t\n ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n {\n     ngx_addr_t            addr;\n-    ngx_array_t          *xfwd;\n+    ngx_table_elt_t      *xfwd;\n     in_addr_t             addr4;\n     struct in6_addr       addr6;\n     struct sockaddr_in   *sin;\n@@ -302,9 +302,9 @@ ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n     addr.socklen = r->connection->socklen;\n     /* addr.name = r->connection->addr_text; */\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {\n+    if (xfwd != NULL && gcf->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,\n                                            gcf->proxies, gcf->proxy_recursive);\n     }\nDiff:\n@@ -329,8 +329,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     time_t               now, expires_time, max_age;\n     ngx_str_t            value;\n     ngx_int_t            rc;\n-    ngx_uint_t           i;\n-    ngx_table_elt_t     *e, *cc, **ccp;\n+    ngx_table_elt_t     *e, *cc;\n     ngx_http_expires_t   expires;\n \n     expires = conf->expires;\n@@ -371,38 +370,28 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     len = sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\");\n     e->value.len = len - 1;\n \n-    ccp = r->headers_out.cache_control.elts;\n+    cc = r->headers_out.cache_control;\n \n-    if (ccp == NULL) {\n-\n-        if (ngx_array_init(&r->headers_out.cache_control, r->pool,\n-                           1, sizeof(ngx_table_elt_t *))\n-            != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n+    if (cc == NULL) {\n \n         cc = ngx_list_push(&r->headers_out.headers);\n         if (cc == NULL) {\n             return NGX_ERROR;\n         }\n \n+        r->headers_out.cache_control = cc;\n+        cc->next = NULL;\n+\n         cc->hash = 1;\n         ngx_str_set(&cc->key, \"Cache-Control\");\n \n-        ccp = ngx_array_push(&r->headers_out.cache_control);\n-        if (ccp == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        *ccp = cc;\n-\n     } else {\n-        for (i = 1; i < r->headers_out.cache_control.nelts; i++) {\n-            ccp[i]->hash = 0;\n+        for (cc = cc->next; cc; cc = cc->next) {\n+            cc->hash = 0;\n         }\n \n-        cc = ccp[0];\n+        cc = r->headers_out.cache_control;\n+        cc->next = NULL;\n     }\n \n     if (expires == NGX_HTTP_EXPIRES_EPOCH) {\n@@ -564,22 +553,12 @@ static ngx_int_t\n ngx_http_add_multi_header_lines(ngx_http_request_t *r,\n     ngx_http_header_val_t *hv, ngx_str_t *value)\n {\n-    ngx_array_t      *pa;\n     ngx_table_elt_t  *h, **ph;\n \n     if (value->len == 0) {\n         return NGX_OK;\n     }\n \n-    pa = (ngx_array_t *) ((char *) &r->headers_out + hv->offset);\n-\n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n     h = ngx_list_push(&r->headers_out.headers);\n     if (h == NULL) {\n         return NGX_ERROR;\n@@ -589,12 +568,12 @@ ngx_http_add_multi_header_lines(ngx_http_request_t *r,\n     h->key = hv->key;\n     h->value = *value;\n \n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + hv->offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n     return NGX_OK;\n }\nDiff:\n@@ -2559,22 +2559,20 @@ static ngx_int_t\n ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    size_t             len;\n-    u_char            *p;\n-    ngx_uint_t         i, n;\n-    ngx_table_elt_t  **h;\n+    size_t            len;\n+    u_char           *p;\n+    ngx_table_elt_t  *h, *xfwd;\n \n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n \n-    n = r->headers_in.x_forwarded_for.nelts;\n-    h = r->headers_in.x_forwarded_for.elts;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n     len = 0;\n \n-    for (i = 0; i < n; i++) {\n-        len += h[i]->value.len + sizeof(\", \") - 1;\n+    for (h = xfwd; h; h = h->next) {\n+        len += h->value.len + sizeof(\", \") - 1;\n     }\n \n     if (len == 0) {\n@@ -2593,8 +2591,8 @@ ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,\n     v->len = len;\n     v->data = p;\n \n-    for (i = 0; i < n; i++) {\n-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);\n+    for (h = xfwd; h; h = h->next) {\n+        p = ngx_copy(p, h->value.data, h->value.len);\n         *p++ = ','; *p++ = ' ';\n     }\n \nDiff:\n@@ -134,9 +134,8 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n     ngx_str_t                   *value;\n     ngx_uint_t                   i, hash;\n     ngx_addr_t                   addr;\n-    ngx_array_t                 *xfwd;\n     ngx_list_part_t             *part;\n-    ngx_table_elt_t             *header;\n+    ngx_table_elt_t             *header, *xfwd;\n     ngx_connection_t            *c;\n     ngx_http_realip_ctx_t       *ctx;\n     ngx_http_realip_loc_conf_t  *rlcf;\n@@ -168,9 +167,9 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n \n     case NGX_HTTP_REALIP_XFWD:\n \n-        xfwd = &r->headers_in.x_forwarded_for;\n+        xfwd = r->headers_in.x_forwarded_for;\n \n-        if (xfwd->elts == NULL) {\n+        if (xfwd == NULL) {\n             return NGX_DECLINED;\n         }\n \nDiff:\n@@ -319,10 +319,9 @@ ngx_http_userid_set_variable(ngx_http_request_t *r,\n static ngx_http_userid_ctx_t *\n ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n {\n-    ngx_int_t                n;\n-    ngx_str_t                src, dst;\n-    ngx_table_elt_t        **cookies;\n-    ngx_http_userid_ctx_t   *ctx;\n+    ngx_str_t               src, dst;\n+    ngx_table_elt_t        *cookie;\n+    ngx_http_userid_ctx_t  *ctx;\n \n     ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\n \n@@ -339,20 +338,19 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n         ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\n     }\n \n-    n = ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &conf->name,\n-                                          &ctx->cookie);\n-    if (n == NGX_DECLINED) {\n+    cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n+                                               &conf->name, &ctx->cookie);\n+    if (cookie == NULL) {\n         return ctx;\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"uid cookie: \\\"%V\\\"\", &ctx->cookie);\n \n     if (ctx->cookie.len < 22) {\n-        cookies = r->headers_in.cookies.elts;\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"client sent too short userid cookie \\\"%V\\\"\",\n-                      &cookies[n]->value);\n+                      &cookie->value);\n         return ctx;\n     }\n \n@@ -361,10 +359,9 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n     dst.data = (u_char *) ctx->uid_got;\n \n     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n-        cookies = r->headers_in.cookies.elts;\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"client sent invalid userid cookie \\\"%V\\\"\",\n-                      &cookies[n]->value);\n+                      &cookie->value);\n         return ctx;\n     }\n \nDiff:\n@@ -302,7 +302,7 @@ header_in(r, key)\n \n     if (hh) {\n \n-        if (hh->offset == offsetof(ngx_http_headers_in_t, cookies)) {\n+        if (hh->offset == offsetof(ngx_http_headers_in_t, cookie)) {\n             sep = ';';\n             goto multi;\n         }\n@@ -327,26 +327,22 @@ header_in(r, key)\n \n         /* Cookie, X-Forwarded-For */\n \n-        a = (ngx_array_t *) ((char *) &r->headers_in + hh->offset);\n-\n-        n = a->nelts;\n+        ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n-        if (n == 0) {\n+        if (*ph == NULL) {\n             XSRETURN_UNDEF;\n         }\n \n-        ph = a->elts;\n-\n-        if (n == 1) {\n+        if ((*ph)->next == NULL) {\n             ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n \n             goto done;\n         }\n \n         size = - (ssize_t) (sizeof(\"; \") - 1);\n \n-        for (i = 0; i < n; i++) {\n-            size += ph[i]->value.len + sizeof(\"; \") - 1;\n+        for (h = *ph; h; h = h->next) {\n+            size += h->value.len + sizeof(\"; \") - 1;\n         }\n \n         value = ngx_pnalloc(r->pool, size);\n@@ -357,10 +353,10 @@ header_in(r, key)\n \n         p = value;\n \n-        for (i = 0; /* void */ ; i++) {\n-            p = ngx_copy(p, ph[i]->value.data, ph[i]->value.len);\n+        for (h = *ph; h; h = h->next) {\n+            p = ngx_copy(p, h->value.data, h->value.len);\n \n-            if (i == n - 1) {\n+            if (h->next == NULL) {\n                 break;\n             }\n \nDiff:\n@@ -103,10 +103,10 @@ ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,\n     ngx_str_t *args, ngx_uint_t *flags);\n ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n     ngx_uint_t allow_underscores);\n-ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers,\n-    ngx_str_t *name, ngx_str_t *value);\n-ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers,\n-    ngx_str_t *name, ngx_str_t *value);\n+ngx_table_elt_t *ngx_http_parse_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);\n+ngx_table_elt_t *ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);\n ngx_int_t ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len,\n     ngx_str_t *value);\n void ngx_http_split_args(ngx_http_request_t *r, ngx_str_t *uri,\nDiff:\n@@ -2024,8 +2024,7 @@ ngx_http_gzip_ok(ngx_http_request_t *r)\n {\n     time_t                     date, expires;\n     ngx_uint_t                 p;\n-    ngx_array_t               *cc;\n-    ngx_table_elt_t           *e, *d, *ae;\n+    ngx_table_elt_t           *e, *d, *ae, *cc;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r->gzip_tested = 1;\n@@ -2118,30 +2117,30 @@ ngx_http_gzip_ok(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    cc = &r->headers_out.cache_control;\n+    cc = r->headers_out.cache_control;\n \n-    if (cc->elts) {\n+    if (cc) {\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_NO_CACHE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_cache,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_cache,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_NO_STORE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_store,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_store,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_PRIVATE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_private,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_private,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n@@ -2712,29 +2711,36 @@ ngx_http_set_disable_symlinks(ngx_http_request_t *r,\n \n ngx_int_t\n ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive)\n {\n-    ngx_int_t          rc;\n-    ngx_uint_t         i, found;\n-    ngx_table_elt_t  **h;\n+    ngx_int_t         rc;\n+    ngx_uint_t        found;\n+    ngx_table_elt_t  *h, *next;\n \n     if (headers == NULL) {\n         return ngx_http_get_forwarded_addr_internal(r, addr, value->data,\n                                                     value->len, proxies,\n                                                     recursive);\n     }\n \n-    i = headers->nelts;\n-    h = headers->elts;\n+    /* revert headers order */\n+\n+    for (h = headers, headers = NULL; h; h = next) {\n+        next = h->next;\n+        h->next = headers;\n+        headers = h;\n+    }\n+\n+    /* iterate over all headers in reverse order */\n \n     rc = NGX_DECLINED;\n \n     found = 0;\n \n-    while (i-- > 0) {\n-        rc = ngx_http_get_forwarded_addr_internal(r, addr, h[i]->value.data,\n-                                                  h[i]->value.len, proxies,\n+    for (h = headers; h; h = h->next) {\n+        rc = ngx_http_get_forwarded_addr_internal(r, addr, h->value.data,\n+                                                  h->value.len, proxies,\n                                                   recursive);\n \n         if (!recursive) {\n@@ -2753,6 +2759,14 @@ ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n         found = 1;\n     }\n \n+    /* restore headers order */\n+\n+    for (h = headers, headers = NULL; h; h = next) {\n+        next = h->next;\n+        h->next = headers;\n+        headers = h;\n+    }\n+\n     return rc;\n }\n \nDiff:\n@@ -532,7 +532,7 @@ ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r,\n     ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of);\n \n ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive);\n \n ngx_int_t ngx_http_link_multi_headers(ngx_http_request_t *r);\nDiff:\n@@ -1960,27 +1960,24 @@ ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,\n }\n \n \n-ngx_int_t\n-ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n-    ngx_str_t *value)\n+ngx_table_elt_t *\n+ngx_http_parse_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)\n {\n-    ngx_uint_t         i;\n-    u_char            *start, *last, *end, ch;\n-    ngx_table_elt_t  **h;\n-\n-    h = headers->elts;\n+    u_char           *start, *last, *end, ch;\n+    ngx_table_elt_t  *h;\n \n-    for (i = 0; i < headers->nelts; i++) {\n+    for (h = headers; h; h = h->next) {\n \n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,\n-                       \"parse header: \\\"%V: %V\\\"\", &h[i]->key, &h[i]->value);\n+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                       \"parse header: \\\"%V: %V\\\"\", &h->key, &h->value);\n \n-        if (name->len > h[i]->value.len) {\n+        if (name->len > h->value.len) {\n             continue;\n         }\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n         while (start < end) {\n \n@@ -1994,7 +1991,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n \n             if (value == NULL) {\n                 if (start == end || *start == ',') {\n-                    return i;\n+                    return h;\n                 }\n \n                 goto skip;\n@@ -2014,7 +2011,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n             value->len = last - start;\n             value->data = start;\n \n-            return i;\n+            return h;\n \n         skip:\n \n@@ -2029,31 +2026,28 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n         }\n     }\n \n-    return NGX_DECLINED;\n+    return NULL;\n }\n \n \n-ngx_int_t\n-ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,\n-    ngx_str_t *value)\n+ngx_table_elt_t *\n+ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)\n {\n-    ngx_uint_t         i;\n-    u_char            *start, *last, *end;\n-    ngx_table_elt_t  **h;\n-\n-    h = headers->elts;\n+    u_char           *start, *last, *end;\n+    ngx_table_elt_t  *h;\n \n-    for (i = 0; i < headers->nelts; i++) {\n+    for (h = headers; h; h = h->next) {\n \n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,\n-                       \"parse header: \\\"%V: %V\\\"\", &h[i]->key, &h[i]->value);\n+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                       \"parse header: \\\"%V: %V\\\"\", &h->key, &h->value);\n \n-        if (name->len >= h[i]->value.len) {\n+        if (name->len >= h->value.len) {\n             continue;\n         }\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n         if (ngx_strncasecmp(start, name->data, name->len) != 0) {\n             continue;\n@@ -2077,10 +2071,10 @@ ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,\n         value->len = last - start;\n         value->data = start;\n \n-        return i;\n+        return h;\n     }\n \n-    return NGX_DECLINED;\n+    return NULL;\n }\n \n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,\n     ngx_http_request_t *r, ngx_http_core_srv_conf_t **cscfp);\n \n static void ngx_http_request_handler(ngx_event_t *ev);\n+static ngx_int_t ngx_http_trace_handler(ngx_http_request_t *r);\n static void ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc);\n static void ngx_http_terminate_handler(ngx_http_request_t *r);\n static void ngx_http_finalize_connection(ngx_http_request_t *r);\n@@ -205,7 +206,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  ngx_http_process_header_line },\n #endif\n \n-    { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookies),\n+    { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookie),\n                  ngx_http_process_multi_header_lines },\n \n     { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n@@ -1768,6 +1769,7 @@ ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -1784,6 +1786,7 @@ ngx_http_process_unique_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n         return NGX_OK;\n     }\n \n@@ -1816,6 +1819,7 @@ ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     r->headers_in.host = h;\n+    h->next = NULL;\n \n     host = h->value;\n \n@@ -1877,6 +1881,7 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     r->headers_in.user_agent = h;\n+    h->next = NULL;\n \n     /* check some widespread browsers while the header is in CPU cache */\n \n@@ -1943,34 +1948,24 @@ static ngx_int_t\n ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_array_t       *headers;\n     ngx_table_elt_t  **ph;\n \n-    headers = (ngx_array_t *) ((char *) &r->headers_in + offset);\n-\n-    if (headers->elts == NULL) {\n-        if (ngx_array_init(headers, r->pool, 1, sizeof(ngx_table_elt_t *))\n-            != NGX_OK)\n-        {\n-            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-            return NGX_ERROR;\n-        }\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n \n-    ph = ngx_array_push(headers);\n-    if (ph == NULL) {\n-        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n+\n     return NGX_OK;\n }\n \n \n ngx_int_t\n ngx_http_process_request_header(ngx_http_request_t *r)\n {\n+    ngx_core_conf_t *ccf = (ngx_core_conf_t *) ngx_get_conf(r->cycle->conf_ctx, ngx_core_module);\n+\n     if (r->headers_in.server.len == 0\n         && ngx_http_set_virtual_server(r, &r->headers_in.server)\n            == NGX_ERROR)\n@@ -2049,8 +2044,12 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n     if (r->method == NGX_HTTP_TRACE) {\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                       \"client sent TRACE method\");\n-        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n-        return NGX_ERROR;\n+          if (ccf->trace_enable != -1) {\n+               return ngx_http_trace_handler(r);\n+          } else {\n+               ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+               return NGX_ERROR;\n+          }\n     }\n \n     return NGX_OK;\n@@ -4049,3 +4048,65 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     return NGX_OK;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_trace_handler(ngx_http_request_t *r)\n+{\n+    ngx_list_part_t *part;\n+    ngx_table_elt_t *header;\n+    ngx_buf_t *b;\n+    ngx_chain_t out;\n+    ngx_int_t rc, content_len;\n+\n+    b = ngx_create_temp_buf(r->pool, 200);\n+    if (b == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);\n+    *b->last++ = '\\n';\n+\n+    content_len = r->request_line.len + 1;\n+\n+    part = &r->headers_in.headers.part;\n+    header = part->elts;\n+    for (ngx_uint_t i = 0; ; i++) {\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                b->last_buf = 1;\n+                break;\n+            }\n+            part = part->next;\n+            header = part->elts;\n+            i = 0;\n+        }\n+\n+        size_t header_len = header[i].key.len + header[i].value.len + 3;\n+        content_len += header_len;\n+\n+        b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n+        *b->last++ = ':';\n+        *b->last++ = ' ';\n+        b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);\n+        *b->last++ = '\\n';\n+    }\n+\n+    ngx_str_t ct = ngx_string(\"message/http\");\n+    r->headers_out.status = NGX_HTTP_OK;\n+    r->headers_out.content_type = ct;\n+    r->headers_out.content_length_n = content_len;\n+    rc = ngx_http_send_header(r);\n+\n+    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n+        return rc;\n+    }\n+\n+    out.buf = b;\n+    out.next = NULL;\n+\n+    rc = ngx_http_output_filter(r, &out);\n+    ngx_http_close_request(r, rc);\n+\n+    return NGX_DONE;\n+}\nDiff:\n@@ -214,7 +214,7 @@ typedef struct {\n     ngx_table_elt_t                  *keep_alive;\n \n #if (NGX_HTTP_X_FORWARDED_FOR)\n-    ngx_array_t                       x_forwarded_for;\n+    ngx_table_elt_t                  *x_forwarded_for;\n #endif\n \n #if (NGX_HTTP_REALIP)\n@@ -233,11 +233,11 @@ typedef struct {\n     ngx_table_elt_t                  *date;\n #endif\n \n+    ngx_table_elt_t                  *cookie;\n+\n     ngx_str_t                         user;\n     ngx_str_t                         passwd;\n \n-    ngx_array_t                       cookies;\n-\n     ngx_str_t                         server;\n     off_t                             content_length_n;\n     time_t                            keep_alive_n;\n@@ -279,6 +279,9 @@ typedef struct {\n     ngx_table_elt_t                  *expires;\n     ngx_table_elt_t                  *etag;\n \n+    ngx_table_elt_t                  *cache_control;\n+    ngx_table_elt_t                  *link;\n+\n     ngx_str_t                        *override_charset;\n \n     size_t                            content_type_len;\n@@ -287,9 +290,6 @@ typedef struct {\n     u_char                           *content_type_lowcase;\n     ngx_uint_t                        content_type_hash;\n \n-    ngx_array_t                       cache_control;\n-    ngx_array_t                       link;\n-\n     off_t                             content_length_n;\n     off_t                             content_offset;\n     time_t                            date_time;\nDiff:\n@@ -246,7 +246,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n \n     { ngx_string(\"Set-Cookie\"),\n                  ngx_http_upstream_process_set_cookie,\n-                 offsetof(ngx_http_upstream_headers_in_t, cookies),\n+                 offsetof(ngx_http_upstream_headers_in_t, set_cookie),\n                  ngx_http_upstream_rewrite_set_cookie, 0, 1 },\n \n     { ngx_string(\"Content-Disposition\"),\n@@ -4666,26 +4666,16 @@ static ngx_int_t\n ngx_http_upstream_process_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_array_t           *pa;\n     ngx_table_elt_t      **ph;\n     ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    pa = &u->headers_in.cookies;\n+    ph = &u->headers_in.set_cookie;\n \n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     if (!(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_SET_COOKIE)) {\n@@ -4701,26 +4691,16 @@ static ngx_int_t\n ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_array_t          *pa;\n     ngx_table_elt_t     **ph;\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n-    pa = &u->headers_in.cache_control;\n+    ph = &u->headers_in.cache_control;\n \n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -5103,31 +5083,21 @@ static ngx_int_t\n ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_array_t      *pa;\n     ngx_table_elt_t  *ho, **ph;\n \n-    pa = (ngx_array_t *) ((char *) &r->headers_out + offset);\n-\n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n     ho = ngx_list_push(&r->headers_out.headers);\n     if (ho == NULL) {\n         return NGX_ERROR;\n     }\n \n     *ho = *h;\n \n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = ho;\n+    ho->next = NULL;\n \n     return NGX_OK;\n }\n@@ -5740,9 +5710,9 @@ ngx_http_upstream_cookie_variable(ngx_http_request_t *r,\n     s.len = name->len - (sizeof(\"upstream_cookie_\") - 1);\n     s.data = name->data + sizeof(\"upstream_cookie_\") - 1;\n \n-    if (ngx_http_parse_set_cookie_lines(&r->upstream->headers_in.cookies,\n+    if (ngx_http_parse_set_cookie_lines(r, r->upstream->headers_in.set_cookie,\n                                         &s, &cookie)\n-        == NGX_DECLINED)\n+        == NULL)\n     {\n         v->not_found = 1;\n         return NGX_OK;\nDiff:\n@@ -289,8 +289,8 @@ typedef struct {\n     ngx_table_elt_t                 *content_encoding;\n #endif\n \n-    ngx_array_t                      cache_control;\n-    ngx_array_t                      cookies;\n+    ngx_table_elt_t                 *cache_control;\n+    ngx_table_elt_t                 *set_cookie;\n \n     off_t                            content_length_n;\n     time_t                           last_modified_time;\nDiff:\n@@ -187,7 +187,7 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n #endif\n \n     { ngx_string(\"http_cookie\"), NULL, ngx_http_variable_cookies,\n-      offsetof(ngx_http_request_t, headers_in.cookies), 0, 0 },\n+      offsetof(ngx_http_request_t, headers_in.cookie), 0, 0 },\n \n     { ngx_string(\"content_length\"), NULL, ngx_http_variable_content_length,\n       0, 0, 0 },\n@@ -856,26 +856,21 @@ static ngx_int_t\n ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep)\n {\n-    size_t             len;\n-    u_char            *p, *end;\n-    ngx_uint_t         i, n;\n-    ngx_array_t       *a;\n-    ngx_table_elt_t  **h;\n-\n-    a = (ngx_array_t *) ((char *) r + data);\n+    size_t            len;\n+    u_char           *p;\n+    ngx_table_elt_t  *h, *th;\n \n-    n = a->nelts;\n-    h = a->elts;\n+    h = *(ngx_table_elt_t **) ((char *) r + data);\n \n     len = 0;\n \n-    for (i = 0; i < n; i++) {\n+    for (th = h; th; th = th->next) {\n \n-        if (h[i]->hash == 0) {\n+        if (th->hash == 0) {\n             continue;\n         }\n \n-        len += h[i]->value.len + 2;\n+        len += th->value.len + 2;\n     }\n \n     if (len == 0) {\n@@ -889,9 +884,9 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     v->no_cacheable = 0;\n     v->not_found = 0;\n \n-    if (n == 1) {\n-        v->len = (*h)->value.len;\n-        v->data = (*h)->value.data;\n+    if (h->next == NULL) {\n+        v->len = h->value.len;\n+        v->data = h->value.data;\n \n         return NGX_OK;\n     }\n@@ -904,17 +899,15 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     v->len = len;\n     v->data = p;\n \n-    end = p + len;\n-\n-    for (i = 0; /* void */ ; i++) {\n+    for (th = h; th; th = th->next) {\n \n-        if (h[i]->hash == 0) {\n+        if (th->hash == 0) {\n             continue;\n         }\n \n-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);\n+        p = ngx_copy(p, th->value.data, th->value.len);\n \n-        if (p == end) {\n+        if (th->next == NULL) {\n             break;\n         }\n \n@@ -1112,8 +1105,8 @@ ngx_http_variable_cookie(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     s.len = name->len - (sizeof(\"cookie_\") - 1);\n     s.data = name->data + sizeof(\"cookie_\") - 1;\n \n-    if (ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &s, &cookie)\n-        == NGX_DECLINED)\n+    if (ngx_http_parse_multi_header_lines(r, r->headers_in.cookie, &s, &cookie)\n+        == NULL)\n     {\n         v->not_found = 1;\n         return NGX_OK;\nDiff:\n@@ -674,14 +674,14 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_v2_push_resources(ngx_http_request_t *r)\n {\n-    u_char                     *start, *end, *last;\n-    ngx_int_t                   rc;\n-    ngx_str_t                   path;\n-    ngx_uint_t                  i, push;\n-    ngx_table_elt_t           **h;\n-    ngx_http_v2_loc_conf_t     *h2lcf;\n-    ngx_http_complex_value_t   *pushes;\n-    ngx_str_t                   binary[NGX_HTTP_V2_PUSH_HEADERS];\n+    u_char                    *start, *end, *last;\n+    ngx_int_t                  rc;\n+    ngx_str_t                  path;\n+    ngx_uint_t                 i, push;\n+    ngx_table_elt_t           *h;\n+    ngx_http_v2_loc_conf_t    *h2lcf;\n+    ngx_http_complex_value_t  *pushes;\n+    ngx_str_t                  binary[NGX_HTTP_V2_PUSH_HEADERS];\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http2 push resources\");\n@@ -725,15 +725,13 @@ ngx_http_v2_push_resources(ngx_http_request_t *r)\n         return NGX_OK;\n     }\n \n-    h = r->headers_out.link.elts;\n-\n-    for (i = 0; i < r->headers_out.link.nelts; i++) {\n+    for (h = r->headers_out.link; h; h = h->next) {\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"http2 parse link: \\\"%V\\\"\", &h[i]->value);\n+                       \"http2 parse link: \\\"%V\\\"\", &h->value);\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n     next_link:\n \n"
    },
    {
        "commit_sha": "8a3b9ec5de6b9b099ce69603820c539a55d8c86b",
        "commit_index": "Commit 152",
        "commit_diff": "Diff:\n@@ -5703,7 +5703,7 @@ ngx_http_upstream_header_variable(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                          &r->upstream->headers_in.headers.part,\n                                          sizeof(\"upstream_http_\") - 1);\n }\n@@ -5718,7 +5718,7 @@ ngx_http_upstream_trailer_variable(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                         &r->upstream->headers_in.trailers.part,\n                                         sizeof(\"upstream_trailer_\") - 1);\n }\nDiff:\n@@ -929,7 +929,7 @@ static ngx_int_t\n ngx_http_variable_unknown_header_in(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                             &r->headers_in.headers.part,\n                                             sizeof(\"http_\") - 1);\n }\n@@ -939,7 +939,7 @@ static ngx_int_t\n ngx_http_variable_unknown_header_out(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                             &r->headers_out.headers.part,\n                                             sizeof(\"sent_http_\") - 1);\n }\n@@ -949,19 +949,26 @@ static ngx_int_t\n ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                             &r->headers_out.trailers.part,\n                                             sizeof(\"sent_trailer_\") - 1);\n }\n \n \n ngx_int_t\n-ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,\n+ngx_http_variable_unknown_header(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, ngx_str_t *var,\n     ngx_list_part_t *part, size_t prefix)\n {\n-    u_char            ch;\n+    u_char           *p, ch;\n+    size_t            len;\n     ngx_uint_t        i, n;\n-    ngx_table_elt_t  *header;\n+    ngx_table_elt_t  *header, *h, **ph;\n+\n+    ph = &h;\n+#if (NGX_SUPPRESS_WARN)\n+    len = 0;\n+#endif\n \n     header = part->elts;\n \n@@ -981,7 +988,11 @@ ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,\n             continue;\n         }\n \n-        for (n = 0; n + prefix < var->len && n < header[i].key.len; n++) {\n+        if (header[i].key.len != var->len - prefix) {\n+            continue;\n+        }\n+\n+        for (n = 0; n < var->len - prefix; n++) {\n             ch = header[i].key.data[n];\n \n             if (ch >= 'A' && ch <= 'Z') {\n@@ -996,18 +1007,59 @@ ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,\n             }\n         }\n \n-        if (n + prefix == var->len && n == header[i].key.len) {\n-            v->len = header[i].value.len;\n-            v->valid = 1;\n-            v->no_cacheable = 0;\n-            v->not_found = 0;\n-            v->data = header[i].value.data;\n-\n-            return NGX_OK;\n+        if (n != var->len - prefix) {\n+            continue;\n         }\n+\n+        len += header[i].value.len + 2;\n+\n+        *ph = &header[i];\n+        ph = &header[i].next;\n     }\n \n-    v->not_found = 1;\n+    *ph = NULL;\n+\n+    if (h == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    len -= 2;\n+\n+    if (h->next == NULL) {\n+\n+        v->len = h->value.len;\n+        v->valid = 1;\n+        v->no_cacheable = 0;\n+        v->not_found = 0;\n+        v->data = h->value.data;\n+\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_pnalloc(r->pool, len);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    v->len = len;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = p;\n+\n+    for ( ;; ) {\n+\n+        p = ngx_copy(p, h->value.data, h->value.len);\n+\n+        if (h->next == NULL) {\n+            break;\n+        }\n+\n+        *p++ = ','; *p++ = ' ';\n+\n+        h = h->next;\n+    }\n \n     return NGX_OK;\n }\n@@ -1889,7 +1941,7 @@ ngx_http_variable_sent_location(ngx_http_request_t *r,\n \n     ngx_str_set(&name, \"sent_http_location\");\n \n-    return ngx_http_variable_unknown_header(v, &name,\n+    return ngx_http_variable_unknown_header(r, v, &name,\n                                             &r->headers_out.headers.part,\n                                             sizeof(\"sent_http_\") - 1);\n }\nDiff:\n@@ -57,8 +57,9 @@ ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r,\n ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r,\n     ngx_str_t *name, ngx_uint_t key);\n \n-ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v,\n-    ngx_str_t *var, ngx_list_part_t *part, size_t prefix);\n+ngx_int_t ngx_http_variable_unknown_header(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, ngx_str_t *var, ngx_list_part_t *part,\n+    size_t prefix);\n \n \n #if (NGX_PCRE)\n"
    },
    {
        "commit_sha": "e62fcf622a4141fd042496167b6ae1ad7b475672",
        "commit_index": "Commit 151",
        "commit_diff": "Diff:\n@@ -89,12 +89,15 @@ typedef struct {\n } ngx_hash_keys_arrays_t;\n \n \n-typedef struct {\n+typedef struct ngx_table_elt_s  ngx_table_elt_t;\n+\n+struct ngx_table_elt_s {\n     ngx_uint_t        hash;\n     ngx_str_t         key;\n     ngx_str_t         value;\n     u_char           *lowcase_key;\n-} ngx_table_elt_t;\n+    ngx_table_elt_t  *next;\n+};\n \n \n void *ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len);\nDiff:\n@@ -835,14 +835,14 @@ static ngx_int_t\n ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n {\n     off_t                         file_pos;\n-    u_char                        ch, *pos, *lowcase_key;\n+    u_char                        ch, sep, *pos, *lowcase_key;\n     size_t                        size, len, key_len, val_len, padding,\n                                   allocated;\n     ngx_uint_t                    i, n, next, hash, skip_empty, header_params;\n     ngx_buf_t                    *b;\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n-    ngx_table_elt_t              *header, **ignored;\n+    ngx_table_elt_t              *header, *hn, **ignored;\n     ngx_http_upstream_t          *u;\n     ngx_http_script_code_pt       code;\n     ngx_http_script_engine_t      e, le;\n@@ -900,7 +900,11 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n         allocated = 0;\n         lowcase_key = NULL;\n \n-        if (params->number) {\n+        if (ngx_http_link_multi_headers(r) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (params->number || r->headers_in.multi) {\n             n = 0;\n             part = &r->headers_in.headers.part;\n \n@@ -930,6 +934,12 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n                 i = 0;\n             }\n \n+            for (n = 0; n < header_params; n++) {\n+                if (&header[i] == ignored[n]) {\n+                    goto next_length;\n+                }\n+            }\n+\n             if (params->number) {\n                 if (allocated < header[i].key.len) {\n                     allocated = header[i].key.len + 16;\n@@ -959,15 +969,23 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n                     ignored[header_params++] = &header[i];\n                     continue;\n                 }\n+            }\n \n-                n += sizeof(\"HTTP_\") - 1;\n+            key_len = sizeof(\"HTTP_\") - 1 + header[i].key.len;\n \n-            } else {\n-                n = sizeof(\"HTTP_\") - 1 + header[i].key.len;\n+            val_len = header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                val_len += hn->value.len + 2;\n+                ignored[header_params++] = hn;\n             }\n \n-            len += ((n > 127) ? 4 : 1) + ((header[i].value.len > 127) ? 4 : 1)\n-                + n + header[i].value.len;\n+            len += ((key_len > 127) ? 4 : 1) + key_len\n+                   + ((val_len > 127) ? 4 : 1) + val_len;\n+\n+        next_length:\n+\n+            continue;\n         }\n     }\n \n@@ -1109,7 +1127,7 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n \n             for (n = 0; n < header_params; n++) {\n                 if (&header[i] == ignored[n]) {\n-                    goto next;\n+                    goto next_value;\n                 }\n             }\n \n@@ -1125,6 +1143,11 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n             }\n \n             val_len = header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                val_len += hn->value.len + 2;\n+            }\n+\n             if (val_len > 127) {\n                 *b->last++ = (u_char) (((val_len >> 24) & 0x7f) | 0x80);\n                 *b->last++ = (u_char) ((val_len >> 16) & 0xff);\n@@ -1150,13 +1173,34 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n                 *b->last++ = ch;\n             }\n \n-            b->last = ngx_copy(b->last, header[i].value.data, val_len);\n+            b->last = ngx_copy(b->last, header[i].value.data,\n+                               header[i].value.len);\n+\n+            if (header[i].next) {\n+\n+                if (header[i].key.len == sizeof(\"Cookie\") - 1\n+                    && ngx_strncasecmp(header[i].key.data, (u_char *) \"Cookie\",\n+                                       sizeof(\"Cookie\") - 1)\n+                       == 0)\n+                {\n+                    sep = ';';\n+\n+                } else {\n+                    sep = ',';\n+                }\n+\n+                for (hn = header[i].next; hn; hn = hn->next) {\n+                    *b->last++ = sep;\n+                    *b->last++ = ' ';\n+                    b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n+                }\n+            }\n \n             ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                            \"fastcgi param: \\\"%*s: %*s\\\"\",\n                            key_len, b->last - (key_len + val_len),\n                            val_len, b->last - val_len);\n-        next:\n+        next_value:\n \n             continue;\n         }\nDiff:\n@@ -633,14 +633,14 @@ static ngx_int_t\n ngx_http_scgi_create_request(ngx_http_request_t *r)\n {\n     off_t                         content_length_n;\n-    u_char                        ch, *key, *val, *lowcase_key;\n+    u_char                        ch, sep, *key, *val, *lowcase_key;\n     size_t                        len, key_len, val_len, allocated;\n     ngx_buf_t                    *b;\n     ngx_str_t                     content_length;\n     ngx_uint_t                    i, n, hash, skip_empty, header_params;\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n-    ngx_table_elt_t              *header, **ignored;\n+    ngx_table_elt_t              *header, *hn, **ignored;\n     ngx_http_scgi_params_t       *params;\n     ngx_http_script_code_pt       code;\n     ngx_http_script_engine_t      e, le;\n@@ -707,7 +707,11 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n         allocated = 0;\n         lowcase_key = NULL;\n \n-        if (params->number) {\n+        if (ngx_http_link_multi_headers(r) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (params->number || r->headers_in.multi) {\n             n = 0;\n             part = &r->headers_in.headers.part;\n \n@@ -737,6 +741,12 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n                 i = 0;\n             }\n \n+            for (n = 0; n < header_params; n++) {\n+                if (&header[i] == ignored[n]) {\n+                    goto next_length;\n+                }\n+            }\n+\n             if (params->number) {\n                 if (allocated < header[i].key.len) {\n                     allocated = header[i].key.len + 16;\n@@ -770,6 +780,15 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n \n             len += sizeof(\"HTTP_\") - 1 + header[i].key.len + 1\n                 + header[i].value.len + 1;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                len += hn->value.len + 2;\n+                ignored[header_params++] = hn;\n+            }\n+\n+        next_length:\n+\n+            continue;\n         }\n     }\n \n@@ -869,7 +888,7 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n \n             for (n = 0; n < header_params; n++) {\n                 if (&header[i] == ignored[n]) {\n-                    goto next;\n+                    goto next_value;\n                 }\n             }\n \n@@ -893,12 +912,33 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n \n             val = b->last;\n             b->last = ngx_copy(val, header[i].value.data, header[i].value.len);\n+\n+            if (header[i].next) {\n+\n+                if (header[i].key.len == sizeof(\"Cookie\") - 1\n+                    && ngx_strncasecmp(header[i].key.data, (u_char *) \"Cookie\",\n+                                       sizeof(\"Cookie\") - 1)\n+                       == 0)\n+                {\n+                    sep = ';';\n+\n+                } else {\n+                    sep = ',';\n+                }\n+\n+                for (hn = header[i].next; hn; hn = hn->next) {\n+                    *b->last++ = sep;\n+                    *b->last++ = ' ';\n+                    b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n+                }\n+            }\n+\n             *b->last++ = (u_char) 0;\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                            \"scgi param: \\\"%s: %s\\\"\", key, val);\n \n-        next:\n+        next_value:\n \n             continue;\n         }\nDiff:\n@@ -845,13 +845,13 @@ ngx_http_uwsgi_create_key(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n {\n-    u_char                        ch, *lowcase_key;\n+    u_char                        ch, sep, *lowcase_key;\n     size_t                        key_len, val_len, len, allocated;\n     ngx_uint_t                    i, n, hash, skip_empty, header_params;\n     ngx_buf_t                    *b;\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n-    ngx_table_elt_t              *header, **ignored;\n+    ngx_table_elt_t              *header, *hn, **ignored;\n     ngx_http_uwsgi_params_t      *params;\n     ngx_http_script_code_pt       code;\n     ngx_http_script_engine_t      e, le;\n@@ -905,7 +905,11 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n         allocated = 0;\n         lowcase_key = NULL;\n \n-        if (params->number) {\n+        if (ngx_http_link_multi_headers(r) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (params->number || r->headers_in.multi) {\n             n = 0;\n             part = &r->headers_in.headers.part;\n \n@@ -935,6 +939,12 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n                 i = 0;\n             }\n \n+            for (n = 0; n < header_params; n++) {\n+                if (&header[i] == ignored[n]) {\n+                    goto next_length;\n+                }\n+            }\n+\n             if (params->number) {\n                 if (allocated < header[i].key.len) {\n                     allocated = header[i].key.len + 16;\n@@ -968,6 +978,15 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n \n             len += 2 + sizeof(\"HTTP_\") - 1 + header[i].key.len\n                  + 2 + header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                len += hn->value.len + 2;\n+                ignored[header_params++] = hn;\n+            }\n+\n+        next_length:\n+\n+            continue;\n         }\n     }\n \n@@ -1086,7 +1105,7 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n \n             for (n = 0; n < header_params; n++) {\n                 if (&header[i] == ignored[n]) {\n-                    goto next;\n+                    goto next_value;\n                 }\n             }\n \n@@ -1109,15 +1128,41 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n             }\n \n             val_len = header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                val_len += hn->value.len + 2;\n+            }\n+\n             *b->last++ = (u_char) (val_len & 0xff);\n             *b->last++ = (u_char) ((val_len >> 8) & 0xff);\n-            b->last = ngx_copy(b->last, header[i].value.data, val_len);\n+            b->last = ngx_copy(b->last, header[i].value.data,\n+                               header[i].value.len);\n+\n+            if (header[i].next) {\n+\n+                if (header[i].key.len == sizeof(\"Cookie\") - 1\n+                    && ngx_strncasecmp(header[i].key.data, (u_char *) \"Cookie\",\n+                                       sizeof(\"Cookie\") - 1)\n+                       == 0)\n+                {\n+                    sep = ';';\n+\n+                } else {\n+                    sep = ',';\n+                }\n+\n+                for (hn = header[i].next; hn; hn = hn->next) {\n+                    *b->last++ = sep;\n+                    *b->last++ = ' ';\n+                    b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n+                }\n+            }\n \n             ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                            \"uwsgi param: \\\"%*s: %*s\\\"\",\n                            key_len, b->last - (key_len + 2 + val_len),\n                            val_len, b->last - val_len);\n-        next:\n+        next_value:\n \n             continue;\n         }\nDiff:\n@@ -2802,6 +2802,80 @@ ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r, ngx_addr_t *addr,\n }\n \n \n+ngx_int_t\n+ngx_http_link_multi_headers(ngx_http_request_t *r)\n+{\n+    ngx_uint_t        i, j;\n+    ngx_list_part_t  *part, *ppart;\n+    ngx_table_elt_t  *header, *pheader, **ph;\n+\n+    if (r->headers_in.multi_linked) {\n+        return NGX_OK;\n+    }\n+\n+    r->headers_in.multi_linked = 1;\n+\n+    part = &r->headers_in.headers.part;\n+    header = part->elts;\n+\n+    for (i = 0; /* void */; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+\n+            part = part->next;\n+            header = part->elts;\n+            i = 0;\n+        }\n+\n+        header[i].next = NULL;\n+\n+        /*\n+         * search for previous headers with the same name;\n+         * if there are any, link to them\n+         */\n+\n+        ppart = &r->headers_in.headers.part;\n+        pheader = ppart->elts;\n+\n+        for (j = 0; /* void */; j++) {\n+\n+            if (j >= ppart->nelts) {\n+                if (ppart->next == NULL) {\n+                    break;\n+                }\n+\n+                ppart = ppart->next;\n+                pheader = ppart->elts;\n+                j = 0;\n+            }\n+\n+            if (part == ppart && i == j) {\n+                break;\n+            }\n+\n+            if (header[i].key.len == pheader[j].key.len\n+                && ngx_strncasecmp(header[i].key.data, pheader[j].key.data,\n+                                   header[i].key.len)\n+                   == 0)\n+            {\n+                ph = &pheader[j].next;\n+                while (*ph) { ph = &(*ph)->next; }\n+                *ph = &header[i];\n+\n+                r->headers_in.multi = 1;\n+\n+                break;\n+            }\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static char *\n ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)\n {\nDiff:\n@@ -535,6 +535,8 @@ ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n     ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive);\n \n+ngx_int_t ngx_http_link_multi_headers(ngx_http_request_t *r);\n+\n \n extern ngx_module_t  ngx_http_core_module;\n \nDiff:\n@@ -247,6 +247,8 @@ typedef struct {\n \n     unsigned                          connection_type:2;\n     unsigned                          chunked:1;\n+    unsigned                          multi:1;\n+    unsigned                          multi_linked:1;\n     unsigned                          msie:1;\n     unsigned                          msie6:1;\n     unsigned                          opera:1;\n"
    },
    {
        "commit_sha": "bc21f8cf43a48eb78485bcb74df61d9ac693359b",
        "commit_index": "Commit 150",
        "commit_diff": "Diff:\n@@ -1851,6 +1851,10 @@ static ngx_int_t\n ngx_http_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n+    if (ngx_http_process_header_line(r, h, offset) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n     if (ngx_strcasestrn(h->value.data, \"close\", 5 - 1)) {\n         r->headers_in.connection_type = NGX_HTTP_CONNECTION_CLOSE;\n \nDiff:\n@@ -55,7 +55,9 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n \n #if (NGX_HAVE_EPOLLRDHUP)\n \n-    if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+    if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n+        && ngx_use_epoll_rdhup)\n+    {\n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                        \"readv: eof:%d, avail:%d\",\n                        rev->pending_eof, rev->available);\nDiff:\n@@ -52,7 +52,9 @@ ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size)\n \n #if (NGX_HAVE_EPOLLRDHUP)\n \n-    if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+    if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n+        && ngx_use_epoll_rdhup)\n+    {\n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                        \"recv: eof:%d, avail:%d\",\n                        rev->pending_eof, rev->available);\n"
    },
    {
        "commit_sha": "11faa5211fda0e8d5b67196b9f258aa9e46024b9",
        "commit_index": "Commit 149",
        "commit_diff": "Diff:\n@@ -110,7 +110,7 @@ case \"$NGX_MACHINE\" in\n         NGX_MACH_CACHE_LINE=64\n     ;;\n \n-    aarch64 )\n+    aarch64 | arm64)\n         have=NGX_ALIGNMENT value=16 . auto/define\n         NGX_MACH_CACHE_LINE=64\n     ;;\nDiff:\n@@ -6,8 +6,8 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1m\n-ZLIB =\t\tzlib-1.2.11\n+OPENSSL =\topenssl-1.1.1o\n+ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021007\n-#define NGINX_VERSION      \"1.21.7\"\n+#define nginx_version      1023000\n+#define NGINX_VERSION      \"1.23.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "0458fc1b435ae514598afa12b7d8554b84f8cd7a",
        "commit_index": "Commit 148",
        "commit_diff": "Diff:\n@@ -1,6 +1,6 @@\n /* \n  * Copyright (C) 2002-2021 Igor Sysoev\n- * Copyright (C) 2011-2021 Nginx, Inc.\n+ * Copyright (C) 2011-2022 Nginx, Inc.\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\nDiff:\n@@ -3385,6 +3385,12 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n             || n == SSL_R_WRONG_VERSION_NUMBER                       /*  267 */\n             || n == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC        /*  281 */\n+#ifdef SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY\n+            || n == SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY        /*  291 */\n+#endif\n+#ifdef SSL_R_APPLICATION_DATA_ON_SHUTDOWN\n+            || n == SSL_R_APPLICATION_DATA_ON_SHUTDOWN               /*  291 */\n+#endif\n #ifdef SSL_R_RENEGOTIATE_EXT_TOO_LONG\n             || n == SSL_R_RENEGOTIATE_EXT_TOO_LONG                   /*  335 */\n             || n == SSL_R_RENEGOTIATION_ENCODING_ERR                 /*  336 */\nDiff:\n@@ -153,12 +153,12 @@ struct ngx_http_v2_connection_s {\n     ngx_queue_t                      dependencies;\n     ngx_queue_t                      closed;\n \n+    ngx_uint_t                       closed_nodes;\n     ngx_uint_t                       last_sid;\n     ngx_uint_t                       last_push;\n \n     time_t                           lingering_time;\n \n-    unsigned                         closed_nodes:8;\n     unsigned                         settings_ack:1;\n     unsigned                         table_update:1;\n     unsigned                         blocked:1;\n"
    },
    {
        "commit_sha": "7078391b0baba914c3cb61328de1770a0e2345c0",
        "commit_index": "Commit 147",
        "commit_diff": "Diff:\n@@ -186,6 +186,7 @@ struct ngx_connection_s {\n     unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */\n \n     unsigned            need_last_buf:1;\n+    unsigned            need_flush_buf:1;\n \n #if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)\n     unsigned            busy_count:2;\nDiff:\n@@ -179,6 +179,8 @@ ngx_event_connect_peer(ngx_peer_connection_t *pc)\n         c->recv = ngx_udp_recv;\n         c->send = ngx_send;\n         c->send_chain = ngx_udp_send_chain;\n+\n+        c->need_flush_buf = 1;\n     }\n \n     c->log_error = pc->log_error;\nDiff:\n@@ -246,6 +246,8 @@ ngx_event_recvmsg(ngx_event_t *ev)\n         c->send = ngx_udp_send;\n         c->send_chain = ngx_udp_send_chain;\n \n+        c->need_flush_buf = 1;\n+\n         c->log = log;\n         c->pool->log = log;\n         c->listening = ls;\nDiff:\n@@ -227,7 +227,8 @@ ngx_http_write_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     if (size == 0\n         && !(c->buffered & NGX_LOWLEVEL_BUFFERED)\n-        && !(last && c->need_last_buf))\n+        && !(last && c->need_last_buf)\n+        && !(flush && c->need_flush_buf))\n     {\n         if (last || flush || sync) {\n             for (cl = r->out; cl; /* void */) {\nDiff:\n@@ -665,6 +665,7 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)\n \n     fc->send_chain = ngx_http_v2_send_chain;\n     fc->need_last_buf = 1;\n+    fc->need_flush_buf = 1;\n \n     return ngx_http_v2_filter_send(fc, stream);\n }\n@@ -1815,7 +1816,11 @@ ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,\n static ngx_inline ngx_int_t\n ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)\n {\n-    if (stream->queued == 0) {\n+    ngx_connection_t  *c;\n+\n+    c = stream->connection->connection;\n+\n+    if (stream->queued == 0 && !c->buffered) {\n         fc->buffered &= ~NGX_HTTP_V2_BUFFERED;\n         return NGX_OK;\n     }\nDiff:\n@@ -235,7 +235,7 @@ ngx_stream_write_filter(ngx_stream_session_t *s, ngx_chain_t *in,\n     if (size == 0\n         && !(c->buffered & NGX_LOWLEVEL_BUFFERED)\n         && !(last && c->need_last_buf)\n-        && !(c->type == SOCK_DGRAM && flush))\n+        && !(flush && c->need_flush_buf))\n     {\n         if (last || flush || sync) {\n             for (cl = *out; cl; /* void */) {\n"
    },
    {
        "commit_sha": "031de25957a222415570b151ab4953877350ebaf",
        "commit_index": "Commit 146",
        "commit_diff": "Diff:\n@@ -232,4 +232,20 @@ ngx_feature_test=\"struct crypt_data  cd;\n ngx_include=\"sys/vfs.h\";     . auto/include\n \n \n+# UDP segmentation offloading\n+\n+ngx_feature=\"UDP_SEGMENT\"\n+ngx_feature_name=\"NGX_HAVE_UDP_SEGMENT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <stdint.h>\n+                  #include <netinet/udp.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"socklen_t optlen = sizeof(int);\n+                  int val;\n+                  getsockopt(0, SOL_UDP, UDP_SEGMENT, &val, &optlen)\"\n+. auto/feature\n+\n+\n CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\"\nDiff:\n@@ -1756,6 +1756,11 @@ ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache)\n             break;\n         }\n \n+        if (fcn->deleting) {\n+            wait = 1;\n+            break;\n+        }\n+\n         p = ngx_hex_dump(key, (u_char *) &fcn->node.key,\n                          sizeof(ngx_rbtree_key_t));\n         len = NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t);\nDiff:\n@@ -103,6 +103,10 @@ typedef struct iocb  ngx_aiocb_t;\n #include <linux/capability.h>\n #endif\n \n+#if (NGX_HAVE_UDP_SEGMENT)\n+#include <netinet/udp.h>\n+#endif\n+\n \n #define NGX_LISTEN_BACKLOG        511\n \n"
    },
    {
        "commit_sha": "5aaeb839b565de155f7aa6e294a5a2e772e142c2",
        "commit_index": "Commit 145",
        "commit_diff": "Diff:\n@@ -46,18 +46,8 @@ ngx_event_recvmsg(ngx_event_t *ev)\n     ngx_connection_t  *c, *lc;\n     static u_char      buffer[65535];\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n-#if (NGX_HAVE_IP_RECVDSTADDR)\n-    u_char             msg_control[CMSG_SPACE(sizeof(struct in_addr))];\n-#elif (NGX_HAVE_IP_PKTINFO)\n-    u_char             msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-    u_char             msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n-#endif\n-\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n+    u_char             msg_control[CMSG_SPACE(sizeof(ngx_addrinfo_t))];\n #endif\n \n     if (ev->timedout) {\n@@ -92,25 +82,13 @@ ngx_event_recvmsg(ngx_event_t *ev)\n         msg.msg_iov = iov;\n         msg.msg_iovlen = 1;\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n         if (ls->wildcard) {\n+            msg.msg_control = &msg_control;\n+            msg.msg_controllen = sizeof(msg_control);\n \n-#if (NGX_HAVE_IP_RECVDSTADDR || NGX_HAVE_IP_PKTINFO)\n-            if (ls->sockaddr->sa_family == AF_INET) {\n-                msg.msg_control = &msg_control;\n-                msg.msg_controllen = sizeof(msg_control);\n-            }\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-            if (ls->sockaddr->sa_family == AF_INET6) {\n-                msg.msg_control = &msg_control6;\n-                msg.msg_controllen = sizeof(msg_control6);\n-            }\n-#endif\n-        }\n-\n+            ngx_memzero(&msg_control, sizeof(msg_control));\n+       }\n #endif\n \n         n = recvmsg(lc->fd, &msg, 0);\n@@ -129,7 +107,7 @@ ngx_event_recvmsg(ngx_event_t *ev)\n             return;\n         }\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n         if (msg.msg_flags & (MSG_TRUNC|MSG_CTRUNC)) {\n             ngx_log_error(NGX_LOG_ALERT, ev->log, 0,\n                           \"recvmsg() truncated data\");\n@@ -159,7 +137,7 @@ ngx_event_recvmsg(ngx_event_t *ev)\n         local_sockaddr = ls->sockaddr;\n         local_socklen = ls->socklen;\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n \n         if (ls->wildcard) {\n             struct cmsghdr  *cmsg;\n@@ -171,59 +149,9 @@ ngx_event_recvmsg(ngx_event_t *ev)\n                  cmsg != NULL;\n                  cmsg = CMSG_NXTHDR(&msg, cmsg))\n             {\n-\n-#if (NGX_HAVE_IP_RECVDSTADDR)\n-\n-                if (cmsg->cmsg_level == IPPROTO_IP\n-                    && cmsg->cmsg_type == IP_RECVDSTADDR\n-                    && local_sockaddr->sa_family == AF_INET)\n-                {\n-                    struct in_addr      *addr;\n-                    struct sockaddr_in  *sin;\n-\n-                    addr = (struct in_addr *) CMSG_DATA(cmsg);\n-                    sin = (struct sockaddr_in *) local_sockaddr;\n-                    sin->sin_addr = *addr;\n-\n+                if (ngx_get_srcaddr_cmsg(cmsg, local_sockaddr) == NGX_OK) {\n                     break;\n                 }\n-\n-#elif (NGX_HAVE_IP_PKTINFO)\n-\n-                if (cmsg->cmsg_level == IPPROTO_IP\n-                    && cmsg->cmsg_type == IP_PKTINFO\n-                    && local_sockaddr->sa_family == AF_INET)\n-                {\n-                    struct in_pktinfo   *pkt;\n-                    struct sockaddr_in  *sin;\n-\n-                    pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n-                    sin = (struct sockaddr_in *) local_sockaddr;\n-                    sin->sin_addr = pkt->ipi_addr;\n-\n-                    break;\n-                }\n-\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-\n-                if (cmsg->cmsg_level == IPPROTO_IPV6\n-                    && cmsg->cmsg_type == IPV6_PKTINFO\n-                    && local_sockaddr->sa_family == AF_INET6)\n-                {\n-                    struct in6_pktinfo   *pkt6;\n-                    struct sockaddr_in6  *sin6;\n-\n-                    pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n-                    sin6 = (struct sockaddr_in6 *) local_sockaddr;\n-                    sin6->sin6_addr = pkt6->ipi6_addr;\n-\n-                    break;\n-                }\n-\n-#endif\n-\n             }\n         }\n \nDiff:\n@@ -41,6 +41,8 @@ typedef union {\n \n size_t ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg,\n     struct sockaddr *local_sockaddr);\n+ngx_int_t ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg,\n+    struct sockaddr *local_sockaddr);\n \n #endif\n \nDiff:\n@@ -316,6 +316,71 @@ ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n     return 0;\n }\n \n+\n+ngx_int_t\n+ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n+{\n+\n+#if (NGX_HAVE_IP_RECVDSTADDR)\n+    struct in_addr       *addr;\n+    struct sockaddr_in   *sin;\n+#elif (NGX_HAVE_IP_PKTINFO)\n+    struct in_pktinfo    *pkt;\n+    struct sockaddr_in   *sin;\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    struct in6_pktinfo   *pkt6;\n+    struct sockaddr_in6  *sin6;\n+#endif\n+\n+\n+ #if (NGX_HAVE_IP_RECVDSTADDR)\n+\n+    if (cmsg->cmsg_level == IPPROTO_IP\n+        && cmsg->cmsg_type == IP_RECVDSTADDR\n+        && local_sockaddr->sa_family == AF_INET)\n+    {\n+        addr = (struct in_addr *) CMSG_DATA(cmsg);\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+        sin->sin_addr = *addr;\n+\n+        return NGX_OK;\n+    }\n+\n+#elif (NGX_HAVE_IP_PKTINFO)\n+\n+    if (cmsg->cmsg_level == IPPROTO_IP\n+        && cmsg->cmsg_type == IP_PKTINFO\n+        && local_sockaddr->sa_family == AF_INET)\n+    {\n+        pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+        sin->sin_addr = pkt->ipi_addr;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+\n+    if (cmsg->cmsg_level == IPPROTO_IPV6\n+        && cmsg->cmsg_type == IPV6_PKTINFO\n+        && local_sockaddr->sa_family == AF_INET6)\n+    {\n+        pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n+        sin6 = (struct sockaddr_in6 *) local_sockaddr;\n+        sin6->sin6_addr = pkt6->ipi6_addr;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    return NGX_DECLINED;\n+}\n+\n #endif\n \n \n"
    },
    {
        "commit_sha": "45119c6e59e88b07dad94278d19eafc02e218a70",
        "commit_index": "Commit 144",
        "commit_diff": "Diff:\n@@ -89,7 +89,8 @@ EVENT_DEPS=\"src/event/ngx_event.h \\\n             src/event/ngx_event_timer.h \\\n             src/event/ngx_event_posted.h \\\n             src/event/ngx_event_connect.h \\\n-            src/event/ngx_event_pipe.h\"\n+            src/event/ngx_event_pipe.h \\\n+            src/event/ngx_event_udp.h\"\n \n EVENT_SRCS=\"src/event/ngx_event.c \\\n             src/event/ngx_event_timer.c \\\nDiff:\n@@ -498,12 +498,6 @@ extern ngx_module_t           ngx_event_core_module;\n \n \n void ngx_event_accept(ngx_event_t *ev);\n-#if !(NGX_WIN32)\n-void ngx_event_recvmsg(ngx_event_t *ev);\n-void ngx_udp_rbtree_insert_value(ngx_rbtree_node_t *temp,\n-    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);\n-#endif\n-void ngx_delete_udp_connection(void *data);\n ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle);\n ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle);\n u_char *ngx_accept_log_error(ngx_log_t *log, u_char *buf, size_t len);\n@@ -533,6 +527,7 @@ ngx_int_t ngx_send_lowat(ngx_connection_t *c, size_t lowat);\n \n #include <ngx_event_timer.h>\n #include <ngx_event_posted.h>\n+#include <ngx_event_udp.h>\n \n #if (NGX_WIN32)\n #include <ngx_iocp_module.h>\nDiff:\n@@ -0,0 +1,56 @@\n+\n+/*\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_EVENT_UDP_H_INCLUDED_\n+#define _NGX_EVENT_UDP_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if !(NGX_WIN32)\n+\n+#if ((NGX_HAVE_MSGHDR_MSG_CONTROL)                                            \\\n+     && (NGX_HAVE_IP_SENDSRCADDR || NGX_HAVE_IP_RECVDSTADDR                   \\\n+         || NGX_HAVE_IP_PKTINFO                                               \\\n+         || (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)))\n+#define NGX_HAVE_ADDRINFO_CMSG  1\n+\n+#endif\n+\n+\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n+\n+typedef union {\n+#if (NGX_HAVE_IP_SENDSRCADDR || NGX_HAVE_IP_RECVDSTADDR)\n+    struct in_addr        addr;\n+#endif\n+\n+#if (NGX_HAVE_IP_PKTINFO)\n+    struct in_pktinfo     pkt;\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    struct in6_pktinfo    pkt6;\n+#endif\n+} ngx_addrinfo_t;\n+\n+size_t ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg,\n+    struct sockaddr *local_sockaddr);\n+\n+#endif\n+\n+void ngx_event_recvmsg(ngx_event_t *ev);\n+ssize_t ngx_sendmsg(ngx_connection_t *c, struct msghdr *msg, int flags);\n+void ngx_udp_rbtree_insert_value(ngx_rbtree_node_t *temp,\n+    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);\n+#endif\n+\n+void ngx_delete_udp_connection(void *data);\n+\n+\n+#endif /* _NGX_EVENT_UDP_H_INCLUDED_ */\nDiff:\n@@ -12,7 +12,7 @@\n \n static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec,\n     ngx_chain_t *in, ngx_log_t *log);\n-static ssize_t ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec);\n+static ssize_t ngx_sendmsg_vec(ngx_connection_t *c, ngx_iovec_t *vec);\n \n \n ngx_chain_t *\n@@ -88,7 +88,7 @@ ngx_udp_unix_sendmsg_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         send += vec.size;\n \n-        n = ngx_sendmsg(c, &vec);\n+        n = ngx_sendmsg_vec(c, &vec);\n \n         if (n == NGX_ERROR) {\n             return NGX_CHAIN_ERROR;\n@@ -204,24 +204,13 @@ ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, ngx_log_t *log)\n \n \n static ssize_t\n-ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n+ngx_sendmsg_vec(ngx_connection_t *c, ngx_iovec_t *vec)\n {\n-    ssize_t        n;\n-    ngx_err_t      err;\n-    struct msghdr  msg;\n-\n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n-#if (NGX_HAVE_IP_SENDSRCADDR)\n-    u_char         msg_control[CMSG_SPACE(sizeof(struct in_addr))];\n-#elif (NGX_HAVE_IP_PKTINFO)\n-    u_char         msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-    u_char         msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n-#endif\n+    struct msghdr    msg;\n \n+#if (NGX_HAVE_ADDRINFO_CMSG)\n+    struct cmsghdr  *cmsg;\n+    u_char           msg_control[CMSG_SPACE(sizeof(ngx_addrinfo_t))];\n #endif\n \n     ngx_memzero(&msg, sizeof(struct msghdr));\n@@ -234,88 +223,115 @@ ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n     msg.msg_iov = vec->iovs;\n     msg.msg_iovlen = vec->count;\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n     if (c->listening && c->listening->wildcard && c->local_sockaddr) {\n \n-#if (NGX_HAVE_IP_SENDSRCADDR)\n+        msg.msg_control = msg_control;\n+        msg.msg_controllen = sizeof(msg_control);\n+        ngx_memzero(msg_control, sizeof(msg_control));\n \n-        if (c->local_sockaddr->sa_family == AF_INET) {\n-            struct cmsghdr      *cmsg;\n-            struct in_addr      *addr;\n-            struct sockaddr_in  *sin;\n+        cmsg = CMSG_FIRSTHDR(&msg);\n \n-            msg.msg_control = &msg_control;\n-            msg.msg_controllen = sizeof(msg_control);\n+        msg.msg_controllen = ngx_set_srcaddr_cmsg(cmsg, c->local_sockaddr);\n+    }\n+#endif\n \n-            cmsg = CMSG_FIRSTHDR(&msg);\n-            cmsg->cmsg_level = IPPROTO_IP;\n-            cmsg->cmsg_type = IP_SENDSRCADDR;\n-            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_addr));\n+    return ngx_sendmsg(c, &msg, 0);\n+}\n \n-            sin = (struct sockaddr_in *) c->local_sockaddr;\n \n-            addr = (struct in_addr *) CMSG_DATA(cmsg);\n-            *addr = sin->sin_addr;\n-        }\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n \n+size_t\n+ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n+{\n+    size_t                len;\n+#if (NGX_HAVE_IP_SENDSRCADDR)\n+    struct in_addr       *addr;\n+    struct sockaddr_in   *sin;\n #elif (NGX_HAVE_IP_PKTINFO)\n+    struct in_pktinfo    *pkt;\n+    struct sockaddr_in   *sin;\n+#endif\n \n-        if (c->local_sockaddr->sa_family == AF_INET) {\n-            struct cmsghdr      *cmsg;\n-            struct in_pktinfo   *pkt;\n-            struct sockaddr_in  *sin;\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    struct in6_pktinfo   *pkt6;\n+    struct sockaddr_in6  *sin6;\n+#endif\n \n-            msg.msg_control = &msg_control;\n-            msg.msg_controllen = sizeof(msg_control);\n \n-            cmsg = CMSG_FIRSTHDR(&msg);\n-            cmsg->cmsg_level = IPPROTO_IP;\n-            cmsg->cmsg_type = IP_PKTINFO;\n-            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));\n+#if (NGX_HAVE_IP_SENDSRCADDR) || (NGX_HAVE_IP_PKTINFO)\n \n-            sin = (struct sockaddr_in *) c->local_sockaddr;\n+    if (local_sockaddr->sa_family == AF_INET) {\n \n-            pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n-            ngx_memzero(pkt, sizeof(struct in_pktinfo));\n-            pkt->ipi_spec_dst = sin->sin_addr;\n-        }\n+        cmsg->cmsg_level = IPPROTO_IP;\n+\n+#if (NGX_HAVE_IP_SENDSRCADDR)\n+\n+        cmsg->cmsg_type = IP_SENDSRCADDR;\n+        cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_addr));\n+        len = CMSG_SPACE(sizeof(struct in_addr));\n+\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+\n+        addr = (struct in_addr *) CMSG_DATA(cmsg);\n+        *addr = sin->sin_addr;\n+\n+#elif (NGX_HAVE_IP_PKTINFO)\n+\n+        cmsg->cmsg_type = IP_PKTINFO;\n+        cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));\n+        len = CMSG_SPACE(sizeof(struct in_pktinfo));\n+\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+\n+        pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n+        ngx_memzero(pkt, sizeof(struct in_pktinfo));\n+        pkt->ipi_spec_dst = sin->sin_addr;\n+\n+#endif\n+        return len;\n+    }\n \n #endif\n \n #if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    if (local_sockaddr->sa_family == AF_INET6) {\n \n-        if (c->local_sockaddr->sa_family == AF_INET6) {\n-            struct cmsghdr       *cmsg;\n-            struct in6_pktinfo   *pkt6;\n-            struct sockaddr_in6  *sin6;\n+        cmsg->cmsg_level = IPPROTO_IPV6;\n+        cmsg->cmsg_type = IPV6_PKTINFO;\n+        cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n+        len = CMSG_SPACE(sizeof(struct in6_pktinfo));\n \n-            msg.msg_control = &msg_control6;\n-            msg.msg_controllen = sizeof(msg_control6);\n+        sin6 = (struct sockaddr_in6 *) local_sockaddr;\n \n-            cmsg = CMSG_FIRSTHDR(&msg);\n-            cmsg->cmsg_level = IPPROTO_IPV6;\n-            cmsg->cmsg_type = IPV6_PKTINFO;\n-            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n+        pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n+        ngx_memzero(pkt6, sizeof(struct in6_pktinfo));\n+        pkt6->ipi6_addr = sin6->sin6_addr;\n \n-            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;\n+        return len;\n+    }\n+#endif\n \n-            pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n-            ngx_memzero(pkt6, sizeof(struct in6_pktinfo));\n-            pkt6->ipi6_addr = sin6->sin6_addr;\n-        }\n+    return 0;\n+}\n \n #endif\n-    }\n \n+\n+ssize_t\n+ngx_sendmsg(ngx_connection_t *c, struct msghdr *msg, int flags)\n+{\n+    ssize_t    n;\n+    ngx_err_t  err;\n+#if (NGX_DEBUG)\n+    size_t      size;\n+    ngx_uint_t  i;\n #endif\n \n eintr:\n \n-    n = sendmsg(c->fd, &msg, 0);\n-\n-    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                   \"sendmsg: %z of %uz\", n, vec->size);\n+    n = sendmsg(c->fd, msg, flags);\n \n     if (n == -1) {\n         err = ngx_errno;\n@@ -338,5 +354,14 @@ ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n         }\n     }\n \n+#if (NGX_DEBUG)\n+    for (i = 0, size = 0; i < (size_t) msg->msg_iovlen; i++) {\n+        size += msg->msg_iov[i].iov_len;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"sendmsg: %z of %uz\", n, size);\n+#endif\n+\n     return n;\n }\n"
    },
    {
        "commit_sha": "20fac060837dcef81f02284460311e2e97806875",
        "commit_index": "Commit 143",
        "commit_diff": "Diff:\n@@ -466,3 +466,4 @@ bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\n 39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\n d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n+714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\nDiff:\n@@ -5,6 +5,44 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.6\" date=\"2022-01-25\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использование EPOLLEXCLUSIVE на Linux\n+распределение клиентских соединений между рабочими процессами\n+было неравномерным.\n+</para>\n+<para lang=\"en\">\n+when using EPOLLEXCLUSIVE on Linux\n+client connections were unevenly distributed\n+among worker processes.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+во время плавного завершения старых рабочих процессов\n+nginx возвращал в ответах строку заголовка \"Connection: keep-alive\".\n+</para>\n+<para lang=\"en\">\n+nginx returned the \"Connection: keep-alive\" header line in responses\n+during graceful shutdown of old worker processes.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве ssl_session_ticket_key при использовании TLSv1.3.\n+</para>\n+<para lang=\"en\">\n+in the \"ssl_session_ticket_key\" when using TLSv1.3.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.5\" date=\"2021-12-28\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021006\n-#define NGINX_VERSION      \"1.21.6\"\n+#define nginx_version      1021007\n+#define NGINX_VERSION      \"1.21.7\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "506065becc9fa7f669917d6abd95bde6eefdab97",
        "commit_index": "Commit 142",
        "commit_diff": "Diff:\n@@ -5,6 +5,9 @@ if exists(\"b:current_syntax\")\n   finish\n end\n \n+let s:save_cpo = &cpo\n+set cpo&vim\n+\n \" general syntax\n \n if has(\"patch-7.4.1142\")\n@@ -2485,4 +2488,7 @@ hi def link ngxDirectiveThirdPartyDeprecated Error\n hi def link ngxListenOptions Keyword\n hi def link ngxListenOptionsDeprecated Error\n \n+let &cpo = s:save_cpo\n+unlet s:save_cpo\n+\n let b:current_syntax = \"nginx\"\nDiff:\n@@ -89,22 +89,10 @@ ngx_rwlock_rlock(ngx_atomic_t *lock)\n void\n ngx_rwlock_unlock(ngx_atomic_t *lock)\n {\n-    ngx_atomic_uint_t  readers;\n-\n-    readers = *lock;\n-\n-    if (readers == NGX_RWLOCK_WLOCK) {\n+    if (*lock == NGX_RWLOCK_WLOCK) {\n         (void) ngx_atomic_cmp_set(lock, NGX_RWLOCK_WLOCK, 0);\n-        return;\n-    }\n-\n-    for ( ;; ) {\n-\n-        if (ngx_atomic_cmp_set(lock, readers, readers - 1)) {\n-            return;\n-        }\n-\n-        readers = *lock;\n+    } else {\n+        (void) ngx_atomic_fetch_add(lock, -1);\n     }\n }\n \nDiff:\n@@ -4451,7 +4451,21 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n             return -1;\n         }\n \n-        return (i == 0) ? 1 : 2 /* renew */;\n+        /* renew if TLSv1.3 */\n+\n+#ifdef TLS1_3_VERSION\n+        if (SSL_version(ssl_conn) == TLS1_3_VERSION) {\n+            return 2;\n+        }\n+#endif\n+\n+        /* renew if non-default key */\n+\n+        if (i != 0) {\n+            return 2;\n+        }\n+\n+        return 1;\n     }\n }\n \n"
    },
    {
        "commit_sha": "2ef07a4afe741c085044d228afbc84f2626ec858",
        "commit_index": "Commit 141",
        "commit_diff": "Diff:\n@@ -55,6 +55,7 @@ ngx_uint_t            ngx_accept_events;\n ngx_uint_t            ngx_accept_mutex_held;\n ngx_msec_t            ngx_accept_mutex_delay;\n ngx_int_t             ngx_accept_disabled;\n+ngx_uint_t            ngx_use_exclusive_accept;\n \n \n #if (NGX_STAT_STUB)\n@@ -644,6 +645,8 @@ ngx_event_process_init(ngx_cycle_t *cycle)\n \n #endif\n \n+    ngx_use_exclusive_accept = 0;\n+\n     ngx_queue_init(&ngx_posted_accept_events);\n     ngx_queue_init(&ngx_posted_next_events);\n     ngx_queue_init(&ngx_posted_events);\n@@ -889,6 +892,8 @@ ngx_event_process_init(ngx_cycle_t *cycle)\n         if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n             && ccf->worker_processes > 1)\n         {\n+            ngx_use_exclusive_accept = 1;\n+\n             if (ngx_add_event(rev, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT)\n                 == NGX_ERROR)\n             {\nDiff:\n@@ -466,6 +466,7 @@ extern ngx_uint_t             ngx_accept_events;\n extern ngx_uint_t             ngx_accept_mutex_held;\n extern ngx_msec_t             ngx_accept_mutex_delay;\n extern ngx_int_t              ngx_accept_disabled;\n+extern ngx_uint_t             ngx_use_exclusive_accept;\n \n \n #if (NGX_STAT_STUB)\nDiff:\n@@ -11,6 +11,9 @@\n \n \n static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all);\n+#if (NGX_HAVE_EPOLLEXCLUSIVE)\n+static void ngx_reorder_accept_events(ngx_listening_t *ls);\n+#endif\n static void ngx_close_accepted_connection(ngx_connection_t *c);\n \n \n@@ -314,6 +317,10 @@ ngx_event_accept(ngx_event_t *ev)\n         }\n \n     } while (ev->available);\n+\n+#if (NGX_HAVE_EPOLLEXCLUSIVE)\n+    ngx_reorder_accept_events(ls);\n+#endif\n }\n \n \n@@ -420,6 +427,57 @@ ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all)\n }\n \n \n+#if (NGX_HAVE_EPOLLEXCLUSIVE)\n+\n+static void\n+ngx_reorder_accept_events(ngx_listening_t *ls)\n+{\n+    ngx_connection_t  *c;\n+\n+    /*\n+     * Linux with EPOLLEXCLUSIVE usually notifies only the process which\n+     * was first to add the listening socket to the epoll instance.  As\n+     * a result most of the connections are handled by the first worker\n+     * process.  To fix this, we re-add the socket periodically, so other\n+     * workers will get a chance to accept connections.\n+     */\n+\n+    if (!ngx_use_exclusive_accept) {\n+        return;\n+    }\n+\n+#if (NGX_HAVE_REUSEPORT)\n+\n+    if (ls->reuseport) {\n+        return;\n+    }\n+\n+#endif\n+\n+    c = ls->connection;\n+\n+    if (c->requests++ % 16 != 0\n+        && ngx_accept_disabled <= 0)\n+    {\n+        return;\n+    }\n+\n+    if (ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT)\n+        == NGX_ERROR)\n+    {\n+        return;\n+    }\n+\n+    if (ngx_add_event(c->read, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT)\n+        == NGX_ERROR)\n+    {\n+        return;\n+    }\n+}\n+\n+#endif\n+\n+\n static void\n ngx_close_accepted_connection(ngx_connection_t *c)\n {\nDiff:\n@@ -1383,6 +1383,9 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n     if (SSL_CTX_set0_tmp_dh_pkey(ssl->ctx, dh) != 1) {\n         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n                       \"SSL_CTX_set0_tmp_dh_pkey(\\%s\\\") failed\", file->data);\n+#if (OPENSSL_VERSION_NUMBER >= 0x3000001fL)\n+        EVP_PKEY_free(dh);\n+#endif\n         BIO_free(bio);\n         return NGX_ERROR;\n     }\nDiff:\n@@ -197,6 +197,10 @@ ngx_http_header_filter(ngx_http_request_t *r)\n         }\n     }\n \n+    if (r->keepalive && (ngx_terminate || ngx_exiting)) {\n+        r->keepalive = 0;\n+    }\n+\n     len = sizeof(\"HTTP/1.x \") - 1 + sizeof(CRLF) - 1\n           /* the end of the header */\n           + sizeof(CRLF) - 1;\n"
    },
    {
        "commit_sha": "be33c33d226120a3b2afc3a753be3afd24d1a2df",
        "commit_index": "Commit 140",
        "commit_diff": "Diff:\n@@ -465,3 +465,4 @@ a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\n 39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\n+d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\nDiff:\n@@ -5,6 +5,58 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.5\" date=\"2021-12-28\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx по умолчанию собирается с библиотекой PCRE2.\n+</para>\n+<para lang=\"en\">\n+now nginx is built with the PCRE2 library by default.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда использует sendfile(SF_NODISKIO) на FreeBSD.\n+</para>\n+<para lang=\"en\">\n+now nginx always uses sendfile(SF_NODISKIO) on FreeBSD.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+поддержка sendfile(SF_NOCACHE) на FreeBSD.\n+</para>\n+<para lang=\"en\">\n+support for sendfile(SF_NOCACHE) on FreeBSD.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $ssl_curve.\n+</para>\n+<para lang=\"en\">\n+the $ssl_curve variable.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2 без SSL вместе с директивами sendfile и aio\n+соединения могли зависать.\n+</para>\n+<para lang=\"en\">\n+connections might hang\n+when using HTTP/2 without SSL with the \"sendfile\" and \"aio\" directives.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.4\" date=\"2021-11-02\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021005\n-#define NGINX_VERSION      \"1.21.5\"\n+#define nginx_version      1021006\n+#define NGINX_VERSION      \"1.21.6\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "494ab3700189b4bd9af99b04980c8221457d1f6f",
        "commit_index": "Commit 139",
        "commit_diff": "Diff:\n@@ -6,9 +6,9 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1l\n+OPENSSL =\topenssl-1.1.1m\n ZLIB =\t\tzlib-1.2.11\n-PCRE =\t\tpcre-8.44\n+PCRE =\t\tpcre2-10.39\n \n \n release: export\nDiff:\n@@ -256,10 +256,6 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n     }\n #endif\n \n-    if (buf->in_file && buf->file->directio) {\n-        return 0;\n-    }\n-\n     sendfile = ctx->sendfile;\n \n #if (NGX_SENDFILE_LIMIT)\n@@ -268,6 +264,19 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n         sendfile = 0;\n     }\n \n+#endif\n+\n+#if !(NGX_HAVE_SENDFILE_NODISKIO)\n+\n+    /*\n+     * With DIRECTIO, disable sendfile() unless sendfile(SF_NOCACHE)\n+     * is available.\n+     */\n+\n+    if (buf->in_file && buf->file->directio) {\n+        sendfile = 0;\n+    }\n+\n #endif\n \n     if (!sendfile) {\nDiff:\n@@ -2955,7 +2955,13 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     ngx_set_errno(0);\n \n #if (NGX_HAVE_SENDFILE_NODISKIO)\n+\n     flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n+\n+    if (file->file->directio) {\n+        flags |= SF_NOCACHE;\n+    }\n+\n #else\n     flags = 0;\n #endif\nDiff:\n@@ -174,7 +174,13 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n             sent = 0;\n \n #if (NGX_HAVE_SENDFILE_NODISKIO)\n+\n             flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n+\n+            if (file->file->directio) {\n+                flags |= SF_NOCACHE;\n+            }\n+\n #endif\n \n             rc = sendfile(file->file->fd, c->fd, file->file_pos,\n"
    },
    {
        "commit_sha": "b079d73641c8b8ab1d21b46ea6488dd5f8fe842d",
        "commit_index": "Commit 138",
        "commit_diff": "Diff:\n@@ -44,12 +44,10 @@ if [ $osreldate -gt 300007 ]; then\n     CORE_SRCS=\"$CORE_SRCS $FREEBSD_SENDFILE_SRCS\"\n fi\n \n-if [ $NGX_FILE_AIO = YES ]; then\n-    if [ $osreldate -gt 502103 ]; then\n-        echo \" + sendfile()'s SF_NODISKIO found\"\n+if [ $osreldate -gt 1100093 ]; then\n+    echo \" + sendfile()'s SF_NODISKIO found\"\n \n-        have=NGX_HAVE_AIO_SENDFILE . auto/have\n-    fi\n+    have=NGX_HAVE_SENDFILE_NODISKIO . auto/have\n fi\n \n # POSIX semaphores\nDiff:\n@@ -91,9 +91,6 @@ struct ngx_output_chain_ctx_s {\n \n #if (NGX_HAVE_FILE_AIO || NGX_COMPAT)\n     ngx_output_chain_aio_pt      aio_handler;\n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n-    ssize_t                    (*aio_preload)(ngx_buf_t *file);\n-#endif\n #endif\n \n #if (NGX_THREADS || NGX_COMPAT)\nDiff:\n@@ -187,7 +187,7 @@ struct ngx_connection_s {\n \n     unsigned            need_last_buf:1;\n \n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n+#if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)\n     unsigned            busy_count:2;\n #endif\n \nDiff:\n@@ -41,7 +41,7 @@\n #define NGX_MODULE_SIGNATURE_3   \"0\"\n #endif\n \n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n+#if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)\n #define NGX_MODULE_SIGNATURE_4   \"1\"\n #else\n #define NGX_MODULE_SIGNATURE_4   \"0\"\nDiff:\n@@ -29,10 +29,6 @@\n \n static ngx_inline ngx_int_t\n     ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf);\n-#if (NGX_HAVE_AIO_SENDFILE)\n-static ngx_int_t ngx_output_chain_aio_setup(ngx_output_chain_ctx_t *ctx,\n-    ngx_file_t *file);\n-#endif\n static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool,\n     ngx_chain_t **chain, ngx_chain_t *in);\n static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx,\n@@ -283,12 +279,6 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n         buf->in_file = 0;\n     }\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-    if (ctx->aio_preload && buf->in_file) {\n-        (void) ngx_output_chain_aio_setup(ctx, buf->file);\n-    }\n-#endif\n-\n     if (ctx->need_in_memory && !ngx_buf_in_memory(buf)) {\n         return 0;\n     }\n@@ -301,28 +291,6 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n }\n \n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-\n-static ngx_int_t\n-ngx_output_chain_aio_setup(ngx_output_chain_ctx_t *ctx, ngx_file_t *file)\n-{\n-    ngx_event_aio_t  *aio;\n-\n-    if (file->aio == NULL && ngx_file_aio_init(file, ctx->pool) != NGX_OK) {\n-        return NGX_ERROR;\n-    }\n-\n-    aio = file->aio;\n-\n-    aio->data = ctx->filter_ctx;\n-    aio->preload_handler = ctx->aio_preload;\n-\n-    return NGX_OK;\n-}\n-\n-#endif\n-\n-\n static ngx_int_t\n ngx_output_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain,\n     ngx_chain_t *in)\nDiff:\n@@ -151,10 +151,6 @@ struct ngx_event_aio_s {\n \n     ngx_fd_t                   fd;\n \n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n-    ssize_t                  (*preload_handler)(ngx_buf_t *file);\n-#endif\n-\n #if (NGX_HAVE_EVENTFD)\n     int64_t                    res;\n #endif\nDiff:\n@@ -2942,7 +2942,7 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n {\n #ifdef BIO_get_ktls_send\n \n-    int        sslerr;\n+    int        sslerr, flags;\n     ssize_t    n;\n     ngx_err_t  err;\n \n@@ -2954,8 +2954,14 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n \n     ngx_set_errno(0);\n \n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+    flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n+#else\n+    flags = 0;\n+#endif\n+\n     n = SSL_sendfile(c->ssl->connection, file->file->fd, file->file_pos,\n-                     size, 0);\n+                     size, flags);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %d\", n);\n \n@@ -2974,6 +2980,10 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n             ngx_post_event(c->read, &ngx_posted_events);\n         }\n \n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+        c->busy_count = 0;\n+#endif\n+\n         c->sent += n;\n \n         return n;\n@@ -3038,6 +3048,23 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n             ngx_post_event(c->read, &ngx_posted_events);\n         }\n \n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+\n+        if (ngx_errno == EBUSY) {\n+            c->busy_count++;\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"SSL_sendfile() busy, count:%d\", c->busy_count);\n+\n+            if (c->write->posted) {\n+                ngx_delete_posted_event(c->write);\n+            }\n+\n+            ngx_post_event(c->write, &ngx_posted_next_events);\n+        }\n+\n+#endif\n+\n         c->write->ready = 0;\n         return NGX_AGAIN;\n     }\nDiff:\n@@ -19,10 +19,6 @@ typedef struct {\n static void ngx_http_copy_aio_handler(ngx_output_chain_ctx_t *ctx,\n     ngx_file_t *file);\n static void ngx_http_copy_aio_event_handler(ngx_event_t *ev);\n-#if (NGX_HAVE_AIO_SENDFILE)\n-static ssize_t ngx_http_copy_aio_sendfile_preload(ngx_buf_t *file);\n-static void ngx_http_copy_aio_sendfile_event_handler(ngx_event_t *ev);\n-#endif\n #endif\n #if (NGX_THREADS)\n static ngx_int_t ngx_http_copy_thread_handler(ngx_thread_task_t *task,\n@@ -128,9 +124,6 @@ ngx_http_copy_filter(ngx_http_request_t *r, ngx_chain_t *in)\n #if (NGX_HAVE_FILE_AIO)\n         if (ngx_file_aio && clcf->aio == NGX_HTTP_AIO_ON) {\n             ctx->aio_handler = ngx_http_copy_aio_handler;\n-#if (NGX_HAVE_AIO_SENDFILE)\n-            ctx->aio_preload = ngx_http_copy_aio_sendfile_preload;\n-#endif\n         }\n #endif\n \n@@ -207,81 +200,6 @@ ngx_http_copy_aio_event_handler(ngx_event_t *ev)\n     ngx_http_run_posted_requests(c);\n }\n \n-\n-#if (NGX_HAVE_AIO_SENDFILE)\n-\n-static ssize_t\n-ngx_http_copy_aio_sendfile_preload(ngx_buf_t *file)\n-{\n-    ssize_t                  n;\n-    static u_char            buf[1];\n-    ngx_event_aio_t         *aio;\n-    ngx_http_request_t      *r;\n-    ngx_output_chain_ctx_t  *ctx;\n-\n-    aio = file->file->aio;\n-    r = aio->data;\n-\n-    if (r->aio) {\n-        /*\n-         * tolerate sendfile() calls if another operation is already\n-         * running; this can happen due to subrequests, multiple calls\n-         * of the next body filter from a filter, or in HTTP/2 due to\n-         * a write event on the main connection\n-         */\n-\n-        return NGX_AGAIN;\n-    }\n-\n-    n = ngx_file_aio_read(file->file, buf, 1, file->file_pos, NULL);\n-\n-    if (n == NGX_AGAIN) {\n-        aio->handler = ngx_http_copy_aio_sendfile_event_handler;\n-\n-        r->main->blocked++;\n-        r->aio = 1;\n-\n-        ctx = ngx_http_get_module_ctx(r, ngx_http_copy_filter_module);\n-        ctx->aio = 1;\n-    }\n-\n-    return n;\n-}\n-\n-\n-static void\n-ngx_http_copy_aio_sendfile_event_handler(ngx_event_t *ev)\n-{\n-    ngx_event_aio_t     *aio;\n-    ngx_connection_t    *c;\n-    ngx_http_request_t  *r;\n-\n-    aio = ev->data;\n-    r = aio->data;\n-    c = r->connection;\n-\n-    r->main->blocked--;\n-    r->aio = 0;\n-    ev->complete = 0;\n-\n-#if (NGX_HTTP_V2)\n-\n-    if (r->stream) {\n-        /*\n-         * for HTTP/2, update write event to make sure processing will\n-         * reach the main connection to handle sendfile() preload\n-         */\n-\n-        c->write->ready = 1;\n-        c->write->active = 0;\n-    }\n-\n-#endif\n-\n-    c->write->handler(c->write);\n-}\n-\n-#endif\n #endif\n \n \nDiff:\n@@ -32,23 +32,22 @@\n ngx_chain_t *\n ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n {\n-    int               rc, flags;\n-    off_t             send, prev_send, sent;\n-    size_t            file_size;\n-    ssize_t           n;\n-    ngx_uint_t        eintr, eagain;\n-    ngx_err_t         err;\n-    ngx_buf_t        *file;\n-    ngx_event_t      *wev;\n-    ngx_chain_t      *cl;\n-    ngx_iovec_t       header, trailer;\n-    struct sf_hdtr    hdtr;\n-    struct iovec      headers[NGX_IOVS_PREALLOCATE];\n-    struct iovec      trailers[NGX_IOVS_PREALLOCATE];\n-#if (NGX_HAVE_AIO_SENDFILE)\n-    ngx_uint_t        ebusy;\n-    ngx_event_aio_t  *aio;\n+    int              rc, flags;\n+    off_t            send, prev_send, sent;\n+    size_t           file_size;\n+    ssize_t          n;\n+    ngx_err_t        err;\n+    ngx_buf_t       *file;\n+    ngx_uint_t       eintr, eagain;\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+    ngx_uint_t       ebusy;\n #endif\n+    ngx_event_t     *wev;\n+    ngx_chain_t     *cl;\n+    ngx_iovec_t      header, trailer;\n+    struct sf_hdtr   hdtr;\n+    struct iovec     headers[NGX_IOVS_PREALLOCATE];\n+    struct iovec     trailers[NGX_IOVS_PREALLOCATE];\n \n     wev = c->write;\n \n@@ -77,11 +76,6 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n     eagain = 0;\n     flags = 0;\n \n-#if (NGX_HAVE_AIO_SENDFILE && NGX_SUPPRESS_WARN)\n-    aio = NULL;\n-    file = NULL;\n-#endif\n-\n     header.iovs = headers;\n     header.nalloc = NGX_IOVS_PREALLOCATE;\n \n@@ -90,7 +84,7 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n     for ( ;; ) {\n         eintr = 0;\n-#if (NGX_HAVE_AIO_SENDFILE)\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n         ebusy = 0;\n #endif\n         prev_send = send;\n@@ -179,9 +173,8 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n             sent = 0;\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-            aio = file->file->aio;\n-            flags = (aio && aio->preload_handler) ? SF_NODISKIO : 0;\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+            flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n #endif\n \n             rc = sendfile(file->file->fd, c->fd, file->file_pos,\n@@ -199,7 +192,7 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                     eintr = 1;\n                     break;\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n                 case NGX_EBUSY:\n                     ebusy = 1;\n                     break;\n@@ -252,41 +245,30 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         in = ngx_chain_update_sent(in, sent);\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n \n         if (ebusy) {\n             if (sent == 0) {\n                 c->busy_count++;\n \n-                if (c->busy_count > 2) {\n-                    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n-                                  \"sendfile(%V) returned busy again\",\n-                                  &file->file->name);\n-\n-                    c->busy_count = 0;\n-                    aio->preload_handler = NULL;\n-\n-                    send = prev_send;\n-                    continue;\n-                }\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                               \"sendfile() busy, count:%d\", c->busy_count);\n \n             } else {\n                 c->busy_count = 0;\n             }\n \n-            n = aio->preload_handler(file);\n-\n-            if (n > 0) {\n-                send = prev_send + sent;\n-                continue;\n+            if (wev->posted) {\n+                ngx_delete_posted_event(wev);\n             }\n \n+            ngx_post_event(wev, &ngx_posted_next_events);\n+\n+            wev->ready = 0;\n             return in;\n         }\n \n-        if (flags == SF_NODISKIO) {\n-            c->busy_count = 0;\n-        }\n+        c->busy_count = 0;\n \n #endif\n \n"
    },
    {
        "commit_sha": "116294aae7cd0d4bf308acd588562d6337076ec7",
        "commit_index": "Commit 137",
        "commit_diff": "Diff:\n@@ -159,7 +159,11 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n         options |= PCRE2_CASELESS;\n     }\n \n-    if (rc->options & ~NGX_REGEX_CASELESS) {\n+    if (rc->options & NGX_REGEX_MULTILINE) {\n+        options |= PCRE2_MULTILINE;\n+    }\n+\n+    if (rc->options & ~(NGX_REGEX_CASELESS|NGX_REGEX_MULTILINE)) {\n         rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                             \"regex \\\"%V\\\" compilation failed: invalid options\",\n                             &rc->pattern)\n@@ -275,7 +279,11 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n         options |= PCRE_CASELESS;\n     }\n \n-    if (rc->options & ~NGX_REGEX_CASELESS) {\n+    if (rc->options & NGX_REGEX_MULTILINE) {\n+        options |= PCRE_MULTILINE;\n+    }\n+\n+    if (rc->options & ~(NGX_REGEX_CASELESS|NGX_REGEX_MULTILINE)) {\n         rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                             \"regex \\\"%V\\\" compilation failed: invalid options\",\n                             &rc->pattern)\nDiff:\n@@ -37,6 +37,7 @@ typedef struct {\n \n \n #define NGX_REGEX_CASELESS     0x00000001\n+#define NGX_REGEX_MULTILINE    0x00000002\n \n \n typedef struct {\nDiff:\n@@ -4568,19 +4568,6 @@ ngx_http_core_set_aio(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n     }\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-\n-    if (ngx_strcmp(value[1].data, \"sendfile\") == 0) {\n-        clcf->aio = NGX_HTTP_AIO_ON;\n-\n-        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n-                           \"the \\\"sendfile\\\" parameter of \"\n-                           \"the \\\"aio\\\" directive is deprecated\");\n-        return NGX_CONF_OK;\n-    }\n-\n-#endif\n-\n     if (ngx_strncmp(value[1].data, \"threads\", 7) == 0\n         && (value[1].len == 7 || value[1].data[7] == '='))\n     {\n"
    },
    {
        "commit_sha": "136d046584a499f37995c52fba54b8f10539cfbe",
        "commit_index": "Commit 136",
        "commit_diff": "Diff:\n@@ -5,29 +5,61 @@\n \n if [ $PCRE != NONE ]; then\n \n-    have=NGX_PCRE . auto/have\n+    if [ -f $PCRE/src/pcre2.h.generic ]; then\n \n-    if [ \"$NGX_PLATFORM\" = win32 ]; then\n-        have=PCRE_STATIC . auto/have\n-    fi\n+        PCRE_LIBRARY=PCRE2\n+\n+        have=NGX_PCRE . auto/have\n+        have=NGX_PCRE2 . auto/have\n+\n+        if [ \"$NGX_PLATFORM\" = win32 ]; then\n+            have=PCRE2_STATIC . auto/have\n+        fi\n+\n+        CORE_INCS=\"$CORE_INCS $PCRE/src/\"\n+        CORE_DEPS=\"$CORE_DEPS $PCRE/src/pcre2.h\"\n \n-    CORE_INCS=\"$CORE_INCS $PCRE\"\n-    CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n+        case \"$NGX_CC_NAME\" in\n \n-    case \"$NGX_CC_NAME\" in\n+            msvc)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/src/pcre2-8.lib\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/src/pcre2-8.lib\"\n+            ;;\n \n-        msvc | owc | bcc)\n-            LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n-            CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n-        ;;\n+            *)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre2-8.a\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre2-8.a\"\n+            ;;\n \n-        *)\n-            LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n-            CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n-        ;;\n+        esac\n+\n+    else\n+\n+        PCRE_LIBRARY=PCRE\n+\n+        have=NGX_PCRE . auto/have\n+\n+        if [ \"$NGX_PLATFORM\" = win32 ]; then\n+            have=PCRE_STATIC . auto/have\n+        fi\n \n-    esac\n+        CORE_INCS=\"$CORE_INCS $PCRE\"\n+        CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n \n+        case \"$NGX_CC_NAME\" in\n+\n+            msvc | owc | bcc)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n+            ;;\n+\n+            *)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n+            ;;\n+\n+        esac\n+    fi\n \n     if [ $PCRE_JIT = YES ]; then\n         have=NGX_HAVE_PCRE_JIT . auto/have\n@@ -37,8 +69,48 @@ if [ $PCRE != NONE ]; then\n else\n \n     if [ \"$NGX_PLATFORM\" != win32 ]; then\n-\n         PCRE=NO\n+    fi\n+\n+    if [ $PCRE = NO -a $PCRE2 != DISABLED ]; then\n+\n+        ngx_feature=\"PCRE2 library\"\n+        ngx_feature_name=\"NGX_PCRE2\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#define PCRE2_CODE_UNIT_WIDTH 8\n+                          #include <pcre2.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\"-lpcre2-8\"\n+        ngx_feature_test=\"pcre2_code *re;\n+                          re = pcre2_compile(NULL, 0, 0, NULL, NULL, NULL);\n+                          if (re == NULL) return 1\"\n+        . auto/feature\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # pcre2-config\n+\n+            ngx_pcre2_prefix=`pcre2-config --prefix 2>/dev/null`\n+\n+            if [ -n \"$ngx_pcre2_prefix\" ]; then\n+                ngx_feature=\"PCRE2 library in $ngx_pcre2_prefix\"\n+                ngx_feature_path=`pcre2-config --cflags \\\n+                                  | sed -n -e 's/.*-I *\\([^ ][^ ]*\\).*/\\1/p'`\n+                ngx_feature_libs=`pcre2-config --libs8`\n+                . auto/feature\n+            fi\n+        fi\n+\n+        if [ $ngx_found = yes ]; then\n+            have=NGX_PCRE . auto/have\n+            CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+            CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+            PCRE=YES\n+            PCRE_LIBRARY=PCRE2\n+        fi\n+    fi\n+\n+    if [ $PCRE = NO ]; then\n \n         ngx_feature=\"PCRE library\"\n         ngx_feature_name=\"NGX_PCRE\"\n@@ -114,6 +186,7 @@ else\n             CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n             CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n             PCRE=YES\n+            PCRE_LIBRARY=PCRE\n         fi\n \n         if [ $PCRE = YES ]; then\nDiff:\n@@ -3,36 +3,138 @@\n # Copyright (C) Nginx, Inc.\n \n \n-case \"$NGX_CC_NAME\" in\n+if [ $PCRE_LIBRARY = PCRE2 ]; then\n+\n+    # PCRE2\n+\n+    if [ $NGX_CC_NAME = msvc ]; then\n+\n+        # With PCRE2, it is not possible to compile all sources.\n+        # Since list of source files changes between versions, we\n+        # test files which might not be present.\n+\n+        ngx_pcre_srcs=\"pcre2_auto_possess.c \\\n+                       pcre2_chartables.c \\\n+                       pcre2_compile.c \\\n+                       pcre2_config.c \\\n+                       pcre2_context.c \\\n+                       pcre2_dfa_match.c \\\n+                       pcre2_error.c \\\n+                       pcre2_jit_compile.c \\\n+                       pcre2_maketables.c \\\n+                       pcre2_match.c \\\n+                       pcre2_match_data.c \\\n+                       pcre2_newline.c \\\n+                       pcre2_ord2utf.c \\\n+                       pcre2_pattern_info.c \\\n+                       pcre2_string_utils.c \\\n+                       pcre2_study.c \\\n+                       pcre2_substitute.c \\\n+                       pcre2_substring.c \\\n+                       pcre2_tables.c \\\n+                       pcre2_ucd.c \\\n+                       pcre2_valid_utf.c \\\n+                       pcre2_xclass.c\"\n+\n+        ngx_pcre_test=\"pcre2_convert.c \\\n+                       pcre2_extuni.c \\\n+                       pcre2_find_bracket.c \\\n+                       pcre2_script_run.c \\\n+                       pcre2_serialize.c\"\n+\n+        for ngx_src in $ngx_pcre_test\n+        do\n+            if [ -f $PCRE/src/$ngx_src ]; then\n+                ngx_pcre_srcs=\"$ngx_pcre_srcs $ngx_src\"\n+            fi\n+        done\n+\n+        ngx_pcre_objs=`echo $ngx_pcre_srcs \\\n+            | sed -e \"s#\\([^ ]*\\.\\)c#\\1$ngx_objext#g\"`\n+\n+        ngx_pcre_srcs=`echo $ngx_pcre_srcs \\\n+            | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\"`\n+        ngx_pcre_objs=`echo $ngx_pcre_objs \\\n+            | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+PCRE_CFLAGS =\t-O2 -Ob1 -Oi -Gs $LIBC $CPU_OPT\n+PCRE_FLAGS =\t-DHAVE_CONFIG_H -DPCRE2_STATIC -DPCRE2_CODE_UNIT_WIDTH=8 \\\\\n+\t\t-DHAVE_MEMMOVE\n+\n+PCRE_SRCS =\t $ngx_pcre_srcs\n+PCRE_OBJS =\t $ngx_pcre_objs\n+\n+$PCRE/src/pcre2.h:\n+\tcd $PCRE/src \\\\\n+\t&& copy /y config.h.generic config.h \\\\\n+\t&& copy /y pcre2.h.generic pcre2.h \\\\\n+\t&& copy /y pcre2_chartables.c.dist pcre2_chartables.c\n+\n+$PCRE/src/pcre2-8.lib:\t$PCRE/src/pcre2.h $NGX_MAKEFILE\n+\tcd $PCRE/src \\\\\n+\t&& cl -nologo -c \\$(PCRE_CFLAGS) -I . \\$(PCRE_FLAGS) \\$(PCRE_SRCS) \\\\\n+\t&& link -lib -out:pcre2-8.lib -verbose:lib \\$(PCRE_OBJS)\n \n-    msvc)\n-        ngx_makefile=makefile.msvc\n-        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\" LIBC=$LIBC\"\n-        ngx_pcre=\"PCRE=\\\"$PCRE\\\"\"\n-    ;;\n+END\n+\n+    else\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n \n-    owc)\n-        ngx_makefile=makefile.owc\n-        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\"\"\n-        ngx_pcre=`echo PCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n-    ;;\n+$PCRE/src/pcre2.h:\t$PCRE/Makefile\n+\n+$PCRE/Makefile:\t$NGX_MAKEFILE\n+\tcd $PCRE \\\\\n+\t&& if [ -f Makefile ]; then \\$(MAKE) distclean; fi \\\\\n+\t&& CC=\"\\$(CC)\" CFLAGS=\"$PCRE_OPT\" \\\\\n+\t./configure --disable-shared $PCRE_CONF_OPT\n \n-    bcc)\n-        ngx_makefile=makefile.bcc\n-        ngx_opt=\"-DCPU_OPT=\\\"$CPU_OPT\\\"\"\n-        ngx_pcre=`echo \\-DPCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n-    ;;\n+$PCRE/.libs/libpcre2-8.a:\t$PCRE/Makefile\n+\tcd $PCRE \\\\\n+\t&& \\$(MAKE) libpcre2-8.la\n \n-    *)\n-        ngx_makefile=\n-    ;;\n+END\n \n-esac\n+    fi\n \n \n-if [ -n \"$ngx_makefile\" ]; then\n+else\n \n-    cat << END                                                >> $NGX_MAKEFILE\n+    # PCRE\n+\n+    case \"$NGX_CC_NAME\" in\n+\n+        msvc)\n+            ngx_makefile=makefile.msvc\n+            ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\" LIBC=$LIBC\"\n+            ngx_pcre=\"PCRE=\\\"$PCRE\\\"\"\n+        ;;\n+\n+        owc)\n+            ngx_makefile=makefile.owc\n+            ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\"\"\n+            ngx_pcre=`echo PCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ;;\n+\n+        bcc)\n+            ngx_makefile=makefile.bcc\n+            ngx_opt=\"-DCPU_OPT=\\\"$CPU_OPT\\\"\"\n+            ngx_pcre=`echo \\-DPCRE=\\\"$PCRE\\\" \\\n+                | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ;;\n+\n+        *)\n+            ngx_makefile=\n+        ;;\n+\n+    esac\n+\n+\n+    if [ -n \"$ngx_makefile\" ]; then\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n \n `echo \"$PCRE/pcre.lib:\t$PCRE/pcre.h $NGX_MAKEFILE\"\t\t\t\\\n \t| sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n@@ -43,9 +145,9 @@ if [ -n \"$ngx_makefile\" ]; then\n \n END\n \n-else\n+    else\n \n-    cat << END                                                >> $NGX_MAKEFILE\n+        cat << END                                            >> $NGX_MAKEFILE\n \n $PCRE/pcre.h:\t$PCRE/Makefile\n \n@@ -61,4 +163,6 @@ $PCRE/.libs/libpcre.a:\t$PCRE/Makefile\n \n END\n \n+    fi\n+\n fi\nDiff:\n@@ -146,6 +146,7 @@ PCRE=NONE\n PCRE_OPT=\n PCRE_CONF_OPT=\n PCRE_JIT=NO\n+PCRE2=YES\n \n USE_OPENSSL=NO\n OPENSSL=NONE\n@@ -357,6 +358,7 @@ use the \\\"--with-mail_ssl_module\\\" option instead\"\n         --with-pcre=*)                   PCRE=\"$value\"              ;;\n         --with-pcre-opt=*)               PCRE_OPT=\"$value\"          ;;\n         --with-pcre-jit)                 PCRE_JIT=YES               ;;\n+        --without-pcre2)                 PCRE2=DISABLED             ;;\n \n         --with-openssl=*)                OPENSSL=\"$value\"           ;;\n         --with-openssl-opt=*)            OPENSSL_OPT=\"$value\"       ;;\n@@ -573,6 +575,7 @@ cat << END\n   --with-pcre=DIR                    set path to PCRE library sources\n   --with-pcre-opt=OPTIONS            set additional build options for PCRE\n   --with-pcre-jit                    build PCRE with JIT compilation support\n+  --without-pcre2                    do not use PCRE2 library\n \n   --with-zlib=DIR                    set path to zlib library sources\n   --with-zlib-opt=OPTIONS            set additional build options for zlib\nDiff:\n@@ -16,9 +16,9 @@ if [ $USE_PCRE = DISABLED ]; then\n \n else\n     case $PCRE in\n-        YES)   echo \"  + using system PCRE library\" ;;\n+        YES)   echo \"  + using system $PCRE_LIBRARY library\" ;;\n         NONE)  echo \"  + PCRE library is not used\" ;;\n-        *)     echo \"  + using PCRE library: $PCRE\" ;;\n+        *)     echo \"  + using $PCRE_LIBRARY library: $PCRE\" ;;\n     esac\n fi\n \nDiff:\n@@ -18,8 +18,13 @@ typedef struct {\n static ngx_inline void ngx_regex_malloc_init(ngx_pool_t *pool);\n static ngx_inline void ngx_regex_malloc_done(void);\n \n+#if (NGX_PCRE2)\n+static void * ngx_libc_cdecl ngx_regex_malloc(size_t size, void *data);\n+static void ngx_libc_cdecl ngx_regex_free(void *p, void *data);\n+#else\n static void * ngx_libc_cdecl ngx_regex_malloc(size_t size);\n static void ngx_libc_cdecl ngx_regex_free(void *p);\n+#endif\n static void ngx_regex_cleanup(void *data);\n \n static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle);\n@@ -67,31 +72,192 @@ ngx_module_t  ngx_regex_module = {\n };\n \n \n-static ngx_pool_t  *ngx_regex_pool;\n-static ngx_list_t  *ngx_regex_studies;\n+static ngx_pool_t             *ngx_regex_pool;\n+static ngx_list_t             *ngx_regex_studies;\n+static ngx_uint_t              ngx_regex_direct_alloc;\n+\n+#if (NGX_PCRE2)\n+static pcre2_compile_context  *ngx_regex_compile_context;\n+static pcre2_match_data       *ngx_regex_match_data;\n+static ngx_uint_t              ngx_regex_match_data_size;\n+#endif\n \n \n void\n ngx_regex_init(void)\n {\n+#if !(NGX_PCRE2)\n     pcre_malloc = ngx_regex_malloc;\n     pcre_free = ngx_regex_free;\n+#endif\n }\n \n \n static ngx_inline void\n ngx_regex_malloc_init(ngx_pool_t *pool)\n {\n     ngx_regex_pool = pool;\n+    ngx_regex_direct_alloc = (pool == NULL) ? 1 : 0;\n }\n \n \n static ngx_inline void\n ngx_regex_malloc_done(void)\n {\n     ngx_regex_pool = NULL;\n+    ngx_regex_direct_alloc = 0;\n+}\n+\n+\n+#if (NGX_PCRE2)\n+\n+ngx_int_t\n+ngx_regex_compile(ngx_regex_compile_t *rc)\n+{\n+    int                     n, errcode;\n+    char                   *p;\n+    u_char                  errstr[128];\n+    size_t                  erroff;\n+    uint32_t                options;\n+    pcre2_code             *re;\n+    ngx_regex_elt_t        *elt;\n+    pcre2_general_context  *gctx;\n+    pcre2_compile_context  *cctx;\n+\n+    if (ngx_regex_compile_context == NULL) {\n+        /*\n+         * Allocate a compile context if not yet allocated.  This uses\n+         * direct allocations from heap, so the result can be cached\n+         * even at runtime.\n+         */\n+\n+        ngx_regex_malloc_init(NULL);\n+\n+        gctx = pcre2_general_context_create(ngx_regex_malloc, ngx_regex_free,\n+                                            NULL);\n+        if (gctx == NULL) {\n+            ngx_regex_malloc_done();\n+            goto nomem;\n+        }\n+\n+        cctx = pcre2_compile_context_create(gctx);\n+        if (cctx == NULL) {\n+            pcre2_general_context_free(gctx);\n+            ngx_regex_malloc_done();\n+            goto nomem;\n+        }\n+\n+        ngx_regex_compile_context = cctx;\n+\n+        pcre2_general_context_free(gctx);\n+        ngx_regex_malloc_done();\n+    }\n+\n+    options = 0;\n+\n+    if (rc->options & NGX_REGEX_CASELESS) {\n+        options |= PCRE2_CASELESS;\n+    }\n+\n+    if (rc->options & ~NGX_REGEX_CASELESS) {\n+        rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                            \"regex \\\"%V\\\" compilation failed: invalid options\",\n+                            &rc->pattern)\n+                      - rc->err.data;\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_regex_malloc_init(rc->pool);\n+\n+    re = pcre2_compile(rc->pattern.data, rc->pattern.len, options,\n+                       &errcode, &erroff, ngx_regex_compile_context);\n+\n+    /* ensure that there is no current pool */\n+    ngx_regex_malloc_done();\n+\n+    if (re == NULL) {\n+        pcre2_get_error_message(errcode, errstr, 128);\n+\n+        if ((size_t) erroff == rc->pattern.len) {\n+            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                              \"pcre2_compile() failed: %s in \\\"%V\\\"\",\n+                               errstr, &rc->pattern)\n+                          - rc->err.data;\n+\n+        } else {\n+            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                              \"pcre2_compile() failed: %s in \\\"%V\\\" at \\\"%s\\\"\",\n+                               errstr, &rc->pattern, rc->pattern.data + erroff)\n+                          - rc->err.data;\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    rc->regex = re;\n+\n+    /* do not study at runtime */\n+\n+    if (ngx_regex_studies != NULL) {\n+        elt = ngx_list_push(ngx_regex_studies);\n+        if (elt == NULL) {\n+            goto nomem;\n+        }\n+\n+        elt->regex = rc->regex;\n+        elt->name = rc->pattern.data;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_CAPTURECOUNT, &rc->captures);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_CAPTURECOUNT) failed: %d\";\n+        goto failed;\n+    }\n+\n+    if (rc->captures == 0) {\n+        return NGX_OK;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_NAMECOUNT, &rc->named_captures);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_NAMECOUNT) failed: %d\";\n+        goto failed;\n+    }\n+\n+    if (rc->named_captures == 0) {\n+        return NGX_OK;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_NAMEENTRYSIZE, &rc->name_size);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_NAMEENTRYSIZE) failed: %d\";\n+        goto failed;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_NAMETABLE, &rc->names);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_NAMETABLE) failed: %d\";\n+        goto failed;\n+    }\n+\n+    return NGX_OK;\n+\n+failed:\n+\n+    rc->err.len = ngx_snprintf(rc->err.data, rc->err.len, p, &rc->pattern, n)\n+                  - rc->err.data;\n+    return NGX_ERROR;\n+\n+nomem:\n+\n+    rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                               \"regex \\\"%V\\\" compilation failed: no memory\",\n+                               &rc->pattern)\n+                  - rc->err.data;\n+    return NGX_ERROR;\n }\n \n+#else\n \n ngx_int_t\n ngx_regex_compile(ngx_regex_compile_t *rc)\n@@ -100,11 +266,26 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n     char             *p;\n     pcre             *re;\n     const char       *errstr;\n+    ngx_uint_t        options;\n     ngx_regex_elt_t  *elt;\n \n+    options = 0;\n+\n+    if (rc->options & NGX_REGEX_CASELESS) {\n+        options |= PCRE_CASELESS;\n+    }\n+\n+    if (rc->options & ~NGX_REGEX_CASELESS) {\n+        rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                            \"regex \\\"%V\\\" compilation failed: invalid options\",\n+                            &rc->pattern)\n+                      - rc->err.data;\n+        return NGX_ERROR;\n+    }\n+\n     ngx_regex_malloc_init(rc->pool);\n \n-    re = pcre_compile((const char *) rc->pattern.data, (int) rc->options,\n+    re = pcre_compile((const char *) rc->pattern.data, (int) options,\n                       &errstr, &erroff, NULL);\n \n     /* ensure that there is no current pool */\n@@ -195,6 +376,83 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n     return NGX_ERROR;\n }\n \n+#endif\n+\n+\n+#if (NGX_PCRE2)\n+\n+ngx_int_t\n+ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures, ngx_uint_t size)\n+{\n+    size_t      *ov;\n+    ngx_int_t    rc;\n+    ngx_uint_t   n, i;\n+\n+    /*\n+     * The pcre2_match() function might allocate memory for backtracking\n+     * frames, typical allocations are from 40k and above.  So the allocator\n+     * is configured to do direct allocations from heap during matching.\n+     */\n+\n+    ngx_regex_malloc_init(NULL);\n+\n+    if (ngx_regex_match_data == NULL\n+        || size > ngx_regex_match_data_size)\n+    {\n+        /*\n+         * Allocate a match data if not yet allocated or smaller than\n+         * needed.\n+         */\n+\n+        if (ngx_regex_match_data) {\n+            pcre2_match_data_free(ngx_regex_match_data);\n+        }\n+\n+        ngx_regex_match_data_size = size;\n+        ngx_regex_match_data = pcre2_match_data_create(size / 3, NULL);\n+\n+        if (ngx_regex_match_data == NULL) {\n+            rc = PCRE2_ERROR_NOMEMORY;\n+            goto failed;\n+        }\n+    }\n+\n+    rc = pcre2_match(re, s->data, s->len, 0, 0, ngx_regex_match_data, NULL);\n+\n+    if (rc < 0) {\n+        goto failed;\n+    }\n+\n+    n = pcre2_get_ovector_count(ngx_regex_match_data);\n+    ov = pcre2_get_ovector_pointer(ngx_regex_match_data);\n+\n+    if (n > size / 3) {\n+        n = size / 3;\n+    }\n+\n+    for (i = 0; i < n; i++) {\n+        captures[i * 2] = ov[i * 2];\n+        captures[i * 2 + 1] = ov[i * 2 + 1];\n+    }\n+\n+failed:\n+\n+    ngx_regex_malloc_done();\n+\n+    return rc;\n+}\n+\n+#else\n+\n+ngx_int_t\n+ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures, ngx_uint_t size)\n+{\n+    return pcre_exec(re->code, re->extra, (const char *) s->data, s->len,\n+                     0, 0, captures, size);\n+}\n+\n+#endif\n+\n \n ngx_int_t\n ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)\n@@ -229,6 +487,35 @@ ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)\n }\n \n \n+#if (NGX_PCRE2)\n+\n+static void * ngx_libc_cdecl\n+ngx_regex_malloc(size_t size, void *data)\n+{\n+    if (ngx_regex_pool) {\n+        return ngx_palloc(ngx_regex_pool, size);\n+    }\n+\n+    if (ngx_regex_direct_alloc) {\n+        return ngx_alloc(size, ngx_cycle->log);\n+    }\n+\n+    return NULL;\n+}\n+\n+\n+static void ngx_libc_cdecl\n+ngx_regex_free(void *p, void *data)\n+{\n+    if (ngx_regex_direct_alloc) {\n+        ngx_free(p);\n+    }\n+\n+    return;\n+}\n+\n+#else\n+\n static void * ngx_libc_cdecl\n ngx_regex_malloc(size_t size)\n {\n@@ -246,11 +533,13 @@ ngx_regex_free(void *p)\n     return;\n }\n \n+#endif\n+\n \n static void\n ngx_regex_cleanup(void *data)\n {\n-#if (NGX_HAVE_PCRE_JIT)\n+#if (NGX_PCRE2 || NGX_HAVE_PCRE_JIT)\n     ngx_regex_conf_t *rcf = data;\n \n     ngx_uint_t        i;\n@@ -275,12 +564,17 @@ ngx_regex_cleanup(void *data)\n         /*\n          * The PCRE JIT compiler uses mmap for its executable codes, so we\n          * have to explicitly call the pcre_free_study() function to free\n-         * this memory.\n+         * this memory.  In PCRE2, we call the pcre2_code_free() function\n+         * for the same reason.\n          */\n \n+#if (NGX_PCRE2)\n+        pcre2_code_free(elts[i].regex);\n+#else\n         if (elts[i].regex->extra != NULL) {\n             pcre_free_study(elts[i].regex->extra);\n         }\n+#endif\n     }\n #endif\n \n@@ -290,14 +584,36 @@ ngx_regex_cleanup(void *data)\n      */\n \n     ngx_regex_studies = NULL;\n+\n+#if (NGX_PCRE2)\n+\n+    /*\n+     * Free compile context and match data.  If needed at runtime by\n+     * the new cycle, these will be re-allocated.\n+     */\n+\n+    if (ngx_regex_compile_context) {\n+        pcre2_compile_context_free(ngx_regex_compile_context);\n+        ngx_regex_compile_context = NULL;\n+    }\n+\n+    if (ngx_regex_match_data) {\n+        pcre2_match_data_free(ngx_regex_match_data);\n+        ngx_regex_match_data = NULL;\n+        ngx_regex_match_data_size = 0;\n+    }\n+\n+#endif\n }\n \n \n static ngx_int_t\n ngx_regex_module_init(ngx_cycle_t *cycle)\n {\n     int                opt;\n+#if !(NGX_PCRE2)\n     const char        *errstr;\n+#endif\n     ngx_uint_t         i;\n     ngx_list_part_t   *part;\n     ngx_regex_elt_t   *elts;\n@@ -307,10 +623,16 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n \n     rcf = (ngx_regex_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_regex_module);\n \n-#if (NGX_HAVE_PCRE_JIT)\n+#if (NGX_PCRE2 || NGX_HAVE_PCRE_JIT)\n+\n     if (rcf->pcre_jit) {\n+#if (NGX_PCRE2)\n+        opt = 1;\n+#else\n         opt = PCRE_STUDY_JIT_COMPILE;\n+#endif\n     }\n+\n #endif\n \n     ngx_regex_malloc_init(cycle->pool);\n@@ -330,6 +652,23 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n             i = 0;\n         }\n \n+#if (NGX_PCRE2)\n+\n+        if (opt) {\n+            int  n;\n+\n+            n = pcre2_jit_compile(elts[i].regex, PCRE2_JIT_COMPLETE);\n+\n+            if (n != 0) {\n+                ngx_log_error(NGX_LOG_INFO, cycle->log, 0,\n+                              \"pcre2_jit_compile() failed: %d in \\\"%s\\\", \"\n+                              \"ignored\",\n+                              n, elts[i].name);\n+            }\n+        }\n+\n+#else\n+\n         elts[i].regex->extra = pcre_study(elts[i].regex->code, opt, &errstr);\n \n         if (errstr != NULL) {\n@@ -352,12 +691,16 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n                               elts[i].name);\n             }\n         }\n+#endif\n #endif\n     }\n \n     ngx_regex_malloc_done();\n \n     ngx_regex_studies = NULL;\n+#if (NGX_PCRE2)\n+    ngx_regex_compile_context = NULL;\n+#endif\n \n     return NGX_OK;\n }\n@@ -415,7 +758,21 @@ ngx_regex_pcre_jit(ngx_conf_t *cf, void *post, void *data)\n         return NGX_CONF_OK;\n     }\n \n-#if (NGX_HAVE_PCRE_JIT)\n+#if (NGX_PCRE2)\n+    {\n+    int       r;\n+    uint32_t  jit;\n+\n+    jit = 0;\n+    r = pcre2_config(PCRE2_CONFIG_JIT, &jit);\n+\n+    if (r != 0 || jit != 1) {\n+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                           \"PCRE2 library does not support JIT\");\n+        *fp = 0;\n+    }\n+    }\n+#elif (NGX_HAVE_PCRE_JIT)\n     {\n     int  jit, r;\n \nDiff:\n@@ -12,24 +12,37 @@\n #include <ngx_config.h>\n #include <ngx_core.h>\n \n-#include <pcre.h>\n \n+#if (NGX_PCRE2)\n+\n+#define PCRE2_CODE_UNIT_WIDTH  8\n+#include <pcre2.h>\n+\n+#define NGX_REGEX_NO_MATCHED   PCRE2_ERROR_NOMATCH   /* -1 */\n \n-#define NGX_REGEX_NO_MATCHED  PCRE_ERROR_NOMATCH   /* -1 */\n+typedef pcre2_code  ngx_regex_t;\n \n-#define NGX_REGEX_CASELESS    PCRE_CASELESS\n+#else\n+\n+#include <pcre.h>\n \n+#define NGX_REGEX_NO_MATCHED   PCRE_ERROR_NOMATCH    /* -1 */\n \n typedef struct {\n     pcre        *code;\n     pcre_extra  *extra;\n } ngx_regex_t;\n \n+#endif\n+\n+\n+#define NGX_REGEX_CASELESS     0x00000001\n+\n \n typedef struct {\n     ngx_str_t     pattern;\n     ngx_pool_t   *pool;\n-    ngx_int_t     options;\n+    ngx_uint_t    options;\n \n     ngx_regex_t  *regex;\n     int           captures;\n@@ -49,10 +62,14 @@ typedef struct {\n void ngx_regex_init(void);\n ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc);\n \n-#define ngx_regex_exec(re, s, captures, size)                                \\\n-    pcre_exec(re->code, re->extra, (const char *) (s)->data, (s)->len, 0, 0, \\\n-              captures, size)\n-#define ngx_regex_exec_n      \"pcre_exec()\"\n+ngx_int_t ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures,\n+    ngx_uint_t size);\n+\n+#if (NGX_PCRE2)\n+#define ngx_regex_exec_n       \"pcre2_match()\"\n+#else\n+#define ngx_regex_exec_n       \"pcre_exec()\"\n+#endif\n \n ngx_int_t ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log);\n \n"
    },
    {
        "commit_sha": "1ef7e810d66132c32ad4544688cc13574b66881f",
        "commit_index": "Commit 135",
        "commit_diff": "Diff:\n@@ -4,81 +4,24 @@\n \n \n if [ $PCRE != NONE ]; then\n+\n+    have=NGX_PCRE . auto/have\n+\n+    if [ \"$NGX_PLATFORM\" = win32 ]; then\n+        have=PCRE_STATIC . auto/have\n+    fi\n+\n     CORE_INCS=\"$CORE_INCS $PCRE\"\n+    CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n \n     case \"$NGX_CC_NAME\" in\n \n         msvc | owc | bcc)\n-            have=NGX_PCRE . auto/have\n-            have=PCRE_STATIC . auto/have\n-            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n             LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n             CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n         ;;\n \n-        icc)\n-            have=NGX_PCRE . auto/have\n-            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n-\n-            LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n-\n-            echo $ngx_n \"checking for PCRE library ...$ngx_c\"\n-\n-            if [ -f $PCRE/pcre.h ]; then\n-                ngx_pcre_ver=`grep PCRE_MAJOR $PCRE/pcre.h \\\n-                              | sed -e 's/^.*PCRE_MAJOR.* \\(.*\\)$/\\1/'`\n-\n-            else if [ -f $PCRE/configure.in ]; then\n-                ngx_pcre_ver=`grep PCRE_MAJOR= $PCRE/configure.in \\\n-                              | sed -e 's/^.*=\\(.*\\)$/\\1/'`\n-\n-            else\n-                ngx_pcre_ver=`grep pcre_major, $PCRE/configure.ac \\\n-                              | sed -e 's/^.*pcre_major,.*\\[\\(.*\\)\\].*$/\\1/'`\n-            fi\n-            fi\n-\n-            echo \" $ngx_pcre_ver major version found\"\n-\n-            # to allow -ipo optimization we link with the *.o but not library\n-\n-            case \"$ngx_pcre_ver\" in\n-                4|5)\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.o\"\n-                ;;\n-\n-                6)\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_chartables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_compile.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_exec.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_fullinfo.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_globals.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_tables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_try_flipped.o\"\n-                ;;\n-\n-                *)\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_chartables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_compile.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_exec.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_fullinfo.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_globals.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_tables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_try_flipped.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_newline.o\"\n-                ;;\n-\n-            esac\n-        ;;\n-\n         *)\n-            have=NGX_PCRE . auto/have\n-\n-            if [ \"$NGX_PLATFORM\" = win32 ]; then\n-                have=PCRE_STATIC . auto/have\n-            fi\n-\n-            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n             LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n             CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n         ;;\nDiff:\n@@ -102,6 +102,11 @@ if [ $HTTP = YES ]; then\n     fi\n \n \n+    if [ $HTTP_V2 = YES ]; then\n+        HTTP_SRCS=\"$HTTP_SRCS $HTTP_HUFF_SRCS\"\n+    fi\n+\n+\n     # the module order is important\n     #     ngx_http_static_module\n     #     ngx_http_gzip_static_module\n@@ -414,8 +419,6 @@ if [ $HTTP = YES ]; then\n         ngx_module_srcs=\"src/http/v2/ngx_http_v2.c \\\n                          src/http/v2/ngx_http_v2_table.c \\\n                          src/http/v2/ngx_http_v2_encode.c \\\n-                         src/http/v2/ngx_http_v2_huff_decode.c \\\n-                         src/http/v2/ngx_http_v2_huff_encode.c \\\n                          src/http/v2/ngx_http_v2_module.c\"\n         ngx_module_libs=\n         ngx_module_link=$HTTP_V2\nDiff:\n@@ -255,3 +255,6 @@ NGX_WIN32_RC=\"src/os/win32/nginx.rc\"\n \n \n HTTP_FILE_CACHE_SRCS=src/http/ngx_http_file_cache.c\n+\n+HTTP_HUFF_SRCS=\"src/http/ngx_http_huff_decode.c\n+                src/http/ngx_http_huff_encode.c\"\nDiff:\n@@ -10,15 +10,17 @@\n \n \n typedef struct {\n-    ngx_flag_t  pcre_jit;\n+    ngx_flag_t   pcre_jit;\n+    ngx_list_t  *studies;\n } ngx_regex_conf_t;\n \n \n+static ngx_inline void ngx_regex_malloc_init(ngx_pool_t *pool);\n+static ngx_inline void ngx_regex_malloc_done(void);\n+\n static void * ngx_libc_cdecl ngx_regex_malloc(size_t size);\n static void ngx_libc_cdecl ngx_regex_free(void *p);\n-#if (NGX_HAVE_PCRE_JIT)\n-static void ngx_pcre_free_studies(void *data);\n-#endif\n+static void ngx_regex_cleanup(void *data);\n \n static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle);\n \n@@ -65,8 +67,8 @@ ngx_module_t  ngx_regex_module = {\n };\n \n \n-static ngx_pool_t  *ngx_pcre_pool;\n-static ngx_list_t  *ngx_pcre_studies;\n+static ngx_pool_t  *ngx_regex_pool;\n+static ngx_list_t  *ngx_regex_studies;\n \n \n void\n@@ -80,14 +82,14 @@ ngx_regex_init(void)\n static ngx_inline void\n ngx_regex_malloc_init(ngx_pool_t *pool)\n {\n-    ngx_pcre_pool = pool;\n+    ngx_regex_pool = pool;\n }\n \n \n static ngx_inline void\n ngx_regex_malloc_done(void)\n {\n-    ngx_pcre_pool = NULL;\n+    ngx_regex_pool = NULL;\n }\n \n \n@@ -113,13 +115,13 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                               \"pcre_compile() failed: %s in \\\"%V\\\"\",\n                                errstr, &rc->pattern)\n-                      - rc->err.data;\n+                         - rc->err.data;\n \n         } else {\n            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                               \"pcre_compile() failed: %s in \\\"%V\\\" at \\\"%s\\\"\",\n                                errstr, &rc->pattern, rc->pattern.data + erroff)\n-                      - rc->err.data;\n+                         - rc->err.data;\n         }\n \n         return NGX_ERROR;\n@@ -134,8 +136,8 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n \n     /* do not study at runtime */\n \n-    if (ngx_pcre_studies != NULL) {\n-        elt = ngx_list_push(ngx_pcre_studies);\n+    if (ngx_regex_studies != NULL) {\n+        elt = ngx_list_push(ngx_regex_studies);\n         if (elt == NULL) {\n             goto nomem;\n         }\n@@ -230,11 +232,8 @@ ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)\n static void * ngx_libc_cdecl\n ngx_regex_malloc(size_t size)\n {\n-    ngx_pool_t      *pool;\n-    pool = ngx_pcre_pool;\n-\n-    if (pool) {\n-        return ngx_palloc(pool, size);\n+    if (ngx_regex_pool) {\n+        return ngx_palloc(ngx_regex_pool, size);\n     }\n \n     return NULL;\n@@ -248,18 +247,17 @@ ngx_regex_free(void *p)\n }\n \n \n-#if (NGX_HAVE_PCRE_JIT)\n-\n static void\n-ngx_pcre_free_studies(void *data)\n+ngx_regex_cleanup(void *data)\n {\n-    ngx_list_t *studies = data;\n+#if (NGX_HAVE_PCRE_JIT)\n+    ngx_regex_conf_t *rcf = data;\n \n     ngx_uint_t        i;\n     ngx_list_part_t  *part;\n     ngx_regex_elt_t  *elts;\n \n-    part = &studies->part;\n+    part = &rcf->studies->part;\n     elts = part->elts;\n \n     for (i = 0; /* void */ ; i++) {\n@@ -274,56 +272,50 @@ ngx_pcre_free_studies(void *data)\n             i = 0;\n         }\n \n+        /*\n+         * The PCRE JIT compiler uses mmap for its executable codes, so we\n+         * have to explicitly call the pcre_free_study() function to free\n+         * this memory.\n+         */\n+\n         if (elts[i].regex->extra != NULL) {\n             pcre_free_study(elts[i].regex->extra);\n         }\n     }\n-}\n-\n #endif\n \n+    /*\n+     * On configuration parsing errors ngx_regex_module_init() will not\n+     * be called.  Make sure ngx_regex_studies is properly cleared anyway.\n+     */\n+\n+    ngx_regex_studies = NULL;\n+}\n+\n \n static ngx_int_t\n ngx_regex_module_init(ngx_cycle_t *cycle)\n {\n-    int               opt;\n-    const char       *errstr;\n-    ngx_uint_t        i;\n-    ngx_list_part_t  *part;\n-    ngx_regex_elt_t  *elts;\n+    int                opt;\n+    const char        *errstr;\n+    ngx_uint_t         i;\n+    ngx_list_part_t   *part;\n+    ngx_regex_elt_t   *elts;\n+    ngx_regex_conf_t  *rcf;\n \n     opt = 0;\n \n-#if (NGX_HAVE_PCRE_JIT)\n-    {\n-    ngx_regex_conf_t    *rcf;\n-    ngx_pool_cleanup_t  *cln;\n-\n     rcf = (ngx_regex_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_regex_module);\n \n+#if (NGX_HAVE_PCRE_JIT)\n     if (rcf->pcre_jit) {\n         opt = PCRE_STUDY_JIT_COMPILE;\n-\n-        /*\n-         * The PCRE JIT compiler uses mmap for its executable codes, so we\n-         * have to explicitly call the pcre_free_study() function to free\n-         * this memory.\n-         */\n-\n-        cln = ngx_pool_cleanup_add(cycle->pool, 0);\n-        if (cln == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        cln->handler = ngx_pcre_free_studies;\n-        cln->data = ngx_pcre_studies;\n-    }\n     }\n #endif\n \n     ngx_regex_malloc_init(cycle->pool);\n \n-    part = &ngx_pcre_studies->part;\n+    part = &rcf->studies->part;\n     elts = part->elts;\n \n     for (i = 0; /* void */ ; i++) {\n@@ -365,7 +357,7 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n \n     ngx_regex_malloc_done();\n \n-    ngx_pcre_studies = NULL;\n+    ngx_regex_studies = NULL;\n \n     return NGX_OK;\n }\n@@ -374,7 +366,8 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n static void *\n ngx_regex_create_conf(ngx_cycle_t *cycle)\n {\n-    ngx_regex_conf_t  *rcf;\n+    ngx_regex_conf_t    *rcf;\n+    ngx_pool_cleanup_t  *cln;\n \n     rcf = ngx_pcalloc(cycle->pool, sizeof(ngx_regex_conf_t));\n     if (rcf == NULL) {\n@@ -383,11 +376,21 @@ ngx_regex_create_conf(ngx_cycle_t *cycle)\n \n     rcf->pcre_jit = NGX_CONF_UNSET;\n \n-    ngx_pcre_studies = ngx_list_create(cycle->pool, 8, sizeof(ngx_regex_elt_t));\n-    if (ngx_pcre_studies == NULL) {\n+    cln = ngx_pool_cleanup_add(cycle->pool, 0);\n+    if (cln == NULL) {\n+        return NULL;\n+    }\n+\n+    cln->handler = ngx_regex_cleanup;\n+    cln->data = rcf;\n+\n+    rcf->studies = ngx_list_create(cycle->pool, 8, sizeof(ngx_regex_elt_t));\n+    if (rcf->studies == NULL) {\n         return NULL;\n     }\n \n+    ngx_regex_studies = rcf->studies;\n+\n     return rcf;\n }\n \nDiff:\n@@ -3180,10 +3180,10 @@ ngx_http_grpc_parse_fragment(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n             ctx->field_rest -= size;\n \n             if (ctx->field_huffman) {\n-                if (ngx_http_v2_huff_decode(&ctx->field_state, p, size,\n-                                            &ctx->field_end,\n-                                            ctx->field_rest == 0,\n-                                            r->connection->log)\n+                if (ngx_http_huff_decode(&ctx->field_state, p, size,\n+                                         &ctx->field_end,\n+                                         ctx->field_rest == 0,\n+                                         r->connection->log)\n                     != NGX_OK)\n                 {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n@@ -3289,10 +3289,10 @@ ngx_http_grpc_parse_fragment(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n             ctx->field_rest -= size;\n \n             if (ctx->field_huffman) {\n-                if (ngx_http_v2_huff_decode(&ctx->field_state, p, size,\n-                                            &ctx->field_end,\n-                                            ctx->field_rest == 0,\n-                                            r->connection->log)\n+                if (ngx_http_huff_decode(&ctx->field_state, p, size,\n+                                         &ctx->field_end,\n+                                         ctx->field_rest == 0,\n+                                         r->connection->log)\n                     != NGX_OK)\n                 {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\nDiff:\n@@ -167,6 +167,14 @@ ngx_uint_t  ngx_http_degraded(ngx_http_request_t *);\n #endif\n \n \n+#if (NGX_HTTP_V2)\n+ngx_int_t ngx_http_huff_decode(u_char *state, u_char *src, size_t len,\n+    u_char **dst, ngx_uint_t last, ngx_log_t *log);\n+size_t ngx_http_huff_encode(u_char *src, size_t len, u_char *dst,\n+    ngx_uint_t lower);\n+#endif\n+\n+\n extern ngx_module_t  ngx_http_module;\n \n extern ngx_str_t  ngx_http_html_default_types[];\nDiff:\n@@ -15,14 +15,14 @@ typedef struct {\n     u_char  emit;\n     u_char  sym;\n     u_char  ending;\n-} ngx_http_v2_huff_decode_code_t;\n+} ngx_http_huff_decode_code_t;\n \n \n-static ngx_inline ngx_int_t ngx_http_v2_huff_decode_bits(u_char *state,\n+static ngx_inline ngx_int_t ngx_http_huff_decode_bits(u_char *state,\n     u_char *ending, ngx_uint_t bits, u_char **dst);\n \n \n-static ngx_http_v2_huff_decode_code_t  ngx_http_v2_huff_decode_codes[256][16] =\n+static ngx_http_huff_decode_code_t  ngx_http_huff_decode_codes[256][16] =\n {\n     /* 0 */\n     {\n@@ -2640,7 +2640,7 @@ static ngx_http_v2_huff_decode_code_t  ngx_http_v2_huff_decode_codes[256][16] =\n \n \n ngx_int_t\n-ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n+ngx_http_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n     ngx_uint_t last, ngx_log_t *log)\n {\n     u_char  *end, ch, ending;\n@@ -2653,7 +2653,7 @@ ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n     while (src != end) {\n         ch = *src++;\n \n-        if (ngx_http_v2_huff_decode_bits(state, &ending, ch >> 4, dst)\n+        if (ngx_http_huff_decode_bits(state, &ending, ch >> 4, dst)\n             != NGX_OK)\n         {\n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,\n@@ -2663,7 +2663,7 @@ ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n             return NGX_ERROR;\n         }\n \n-        if (ngx_http_v2_huff_decode_bits(state, &ending, ch & 0xf, dst)\n+        if (ngx_http_huff_decode_bits(state, &ending, ch & 0xf, dst)\n             != NGX_OK)\n         {\n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,\n@@ -2692,12 +2692,12 @@ ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n \n \n static ngx_inline ngx_int_t\n-ngx_http_v2_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,\n+ngx_http_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,\n     u_char **dst)\n {\n-    ngx_http_v2_huff_decode_code_t  code;\n+    ngx_http_huff_decode_code_t  code;\n \n-    code = ngx_http_v2_huff_decode_codes[*state][bits];\n+    code = ngx_http_huff_decode_codes[*state][bits];\n \n     if (code.next == *state) {\n         return NGX_ERROR;\nDiff:\n@@ -14,10 +14,10 @@\n typedef struct {\n     uint32_t  code;\n     uint32_t  len;\n-} ngx_http_v2_huff_encode_code_t;\n+} ngx_http_huff_encode_code_t;\n \n \n-static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table[256] =\n+static ngx_http_huff_encode_code_t  ngx_http_huff_encode_table[256] =\n {\n     {0x00001ff8, 13}, {0x007fffd8, 23}, {0x0fffffe2, 28}, {0x0fffffe3, 28},\n     {0x0fffffe4, 28}, {0x0fffffe5, 28}, {0x0fffffe6, 28}, {0x0fffffe7, 28},\n@@ -87,7 +87,7 @@ static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table[256] =\n \n \n /* same as above, but embeds lowercase transformation */\n-static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table_lc[256] =\n+static ngx_http_huff_encode_code_t  ngx_http_huff_encode_table_lc[256] =\n {\n     {0x00001ff8, 13}, {0x007fffd8, 23}, {0x0fffffe2, 28}, {0x0fffffe3, 28},\n     {0x0fffffe4, 28}, {0x0fffffe5, 28}, {0x0fffffe6, 28}, {0x0fffffe7, 28},\n@@ -161,10 +161,10 @@ static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table_lc[256] =\n #if (NGX_HAVE_LITTLE_ENDIAN)\n \n #if (NGX_HAVE_GCC_BSWAP64)\n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     (*(uint64_t *) (dst) = __builtin_bswap64(buf))\n #else\n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     ((dst)[0] = (u_char) ((buf) >> 56),                                       \\\n      (dst)[1] = (u_char) ((buf) >> 48),                                       \\\n      (dst)[2] = (u_char) ((buf) >> 40),                                       \\\n@@ -176,28 +176,28 @@ static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table_lc[256] =\n #endif\n \n #else /* !NGX_HAVE_LITTLE_ENDIAN */\n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     (*(uint64_t *) (dst) = (buf))\n #endif\n \n #else /* NGX_PTR_SIZE == 4 */\n \n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     (*(uint32_t *) (dst) = htonl(buf))\n \n #endif\n \n \n size_t\n-ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)\n+ngx_http_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)\n {\n-    u_char                          *end;\n-    size_t                           hlen;\n-    ngx_uint_t                       buf, pending, code;\n-    ngx_http_v2_huff_encode_code_t  *table, *next;\n+    u_char                       *end;\n+    size_t                        hlen;\n+    ngx_uint_t                    buf, pending, code;\n+    ngx_http_huff_encode_code_t  *table, *next;\n \n-    table = lower ? ngx_http_v2_huff_encode_table_lc\n-                  : ngx_http_v2_huff_encode_table;\n+    table = lower ? ngx_http_huff_encode_table_lc\n+                  : ngx_http_huff_encode_table;\n     hlen = 0;\n     buf = 0;\n     pending = 0;\n@@ -224,7 +224,7 @@ ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)\n \n         buf |= code >> pending;\n \n-        ngx_http_v2_huff_encode_buf(&dst[hlen], buf);\n+        ngx_http_huff_encode_buf(&dst[hlen], buf);\n \n         hlen += sizeof(buf);\n \nDiff:\n@@ -1600,10 +1600,10 @@ ngx_http_v2_state_field_huff(ngx_http_v2_connection_t *h2c, u_char *pos,\n     h2c->state.length -= size;\n     h2c->state.field_rest -= size;\n \n-    if (ngx_http_v2_huff_decode(&h2c->state.field_state, pos, size,\n-                                &h2c->state.field_end,\n-                                h2c->state.field_rest == 0,\n-                                h2c->connection->log)\n+    if (ngx_http_huff_decode(&h2c->state.field_state, pos, size,\n+                             &h2c->state.field_end,\n+                             h2c->state.field_rest == 0,\n+                             h2c->connection->log)\n         != NGX_OK)\n     {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\nDiff:\n@@ -311,12 +311,6 @@ ngx_int_t ngx_http_v2_add_header(ngx_http_v2_connection_t *h2c,\n ngx_int_t ngx_http_v2_table_size(ngx_http_v2_connection_t *h2c, size_t size);\n \n \n-ngx_int_t ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len,\n-    u_char **dst, ngx_uint_t last, ngx_log_t *log);\n-size_t ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst,\n-    ngx_uint_t lower);\n-\n-\n #define ngx_http_v2_prefix(bits)  ((1 << (bits)) - 1)\n \n \nDiff:\n@@ -20,7 +20,7 @@ ngx_http_v2_string_encode(u_char *dst, u_char *src, size_t len, u_char *tmp,\n {\n     size_t  hlen;\n \n-    hlen = ngx_http_v2_huff_encode(src, len, tmp, lower);\n+    hlen = ngx_http_huff_encode(src, len, tmp, lower);\n \n     if (hlen > 0) {\n         *dst = NGX_HTTP_V2_ENCODE_HUFF;\n"
    },
    {
        "commit_sha": "e90c084954e3f724f71fb486985c1cc569af116f",
        "commit_index": "Commit 134",
        "commit_diff": "Diff:\n@@ -152,6 +152,7 @@ syn keyword ngxDirective contained auth_jwt_header_set\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n+syn keyword ngxDirective contained auth_jwt_require\n syn keyword ngxDirective contained auth_jwt_type\n syn keyword ngxDirective contained auth_request\n syn keyword ngxDirective contained auth_request_set\n@@ -335,6 +336,10 @@ syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n+syn keyword ngxDirective contained js_fetch_ciphers\n+syn keyword ngxDirective contained js_fetch_protocols\n+syn keyword ngxDirective contained js_fetch_trusted_certificate\n+syn keyword ngxDirective contained js_fetch_verify_depth\n syn keyword ngxDirective contained js_filter\n syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n@@ -402,6 +407,7 @@ syn keyword ngxDirective contained mp4_buffer_size\n syn keyword ngxDirective contained mp4_limit_rate\n syn keyword ngxDirective contained mp4_limit_rate_after\n syn keyword ngxDirective contained mp4_max_buffer_size\n+syn keyword ngxDirective contained mp4_start_key_frame\n syn keyword ngxDirective contained msie_padding\n syn keyword ngxDirective contained msie_refresh\n syn keyword ngxDirective contained multi_accept\n@@ -458,6 +464,7 @@ syn keyword ngxDirective contained proxy_cookie_flags\n syn keyword ngxDirective contained proxy_cookie_path\n syn keyword ngxDirective contained proxy_download_rate\n syn keyword ngxDirective contained proxy_force_ranges\n+syn keyword ngxDirective contained proxy_half_close\n syn keyword ngxDirective contained proxy_headers_hash_bucket_size\n syn keyword ngxDirective contained proxy_headers_hash_max_size\n syn keyword ngxDirective contained proxy_hide_header\n@@ -597,6 +604,7 @@ syn keyword ngxDirective contained ssi_min_file_chunk\n syn keyword ngxDirective contained ssi_silent_errors\n syn keyword ngxDirective contained ssi_types\n syn keyword ngxDirective contained ssi_value_length\n+syn keyword ngxDirective contained ssl_alpn\n syn keyword ngxDirective contained ssl_buffer_size\n syn keyword ngxDirective contained ssl_certificate\n syn keyword ngxDirective contained ssl_certificate_key\n@@ -788,11 +796,15 @@ syn keyword ngxDirectiveThirdParty contained auth_digest_user_file\n syn keyword ngxDirectiveThirdParty contained auth_gss\n syn keyword ngxDirectiveThirdParty contained auth_gss_allow_basic_fallback\n syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n+syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal_regex\n+syn keyword ngxDirectiveThirdParty contained auth_gss_constrained_delegation\n+syn keyword ngxDirectiveThirdParty contained auth_gss_delegate_credentials\n syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n+syn keyword ngxDirectiveThirdParty contained auth_gss_service_ccache\n syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n \n \" LDAP Authentication\n@@ -969,7 +981,6 @@ syn keyword ngxDirectiveThirdParty contained fancyindex_hide_parent_dir\n syn keyword ngxDirectiveThirdParty contained fancyindex_hide_symlinks\n syn keyword ngxDirectiveThirdParty contained fancyindex_ignore\n syn keyword ngxDirectiveThirdParty contained fancyindex_localtime\n-syn keyword ngxDirectiveThirdParty contained fancyindex_name_length\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_dotfiles\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_path\n syn keyword ngxDirectiveThirdParty contained fancyindex_time_format\n@@ -1059,20 +1070,39 @@ syn keyword ngxDirectiveThirdParty contained nchan_publisher_upstream_request\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_location\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_discovered_ip_range_blacklist\n syn keyword ngxDirectiveThirdParty contained nchan_redis_fakesub_timer_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_idle_channel_cache_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_namespace\n syn keyword ngxDirectiveThirdParty contained nchan_redis_nostore_fastpublish\n syn keyword ngxDirectiveThirdParty contained nchan_redis_optimize_target\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass_inheritable\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_password\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ping_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_publish_msgpacked_max_size\n syn keyword ngxDirectiveThirdParty contained nchan_redis_server\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_ciphers\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_client_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_client_certificate_key\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_server_name\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_trusted_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_trusted_certificate_path\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_verify_certificate\n syn keyword ngxDirectiveThirdParty contained nchan_redis_storage_mode\n syn keyword ngxDirectiveThirdParty contained nchan_redis_subscribe_weights\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_ciphers\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_client_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_server_name\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_trusted_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_trusted_certificate_path\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_verify_certificate\n syn keyword ngxDirectiveThirdParty contained nchan_redis_url\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_username\n syn keyword ngxDirectiveThirdParty contained nchan_redis_wait_after_connecting\n syn keyword ngxDirectiveThirdParty contained nchan_shared_memory_size\n syn keyword ngxDirectiveThirdParty contained nchan_storage_engine\n@@ -1385,13 +1415,15 @@ syn keyword ngxDirectiveThirdParty contained lua_socket_read_timeout\n syn keyword ngxDirectiveThirdParty contained lua_socket_send_lowat\n syn keyword ngxDirectiveThirdParty contained lua_socket_send_timeout\n syn keyword ngxDirectiveThirdParty contained lua_ssl_ciphers\n+syn keyword ngxDirectiveThirdParty contained lua_ssl_conf_command\n syn keyword ngxDirectiveThirdParty contained lua_ssl_crl\n syn keyword ngxDirectiveThirdParty contained lua_ssl_protocols\n syn keyword ngxDirectiveThirdParty contained lua_ssl_trusted_certificate\n syn keyword ngxDirectiveThirdParty contained lua_ssl_verify_depth\n syn keyword ngxDirectiveThirdParty contained lua_thread_cache_max_entries\n syn keyword ngxDirectiveThirdParty contained lua_transform_underscores_in_response_headers\n syn keyword ngxDirectiveThirdParty contained lua_use_default_type\n+syn keyword ngxDirectiveThirdParty contained lua_worker_thread_vm_pool_size\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_block\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_file\n@@ -1401,6 +1433,8 @@ syn keyword ngxDirectiveThirdParty contained set_by_lua_block\n syn keyword ngxDirectiveThirdParty contained set_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_certificate_by_lua_block\n syn keyword ngxDirectiveThirdParty contained ssl_certificate_by_lua_file\n+syn keyword ngxDirectiveThirdParty contained ssl_client_hello_by_lua_block\n+syn keyword ngxDirectiveThirdParty contained ssl_client_hello_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_session_fetch_by_lua_block\n syn keyword ngxDirectiveThirdParty contained ssl_session_fetch_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_session_store_by_lua_block\n@@ -1719,15 +1753,18 @@ syn keyword ngxDirectiveThirdParty contained set_base32_alphabet\n syn keyword ngxDirectiveThirdParty contained set_base32_padding\n syn keyword ngxDirectiveThirdParty contained set_decode_base32\n syn keyword ngxDirectiveThirdParty contained set_decode_base64\n+syn keyword ngxDirectiveThirdParty contained set_decode_base64url\n syn keyword ngxDirectiveThirdParty contained set_decode_hex\n syn keyword ngxDirectiveThirdParty contained set_encode_base32\n syn keyword ngxDirectiveThirdParty contained set_encode_base64\n+syn keyword ngxDirectiveThirdParty contained set_encode_base64url\n syn keyword ngxDirectiveThirdParty contained set_encode_hex\n syn keyword ngxDirectiveThirdParty contained set_escape_uri\n syn keyword ngxDirectiveThirdParty contained set_formatted_gmt_time\n syn keyword ngxDirectiveThirdParty contained set_formatted_local_time\n syn keyword ngxDirectiveThirdParty contained set_hashed_upstream\n syn keyword ngxDirectiveThirdParty contained set_hmac_sha1\n+syn keyword ngxDirectiveThirdParty contained set_hmac_sha256\n syn keyword ngxDirectiveThirdParty contained set_if_empty\n syn keyword ngxDirectiveThirdParty contained set_local_today\n syn keyword ngxDirectiveThirdParty contained set_misc_base32_padding\n@@ -1849,6 +1886,7 @@ syn keyword ngxDirectiveThirdParty contained vod_notification_uri\n syn keyword ngxDirectiveThirdParty contained vod_open_file_thread_pool\n syn keyword ngxDirectiveThirdParty contained vod_output_buffer_pool\n syn keyword ngxDirectiveThirdParty contained vod_parse_hdlr_name\n+syn keyword ngxDirectiveThirdParty contained vod_parse_udta_name\n syn keyword ngxDirectiveThirdParty contained vod_path_response_postfix\n syn keyword ngxDirectiveThirdParty contained vod_path_response_prefix\n syn keyword ngxDirectiveThirdParty contained vod_performance_counters\nDiff:\n@@ -253,16 +253,32 @@ static void\n ngx_http_copy_aio_sendfile_event_handler(ngx_event_t *ev)\n {\n     ngx_event_aio_t     *aio;\n+    ngx_connection_t    *c;\n     ngx_http_request_t  *r;\n \n     aio = ev->data;\n     r = aio->data;\n+    c = r->connection;\n \n     r->main->blocked--;\n     r->aio = 0;\n     ev->complete = 0;\n \n-    r->connection->write->handler(r->connection->write);\n+#if (NGX_HTTP_V2)\n+\n+    if (r->stream) {\n+        /*\n+         * for HTTP/2, update write event to make sure processing will\n+         * reach the main connection to handle sendfile() preload\n+         */\n+\n+        c->write->ready = 1;\n+        c->write->active = 0;\n+    }\n+\n+#endif\n+\n+    c->write->handler(c->write);\n }\n \n #endif\n@@ -357,6 +373,20 @@ ngx_http_copy_thread_event_handler(ngx_event_t *ev)\n     r->main->blocked--;\n     r->aio = 0;\n \n+#if (NGX_HTTP_V2)\n+\n+    if (r->stream) {\n+        /*\n+         * for HTTP/2, update write event to make sure processing will\n+         * reach the main connection to handle sendfile() in threads\n+         */\n+\n+        c->write->ready = 1;\n+        c->write->active = 0;\n+    }\n+\n+#endif\n+\n     if (r->done) {\n         /*\n          * trigger connection event handler if the subrequest was\nDiff:\n@@ -3927,6 +3927,20 @@ ngx_http_upstream_thread_event_handler(ngx_event_t *ev)\n     r->main->blocked--;\n     r->aio = 0;\n \n+#if (NGX_HTTP_V2)\n+\n+    if (r->stream) {\n+        /*\n+         * for HTTP/2, update write event to make sure processing will\n+         * reach the main connection to handle sendfile() in threads\n+         */\n+\n+        c->write->ready = 1;\n+        c->write->active = 0;\n+    }\n+\n+#endif\n+\n     if (r->done) {\n         /*\n          * trigger connection event handler if the subrequest was\nDiff:\n@@ -1432,6 +1432,9 @@ ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)\n     size = 0;\n #endif\n \n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 send chain: %p\", in);\n+\n     while (in) {\n         size = ngx_buf_size(in->buf);\n \n@@ -1450,12 +1453,8 @@ ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)\n             return NGX_CHAIN_ERROR;\n         }\n \n-        if (stream->queued) {\n-            fc->write->active = 1;\n-            fc->write->ready = 0;\n-\n-        } else {\n-            fc->buffered &= ~NGX_HTTP_V2_BUFFERED;\n+        if (ngx_http_v2_filter_send(fc, stream) == NGX_ERROR) {\n+            return NGX_CHAIN_ERROR;\n         }\n \n         return NULL;\n@@ -1464,9 +1463,16 @@ ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)\n     h2c = stream->connection;\n \n     if (size && ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n-        fc->write->active = 1;\n-        fc->write->ready = 0;\n-        return in;\n+\n+        if (ngx_http_v2_filter_send(fc, stream) == NGX_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        if (ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n+            fc->write->active = 1;\n+            fc->write->ready = 0;\n+            return in;\n+        }\n     }\n \n     if (in->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow) {\n@@ -1809,6 +1815,11 @@ ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,\n static ngx_inline ngx_int_t\n ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)\n {\n+    if (stream->queued == 0) {\n+        fc->buffered &= ~NGX_HTTP_V2_BUFFERED;\n+        return NGX_OK;\n+    }\n+\n     stream->blocked = 1;\n \n     if (ngx_http_v2_send_output_queue(stream->connection) == NGX_ERROR) {\n"
    },
    {
        "commit_sha": "aec719f5fd3e438a68105ab109401225ca9088ea",
        "commit_index": "Commit 133",
        "commit_diff": "Diff:\n@@ -219,13 +219,25 @@ ngx_http_copy_aio_sendfile_preload(ngx_buf_t *file)\n     ngx_http_request_t      *r;\n     ngx_output_chain_ctx_t  *ctx;\n \n+    aio = file->file->aio;\n+    r = aio->data;\n+\n+    if (r->aio) {\n+        /*\n+         * tolerate sendfile() calls if another operation is already\n+         * running; this can happen due to subrequests, multiple calls\n+         * of the next body filter from a filter, or in HTTP/2 due to\n+         * a write event on the main connection\n+         */\n+\n+        return NGX_AGAIN;\n+    }\n+\n     n = ngx_file_aio_read(file->file, buf, 1, file->file_pos, NULL);\n \n     if (n == NGX_AGAIN) {\n-        aio = file->file->aio;\n         aio->handler = ngx_http_copy_aio_sendfile_event_handler;\n \n-        r = aio->data;\n         r->main->blocked++;\n         r->aio = 1;\n \n@@ -263,13 +275,35 @@ static ngx_int_t\n ngx_http_copy_thread_handler(ngx_thread_task_t *task, ngx_file_t *file)\n {\n     ngx_str_t                  name;\n+    ngx_connection_t          *c;\n     ngx_thread_pool_t         *tp;\n     ngx_http_request_t        *r;\n     ngx_output_chain_ctx_t    *ctx;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r = file->thread_ctx;\n \n+    if (r->aio) {\n+        /*\n+         * tolerate sendfile() calls if another operation is already\n+         * running; this can happen due to subrequests, multiple calls\n+         * of the next body filter from a filter, or in HTTP/2 due to\n+         * a write event on the main connection\n+         */\n+\n+        c = r->connection;\n+\n+#if (NGX_HTTP_V2)\n+        if (r->stream) {\n+            c = r->stream->connection->connection;\n+        }\n+#endif\n+\n+        if (task == c->sendfile_task) {\n+            return NGX_OK;\n+        }\n+    }\n+\n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n     tp = clcf->thread_pool;\n \nDiff:\n@@ -3847,13 +3847,35 @@ ngx_http_upstream_thread_handler(ngx_thread_task_t *task, ngx_file_t *file)\n {\n     ngx_str_t                  name;\n     ngx_event_pipe_t          *p;\n+    ngx_connection_t          *c;\n     ngx_thread_pool_t         *tp;\n     ngx_http_request_t        *r;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r = file->thread_ctx;\n     p = r->upstream->pipe;\n \n+    if (r->aio) {\n+        /*\n+         * tolerate sendfile() calls if another operation is already\n+         * running; this can happen due to subrequests, multiple calls\n+         * of the next body filter from a filter, or in HTTP/2 due to\n+         * a write event on the main connection\n+         */\n+\n+        c = r->connection;\n+\n+#if (NGX_HTTP_V2)\n+        if (r->stream) {\n+            c = r->stream->connection->connection;\n+        }\n+#endif\n+\n+        if (task == c->sendfile_task) {\n+            return NGX_OK;\n+        }\n+    }\n+\n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n     tp = clcf->thread_pool;\n \nDiff:\n@@ -255,19 +255,6 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n #if (NGX_HAVE_AIO_SENDFILE)\n \n         if (ebusy) {\n-            if (aio->event.active) {\n-                /*\n-                 * tolerate duplicate calls; they can happen due to subrequests\n-                 * or multiple calls of the next body filter from a filter\n-                 */\n-\n-                if (sent) {\n-                    c->busy_count = 0;\n-                }\n-\n-                return in;\n-            }\n-\n             if (sent == 0) {\n                 c->busy_count++;\n \nDiff:\n@@ -426,15 +426,6 @@ ngx_linux_sendfile_thread(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n         return ctx->sent;\n     }\n \n-    if (task->event.active && ctx->file == file) {\n-        /*\n-         * tolerate duplicate calls; they can happen due to subrequests\n-         * or multiple calls of the next body filter from a filter\n-         */\n-\n-        return NGX_DONE;\n-    }\n-\n     ctx->file = file;\n     ctx->socket = c->fd;\n     ctx->size = size;\n"
    },
    {
        "commit_sha": "9458141bea34a92e1b4f5da1f03af3cfd673fc0a",
        "commit_index": "Commit 132",
        "commit_diff": "Diff:\n@@ -4733,6 +4733,42 @@ ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n }\n \n \n+ngx_int_t\n+ngx_ssl_get_curve(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n+{\n+#ifdef SSL_get_negotiated_group\n+\n+    int  nid;\n+\n+    nid = SSL_get_negotiated_group(c->ssl->connection);\n+\n+    if (nid != NID_undef) {\n+\n+        if ((nid & TLSEXT_nid_unknown) == 0) {\n+            s->len = ngx_strlen(OBJ_nid2sn(nid));\n+            s->data = (u_char *) OBJ_nid2sn(nid);\n+            return NGX_OK;\n+        }\n+\n+        s->len = sizeof(\"0x0000\") - 1;\n+\n+        s->data = ngx_pnalloc(pool, s->len);\n+        if (s->data == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_sprintf(s->data, \"0x%04xd\", nid & 0xffff);\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    s->len = 0;\n+    return NGX_OK;\n+}\n+\n+\n ngx_int_t\n ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n {\nDiff:\n@@ -256,6 +256,8 @@ ngx_int_t ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n+ngx_int_t ngx_ssl_get_curve(ngx_connection_t *c, ngx_pool_t *pool,\n+    ngx_str_t *s);\n ngx_int_t ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool,\nDiff:\n@@ -342,6 +342,9 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {\n     { ngx_string(\"ssl_ciphers\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_ciphers, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_curve\"), NULL, ngx_http_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_curve, NGX_HTTP_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_curves\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_curves, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \nDiff:\n@@ -269,6 +269,9 @@ static ngx_stream_variable_t  ngx_stream_ssl_vars[] = {\n     { ngx_string(\"ssl_ciphers\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_ciphers, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_curve\"), NULL, ngx_stream_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_curve, NGX_STREAM_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_curves\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_curves, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n"
    },
    {
        "commit_sha": "51fc0ac631a80aee6adca7878b0224f6a7070833",
        "commit_index": "Commit 131",
        "commit_diff": "Diff:\n@@ -464,3 +464,4 @@ df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\n+39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\nDiff:\n@@ -5,6 +5,137 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.4\" date=\"2021-11-02\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+поддержка NPN вместо ALPN для установления HTTP/2-соединений\n+упразднена.\n+</para>\n+<para lang=\"en\">\n+support for NPN instead of ALPN to establish HTTP/2 connections\n+has been removed.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx закрывает SSL соединение, если клиент использует ALPN,\n+но nginx не поддерживает ни один из присланных клиентом протоколов.\n+</para>\n+<para lang=\"en\">\n+now nginx rejects SSL connections if ALPN is used by the client,\n+but no supported protocols can be negotiated.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+в директиве sendfile_max_chunk значение по умолчанию\n+изменено на 2 мегабайта.\n+</para>\n+<para lang=\"en\">\n+the default value of the \"sendfile_max_chunk\" directive\n+was changed to 2 megabytes.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива proxy_half_close в модуле stream.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_half_close\" directive in the stream module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива ssl_alpn в модуле stream.\n+</para>\n+<para lang=\"en\">\n+the \"ssl_alpn\" directive in the stream module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $ssl_alpn_protocol.\n+</para>\n+<para lang=\"en\">\n+the $ssl_alpn_protocol variable.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+поддержка SSL_sendfile() при использовании OpenSSL 3.0.\n+</para>\n+<para lang=\"en\">\n+support for SSL_sendfile() when using OpenSSL 3.0.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива mp4_start_key_frame в модуле ngx_http_mp4_module.<br/>\n+Спасибо Tracey Jaquith.\n+</para>\n+<para lang=\"en\">\n+the \"mp4_start_key_frame\" directive in the ngx_http_mp4_module.<br/>\n+Thanks to Tracey Jaquith.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в переменной $content_length при использовании chunked transfer encoding.\n+</para>\n+<para lang=\"en\">\n+in the $content_length variable when using chunked transfer encoding.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при получении ответа некорректной длины от проксируемого бэкенда\n+nginx мог тем не менее закэшировать соединение.<br/>\n+Спасибо Awdhesh Mathpal.\n+</para>\n+<para lang=\"en\">\n+after receiving a response with incorrect length from a proxied backend\n+nginx might nevertheless cache the connection.<br/>\n+Thanks to Awdhesh Mathpal.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+некорректные заголовки от бэкендов\n+логгировались на уровне info вместо error;\n+ошибка появилась в 1.21.1.\n+</para>\n+<para lang=\"en\">\n+invalid headers from backends\n+were logged at the \"info\" level instead of \"error\";\n+the bug had appeared in 1.21.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2 и директивы aio_write\n+запросы могли зависать.\n+</para>\n+<para lang=\"en\">\n+requests might hang\n+when using HTTP/2 and the \"aio_write\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.3\" date=\"2021-09-07\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021004\n-#define NGINX_VERSION      \"1.21.4\"\n+#define nginx_version      1021005\n+#define NGINX_VERSION      \"1.21.5\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "2f367147e4bee5345784f9f360bb0ef249d347fa",
        "commit_index": "Commit 130",
        "commit_diff": "Diff:\n@@ -203,16 +203,16 @@ ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free, ngx_chain_t **busy,\n     while (*busy) {\n         cl = *busy;\n \n-        if (ngx_buf_size(cl->buf) != 0) {\n-            break;\n-        }\n-\n         if (cl->buf->tag != tag) {\n             *busy = cl->next;\n             ngx_free_chain(p, cl);\n             continue;\n         }\n \n+        if (ngx_buf_size(cl->buf) != 0) {\n+            break;\n+        }\n+\n         cl->buf->pos = cl->buf->start;\n         cl->buf->last = cl->buf->start;\n \nDiff:\n@@ -804,6 +804,10 @@ ngx_chain_writer(void *data, ngx_chain_t *in)\n         return NGX_ERROR;\n     }\n \n+    if (chain && c->write->ready) {\n+        ngx_post_event(c->write, &ngx_posted_next_events);\n+    }\n+\n     for (cl = ctx->out; cl && cl != chain; /* void */) {\n         ln = cl;\n         cl = cl->next;\nDiff:\n@@ -3720,7 +3720,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->internal, prev->internal, 0);\n     ngx_conf_merge_value(conf->sendfile, prev->sendfile, 0);\n     ngx_conf_merge_size_value(conf->sendfile_max_chunk,\n-                              prev->sendfile_max_chunk, 0);\n+                              prev->sendfile_max_chunk, 2 * 1024 * 1024);\n     ngx_conf_merge_size_value(conf->subrequest_output_buffer_size,\n                               prev->subrequest_output_buffer_size,\n                               (size_t) ngx_pagesize);\nDiff:\n@@ -1511,8 +1511,9 @@ ngx_http_upstream_check_broken_connection(ngx_http_request_t *r,\n static void\n ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)\n {\n-    ngx_int_t          rc;\n-    ngx_connection_t  *c;\n+    ngx_int_t                  rc;\n+    ngx_connection_t          *c;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     r->connection->log->action = \"connecting to upstream\";\n \n@@ -1599,10 +1600,12 @@ ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)\n \n     /* init or reinit the ngx_output_chain() and ngx_chain_writer() contexts */\n \n+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+\n     u->writer.out = NULL;\n     u->writer.last = &u->writer.out;\n     u->writer.connection = c;\n-    u->writer.limit = 0;\n+    u->writer.limit = clcf->sendfile_max_chunk;\n \n     if (u->request_sent) {\n         if (ngx_http_upstream_reinit(r, u) != NGX_OK) {\n"
    },
    {
        "commit_sha": "0548eca94fee63ba55cfd81acae09058cc2071c7",
        "commit_index": "Commit 129",
        "commit_diff": "Diff:\n@@ -11,38 +11,41 @@\n \n #define NGX_HTTP_MP4_TRAK_ATOM     0\n #define NGX_HTTP_MP4_TKHD_ATOM     1\n-#define NGX_HTTP_MP4_MDIA_ATOM     2\n-#define NGX_HTTP_MP4_MDHD_ATOM     3\n-#define NGX_HTTP_MP4_HDLR_ATOM     4\n-#define NGX_HTTP_MP4_MINF_ATOM     5\n-#define NGX_HTTP_MP4_VMHD_ATOM     6\n-#define NGX_HTTP_MP4_SMHD_ATOM     7\n-#define NGX_HTTP_MP4_DINF_ATOM     8\n-#define NGX_HTTP_MP4_STBL_ATOM     9\n-#define NGX_HTTP_MP4_STSD_ATOM    10\n-#define NGX_HTTP_MP4_STTS_ATOM    11\n-#define NGX_HTTP_MP4_STTS_DATA    12\n-#define NGX_HTTP_MP4_STSS_ATOM    13\n-#define NGX_HTTP_MP4_STSS_DATA    14\n-#define NGX_HTTP_MP4_CTTS_ATOM    15\n-#define NGX_HTTP_MP4_CTTS_DATA    16\n-#define NGX_HTTP_MP4_STSC_ATOM    17\n-#define NGX_HTTP_MP4_STSC_START   18\n-#define NGX_HTTP_MP4_STSC_DATA    19\n-#define NGX_HTTP_MP4_STSC_END     20\n-#define NGX_HTTP_MP4_STSZ_ATOM    21\n-#define NGX_HTTP_MP4_STSZ_DATA    22\n-#define NGX_HTTP_MP4_STCO_ATOM    23\n-#define NGX_HTTP_MP4_STCO_DATA    24\n-#define NGX_HTTP_MP4_CO64_ATOM    25\n-#define NGX_HTTP_MP4_CO64_DATA    26\n+#define NGX_HTTP_MP4_EDTS_ATOM     2\n+#define NGX_HTTP_MP4_ELST_ATOM     3\n+#define NGX_HTTP_MP4_MDIA_ATOM     4\n+#define NGX_HTTP_MP4_MDHD_ATOM     5\n+#define NGX_HTTP_MP4_HDLR_ATOM     6\n+#define NGX_HTTP_MP4_MINF_ATOM     7\n+#define NGX_HTTP_MP4_VMHD_ATOM     8\n+#define NGX_HTTP_MP4_SMHD_ATOM     9\n+#define NGX_HTTP_MP4_DINF_ATOM    10\n+#define NGX_HTTP_MP4_STBL_ATOM    11\n+#define NGX_HTTP_MP4_STSD_ATOM    12\n+#define NGX_HTTP_MP4_STTS_ATOM    13\n+#define NGX_HTTP_MP4_STTS_DATA    14\n+#define NGX_HTTP_MP4_STSS_ATOM    15\n+#define NGX_HTTP_MP4_STSS_DATA    16\n+#define NGX_HTTP_MP4_CTTS_ATOM    17\n+#define NGX_HTTP_MP4_CTTS_DATA    18\n+#define NGX_HTTP_MP4_STSC_ATOM    19\n+#define NGX_HTTP_MP4_STSC_START   20\n+#define NGX_HTTP_MP4_STSC_DATA    21\n+#define NGX_HTTP_MP4_STSC_END     22\n+#define NGX_HTTP_MP4_STSZ_ATOM    23\n+#define NGX_HTTP_MP4_STSZ_DATA    24\n+#define NGX_HTTP_MP4_STCO_ATOM    25\n+#define NGX_HTTP_MP4_STCO_DATA    26\n+#define NGX_HTTP_MP4_CO64_ATOM    27\n+#define NGX_HTTP_MP4_CO64_DATA    28\n \n #define NGX_HTTP_MP4_LAST_ATOM    NGX_HTTP_MP4_CO64_DATA\n \n \n typedef struct {\n     size_t                buffer_size;\n     size_t                max_buffer_size;\n+    ngx_flag_t            start_key_frame;\n } ngx_http_mp4_conf_t;\n \n \n@@ -53,6 +56,25 @@ typedef struct {\n } ngx_mp4_stsc_entry_t;\n \n \n+typedef struct {\n+    u_char                size[4];\n+    u_char                name[4];\n+} ngx_mp4_edts_atom_t;\n+\n+\n+typedef struct {\n+    u_char                size[4];\n+    u_char                name[4];\n+    u_char                version[1];\n+    u_char                flags[3];\n+    u_char                entries[4];\n+    u_char                duration[8];\n+    u_char                media_time[8];\n+    u_char                media_rate[2];\n+    u_char                reserved[2];\n+} ngx_mp4_elst_atom_t;\n+\n+\n typedef struct {\n     uint32_t              timescale;\n     uint32_t              time_to_sample_entries;\n@@ -71,6 +93,8 @@ typedef struct {\n     uint64_t              start_chunk_samples_size;\n     uint64_t              end_chunk_samples_size;\n     uint64_t              duration;\n+    uint64_t              prefix;\n+    uint64_t              movie_duration;\n     off_t                 start_offset;\n     off_t                 end_offset;\n \n@@ -86,6 +110,8 @@ typedef struct {\n \n     ngx_buf_t             trak_atom_buf;\n     ngx_buf_t             tkhd_atom_buf;\n+    ngx_buf_t             edts_atom_buf;\n+    ngx_buf_t             elst_atom_buf;\n     ngx_buf_t             mdia_atom_buf;\n     ngx_buf_t             mdhd_atom_buf;\n     ngx_buf_t             hdlr_atom_buf;\n@@ -112,6 +138,8 @@ typedef struct {\n     ngx_buf_t             co64_atom_buf;\n     ngx_buf_t             co64_data_buf;\n \n+    ngx_mp4_edts_atom_t   edts_atom;\n+    ngx_mp4_elst_atom_t   elst_atom;\n     ngx_mp4_stsc_entry_t  stsc_start_chunk_entry;\n     ngx_mp4_stsc_entry_t  stsc_end_chunk_entry;\n } ngx_http_mp4_trak_t;\n@@ -187,6 +215,14 @@ typedef struct {\n     ((u_char *) (p))[6] = n3;                                                 \\\n     ((u_char *) (p))[7] = n4\n \n+#define ngx_mp4_get_16value(p)                                                \\\n+    ( ((uint16_t) ((u_char *) (p))[0] << 8)                                   \\\n+    + (           ((u_char *) (p))[1]) )\n+\n+#define ngx_mp4_set_16value(p, n)                                             \\\n+    ((u_char *) (p))[0] = (u_char) ((n) >> 8);                                \\\n+    ((u_char *) (p))[1] = (u_char)  (n)\n+\n #define ngx_mp4_get_32value(p)                                                \\\n     ( ((uint32_t) ((u_char *) (p))[0] << 24)                                  \\\n     + (           ((u_char *) (p))[1] << 16)                                  \\\n@@ -270,6 +306,8 @@ static ngx_int_t ngx_http_mp4_read_smhd_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n static ngx_int_t ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n+static void ngx_http_mp4_update_edts_atom(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak);\n static void ngx_http_mp4_update_stbl_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_read_stsd_atom(ngx_http_mp4_file_t *mp4,\n@@ -280,6 +318,8 @@ static ngx_int_t ngx_http_mp4_update_stts_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak, ngx_uint_t start);\n+static uint32_t ngx_http_mp4_seek_key_frame(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak, uint32_t start_sample);\n static ngx_int_t ngx_http_mp4_read_stss_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n static ngx_int_t ngx_http_mp4_update_stss_atom(ngx_http_mp4_file_t *mp4,\n@@ -343,6 +383,13 @@ static ngx_command_t  ngx_http_mp4_commands[] = {\n       offsetof(ngx_http_mp4_conf_t, max_buffer_size),\n       NULL },\n \n+    { ngx_string(\"mp4_start_key_frame\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_mp4_conf_t, start_key_frame),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -829,6 +876,7 @@ ngx_http_mp4_process(ngx_http_mp4_file_t *mp4)\n         trak[i].size += trak[i].hdlr_size;\n         ngx_http_mp4_update_mdia_atom(mp4, &trak[i]);\n         trak[i].size += trak[i].tkhd_size;\n+        ngx_http_mp4_update_edts_atom(mp4, &trak[i]);\n         ngx_http_mp4_update_trak_atom(mp4, &trak[i]);\n \n         mp4->moov_size += trak[i].size;\n@@ -1590,6 +1638,7 @@ ngx_http_mp4_read_tkhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n     trak->tkhd_size = atom_size;\n+    trak->movie_duration = duration;\n \n     ngx_mp4_set_32value(tkhd_atom->size, atom_size);\n \n@@ -1985,6 +2034,59 @@ ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n }\n \n \n+static void\n+ngx_http_mp4_update_edts_atom(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak)\n+{\n+    ngx_buf_t            *atom;\n+    ngx_mp4_elst_atom_t  *elst_atom;\n+    ngx_mp4_edts_atom_t  *edts_atom;\n+\n+    if (trak->prefix == 0) {\n+        return;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n+                   \"mp4 edts atom update prefix:%uL\", trak->prefix);\n+\n+    edts_atom = &trak->edts_atom;\n+    ngx_mp4_set_32value(edts_atom->size, sizeof(ngx_mp4_edts_atom_t)\n+                                         + sizeof(ngx_mp4_elst_atom_t));\n+    ngx_mp4_set_atom_name(edts_atom, 'e', 'd', 't', 's');\n+\n+    atom = &trak->edts_atom_buf;\n+    atom->temporary = 1;\n+    atom->pos = (u_char *) edts_atom;\n+    atom->last = (u_char *) edts_atom + sizeof(ngx_mp4_edts_atom_t);\n+\n+    trak->out[NGX_HTTP_MP4_EDTS_ATOM].buf = atom;\n+\n+    elst_atom = &trak->elst_atom;\n+    ngx_mp4_set_32value(elst_atom->size, sizeof(ngx_mp4_elst_atom_t));\n+    ngx_mp4_set_atom_name(elst_atom, 'e', 'l', 's', 't');\n+\n+    elst_atom->version[0] = 1;\n+    elst_atom->flags[0] = 0;\n+    elst_atom->flags[1] = 0;\n+    elst_atom->flags[2] = 0;\n+\n+    ngx_mp4_set_32value(elst_atom->entries, 1);\n+    ngx_mp4_set_64value(elst_atom->duration, trak->movie_duration);\n+    ngx_mp4_set_64value(elst_atom->media_time, trak->prefix);\n+    ngx_mp4_set_16value(elst_atom->media_rate, 1);\n+    ngx_mp4_set_16value(elst_atom->reserved, 0);\n+\n+    atom = &trak->elst_atom_buf;\n+    atom->temporary = 1;\n+    atom->pos = (u_char *) elst_atom;\n+    atom->last = (u_char *) elst_atom + sizeof(ngx_mp4_elst_atom_t);\n+\n+    trak->out[NGX_HTTP_MP4_ELST_ATOM].buf = atom;\n+\n+    trak->size += sizeof(ngx_mp4_edts_atom_t) + sizeof(ngx_mp4_elst_atom_t);\n+}\n+\n+\n static void\n ngx_http_mp4_update_stbl_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak)\n@@ -2183,7 +2285,7 @@ static ngx_int_t\n ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak, ngx_uint_t start)\n {\n-    uint32_t               count, duration, rest;\n+    uint32_t               count, duration, rest, key_prefix;\n     uint64_t               start_time;\n     ngx_buf_t             *data;\n     ngx_uint_t             start_sample, entries, start_sec;\n@@ -2207,7 +2309,7 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n \n     data = trak->out[NGX_HTTP_MP4_STTS_DATA].buf;\n \n-    start_time = (uint64_t) start_sec * trak->timescale / 1000;\n+    start_time = (uint64_t) start_sec * trak->timescale / 1000 + trak->prefix;\n \n     entries = trak->time_to_sample_entries;\n     start_sample = 0;\n@@ -2253,6 +2355,26 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n found:\n \n     if (start) {\n+        key_prefix = ngx_http_mp4_seek_key_frame(mp4, trak, start_sample);\n+\n+        start_sample -= key_prefix;\n+\n+        while (rest < key_prefix) {\n+            trak->prefix += rest * duration;\n+            key_prefix -= rest;\n+\n+            entry--;\n+            entries++;\n+\n+            count = ngx_mp4_get_32value(entry->count);\n+            duration = ngx_mp4_get_32value(entry->duration);\n+            rest = count;\n+        }\n+\n+        trak->prefix += key_prefix * duration;\n+        trak->duration += trak->prefix;\n+        rest -= key_prefix;\n+\n         ngx_mp4_set_32value(entry->count, count - rest);\n         data->pos = (u_char *) entry;\n         trak->time_to_sample_entries = entries;\n@@ -2277,6 +2399,49 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n }\n \n \n+static uint32_t\n+ngx_http_mp4_seek_key_frame(ngx_http_mp4_file_t *mp4, ngx_http_mp4_trak_t *trak,\n+    uint32_t start_sample)\n+{\n+    uint32_t              key_prefix, sample, *entry, *end;\n+    ngx_buf_t            *data;\n+    ngx_http_mp4_conf_t  *conf;\n+\n+    conf = ngx_http_get_module_loc_conf(mp4->request, ngx_http_mp4_module);\n+    if (!conf->start_key_frame) {\n+        return 0;\n+    }\n+\n+    data = trak->out[NGX_HTTP_MP4_STSS_DATA].buf;\n+    if (data == NULL) {\n+        return 0;\n+    }\n+\n+    entry = (uint32_t *) data->pos;\n+    end = (uint32_t *) data->last;\n+\n+    /* sync samples starts from 1 */\n+    start_sample++;\n+\n+    key_prefix = 0;\n+\n+    while (entry < end) {\n+        sample = ngx_mp4_get_32value(entry);\n+        if (sample > start_sample) {\n+            break;\n+        }\n+\n+        key_prefix = start_sample - sample;\n+        entry++;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n+                   \"mp4 key frame prefix:%uD\", key_prefix);\n+\n+    return key_prefix;\n+}\n+\n+\n typedef struct {\n     u_char    size[4];\n     u_char    name[4];\n@@ -3614,6 +3779,7 @@ ngx_http_mp4_create_conf(ngx_conf_t *cf)\n \n     conf->buffer_size = NGX_CONF_UNSET_SIZE;\n     conf->max_buffer_size = NGX_CONF_UNSET_SIZE;\n+    conf->start_key_frame = NGX_CONF_UNSET;\n \n     return conf;\n }\n@@ -3628,6 +3794,7 @@ ngx_http_mp4_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size, 512 * 1024);\n     ngx_conf_merge_size_value(conf->max_buffer_size, prev->max_buffer_size,\n                               10 * 1024 * 1024);\n+    ngx_conf_merge_value(conf->start_key_frame, prev->start_key_frame, 0);\n \n     return NGX_CONF_OK;\n }\nDiff:\n@@ -321,18 +321,13 @@ ngx_http_write_filter(ngx_http_request_t *r, ngx_chain_t *in)\n         delay = (ngx_msec_t) ((nsent - sent) * 1000 / r->limit_rate);\n \n         if (delay > 0) {\n-            limit = 0;\n             c->write->delayed = 1;\n             ngx_add_timer(c->write, delay);\n         }\n     }\n \n-    if (limit\n-        && c->write->ready\n-        && c->sent - sent >= limit - (off_t) (2 * ngx_pagesize))\n-    {\n-        c->write->delayed = 1;\n-        ngx_add_timer(c->write, 1);\n+    if (chain && c->write->ready && !c->write->delayed) {\n+        ngx_post_event(c->write, &ngx_posted_next_events);\n     }\n \n     for (cl = r->out; cl && cl != chain; /* void */) {\nDiff:\n@@ -38,6 +38,9 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\n  * On Linux up to 2.6.16 sendfile() does not allow to pass the count parameter\n  * more than 2G-1 bytes even on 64-bit platforms: it returns EINVAL,\n  * so we limit it to 2G-1 bytes.\n+ *\n+ * On Linux 2.6.16 and later, sendfile() silently limits the count parameter\n+ * to 2G minus the page size, even on 64-bit platforms.\n  */\n \n #define NGX_SENDFILE_MAXSIZE  2147483647L\n@@ -259,7 +262,6 @@ ngx_linux_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n              */\n \n             send = prev_send + sent;\n-            continue;\n         }\n \n         if (send >= limit || in == NULL) {\n"
    },
    {
        "commit_sha": "cba75ce419429e47853b7064f1bfa5a0909f7c50",
        "commit_index": "Commit 128",
        "commit_diff": "Diff:\n@@ -15,6 +15,7 @@ types {\n     text/vnd.wap.wml                                 wml;\n     text/x-component                                 htc;\n \n+    image/avif                                       avif;\n     image/png                                        png;\n     image/svg+xml                                    svg svgz;\n     image/tiff                                       tif tiff;\nDiff:\n@@ -274,6 +274,10 @@ ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts)\n     }\n \n     for (n = 0; n < nelts; n++) {\n+        if (names[n].key.data == NULL) {\n+            continue;\n+        }\n+\n         if (hinit->bucket_size < NGX_HASH_ELT_SIZE(&names[n]) + sizeof(void *))\n         {\n             ngx_log_error(NGX_LOG_EMERG, hinit->pool->log, 0,\nDiff:\n@@ -70,6 +70,7 @@ typedef struct {\n     ngx_uint_t            end_chunk_samples;\n     uint64_t              start_chunk_samples_size;\n     uint64_t              end_chunk_samples_size;\n+    uint64_t              duration;\n     off_t                 start_offset;\n     off_t                 end_offset;\n \n@@ -253,6 +254,8 @@ static void ngx_http_mp4_update_mdia_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n+static void ngx_http_mp4_update_mdhd_atom(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n static ngx_int_t ngx_http_mp4_read_minf_atom(ngx_http_mp4_file_t *mp4,\n@@ -822,7 +825,7 @@ ngx_http_mp4_process(ngx_http_mp4_file_t *mp4)\n \n         ngx_http_mp4_update_stbl_atom(mp4, &trak[i]);\n         ngx_http_mp4_update_minf_atom(mp4, &trak[i]);\n-        trak[i].size += trak[i].mdhd_size;\n+        ngx_http_mp4_update_mdhd_atom(mp4, &trak[i]);\n         trak[i].size += trak[i].hdlr_size;\n         ngx_http_mp4_update_mdia_atom(mp4, &trak[i]);\n         trak[i].size += trak[i].tkhd_size;\n@@ -1749,16 +1752,10 @@ ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     trak = ngx_mp4_last_trak(mp4);\n     trak->mdhd_size = atom_size;\n     trak->timescale = timescale;\n+    trak->duration = duration;\n \n     ngx_mp4_set_32value(mdhd_atom->size, atom_size);\n \n-    if (mdhd_atom->version[0] == 0) {\n-        ngx_mp4_set_32value(mdhd_atom->duration, duration);\n-\n-    } else {\n-        ngx_mp4_set_64value(mdhd64_atom->duration, duration);\n-    }\n-\n     atom = &trak->mdhd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1772,6 +1769,33 @@ ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n }\n \n \n+static void\n+ngx_http_mp4_update_mdhd_atom(ngx_http_mp4_file_t *mp4,\n+            ngx_http_mp4_trak_t *trak)\n+{\n+    ngx_buf_t              *atom;\n+    ngx_mp4_mdhd_atom_t    *mdhd_atom;\n+    ngx_mp4_mdhd64_atom_t  *mdhd64_atom;\n+\n+    atom = trak->out[NGX_HTTP_MP4_MDHD_ATOM].buf;\n+    if (atom == NULL) {\n+        return;\n+    }\n+\n+    mdhd_atom = (ngx_mp4_mdhd_atom_t *) atom->pos;\n+    mdhd64_atom = (ngx_mp4_mdhd64_atom_t *) atom->pos;\n+\n+    if (mdhd_atom->version[0] == 0) {\n+        ngx_mp4_set_32value(mdhd_atom->duration, trak->duration);\n+\n+    } else {\n+        ngx_mp4_set_64value(mdhd64_atom->duration, trak->duration);\n+    }\n+\n+    trak->size += trak->mdhd_size;\n+}\n+\n+\n static ngx_int_t\n ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n {\n"
    },
    {
        "commit_sha": "d216a1f27ab6f011ebaaa04aef62b8b76f09f87e",
        "commit_index": "Commit 127",
        "commit_diff": "Diff:\n@@ -47,6 +47,8 @@ static void ngx_ssl_write_handler(ngx_event_t *wev);\n static ssize_t ngx_ssl_write_early(ngx_connection_t *c, u_char *data,\n     size_t size);\n #endif\n+static ssize_t ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file,\n+    size_t size);\n static void ngx_ssl_read_handler(ngx_event_t *rev);\n static void ngx_ssl_shutdown_handler(ngx_event_t *ev);\n static void ngx_ssl_connection_error(ngx_connection_t *c, int sslerr,\n@@ -1762,6 +1764,16 @@ ngx_ssl_handshake(ngx_connection_t *c)\n \n #endif\n #endif\n+#endif\n+\n+#ifdef BIO_get_ktls_send\n+\n+        if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"BIO_get_ktls_send(): 1\");\n+            c->ssl->sendfile = 1;\n+        }\n+\n #endif\n \n         rc = ngx_ssl_ocsp_validate(c);\n@@ -1899,6 +1911,16 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->read->ready = 1;\n         c->write->ready = 1;\n \n+#ifdef BIO_get_ktls_send\n+\n+        if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"BIO_get_ktls_send(): 1\");\n+            c->ssl->sendfile = 1;\n+        }\n+\n+#endif\n+\n         rc = ngx_ssl_ocsp_validate(c);\n \n         if (rc == NGX_ERROR) {\n@@ -2502,10 +2524,11 @@ ngx_ssl_write_handler(ngx_event_t *wev)\n ngx_chain_t *\n ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n {\n-    int          n;\n-    ngx_uint_t   flush;\n-    ssize_t      send, size;\n-    ngx_buf_t   *buf;\n+    int           n;\n+    ngx_uint_t    flush;\n+    ssize_t       send, size, file_size;\n+    ngx_buf_t    *buf;\n+    ngx_chain_t  *cl;\n \n     if (!c->ssl->buffer) {\n \n@@ -2579,6 +2602,11 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                 continue;\n             }\n \n+            if (in->buf->in_file && c->ssl->sendfile) {\n+                flush = 1;\n+                break;\n+            }\n+\n             size = in->buf->last - in->buf->pos;\n \n             if (size > buf->end - buf->last) {\n@@ -2610,8 +2638,35 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n         size = buf->last - buf->pos;\n \n         if (size == 0) {\n+\n+            if (in && in->buf->in_file && send < limit) {\n+\n+                /* coalesce the neighbouring file bufs */\n+\n+                cl = in;\n+                file_size = (size_t) ngx_chain_coalesce_file(&cl, limit - send);\n+\n+                n = ngx_ssl_sendfile(c, in->buf, file_size);\n+\n+                if (n == NGX_ERROR) {\n+                    return NGX_CHAIN_ERROR;\n+                }\n+\n+                if (n == NGX_AGAIN) {\n+                    break;\n+                }\n+\n+                in = ngx_chain_update_sent(in, n);\n+\n+                send += n;\n+                flush = 0;\n+\n+                continue;\n+            }\n+\n             buf->flush = 0;\n             c->buffered &= ~NGX_SSL_BUFFERED;\n+\n             return in;\n         }\n \n@@ -2636,7 +2691,7 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n         buf->pos = buf->start;\n         buf->last = buf->start;\n \n-        if (in == NULL || send == limit) {\n+        if (in == NULL || send >= limit) {\n             break;\n         }\n     }\n@@ -2882,6 +2937,150 @@ ngx_ssl_write_early(ngx_connection_t *c, u_char *data, size_t size)\n #endif\n \n \n+static ssize_t\n+ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+#ifdef BIO_get_ktls_send\n+\n+    int        sslerr;\n+    ssize_t    n;\n+    ngx_err_t  err;\n+\n+    ngx_ssl_clear_error(c->log);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"SSL to sendfile: @%O %uz\",\n+                   file->file_pos, size);\n+\n+    ngx_set_errno(0);\n+\n+    n = SSL_sendfile(c->ssl->connection, file->file->fd, file->file_pos,\n+                     size, 0);\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %d\", n);\n+\n+    if (n > 0) {\n+\n+        if (c->ssl->saved_read_handler) {\n+\n+            c->read->handler = c->ssl->saved_read_handler;\n+            c->ssl->saved_read_handler = NULL;\n+            c->read->ready = 1;\n+\n+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_post_event(c->read, &ngx_posted_events);\n+        }\n+\n+        c->sent += n;\n+\n+        return n;\n+    }\n+\n+    if (n == 0) {\n+\n+        /*\n+         * if sendfile returns zero, then someone has truncated the file,\n+         * so the offset became beyond the end of the file\n+         */\n+\n+        ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                      \"SSL_sendfile() reported that \\\"%s\\\" was truncated at %O\",\n+                      file->file->name.data, file->file_pos);\n+\n+        return NGX_ERROR;\n+    }\n+\n+    sslerr = SSL_get_error(c->ssl->connection, n);\n+\n+    if (sslerr == SSL_ERROR_ZERO_RETURN) {\n+\n+        /*\n+         * OpenSSL fails to return SSL_ERROR_SYSCALL if an error\n+         * happens during writing after close_notify alert from the\n+         * peer, and returns SSL_ERROR_ZERO_RETURN instead\n+         */\n+\n+        sslerr = SSL_ERROR_SYSCALL;\n+    }\n+\n+    if (sslerr == SSL_ERROR_SSL\n+        && ERR_GET_REASON(ERR_peek_error()) == SSL_R_UNINITIALIZED\n+        && ngx_errno != 0)\n+    {\n+        /*\n+         * OpenSSL fails to return SSL_ERROR_SYSCALL if an error\n+         * happens in sendfile(), and returns SSL_ERROR_SSL with\n+         * SSL_R_UNINITIALIZED reason instead\n+         */\n+\n+        sslerr = SSL_ERROR_SYSCALL;\n+    }\n+\n+    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_get_error: %d\", sslerr);\n+\n+    if (sslerr == SSL_ERROR_WANT_WRITE) {\n+\n+        if (c->ssl->saved_read_handler) {\n+\n+            c->read->handler = c->ssl->saved_read_handler;\n+            c->ssl->saved_read_handler = NULL;\n+            c->read->ready = 1;\n+\n+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_post_event(c->read, &ngx_posted_events);\n+        }\n+\n+        c->write->ready = 0;\n+        return NGX_AGAIN;\n+    }\n+\n+    if (sslerr == SSL_ERROR_WANT_READ) {\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"SSL_sendfile: want read\");\n+\n+        c->read->ready = 0;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        /*\n+         * we do not set the timer because there is already\n+         * the write event timer\n+         */\n+\n+        if (c->ssl->saved_read_handler == NULL) {\n+            c->ssl->saved_read_handler = c->read->handler;\n+            c->read->handler = ngx_ssl_read_handler;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    c->ssl->no_wait_shutdown = 1;\n+    c->ssl->no_send_shutdown = 1;\n+    c->write->error = 1;\n+\n+    ngx_ssl_connection_error(c, sslerr, err, \"SSL_sendfile() failed\");\n+\n+#else\n+    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                  \"SSL_sendfile() not available\");\n+#endif\n+\n+    return NGX_ERROR;\n+}\n+\n+\n static void\n ngx_ssl_read_handler(ngx_event_t *rev)\n {\nDiff:\n@@ -109,6 +109,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    handshake_rejected:1;\n     unsigned                    renegotiation:1;\n     unsigned                    buffer:1;\n+    unsigned                    sendfile:1;\n     unsigned                    no_wait_shutdown:1;\n     unsigned                    no_send_shutdown:1;\n     unsigned                    shutdown_without_free:1;\nDiff:\n@@ -626,7 +626,7 @@ ngx_http_alloc_request(ngx_connection_t *c)\n     }\n \n #if (NGX_HTTP_SSL)\n-    if (c->ssl) {\n+    if (c->ssl && !c->ssl->sendfile) {\n         r->main_filter_need_in_memory = 1;\n     }\n #endif\nDiff:\n@@ -1683,9 +1683,6 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,\n         return;\n     }\n \n-    c->sendfile = 0;\n-    u->output.sendfile = 0;\n-\n     if (u->conf->ssl_server_name || u->conf->ssl_verify) {\n         if (ngx_http_upstream_ssl_name(r, u, c) != NGX_OK) {\n             ngx_http_upstream_finalize_request(r, u,\n@@ -1791,6 +1788,11 @@ ngx_http_upstream_ssl_handshake(ngx_http_request_t *r, ngx_http_upstream_t *u,\n             }\n         }\n \n+        if (!c->ssl->sendfile) {\n+            c->sendfile = 0;\n+            u->output.sendfile = 0;\n+        }\n+\n         c->write->handler = ngx_http_upstream_handler;\n         c->read->handler = ngx_http_upstream_handler;\n \n"
    },
    {
        "commit_sha": "c4e4c30f3f3e9dafcc635f1da5b785c7f0032e5e",
        "commit_index": "Commit 126",
        "commit_diff": "Diff:\n@@ -200,10 +200,6 @@ ngx_monotonic_time(time_t sec, ngx_uint_t msec)\n \n #if defined(CLOCK_MONOTONIC_FAST)\n     clock_gettime(CLOCK_MONOTONIC_FAST, &ts);\n-\n-#elif defined(CLOCK_MONOTONIC_COARSE)\n-    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);\n-\n #else\n     clock_gettime(CLOCK_MONOTONIC, &ts);\n #endif\nDiff:\n@@ -2767,7 +2767,7 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)\n \n #ifdef SSL_READ_EARLY_DATA_SUCCESS\n \n-ssize_t\n+static ssize_t\n ngx_ssl_write_early(ngx_connection_t *c, u_char *data, size_t size)\n {\n     int        n, sslerr;\nDiff:\n@@ -23,7 +23,8 @@ static ngx_int_t ngx_stream_ssl_init_connection(ngx_ssl_t *ssl,\n     ngx_connection_t *c);\n static void ngx_stream_ssl_handshake_handler(ngx_connection_t *c);\n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n-int ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg);\n+static int ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad,\n+    void *arg);\n #endif\n #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n static int ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n@@ -451,7 +452,7 @@ ngx_stream_ssl_handshake_handler(ngx_connection_t *c)\n \n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n \n-int\n+static int\n ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n {\n     return SSL_TLSEXT_ERR_OK;\n@@ -502,7 +503,7 @@ ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n \n #ifdef SSL_R_CERT_CB_ERROR\n \n-int\n+static int\n ngx_stream_ssl_certificate(ngx_ssl_conn_t *ssl_conn, void *arg)\n {\n     ngx_str_t                    cert, key;\n"
    },
    {
        "commit_sha": "874d3bacce988424ff9b68f76b60aaa96d2fa8ca",
        "commit_index": "Commit 125",
        "commit_diff": "Diff:\n@@ -324,6 +324,7 @@ typedef ngx_int_t (*ngx_mail_parse_command_pt)(ngx_mail_session_t *s);\n \n struct ngx_mail_protocol_s {\n     ngx_str_t                   name;\n+    ngx_str_t                   alpn;\n     in_port_t                   port[4];\n     ngx_uint_t                  type;\n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_str_t  ngx_mail_imap_auth_methods_names[] = {\n \n static ngx_mail_protocol_t  ngx_mail_imap_protocol = {\n     ngx_string(\"imap\"),\n+    ngx_string(\"\\x04imap\"),\n     { 143, 993, 0, 0 },\n     NGX_MAIL_IMAP_PROTOCOL,\n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_str_t  ngx_mail_pop3_auth_methods_names[] = {\n \n static ngx_mail_protocol_t  ngx_mail_pop3_protocol = {\n     ngx_string(\"pop3\"),\n+    ngx_string(\"\\x04pop3\"),\n     { 110, 995, 0, 0 },\n     NGX_MAIL_POP3_PROTOCOL,\n \nDiff:\n@@ -39,6 +39,7 @@ static ngx_str_t  ngx_mail_smtp_auth_methods_names[] = {\n \n static ngx_mail_protocol_t  ngx_mail_smtp_protocol = {\n     ngx_string(\"smtp\"),\n+    ngx_string(\"\\x04smtp\"),\n     { 25, 465, 587, 0 },\n     NGX_MAIL_SMTP_PROTOCOL,\n \nDiff:\n@@ -14,6 +14,12 @@\n #define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n \n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+static int ngx_mail_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n+    const unsigned char **out, unsigned char *outlen,\n+    const unsigned char *in, unsigned int inlen, void *arg);\n+#endif\n+\n static void *ngx_mail_ssl_create_conf(ngx_conf_t *cf);\n static char *ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child);\n \n@@ -244,6 +250,54 @@ ngx_module_t  ngx_mail_ssl_module = {\n static ngx_str_t ngx_mail_ssl_sess_id_ctx = ngx_string(\"MAIL\");\n \n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+static int\n+ngx_mail_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n+    unsigned char *outlen, const unsigned char *in, unsigned int inlen,\n+    void *arg)\n+{\n+    unsigned int               srvlen;\n+    unsigned char             *srv;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+#if (NGX_DEBUG)\n+    unsigned int               i;\n+#endif\n+\n+    c = ngx_ssl_get_connection(ssl_conn);\n+    s = c->data;\n+\n+#if (NGX_DEBUG)\n+    for (i = 0; i < inlen; i += in[i] + 1) {\n+        ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                       \"SSL ALPN supported by client: %*s\",\n+                       (size_t) in[i], &in[i + 1]);\n+    }\n+#endif\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    srv = cscf->protocol->alpn.data;\n+    srvlen = cscf->protocol->alpn.len;\n+\n+    if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,\n+                              in, inlen)\n+        != OPENSSL_NPN_NEGOTIATED)\n+    {\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"SSL ALPN selected: %*s\", (size_t) *outlen, *out);\n+\n+    return SSL_TLSEXT_ERR_OK;\n+}\n+\n+#endif\n+\n+\n static void *\n ngx_mail_ssl_create_conf(ngx_conf_t *cf)\n {\n@@ -394,6 +448,10 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = &conf->ssl;\n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+    SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_mail_ssl_alpn_select, NULL);\n+#endif\n+\n     if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n                         conf->prefer_server_ciphers)\n         != NGX_OK)\n"
    },
    {
        "commit_sha": "34ad930f5c84232656c809b89420bfb9d78dbb1c",
        "commit_index": "Commit 124",
        "commit_diff": "Diff:\n@@ -3133,6 +3133,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n #ifdef SSL_R_CALLBACK_FAILED\n             || n == SSL_R_CALLBACK_FAILED                            /*  234 */\n+#endif\n+#ifdef SSL_R_NO_APPLICATION_PROTOCOL\n+            || n == SSL_R_NO_APPLICATION_PROTOCOL                    /*  235 */\n #endif\n             || n == SSL_R_UNEXPECTED_MESSAGE                         /*  244 */\n             || n == SSL_R_UNEXPECTED_RECORD                          /*  245 */\nDiff:\n@@ -17,7 +17,7 @@ typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,\n #define NGX_DEFAULT_CIPHERS     \"HIGH:!aNULL:!MD5\"\n #define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n \n-#define NGX_HTTP_ALPN_PROTO     \"\\x08http/1.1\"\n+#define NGX_HTTP_ALPN_PROTOS    \"\\x08http/1.1\\x08http/1.0\\x08http/0.9\"\n \n \n #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n@@ -442,21 +442,20 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n     hc = c->data;\n \n     if (hc->addr_conf->http2) {\n-        srv = (unsigned char *) NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO;\n-        srvlen = sizeof(NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO) - 1;\n-\n+        srv = (unsigned char *) NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTOS;\n+        srvlen = sizeof(NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTOS) - 1;\n     } else\n #endif\n     {\n-        srv = (unsigned char *) NGX_HTTP_ALPN_PROTO;\n-        srvlen = sizeof(NGX_HTTP_ALPN_PROTO) - 1;\n+        srv = (unsigned char *) NGX_HTTP_ALPN_PROTOS;\n+        srvlen = sizeof(NGX_HTTP_ALPN_PROTOS) - 1;\n     }\n \n     if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,\n                               in, inlen)\n         != OPENSSL_NPN_NEGOTIATED)\n     {\n-        return SSL_TLSEXT_ERR_NOACK;\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n     }\n \n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\nDiff:\n@@ -25,6 +25,11 @@ static void ngx_stream_ssl_handshake_handler(ngx_connection_t *c);\n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n int ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg);\n #endif\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+static int ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n+    const unsigned char **out, unsigned char *outlen,\n+    const unsigned char *in, unsigned int inlen, void *arg);\n+#endif\n #ifdef SSL_R_CERT_CB_ERROR\n static int ngx_stream_ssl_certificate(ngx_ssl_conn_t *ssl_conn, void *arg);\n #endif\n@@ -45,6 +50,8 @@ static char *ngx_stream_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static char *ngx_stream_ssl_alpn(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n \n static char *ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n     void *data);\n@@ -211,6 +218,13 @@ static ngx_command_t  ngx_stream_ssl_commands[] = {\n       offsetof(ngx_stream_ssl_conf_t, conf_commands),\n       &ngx_stream_ssl_conf_command_post },\n \n+    { ngx_string(\"ssl_alpn\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_stream_ssl_alpn,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -446,6 +460,46 @@ ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n #endif\n \n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+static int\n+ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n+    unsigned char *outlen, const unsigned char *in, unsigned int inlen,\n+    void *arg)\n+{\n+    ngx_str_t         *alpn;\n+#if (NGX_DEBUG)\n+    unsigned int       i;\n+    ngx_connection_t  *c;\n+\n+    c = ngx_ssl_get_connection(ssl_conn);\n+\n+    for (i = 0; i < inlen; i += in[i] + 1) {\n+        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                       \"SSL ALPN supported by client: %*s\",\n+                       (size_t) in[i], &in[i + 1]);\n+    }\n+\n+#endif\n+\n+    alpn = arg;\n+\n+    if (SSL_select_next_proto((unsigned char **) out, outlen, alpn->data,\n+                              alpn->len, in, inlen)\n+        != OPENSSL_NPN_NEGOTIATED)\n+    {\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                   \"SSL ALPN selected: %*s\", (size_t) *outlen, *out);\n+\n+    return SSL_TLSEXT_ERR_OK;\n+}\n+\n+#endif\n+\n+\n #ifdef SSL_R_CERT_CB_ERROR\n \n int\n@@ -605,6 +659,7 @@ ngx_stream_ssl_create_conf(ngx_conf_t *cf)\n      *     scf->client_certificate = { 0, NULL };\n      *     scf->trusted_certificate = { 0, NULL };\n      *     scf->crl = { 0, NULL };\n+     *     scf->alpn = { 0, NULL };\n      *     scf->ciphers = { 0, NULL };\n      *     scf->shm_zone = NULL;\n      */\n@@ -663,6 +718,7 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->trusted_certificate,\n                          prev->trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->crl, prev->crl, \"\");\n+    ngx_conf_merge_str_value(conf->alpn, prev->alpn, \"\");\n \n     ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,\n                          NGX_DEFAULT_ECDH_CURVE);\n@@ -723,6 +779,13 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                                            ngx_stream_ssl_servername);\n #endif\n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+    if (conf->alpn.len) {\n+        SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_stream_ssl_alpn_select,\n+                                   &conf->alpn);\n+    }\n+#endif\n+\n     if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n                         conf->prefer_server_ciphers)\n         != NGX_OK)\n@@ -1059,6 +1122,60 @@ ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_stream_ssl_alpn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+    ngx_stream_ssl_conf_t  *scf = conf;\n+\n+    u_char      *p;\n+    size_t       len;\n+    ngx_str_t   *value;\n+    ngx_uint_t   i;\n+\n+    if (scf->alpn.len) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    len = 0;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+\n+        if (value[i].len > 255) {\n+            return \"protocol too long\";\n+        }\n+\n+        len += value[i].len + 1;\n+    }\n+\n+    scf->alpn.data = ngx_pnalloc(cf->pool, len);\n+    if (scf->alpn.data == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    p = scf->alpn.data;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+        *p++ = value[i].len;\n+        p = ngx_cpymem(p, value[i].data, value[i].len);\n+    }\n+\n+    scf->alpn.len = len;\n+\n+    return NGX_CONF_OK;\n+\n+#else\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"the \\\"ssl_alpn\\\" directive requires OpenSSL \"\n+                       \"with ALPN support\");\n+    return NGX_CONF_ERROR;\n+#endif\n+}\n+\n+\n static char *\n ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\nDiff:\n@@ -42,6 +42,7 @@ typedef struct {\n     ngx_str_t        client_certificate;\n     ngx_str_t        trusted_certificate;\n     ngx_str_t        crl;\n+    ngx_str_t        alpn;\n \n     ngx_str_t        ciphers;\n \n"
    },
    {
        "commit_sha": "a2f5fad3ef16615ed23d21264560748cdc21a385",
        "commit_index": "Commit 123",
        "commit_diff": "Diff:\n@@ -124,6 +124,7 @@ typedef intptr_t        ngx_flag_t;\n #define NGX_MAXHOSTNAMELEN  256\n #endif\n \n+#define NGX_MAX_HOST_SPECS_LINE 64\n \n #define NGX_MAX_UINT32_VALUE  (uint32_t) 0xffffffff\n #define NGX_MAX_INT32_VALUE   (uint32_t) 0x7fffffff\nDiff:\n@@ -14,6 +14,7 @@\n \n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_host_specs_s      ngx_host_specs_t;\n typedef struct ngx_con_his_s         ngx_con_his_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n typedef struct ngx_black_list_s      ngx_black_list_t;\nDiff:\n@@ -74,6 +74,7 @@ ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n ngx_cycle_t *\n ngx_init_cycle(ngx_cycle_t *old_cycle)\n {\n+    FILE                *fp;\n     void                *rv;\n     char               **senv;\n     ngx_uint_t           i, n;\n@@ -89,6 +90,8 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n     ngx_core_conf_t     *ccf, *old_ccf;\n     ngx_core_module_t   *module;\n     char                 hostname[NGX_MAXHOSTNAMELEN];\n+    char                 line[NGX_MAX_HOST_SPECS_LINE];\n+    char                *temp_char;\n \n     ngx_timezone_update();\n \n@@ -352,8 +355,110 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n         return cycle;\n     }\n \n+    cycle->host_specs = ngx_alloc(sizeof(ngx_host_specs_t), log);\n+    if (cycle->host_specs == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    cycle->host_specs->host_cpu = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_cpu == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_cpu->data = (u_char*)\"Unknown CPU\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/proc/cpuinfo\", \"r\");\n+    if (fp != NULL) {\n+        temp_char = NULL;\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (ngx_strncmp(line, \"model name\", 10) == 0) {\n+                temp_char = strchr(line, ':');\n+                if (temp_char != NULL) {\n+                    temp_char += 2;\n+                    cycle->host_specs->host_cpu->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_cpu->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_cpu->data, sizeof(line));\n+                    cycle->host_specs->host_cpu->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_cpu->data, \"%s\", temp_char) - \\\n+                        cycle->host_specs->host_cpu->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n+    cycle->host_specs->host_mem = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_mem == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_mem->data = (u_char*)\"Unknown RAM\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/proc/meminfo\", \"r\");\n+    if (fp != NULL) {\n+        temp_char = NULL;\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (ngx_strncmp(line, \"MemTotal:\", 9) == 0) {\n+                temp_char = strchr(line, ':');\n+                if (temp_char != NULL) {\n+                    temp_char += 8;\n+                    cycle->host_specs->host_mem->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_mem->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_mem->data, sizeof(line));\n+                    cycle->host_specs->host_mem->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_mem->data, \"%s\", temp_char) - \\\n+                        cycle->host_specs->host_mem->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n+    cycle->host_specs->host_os = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_os == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_os->data = (u_char*)\"Unknown OS\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/etc/os-release\", \"r\");\n+    if (fp != NULL) {\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (strncmp(line, \"PRETTY_NAME\", 11) == 0) {\n+                temp_char = strchr(line, '=');\n+                if (temp_char != NULL) {\n+                    temp_char += 1;\n+                    cycle->host_specs->host_os->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_os->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_os->data, sizeof(line));\n+                        cycle->host_specs->host_os->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_os->data, \"%s\", temp_char) - \\\n+                    cycle->host_specs->host_os->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n     ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n \n+    if (!ccf->remote_admin) {\n+        ngx_free(cycle->host_specs);\n+    }\n+\n     if (ngx_test_config) {\n \n         if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\nDiff:\n@@ -49,6 +49,13 @@ struct ngx_con_his_s {\n };\n \n \n+struct ngx_host_specs_s {\n+    ngx_str_t *host_cpu;\n+    ngx_str_t *host_mem;\n+    ngx_str_t *host_os;\n+};\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -62,6 +69,8 @@ struct ngx_cycle_s {\n     ngx_connection_t         *free_connections;\n     ngx_uint_t                free_connection_n;\n \n+    ngx_host_specs_t         *host_specs;\n+\n     ngx_module_t            **modules;\n     ngx_uint_t                modules_n;\n     ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */\nDiff:\n@@ -910,7 +910,7 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n                     rev->connection_counter = c->number;\n                     rev->connection_history = cycle->connection_history;\n                 }\n-\n+                rev->cycle = cycle;\n                 rev->handler(rev);\n             }\n         }\nDiff:\n@@ -36,6 +36,8 @@ struct ngx_event_s {\n \n     unsigned         accept:1;\n \n+    ngx_cycle_t     *cycle;\n+\n     /* used to detect the stale events in kqueue and epoll */\n     unsigned         instance:1;\n \n@@ -103,7 +105,6 @@ struct ngx_event_s {\n     int              available;\n \n     ngx_event_handler_pt  handler;\n-    ngx_cycle_t          *cycle;\n \n \n #if (NGX_HAVE_IOCP)\nDiff:\n@@ -4698,6 +4698,36 @@ ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n }\n \n \n+ngx_int_t\n+ngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n+{\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+    unsigned int          len;\n+    const unsigned char  *data;\n+\n+    SSL_get0_alpn_selected(c->ssl->connection, &data, &len);\n+\n+    if (len > 0) {\n+\n+        s->data = ngx_pnalloc(pool, len);\n+        if (s->data == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_memcpy(s->data, data, len);\n+        s->len = len;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    s->len = 0;\n+    return NGX_OK;\n+}\n+\n+\n ngx_int_t\n ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n {\nDiff:\n@@ -265,6 +265,8 @@ ngx_int_t ngx_ssl_get_early_data(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n+ngx_int_t ngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool,\n+    ngx_str_t *s);\n ngx_int_t ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool,\nDiff:\n@@ -358,6 +358,9 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {\n     { ngx_string(\"ssl_server_name\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_server_name, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_alpn_protocol\"), NULL, ngx_http_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_alpn_protocol, NGX_HTTP_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_client_cert\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_certificate, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \nDiff:\n@@ -2799,5 +2799,20 @@ ngx_http_get_last_ip_variable(ngx_http_request_t *r,\n static ngx_int_t ngx_http_get_host_specs(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    u_char *temp;\n+\n+    v->data = ngx_pnalloc(r->pool, NGX_MAX_HOST_SPECS_LINE * 3);\n+    if (v->data == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+    ngx_memzero(v->data, NGX_MAX_HOST_SPECS_LINE * 3);\n+\n+    temp = v->data;\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_cpu->data);\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_mem->data);\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_os->data);\n+    v->len = v->data - temp;\n+    v->data = temp;\n+\n     return NGX_OK;\n }\nDiff:\n@@ -657,6 +657,32 @@ ngx_master_process_exit(ngx_cycle_t *cycle)\n {\n     ngx_uint_t  i;\n \n+    if (cycle->host_specs) {\n+        if (cycle->host_specs->host_cpu) {\n+            ngx_free(cycle->host_specs->host_cpu->data);\n+            cycle->host_specs->host_cpu->data = NULL;\n+            ngx_free(cycle->host_specs->host_cpu);\n+            cycle->host_specs->host_cpu = NULL;\n+        }\n+\n+        if (cycle->host_specs->host_mem) {\n+            ngx_free(cycle->host_specs->host_mem->data);\n+            cycle->host_specs->host_mem->data = NULL;\n+            ngx_free(cycle->host_specs->host_mem);\n+            cycle->host_specs->host_mem = NULL;\n+        }\n+\n+        if (cycle->host_specs->host_os) {\n+            ngx_free(cycle->host_specs->host_os->data);\n+            cycle->host_specs->host_os->data = NULL;\n+            ngx_free(cycle->host_specs->host_os);\n+            cycle->host_specs->host_os = NULL;\n+        }\n+\n+        ngx_free(cycle->host_specs);\n+        cycle->host_specs = NULL;\n+    }\n+\n     ngx_delete_pidfile(cycle);\n \n     ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exit\");\nDiff:\n@@ -266,6 +266,9 @@ static ngx_stream_variable_t  ngx_stream_ssl_vars[] = {\n     { ngx_string(\"ssl_server_name\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_server_name, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_alpn_protocol\"), NULL, ngx_stream_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_alpn_protocol, NGX_STREAM_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_client_cert\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_certificate, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n"
    },
    {
        "commit_sha": "8235b3e9c848ccea7071514ad514656121b08fbb",
        "commit_index": "Commit 122",
        "commit_diff": "Diff:\n@@ -17,7 +17,7 @@ typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,\n #define NGX_DEFAULT_CIPHERS     \"HIGH:!aNULL:!MD5\"\n #define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n \n-#define NGX_HTTP_NPN_ADVERTISE  \"\\x08http/1.1\"\n+#define NGX_HTTP_ALPN_PROTO     \"\\x08http/1.1\"\n \n \n #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n@@ -26,11 +26,6 @@ static int ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n     const unsigned char *in, unsigned int inlen, void *arg);\n #endif\n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-static int ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,\n-    const unsigned char **out, unsigned int *outlen, void *arg);\n-#endif\n-\n static ngx_int_t ngx_http_ssl_static_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_ssl_variable(ngx_http_request_t *r,\n@@ -444,15 +439,14 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n     hc = c->data;\n \n     if (hc->addr_conf->http2) {\n-        srv =\n-           (unsigned char *) NGX_HTTP_V2_ALPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;\n-        srvlen = sizeof(NGX_HTTP_V2_ALPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;\n+        srv = (unsigned char *) NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO;\n+        srvlen = sizeof(NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO) - 1;\n \n     } else\n #endif\n     {\n-        srv = (unsigned char *) NGX_HTTP_NPN_ADVERTISE;\n-        srvlen = sizeof(NGX_HTTP_NPN_ADVERTISE) - 1;\n+        srv = (unsigned char *) NGX_HTTP_ALPN_PROTO;\n+        srvlen = sizeof(NGX_HTTP_ALPN_PROTO) - 1;\n     }\n \n     if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,\n@@ -471,44 +465,6 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n #endif\n \n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-\n-static int\n-ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,\n-    const unsigned char **out, unsigned int *outlen, void *arg)\n-{\n-#if (NGX_HTTP_V2 || NGX_DEBUG)\n-    ngx_connection_t  *c;\n-\n-    c = ngx_ssl_get_connection(ssl_conn);\n-    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, \"SSL NPN advertised\");\n-#endif\n-\n-#if (NGX_HTTP_V2)\n-    {\n-    ngx_http_connection_t  *hc;\n-\n-    hc = c->data;\n-\n-    if (hc->addr_conf->http2) {\n-        *out =\n-            (unsigned char *) NGX_HTTP_V2_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;\n-        *outlen = sizeof(NGX_HTTP_V2_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;\n-\n-        return SSL_TLSEXT_ERR_OK;\n-    }\n-    }\n-#endif\n-\n-    *out = (unsigned char *) NGX_HTTP_NPN_ADVERTISE;\n-    *outlen = sizeof(NGX_HTTP_NPN_ADVERTISE) - 1;\n-\n-    return SSL_TLSEXT_ERR_OK;\n-}\n-\n-#endif\n-\n-\n static ngx_int_t\n ngx_http_ssl_static_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n@@ -792,11 +748,6 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_http_ssl_alpn_select, NULL);\n #endif\n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-    SSL_CTX_set_next_protos_advertised_cb(conf->ssl.ctx,\n-                                          ngx_http_ssl_npn_advertised, NULL);\n-#endif\n-\n     if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n                         conf->prefer_server_ciphers)\n         != NGX_OK)\nDiff:\n@@ -1338,13 +1338,12 @@ ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n     }\n \n #if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \\\n-     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \\\n-     && !defined TLSEXT_TYPE_next_proto_neg)\n+     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation)\n \n     if (lsopt->http2 && lsopt->ssl) {\n         ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                            \"nginx was built with OpenSSL that lacks ALPN \"\n-                           \"and NPN support, HTTP/2 is not enabled for %V\",\n+                           \"support, HTTP/2 is not enabled for %V\",\n                            &lsopt->addr_text);\n     }\n \nDiff:\n@@ -825,8 +825,7 @@ ngx_http_ssl_handshake_handler(ngx_connection_t *c)\n         c->ssl->no_wait_shutdown = 1;\n \n #if (NGX_HTTP_V2                                                              \\\n-     && (defined TLSEXT_TYPE_application_layer_protocol_negotiation           \\\n-         || defined TLSEXT_TYPE_next_proto_neg))\n+     && defined TLSEXT_TYPE_application_layer_protocol_negotiation)\n         {\n         unsigned int            len;\n         const unsigned char    *data;\n@@ -836,19 +835,8 @@ ngx_http_ssl_handshake_handler(ngx_connection_t *c)\n \n         if (hc->addr_conf->http2) {\n \n-#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n             SSL_get0_alpn_selected(c->ssl->connection, &data, &len);\n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-            if (len == 0) {\n-                SSL_get0_next_proto_negotiated(c->ssl->connection, &data, &len);\n-            }\n-#endif\n-\n-#else /* TLSEXT_TYPE_next_proto_neg */\n-            SSL_get0_next_proto_negotiated(c->ssl->connection, &data, &len);\n-#endif\n-\n             if (len == 2 && data[0] == 'h' && data[1] == '2') {\n                 ngx_http_v2_init(c->read);\n                 return;\nDiff:\n@@ -13,8 +13,7 @@\n #include <ngx_http.h>\n \n \n-#define NGX_HTTP_V2_ALPN_ADVERTISE       \"\\x02h2\"\n-#define NGX_HTTP_V2_NPN_ADVERTISE        NGX_HTTP_V2_ALPN_ADVERTISE\n+#define NGX_HTTP_V2_ALPN_PROTO           \"\\x02h2\"\n \n #define NGX_HTTP_V2_STATE_BUFFER_SIZE    16\n \n"
    },
    {
        "commit_sha": "47a7a459ce4af3c15831b85aae00fe26fd68502f",
        "commit_index": "Commit 121",
        "commit_diff": "Diff:\n@@ -2021,7 +2021,7 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n \n             /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                           \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                           r->header_end - r->header_name_start,\n                           r->header_name_start, *r->header_end);\nDiff:\n@@ -2021,7 +2021,7 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n \n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                       r->header_end - r->header_name_start,\n                       r->header_name_start, *r->header_end);\nDiff:\n@@ -1142,7 +1142,7 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n \n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                       r->header_end - r->header_name_start,\n                       r->header_name_start, *r->header_end);\nDiff:\n@@ -1363,7 +1363,7 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n \n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                       r->header_end - r->header_name_start,\n                       r->header_name_start, *r->header_end);\nDiff:\n@@ -505,8 +505,8 @@ ngx_int_t ngx_http_gzip_ok(ngx_http_request_t *r);\n \n \n ngx_int_t ngx_http_subrequest(ngx_http_request_t *r,\n-    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **sr,\n-    ngx_http_post_subrequest_t *psr, ngx_uint_t flags);\n+    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,\n+    ngx_http_post_subrequest_t *ps, ngx_uint_t flags);\n ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r,\n     ngx_str_t *uri, ngx_str_t *args);\n ngx_int_t ngx_http_named_location(ngx_http_request_t *r, ngx_str_t *name);\n"
    },
    {
        "commit_sha": "c84a88789e791617e799b87208e4eecf911087f9",
        "commit_index": "Commit 120",
        "commit_diff": "Diff:\n@@ -2337,6 +2337,7 @@ ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)\n         ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                       \"upstream sent more data than specified in \"\n                       \"\\\"Content-Length\\\" header\");\n+        u->keepalive = 0;\n         return NGX_OK;\n     }\n \nDiff:\n@@ -1189,6 +1189,10 @@ ngx_http_variable_content_length(ngx_http_request_t *r,\n         v->no_cacheable = 0;\n         v->not_found = 0;\n \n+    } else if (r->headers_in.chunked) {\n+        v->not_found = 1;\n+        v->no_cacheable = 1;\n+\n     } else {\n         v->not_found = 1;\n     }\nDiff:\n@@ -31,6 +31,7 @@ typedef struct {\n     ngx_uint_t                       next_upstream_tries;\n     ngx_flag_t                       next_upstream;\n     ngx_flag_t                       proxy_protocol;\n+    ngx_flag_t                       half_close;\n     ngx_stream_upstream_local_t     *local;\n     ngx_flag_t                       socket_keepalive;\n \n@@ -245,6 +246,13 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {\n       offsetof(ngx_stream_proxy_srv_conf_t, proxy_protocol),\n       NULL },\n \n+    { ngx_string(\"proxy_half_close\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_proxy_srv_conf_t, half_close),\n+      NULL },\n+\n #if (NGX_STREAM_SSL)\n \n     { ngx_string(\"proxy_ssl\"),\n@@ -1755,6 +1763,24 @@ ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,\n     }\n \n     if (dst) {\n+\n+        if (dst->type == SOCK_STREAM && pscf->half_close\n+            && src->read->eof && !u->half_closed && !dst->buffered)\n+        {\n+            if (ngx_shutdown_socket(dst->fd, NGX_WRITE_SHUTDOWN) == -1) {\n+                ngx_connection_error(c, ngx_socket_errno,\n+                                     ngx_shutdown_socket_n \" failed\");\n+\n+                ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n+                return;\n+            }\n+\n+            u->half_closed = 1;\n+            ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,\n+                           \"stream proxy %s socket shutdown\",\n+                           from_upstream ? \"client\" : \"upstream\");\n+        }\n+\n         if (ngx_handle_write_event(dst->write, 0) != NGX_OK) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n             return;\n@@ -1833,6 +1859,13 @@ ngx_stream_proxy_test_finalize(ngx_stream_session_t *s,\n         return NGX_DECLINED;\n     }\n \n+    if (pscf->half_close) {\n+        /* avoid closing live connections until both read ends get EOF */\n+        if (!(c->read->eof && pc->read->eof && !c->buffered && !pc->buffered)) {\n+             return NGX_DECLINED;\n+        }\n+    }\n+\n     handler = c->log->handler;\n     c->log->handler = NULL;\n \n@@ -2052,6 +2085,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->proxy_protocol = NGX_CONF_UNSET;\n     conf->local = NGX_CONF_UNSET_PTR;\n     conf->socket_keepalive = NGX_CONF_UNSET;\n+    conf->half_close = NGX_CONF_UNSET;\n \n #if (NGX_STREAM_SSL)\n     conf->ssl_enable = NGX_CONF_UNSET;\n@@ -2110,6 +2144,8 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->socket_keepalive,\n                               prev->socket_keepalive, 0);\n \n+    ngx_conf_merge_value(conf->half_close, prev->half_close, 0);\n+\n #if (NGX_STREAM_SSL)\n \n     ngx_conf_merge_value(conf->ssl_enable, prev->ssl_enable, 0);\nDiff:\n@@ -142,6 +142,7 @@ typedef struct {\n     ngx_stream_upstream_state_t       *state;\n     unsigned                           connected:1;\n     unsigned                           proxy_protocol:1;\n+    unsigned                           half_closed:1;\n } ngx_stream_upstream_t;\n \n \n"
    },
    {
        "commit_sha": "19d656332afb94ecd4aca4553bd9a96741800585",
        "commit_index": "Commit 119",
        "commit_diff": "Diff:\n@@ -463,3 +463,4 @@ ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n+2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\nDiff:\n@@ -5,6 +5,33 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.3\" date=\"2021-09-07\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+оптимизация чтения тела запроса\n+при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+optimization of client request body reading\n+when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+во внутреннем API для обработки тела запроса\n+при использовании HTTP/2 и буферизации обрабатываемых данных.\n+</para>\n+<para lang=\"en\">\n+in request body filters internal API\n+when using HTTP/2 and buffering of the data being processed.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.2\" date=\"2021-08-31\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021003\n-#define NGINX_VERSION      \"1.21.3\"\n+#define nginx_version      1021004\n+#define NGINX_VERSION      \"1.21.4\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1309,7 +1309,7 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     if (rb->rest > 0) {\n \n-        if (rb->buf && rb->buf->last == rb->buf->end\n+        if (rb->bufs && rb->buf && rb->buf->last == rb->buf->end\n             && ngx_http_write_request_body(r) != NGX_OK)\n         {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n"
    },
    {
        "commit_sha": "fd56ca5aff7b69fdda2e82dc8fe1bf152886e9b8",
        "commit_index": "Commit 118",
        "commit_diff": "Diff:\n@@ -462,3 +462,4 @@ da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n+bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021002\n-#define NGINX_VERSION      \"1.21.2\"\n+#define nginx_version      1021003\n+#define NGINX_VERSION      \"1.21.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1092,7 +1092,7 @@ static u_char *\n ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   size, window;\n+    size_t                   size;\n     ngx_buf_t               *buf;\n     ngx_int_t                rc;\n     ngx_connection_t        *fc;\n@@ -1148,32 +1148,6 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n             ngx_http_finalize_request(r, rc);\n         }\n \n-        if (rc == NGX_AGAIN && !stream->no_flow_control) {\n-            buf = r->request_body->buf;\n-            window = buf->end - buf->last;\n-\n-            window -= h2c->state.length - size;\n-\n-            if (window < stream->recv_window) {\n-                ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n-                              \"http2 negative window update\");\n-                return ngx_http_v2_connection_error(h2c,\n-                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n-            }\n-\n-            if (window > stream->recv_window) {\n-                if (ngx_http_v2_send_window_update(h2c, stream->node->id,\n-                                                   window - stream->recv_window)\n-                    == NGX_ERROR)\n-                {\n-                    return ngx_http_v2_connection_error(h2c,\n-                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n-                }\n-\n-                stream->recv_window = window;\n-            }\n-        }\n-\n         ngx_http_run_posted_requests(fc);\n \n     } else if (size) {\n@@ -4214,8 +4188,8 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n \n                 /* update chains */\n \n-                ngx_log_error(NGX_LOG_DEBUG, fc->log, 0,\n-                              \"http2 body update chains\");\n+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                               \"http2 body update chains\");\n \n                 rc = ngx_http_v2_filter_request_body(r);\n \n@@ -4255,30 +4229,22 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n                 rb->rest = 0;\n             }\n \n-            if (r->request_body_no_buffering) {\n+            if (size == 0) {\n                 break;\n             }\n+        }\n \n-            /* pass buffer to request body filter chain */\n+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                       \"http2 request body rest %O\", rb->rest);\n \n+        if (flush) {\n             rc = ngx_http_v2_filter_request_body(r);\n \n             if (rc != NGX_OK) {\n                 return rc;\n             }\n-\n-            if (rb->rest == 0) {\n-                break;\n-            }\n-\n-            if (size == 0) {\n-                break;\n-            }\n         }\n \n-        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n-                       \"http2 request body rest %O\", rb->rest);\n-\n         if (rb->rest == 0 && rb->last_saved) {\n             break;\n         }\n@@ -4287,9 +4253,8 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n             clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n             ngx_add_timer(fc->read, clcf->client_body_timeout);\n \n-            if (r->request_body_no_buffering) {\n+            if (!flush) {\n                 ngx_post_event(fc->read, &ngx_posted_events);\n-                return NGX_AGAIN;\n             }\n \n             return NGX_AGAIN;\n@@ -4301,7 +4266,10 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n     }\n \n     if (r->request_body_no_buffering) {\n-        ngx_post_event(fc->read, &ngx_posted_events);\n+        if (!flush) {\n+            ngx_post_event(fc->read, &ngx_posted_events);\n+        }\n+\n         return NGX_OK;\n     }\n \n@@ -4455,14 +4423,26 @@ ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)\n         return;\n     }\n \n+    if (r->stream->no_flow_control) {\n+        return;\n+    }\n+\n     if (r->request_body->rest == 0) {\n         return;\n     }\n \n+    if (r->request_body->busy != NULL) {\n+        return;\n+    }\n+\n     stream = r->stream;\n     h2c = stream->connection;\n \n     buf = r->request_body->buf;\n+\n+    buf->pos = buf->start;\n+    buf->last = buf->start;\n+\n     window = buf->end - buf->start;\n \n     if (h2c->state.stream == stream) {\n@@ -4511,7 +4491,6 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n     ngx_connection_t          *fc;\n     ngx_http_v2_stream_t      *stream;\n     ngx_http_v2_connection_t  *h2c;\n-    ngx_http_core_loc_conf_t  *clcf;\n \n     stream = r->stream;\n     fc = r->connection;\n@@ -4535,14 +4514,14 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n         return NGX_HTTP_BAD_REQUEST;\n     }\n \n-    rc = ngx_http_v2_filter_request_body(r);\n+    rc = ngx_http_v2_process_request_body(r, NULL, 0, r->stream->in_closed, 1);\n \n-    if (rc != NGX_OK) {\n+    if (rc != NGX_OK && rc != NGX_AGAIN) {\n         stream->skip_data = 1;\n         return rc;\n     }\n \n-    if (r->request_body->rest == 0 && r->request_body->last_saved) {\n+    if (rc == NGX_OK) {\n         return NGX_OK;\n     }\n \n@@ -4590,11 +4569,6 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    if (stream->recv_window == 0) {\n-        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-        ngx_add_timer(fc->read, clcf->client_body_timeout);\n-    }\n-\n     stream->recv_window = window;\n \n     return NGX_AGAIN;\n"
    },
    {
        "commit_sha": "24645f4eb0082fa14ca29aea89ddc8a27333f377",
        "commit_index": "Commit 117",
        "commit_diff": "Diff:\n@@ -5,6 +5,113 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.2\" date=\"2021-08-31\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx возвращает ошибку,\n+если в запросе по протоколу HTTP/1.0 присутствует\n+строка заголовка \"Transfer-Encoding\".\n+</para>\n+<para lang=\"en\">\n+now nginx rejects HTTP/1.0 requests\n+with the \"Transfer-Encoding\" header line.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+экспортные шифры больше не поддерживаются.\n+</para>\n+<para lang=\"en\">\n+export ciphers are no longer supported.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+совместимость с OpenSSL 3.0.\n+</para>\n+<para lang=\"en\">\n+OpenSSL 3.0 compatibility.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь серверу аутентификации почтового прокси-сервера\n+передаются строки заголовка \"Auth-SSL-Protocol\" и \"Auth-SSL-Cipher\".<br/>\n+Спасибо Rob Mueller.\n+</para>\n+<para lang=\"en\">\n+the \"Auth-SSL-Protocol\" and \"Auth-SSL-Cipher\" header lines\n+are now passed to the mail proxy authentication server.<br/>\n+Thanks to Rob Mueller.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+API для обработки тела запроса\n+теперь позволяет буферизировать обрабатываемые данные.\n+</para>\n+<para lang=\"en\">\n+request body filters API\n+now permits buffering of the data being processed.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL-соединения к бэкендам в модуле stream\n+могли зависать после SSL handshake.\n+</para>\n+<para lang=\"en\">\n+backend SSL connections in the stream module\n+might hang after an SSL handshake.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+уровень безопасности, доступный в OpenSSL 1.1.0 и новее,\n+не учитывался при загрузке сертификатов сервера,\n+если был задан через \"@SECLEVEL=N\" в директиве ssl_ciphers.\n+</para>\n+<para lang=\"en\">\n+the security level, which is available in OpenSSL 1.1.0 or newer,\n+did not affect loading of the server certificates\n+when set with \"@SECLEVEL=N\" in the \"ssl_ciphers\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL-соединения с gRPC-бэкендами могли зависать,\n+если использовались методы select, poll или /dev/poll.\n+</para>\n+<para lang=\"en\">\n+SSL connections with gRPC backends might hang\n+if select, poll, or /dev/poll methods were used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2\n+тело запроса всегда записывалось на диск,\n+если в запросе не было строки заголовка \"Content-Length\".\n+</para>\n+<para lang=\"en\">\n+when using HTTP/2\n+client request body was always written to disk\n+if the \"Content-Length\" header line was not present in the request.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.1\" date=\"2021-07-06\">\n \n <change type=\"change\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1k\n+OPENSSL =\topenssl-1.1.1l\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -4241,7 +4241,9 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n                 n = size;\n             }\n \n-            rb->buf->last = ngx_cpymem(rb->buf->last, pos, n);\n+            if (n > 0) {\n+                rb->buf->last = ngx_cpymem(rb->buf->last, pos, n);\n+            }\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                            \"http2 request body recv %uz\", n);\n"
    },
    {
        "commit_sha": "5012a6f6f592eb407bfb98dbb2640bcdaae70a00",
        "commit_index": "Commit 116",
        "commit_diff": "Diff:\n@@ -307,6 +307,8 @@ typedef struct {\n     ngx_chain_t                      *busy;\n     ngx_http_chunked_t               *chunked;\n     ngx_http_client_body_handler_pt   post_handler;\n+    unsigned                          filter_need_buffering:1;\n+    unsigned                          last_sent:1;\n     unsigned                          last_saved:1;\n } ngx_http_request_body_t;\n \nDiff:\n@@ -69,6 +69,8 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n      *     rb->busy = NULL;\n      *     rb->chunked = NULL;\n      *     rb->received = 0;\n+     *     rb->filter_need_buffering = 0;\n+     *     rb->last_sent = 0;\n      *     rb->last_saved = 0;\n      */\n \n@@ -147,7 +149,7 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n         }\n     }\n \n-    if (rb->rest == 0) {\n+    if (rb->rest == 0 && rb->last_saved) {\n         /* the whole request body was pre-read */\n         r->request_body_no_buffering = 0;\n         post_handler(r);\n@@ -175,6 +177,10 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n             size += preread;\n         }\n \n+        if (size == 0) {\n+            size++;\n+        }\n+\n     } else {\n         size = clcf->client_body_buffer_size;\n     }\n@@ -273,19 +279,25 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n     size_t                     size;\n     ssize_t                    n;\n     ngx_int_t                  rc;\n+    ngx_uint_t                 flush;\n     ngx_chain_t                out;\n     ngx_connection_t          *c;\n     ngx_http_request_body_t   *rb;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     c = r->connection;\n     rb = r->request_body;\n+    flush = 1;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                    \"http read client request body\");\n \n     for ( ;; ) {\n         for ( ;; ) {\n+            if (rb->rest == 0) {\n+                break;\n+            }\n+\n             if (rb->buf->last == rb->buf->end) {\n \n                 /* update chains */\n@@ -309,12 +321,25 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n                         return NGX_AGAIN;\n                     }\n \n+                    if (rb->filter_need_buffering) {\n+                        clcf = ngx_http_get_module_loc_conf(r,\n+                                                         ngx_http_core_module);\n+                        ngx_add_timer(c->read, clcf->client_body_timeout);\n+\n+                        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+                        }\n+\n+                        return NGX_AGAIN;\n+                    }\n+\n                     ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                                   \"busy buffers after request body flush\");\n \n                     return NGX_HTTP_INTERNAL_SERVER_ERROR;\n                 }\n \n+                flush = 0;\n                 rb->buf->pos = rb->buf->start;\n                 rb->buf->last = rb->buf->start;\n             }\n@@ -326,6 +351,10 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n                 size = (size_t) rest;\n             }\n \n+            if (size == 0) {\n+                break;\n+            }\n+\n             n = c->recv(c, rb->buf->last, size);\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n@@ -350,6 +379,7 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n \n             /* pass buffer to request body filter chain */\n \n+            flush = 0;\n             out.buf = rb->buf;\n             out.next = NULL;\n \n@@ -371,11 +401,19 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                        \"http client request body rest %O\", rb->rest);\n \n-        if (rb->rest == 0) {\n+        if (flush) {\n+            rc = ngx_http_request_body_filter(r, NULL);\n+\n+            if (rc != NGX_OK) {\n+                return rc;\n+            }\n+        }\n+\n+        if (rb->rest == 0 && rb->last_saved) {\n             break;\n         }\n \n-        if (!c->read->ready) {\n+        if (!c->read->ready || rb->rest == 0) {\n \n             clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n             ngx_add_timer(c->read, clcf->client_body_timeout);\n@@ -1280,7 +1318,9 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n         return NGX_OK;\n     }\n \n-    /* rb->rest == 0 */\n+    if (!rb->last_saved) {\n+        return NGX_OK;\n+    }\n \n     if (rb->temp_file || r->request_body_in_file_only) {\n \nDiff:\n@@ -173,7 +173,7 @@ static ngx_int_t ngx_http_v2_construct_cookie_header(ngx_http_request_t *r);\n static void ngx_http_v2_run_request(ngx_http_request_t *r);\n static void ngx_http_v2_run_request_handler(ngx_event_t *ev);\n static ngx_int_t ngx_http_v2_process_request_body(ngx_http_request_t *r,\n-    u_char *pos, size_t size, ngx_uint_t last);\n+    u_char *pos, size_t size, ngx_uint_t last, ngx_uint_t flush);\n static ngx_int_t ngx_http_v2_filter_request_body(ngx_http_request_t *r);\n static void ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r);\n \n@@ -1092,7 +1092,7 @@ static u_char *\n ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   size;\n+    size_t                   size, window;\n     ngx_buf_t               *buf;\n     ngx_int_t                rc;\n     ngx_connection_t        *fc;\n@@ -1140,13 +1140,40 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     h2c->payload_bytes += size;\n \n     if (r->request_body) {\n-        rc = ngx_http_v2_process_request_body(r, pos, size, stream->in_closed);\n+        rc = ngx_http_v2_process_request_body(r, pos, size,\n+                                              stream->in_closed, 0);\n \n-        if (rc != NGX_OK) {\n+        if (rc != NGX_OK && rc != NGX_AGAIN) {\n             stream->skip_data = 1;\n             ngx_http_finalize_request(r, rc);\n         }\n \n+        if (rc == NGX_AGAIN && !stream->no_flow_control) {\n+            buf = r->request_body->buf;\n+            window = buf->end - buf->last;\n+\n+            window -= h2c->state.length - size;\n+\n+            if (window < stream->recv_window) {\n+                ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n+                              \"http2 negative window update\");\n+                return ngx_http_v2_connection_error(h2c,\n+                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n+            }\n+\n+            if (window > stream->recv_window) {\n+                if (ngx_http_v2_send_window_update(h2c, stream->node->id,\n+                                                   window - stream->recv_window)\n+                    == NGX_ERROR)\n+                {\n+                    return ngx_http_v2_connection_error(h2c,\n+                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n+                }\n+\n+                stream->recv_window = window;\n+            }\n+        }\n+\n         ngx_http_run_posted_requests(fc);\n \n     } else if (size) {\n@@ -4027,6 +4054,17 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         return NGX_OK;\n     }\n \n+    rb->rest = 1;\n+\n+    /* set rb->filter_need_buffering */\n+\n+    rc = ngx_http_top_request_body_filter(r, NULL);\n+\n+    if (rc != NGX_OK) {\n+        stream->skip_data = 1;\n+        return rc;\n+    }\n+\n     h2scf = ngx_http_get_module_srv_conf(r, ngx_http_v2_module);\n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n \n@@ -4039,7 +4077,7 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         len++;\n     }\n \n-    if (r->request_body_no_buffering) {\n+    if (r->request_body_no_buffering || rb->filter_need_buffering) {\n \n         /*\n          * We need a room to store data up to the stream's initial window size,\n@@ -4062,36 +4100,45 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    rb->rest = 1;\n-\n     buf = stream->preread;\n \n     if (stream->in_closed) {\n-        r->request_body_no_buffering = 0;\n+        if (!rb->filter_need_buffering) {\n+            r->request_body_no_buffering = 0;\n+        }\n \n         if (buf) {\n             rc = ngx_http_v2_process_request_body(r, buf->pos,\n-                                                  buf->last - buf->pos, 1);\n+                                                  buf->last - buf->pos, 1, 0);\n             ngx_pfree(r->pool, buf->start);\n+\n+        } else {\n+            rc = ngx_http_v2_process_request_body(r, NULL, 0, 1, 0);\n+        }\n+\n+        if (rc != NGX_AGAIN) {\n             return rc;\n         }\n \n-        return ngx_http_v2_process_request_body(r, NULL, 0, 1);\n+        r->read_event_handler = ngx_http_v2_read_client_request_body_handler;\n+        r->write_event_handler = ngx_http_request_empty_handler;\n+\n+        return NGX_AGAIN;\n     }\n \n     if (buf) {\n         rc = ngx_http_v2_process_request_body(r, buf->pos,\n-                                              buf->last - buf->pos, 0);\n+                                              buf->last - buf->pos, 0, 0);\n \n         ngx_pfree(r->pool, buf->start);\n \n-        if (rc != NGX_OK) {\n+        if (rc != NGX_OK && rc != NGX_AGAIN) {\n             stream->skip_data = 1;\n             return rc;\n         }\n     }\n \n-    if (r->request_body_no_buffering) {\n+    if (r->request_body_no_buffering || rb->filter_need_buffering) {\n         size = (size_t) len - h2scf->preread_size;\n \n     } else {\n@@ -4133,7 +4180,7 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n \n static ngx_int_t\n ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n-    size_t size, ngx_uint_t last)\n+    size_t size, ngx_uint_t last, ngx_uint_t flush)\n {\n     size_t                     n;\n     ngx_int_t                  rc;\n@@ -4147,8 +4194,8 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                    \"http2 process request body\");\n \n-    if (size == 0 && !last) {\n-        return NGX_OK;\n+    if (size == 0 && !last && !flush) {\n+        return NGX_AGAIN;\n     }\n \n     for ( ;; ) {\n@@ -4230,7 +4277,7 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                        \"http2 request body rest %O\", rb->rest);\n \n-        if (rb->rest == 0) {\n+        if (rb->rest == 0 && rb->last_saved) {\n             break;\n         }\n \n@@ -4240,10 +4287,10 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n \n             if (r->request_body_no_buffering) {\n                 ngx_post_event(fc->read, &ngx_posted_events);\n-                return NGX_OK;\n+                return NGX_AGAIN;\n             }\n \n-            return NGX_OK;\n+            return NGX_AGAIN;\n         }\n     }\n \n@@ -4279,7 +4326,7 @@ ngx_http_v2_filter_request_body(ngx_http_request_t *r)\n     rb = r->request_body;\n     buf = rb->buf;\n \n-    if (buf->pos == buf->last && rb->rest) {\n+    if (buf->pos == buf->last && (rb->rest || rb->last_sent)) {\n         cl = NULL;\n         goto update;\n     }\n@@ -4342,6 +4389,7 @@ ngx_http_v2_filter_request_body(ngx_http_request_t *r)\n         }\n \n         b->last_buf = 1;\n+        rb->last_sent = 1;\n     }\n \n     b->tag = (ngx_buf_tag_t) &ngx_http_v2_filter_request_body;\n@@ -4361,7 +4409,12 @@ ngx_http_v2_filter_request_body(ngx_http_request_t *r)\n static void\n ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)\n {\n-    ngx_connection_t  *fc;\n+    size_t                     window;\n+    ngx_buf_t                 *buf;\n+    ngx_int_t                  rc;\n+    ngx_connection_t          *fc;\n+    ngx_http_v2_stream_t      *stream;\n+    ngx_http_v2_connection_t  *h2c;\n \n     fc = r->connection;\n \n@@ -4387,6 +4440,63 @@ ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)\n         ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);\n         return;\n     }\n+\n+    rc = ngx_http_v2_process_request_body(r, NULL, 0, r->stream->in_closed, 1);\n+\n+    if (rc != NGX_OK && rc != NGX_AGAIN) {\n+        r->stream->skip_data = 1;\n+        ngx_http_finalize_request(r, rc);\n+        return;\n+    }\n+\n+    if (rc == NGX_OK) {\n+        return;\n+    }\n+\n+    if (r->request_body->rest == 0) {\n+        return;\n+    }\n+\n+    stream = r->stream;\n+    h2c = stream->connection;\n+\n+    buf = r->request_body->buf;\n+    window = buf->end - buf->start;\n+\n+    if (h2c->state.stream == stream) {\n+        window -= h2c->state.length;\n+    }\n+\n+    if (window <= stream->recv_window) {\n+        if (window < stream->recv_window) {\n+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                          \"http2 negative window update\");\n+\n+            stream->skip_data = 1;\n+\n+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (ngx_http_v2_send_window_update(h2c, stream->node->id,\n+                                       window - stream->recv_window)\n+        == NGX_ERROR)\n+    {\n+        stream->skip_data = 1;\n+        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+        return;\n+    }\n+\n+    stream->recv_window = window;\n+\n+    if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {\n+        stream->skip_data = 1;\n+        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+        return;\n+    }\n }\n \n \n@@ -4430,10 +4540,14 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n         return rc;\n     }\n \n-    if (!r->request_body->rest) {\n+    if (r->request_body->rest == 0 && r->request_body->last_saved) {\n         return NGX_OK;\n     }\n \n+    if (r->request_body->rest == 0) {\n+        return NGX_AGAIN;\n+    }\n+\n     if (r->request_body->busy != NULL) {\n         return NGX_AGAIN;\n     }\nDiff:\n@@ -38,6 +38,39 @@ typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n #define ngx_cpu_pause()\n \n \n+#elif (NGX_HAVE_GCC_ATOMIC)\n+\n+/* GCC 4.1 builtin atomic operations */\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+typedef long                        ngx_atomic_int_t;\n+typedef unsigned long               ngx_atomic_uint_t;\n+\n+#if (NGX_PTR_SIZE == 8)\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+#else\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+#endif\n+\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+\n+#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n+    __sync_bool_compare_and_swap(lock, old, set)\n+\n+#define ngx_atomic_fetch_add(value, add)                                      \\\n+    __sync_fetch_and_add(value, add)\n+\n+#define ngx_memory_barrier()        __sync_synchronize()\n+\n+#if ( __i386__ || __i386 || __amd64__ || __amd64 )\n+#define ngx_cpu_pause()             __asm__ (\"pause\")\n+#else\n+#define ngx_cpu_pause()\n+#endif\n+\n+\n #elif (NGX_DARWIN_ATOMIC)\n \n /*\n@@ -88,39 +121,6 @@ typedef uint32_t                    ngx_atomic_uint_t;\n typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n \n \n-#elif (NGX_HAVE_GCC_ATOMIC)\n-\n-/* GCC 4.1 builtin atomic operations */\n-\n-#define NGX_HAVE_ATOMIC_OPS  1\n-\n-typedef long                        ngx_atomic_int_t;\n-typedef unsigned long               ngx_atomic_uint_t;\n-\n-#if (NGX_PTR_SIZE == 8)\n-#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n-#else\n-#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n-#endif\n-\n-typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n-\n-\n-#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n-    __sync_bool_compare_and_swap(lock, old, set)\n-\n-#define ngx_atomic_fetch_add(value, add)                                      \\\n-    __sync_fetch_and_add(value, add)\n-\n-#define ngx_memory_barrier()        __sync_synchronize()\n-\n-#if ( __i386__ || __i386 || __amd64__ || __amd64 )\n-#define ngx_cpu_pause()             __asm__ (\"pause\")\n-#else\n-#define ngx_cpu_pause()\n-#endif\n-\n-\n #elif ( __i386__ || __i386 )\n \n typedef int32_t                     ngx_atomic_int_t;\n"
    },
    {
        "commit_sha": "4917e7ce9827fecd46591eb3ab66017f8f6caaf6",
        "commit_index": "Commit 115",
        "commit_diff": "Diff:\n@@ -307,6 +307,7 @@ typedef struct {\n     ngx_chain_t                      *busy;\n     ngx_http_chunked_t               *chunked;\n     ngx_http_client_body_handler_pt   post_handler;\n+    unsigned                          last_saved:1;\n } ngx_http_request_body_t;\n \n \nDiff:\n@@ -62,11 +62,14 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n     /*\n      * set by ngx_pcalloc():\n      *\n+     *     rb->temp_file = NULL;\n      *     rb->bufs = NULL;\n      *     rb->buf = NULL;\n      *     rb->free = NULL;\n      *     rb->busy = NULL;\n      *     rb->chunked = NULL;\n+     *     rb->received = 0;\n+     *     rb->last_saved = 0;\n      */\n \n     rb->rest = -1;\n@@ -939,15 +942,32 @@ ngx_http_request_body_length_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     rb = r->request_body;\n \n+    out = NULL;\n+    ll = &out;\n+\n     if (rb->rest == -1) {\n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"http request body content length filter\");\n \n         rb->rest = r->headers_in.content_length_n;\n-    }\n \n-    out = NULL;\n-    ll = &out;\n+        if (rb->rest == 0) {\n+\n+            tl = ngx_chain_get_free_buf(r->pool, &rb->free);\n+            if (tl == NULL) {\n+                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            }\n+\n+            b = tl->buf;\n+\n+            ngx_memzero(b, sizeof(ngx_buf_t));\n+\n+            b->last_buf = 1;\n+\n+            *ll = tl;\n+            ll = &tl->next;\n+        }\n+    }\n \n     for (cl = in; cl; cl = cl->next) {\n \n@@ -1011,6 +1031,9 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     rb = r->request_body;\n \n+    out = NULL;\n+    ll = &out;\n+\n     if (rb->rest == -1) {\n \n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n@@ -1027,9 +1050,6 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n         rb->rest = cscf->large_client_header_buffers.size;\n     }\n \n-    out = NULL;\n-    ll = &out;\n-\n     for (cl = in; cl; cl = cl->next) {\n \n         b = NULL;\n@@ -1186,15 +1206,16 @@ ngx_int_t\n ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n {\n     ngx_buf_t                 *b;\n-    ngx_chain_t               *cl;\n+    ngx_chain_t               *cl, *tl, **ll;\n     ngx_http_request_body_t   *rb;\n \n     rb = r->request_body;\n \n-#if (NGX_DEBUG)\n+    ll = &rb->bufs;\n \n-#if 0\n     for (cl = rb->bufs; cl; cl = cl->next) {\n+\n+#if 0\n         ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                        \"http body old buf t:%d f:%d %p, pos %p, size: %z \"\n                        \"file: %O, size: %O\",\n@@ -1203,10 +1224,13 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n                        cl->buf->last - cl->buf->pos,\n                        cl->buf->file_pos,\n                        cl->buf->file_last - cl->buf->file_pos);\n-    }\n #endif\n \n+        ll = &cl->next;\n+    }\n+\n     for (cl = in; cl; cl = cl->next) {\n+\n         ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                        \"http body new buf t:%d f:%d %p, pos %p, size: %z \"\n                        \"file: %O, size: %O\",\n@@ -1215,16 +1239,32 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n                        cl->buf->last - cl->buf->pos,\n                        cl->buf->file_pos,\n                        cl->buf->file_last - cl->buf->file_pos);\n-    }\n \n-#endif\n+        if (cl->buf->last_buf) {\n \n-    /* TODO: coalesce neighbouring buffers */\n+            if (rb->last_saved) {\n+                ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                              \"duplicate last buf in save filter\");\n+                *ll = NULL;\n+                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            }\n \n-    if (ngx_chain_add_copy(r->pool, &rb->bufs, in) != NGX_OK) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            rb->last_saved = 1;\n+        }\n+\n+        tl = ngx_alloc_chain_link(r->pool);\n+        if (tl == NULL) {\n+            *ll = NULL;\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n+        tl->buf = cl->buf;\n+        *ll = tl;\n+        ll = &tl->next;\n     }\n \n+    *ll = NULL;\n+\n     if (r->request_body_no_buffering) {\n         return NGX_OK;\n     }\n@@ -1244,6 +1284,12 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     if (rb->temp_file || r->request_body_in_file_only) {\n \n+        if (rb->bufs && rb->bufs->buf->in_file) {\n+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                          \"body already in file\");\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n         if (ngx_http_write_request_body(r) != NGX_OK) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\nDiff:\n@@ -4039,7 +4039,7 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         len++;\n     }\n \n-    if (r->request_body_no_buffering && !stream->in_closed) {\n+    if (r->request_body_no_buffering) {\n \n         /*\n          * We need a room to store data up to the stream's initial window size,\n"
    },
    {
        "commit_sha": "163bcf950b1c7bfeebb7cb9e68a8f3f733b4cdbb",
        "commit_index": "Commit 114",
        "commit_diff": "Diff:\n@@ -2113,6 +2113,10 @@ ngx_http_upstream_send_request(ngx_http_request_t *r, ngx_http_upstream_t *u,\n             c->tcp_nopush = NGX_TCP_NOPUSH_UNSET;\n         }\n \n+        if (c->read->ready) {\n+            ngx_post_event(c->read, &ngx_posted_events);\n+        }\n+\n         return;\n     }\n \nDiff:\n@@ -4032,11 +4032,14 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n \n     len = r->headers_in.content_length_n;\n \n-    if (r->request_body_no_buffering && !stream->in_closed) {\n+    if (len < 0 || len > (off_t) clcf->client_body_buffer_size) {\n+        len = clcf->client_body_buffer_size;\n \n-        if (len < 0 || len > (off_t) clcf->client_body_buffer_size) {\n-            len = clcf->client_body_buffer_size;\n-        }\n+    } else {\n+        len++;\n+    }\n+\n+    if (r->request_body_no_buffering && !stream->in_closed) {\n \n         /*\n          * We need a room to store data up to the stream's initial window size,\n@@ -4050,22 +4053,10 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         if (len > NGX_HTTP_V2_MAX_WINDOW) {\n             len = NGX_HTTP_V2_MAX_WINDOW;\n         }\n-\n-        rb->buf = ngx_create_temp_buf(r->pool, (size_t) len);\n-\n-    } else if (len >= 0 && len <= (off_t) clcf->client_body_buffer_size\n-               && !r->request_body_in_file_only)\n-    {\n-        rb->buf = ngx_create_temp_buf(r->pool, (size_t) len);\n-\n-    } else {\n-        rb->buf = ngx_calloc_buf(r->pool);\n-\n-        if (rb->buf != NULL) {\n-            rb->buf->sync = 1;\n-        }\n     }\n \n+    rb->buf = ngx_create_temp_buf(r->pool, (size_t) len);\n+\n     if (rb->buf == NULL) {\n         stream->skip_data = 1;\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n@@ -4144,85 +4135,134 @@ static ngx_int_t\n ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n     size_t size, ngx_uint_t last)\n {\n-    ngx_buf_t                 *buf;\n+    size_t                     n;\n     ngx_int_t                  rc;\n     ngx_connection_t          *fc;\n     ngx_http_request_body_t   *rb;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     fc = r->connection;\n     rb = r->request_body;\n-    buf = rb->buf;\n \n-    if (size) {\n-        if (buf->sync) {\n-            buf->pos = buf->start = pos;\n-            buf->last = buf->end = pos + size;\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 process request body\");\n+\n+    if (size == 0 && !last) {\n+        return NGX_OK;\n+    }\n \n-            r->request_body_in_file_only = 1;\n+    for ( ;; ) {\n+        for ( ;; ) {\n+            if (rb->buf->last == rb->buf->end && size) {\n \n-        } else {\n-            if (size > (size_t) (buf->end - buf->last)) {\n-                ngx_log_error(NGX_LOG_INFO, fc->log, 0,\n-                              \"client intended to send body data \"\n-                              \"larger than declared\");\n+                if (r->request_body_no_buffering) {\n \n-                return NGX_HTTP_BAD_REQUEST;\n+                    /* should never happen due to flow control */\n+\n+                    ngx_log_error(NGX_LOG_ALERT, fc->log, 0,\n+                                  \"no space in http2 body buffer\");\n+\n+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+                }\n+\n+                /* update chains */\n+\n+                ngx_log_error(NGX_LOG_DEBUG, fc->log, 0,\n+                              \"http2 body update chains\");\n+\n+                rc = ngx_http_v2_filter_request_body(r);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n+\n+                if (rb->busy != NULL) {\n+                    ngx_log_error(NGX_LOG_ALERT, fc->log, 0,\n+                                  \"busy buffers after request body flush\");\n+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+                }\n+\n+                rb->buf->pos = rb->buf->start;\n+                rb->buf->last = rb->buf->start;\n             }\n \n-            buf->last = ngx_cpymem(buf->last, pos, size);\n-        }\n-    }\n+            /* copy body data to the buffer */\n \n-    if (last) {\n-        rb->rest = 0;\n+            n = rb->buf->end - rb->buf->last;\n \n-        if (fc->read->timer_set) {\n-            ngx_del_timer(fc->read);\n-        }\n+            if (n > size) {\n+                n = size;\n+            }\n \n-        if (r->request_body_no_buffering) {\n-            ngx_post_event(fc->read, &ngx_posted_events);\n-            return NGX_OK;\n-        }\n+            rb->buf->last = ngx_cpymem(rb->buf->last, pos, n);\n \n-        rc = ngx_http_v2_filter_request_body(r);\n+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                           \"http2 request body recv %uz\", n);\n \n-        if (rc != NGX_OK) {\n-            return rc;\n-        }\n+            pos += n;\n+            size -= n;\n+\n+            if (size == 0 && last) {\n+                rb->rest = 0;\n+            }\n \n-        if (buf->sync) {\n-            /* prevent reusing this buffer in the upstream module */\n-            rb->buf = NULL;\n+            if (r->request_body_no_buffering) {\n+                break;\n+            }\n+\n+            /* pass buffer to request body filter chain */\n+\n+            rc = ngx_http_v2_filter_request_body(r);\n+\n+            if (rc != NGX_OK) {\n+                return rc;\n+            }\n+\n+            if (rb->rest == 0) {\n+                break;\n+            }\n+\n+            if (size == 0) {\n+                break;\n+            }\n         }\n \n-        if (r->headers_in.chunked) {\n-            r->headers_in.content_length_n = rb->received;\n+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                       \"http2 request body rest %O\", rb->rest);\n+\n+        if (rb->rest == 0) {\n+            break;\n         }\n \n-        r->read_event_handler = ngx_http_block_reading;\n-        rb->post_handler(r);\n+        if (size == 0) {\n+            clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+            ngx_add_timer(fc->read, clcf->client_body_timeout);\n \n-        return NGX_OK;\n-    }\n+            if (r->request_body_no_buffering) {\n+                ngx_post_event(fc->read, &ngx_posted_events);\n+                return NGX_OK;\n+            }\n \n-    if (size == 0) {\n-        return NGX_OK;\n+            return NGX_OK;\n+        }\n     }\n \n-    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-    ngx_add_timer(fc->read, clcf->client_body_timeout);\n+    if (fc->read->timer_set) {\n+        ngx_del_timer(fc->read);\n+    }\n \n     if (r->request_body_no_buffering) {\n         ngx_post_event(fc->read, &ngx_posted_events);\n         return NGX_OK;\n     }\n \n-    if (buf->sync) {\n-        return ngx_http_v2_filter_request_body(r);\n+    if (r->headers_in.chunked) {\n+        r->headers_in.content_length_n = rb->received;\n     }\n \n+    r->read_event_handler = ngx_http_block_reading;\n+    rb->post_handler(r);\n+\n     return NGX_OK;\n }\n \n@@ -4364,6 +4404,9 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n     stream = r->stream;\n     fc = r->connection;\n \n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 read unbuffered request body\");\n+\n     if (fc->read->timedout) {\n         if (stream->recv_window) {\n             stream->skip_data = 1;\nDiff:\n@@ -1137,8 +1137,8 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n     ngx_str_t                  login, passwd;\n     ngx_connection_t          *c;\n #if (NGX_MAIL_SSL)\n-    ngx_str_t                  verify, subject, issuer, serial, fingerprint,\n-                               raw_cert, cert;\n+    ngx_str_t                  protocol, cipher, verify, subject, issuer,\n+                               serial, fingerprint, raw_cert, cert;\n     ngx_mail_ssl_conf_t       *sslcf;\n #endif\n     ngx_mail_core_srv_conf_t  *cscf;\n@@ -1155,6 +1155,25 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n \n #if (NGX_MAIL_SSL)\n \n+    if (c->ssl) {\n+\n+        if (ngx_ssl_get_protocol(c, pool, &protocol) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        protocol.len = ngx_strlen(protocol.data);\n+\n+        if (ngx_ssl_get_cipher_name(c, pool, &cipher) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        cipher.len = ngx_strlen(cipher.data);\n+\n+    } else {\n+        ngx_str_null(&protocol);\n+        ngx_str_null(&cipher);\n+    }\n+\n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n     if (c->ssl && sslcf->verify) {\n@@ -1252,6 +1271,10 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n \n     if (c->ssl) {\n         len += sizeof(\"Auth-SSL: on\" CRLF) - 1\n+               + sizeof(\"Auth-SSL-Protocol: \") - 1 + protocol.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Cipher: \") - 1 + cipher.len\n+                     + sizeof(CRLF) - 1\n                + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len\n                      + sizeof(CRLF) - 1\n                + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len\n@@ -1373,6 +1396,20 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n         b->last = ngx_cpymem(b->last, \"Auth-SSL: on\" CRLF,\n                              sizeof(\"Auth-SSL: on\" CRLF) - 1);\n \n+        if (protocol.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Protocol: \",\n+                                 sizeof(\"Auth-SSL-Protocol: \") - 1);\n+            b->last = ngx_copy(b->last, protocol.data, protocol.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (cipher.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Cipher: \",\n+                                 sizeof(\"Auth-SSL-Cipher: \") - 1);\n+            b->last = ngx_copy(b->last, cipher.data, cipher.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n         if (verify.len) {\n             b->last = ngx_cpymem(b->last, \"Auth-SSL-Verify: \",\n                                  sizeof(\"Auth-SSL-Verify: \") - 1);\n"
    },
    {
        "commit_sha": "6ee378917a3d4a9b53e2e1a344aa9e9ff7b3d869",
        "commit_index": "Commit 113",
        "commit_diff": "Diff:\n@@ -4896,6 +4896,12 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = glcf->upstream.ssl;\n \n+    if (ngx_ssl_ciphers(cf, glcf->upstream.ssl, &glcf->ssl_ciphers, 0)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     if (glcf->upstream.ssl_certificate) {\n \n         if (glcf->upstream.ssl_certificate_key == NULL) {\n@@ -4927,12 +4933,6 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, glcf->upstream.ssl, &glcf->ssl_ciphers, 0)\n-        != NGX_OK)\n-    {\n-        return NGX_ERROR;\n-    }\n-\n     if (glcf->upstream.ssl_verify) {\n         if (glcf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -4944,6 +4944,12 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = plcf->upstream.ssl;\n \n+    if (ngx_ssl_ciphers(cf, plcf->upstream.ssl, &plcf->ssl_ciphers, 0)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     if (plcf->upstream.ssl_certificate) {\n \n         if (plcf->upstream.ssl_certificate_key == NULL) {\n@@ -4975,12 +4981,6 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, plcf->upstream.ssl, &plcf->ssl_ciphers, 0)\n-        != NGX_OK)\n-    {\n-        return NGX_ERROR;\n-    }\n-\n     if (plcf->upstream.ssl_verify) {\n         if (plcf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -797,6 +797,13 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                                           ngx_http_ssl_npn_advertised, NULL);\n #endif\n \n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     if (ngx_http_ssl_compile_certificates(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -829,13 +836,6 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n-                        conf->prefer_server_ciphers)\n-        != NGX_OK)\n-    {\n-        return NGX_CONF_ERROR;\n-    }\n-\n     conf->ssl.buffer_size = conf->buffer_size;\n \n     if (conf->verify) {\nDiff:\n@@ -2432,6 +2432,12 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = uwcf->upstream.ssl;\n \n+    if (ngx_ssl_ciphers(cf, uwcf->upstream.ssl, &uwcf->ssl_ciphers, 0)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     if (uwcf->upstream.ssl_certificate) {\n \n         if (uwcf->upstream.ssl_certificate_key == NULL) {\n@@ -2463,12 +2469,6 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, uwcf->upstream.ssl, &uwcf->ssl_ciphers, 0)\n-        != NGX_OK)\n-    {\n-        return NGX_ERROR;\n-    }\n-\n     if (uwcf->upstream.ssl_verify) {\n         if (uwcf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -394,6 +394,13 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = &conf->ssl;\n \n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,\n                              conf->certificate_keys, conf->passwords)\n         != NGX_OK)\n@@ -430,13 +437,6 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n-                        conf->prefer_server_ciphers)\n-        != NGX_OK)\n-    {\n-        return NGX_CONF_ERROR;\n-    }\n-\n     if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\nDiff:\n@@ -2185,6 +2185,10 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = pscf->ssl;\n \n+    if (ngx_ssl_ciphers(cf, pscf->ssl, &pscf->ssl_ciphers, 0) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n     if (pscf->ssl_certificate) {\n \n         if (pscf->ssl_certificate_key == NULL) {\n@@ -2216,10 +2220,6 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, pscf->ssl, &pscf->ssl_ciphers, 0) != NGX_OK) {\n-        return NGX_ERROR;\n-    }\n-\n     if (pscf->ssl_verify) {\n         if (pscf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -720,6 +720,13 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                                            ngx_stream_ssl_servername);\n #endif\n \n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     if (ngx_stream_ssl_compile_certificates(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -752,13 +759,6 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n-                        conf->prefer_server_ciphers)\n-        != NGX_OK)\n-    {\n-        return NGX_CONF_ERROR;\n-    }\n-\n     if (conf->verify) {\n \n         if (conf->client_certificate.len == 0 && conf->verify != 3) {\n"
    },
    {
        "commit_sha": "dcf9f055bf1863555869493d5ac5944b5327f128",
        "commit_index": "Commit 112",
        "commit_diff": "Diff:\n@@ -3,11 +3,9 @@\n <head>\n <title>Error</title>\n <style>\n-    body {\n-        width: 35em;\n-        margin: 0 auto;\n-        font-family: Tahoma, Verdana, Arial, sans-serif;\n-    }\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n </style>\n </head>\n <body>\nDiff:\n@@ -3,11 +3,9 @@\n <head>\n <title>Welcome to nginx!</title>\n <style>\n-    body {\n-        width: 35em;\n-        margin: 0 auto;\n-        font-family: Tahoma, Verdana, Arial, sans-serif;\n-    }\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n </style>\n </head>\n <body>\nDiff:\n@@ -514,6 +514,15 @@ ngx_http_header_filter(ngx_http_request_t *r)\n         *b->last++ = CR; *b->last++ = LF;\n     }\n \n+    if (r->headers_in.prefer) {\n+        b->last = ngx_cpymem(b->last, \"Prefer: \",\n+                             sizeof(\"Prefer: \") - 1);\n+        b->last = ngx_cpymem(b->last, r->headers_in.prefer->value.data,\n+                             r->headers_in.prefer->value.len);\n+\n+        *b->last++ = CR; *b->last++ = LF;\n+    }\n+\n     if (host.data) {\n \n         p = b->last + sizeof(\"Location: \") - 1;\n@@ -551,6 +560,10 @@ ngx_http_header_filter(ngx_http_request_t *r)\n                              sizeof(\"Transfer-Encoding: chunked\" CRLF) - 1);\n     }\n \n+    if (r->headers_in.prefer) {\n+        len += sizeof(\"Prefer: \" CRLF) + r->headers_in.prefer->value.len;\n+    }\n+\n     if (r->headers_out.status == NGX_HTTP_SWITCHING_PROTOCOLS) {\n         b->last = ngx_cpymem(b->last, \"Connection: upgrade\" CRLF,\n                              sizeof(\"Connection: upgrade\" CRLF) - 1);\nDiff:\n@@ -30,6 +30,8 @@ static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,\n@@ -126,6 +128,9 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  offsetof(ngx_http_headers_in_t, content_type),\n                  ngx_http_process_header_line },\n \n+    { ngx_string(\"Prefer\"), offsetof(ngx_http_headers_in_t, prefer),\n+                 ngx_http_process_prefer },\n+\n     { ngx_string(\"Range\"), offsetof(ngx_http_headers_in_t, range),\n                  ngx_http_process_header_line },\n \n@@ -4017,3 +4022,38 @@ ngx_http_process_black_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     return NGX_OK;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    ngx_table_elt_t *p;\n+\n+    if (r->headers_in.prefer) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate host header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.prefer->key,\n+                      &r->headers_in.prefer->value);\n+        ngx_free(r->headers_in.prefer);\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_alloc(sizeof(ngx_table_elt_t), r->connection->log);\n+\n+    if (!p) {\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    p->hash = h->hash;\n+    p->key.len = h->key.len;\n+    p->key.data = h->key.data;\n+    p->value.len = h->value.len;\n+    p->value.data = h->value.data;\n+\n+    r->headers_in.prefer = p;\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -190,6 +190,7 @@ typedef struct {\n     ngx_table_elt_t                  *if_match;\n     ngx_table_elt_t                  *if_none_match;\n     ngx_table_elt_t                  *user_agent;\n+    ngx_table_elt_t                  *prefer;\n     ngx_table_elt_t                  *referer;\n     ngx_table_elt_t                  *content_length;\n     ngx_table_elt_t                  *content_range;\n"
    },
    {
        "commit_sha": "59aa0b2b2644d023a9ceddcbb932df2d8ec64f6d",
        "commit_index": "Commit 111",
        "commit_diff": "Diff:\n@@ -299,11 +299,6 @@ ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)\n     SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);\n #endif\n \n-#ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING\n-    /* this option allow a potential SSL 2.0 rollback (CAN-2005-2969) */\n-    SSL_CTX_set_options(ssl->ctx, SSL_OP_MSIE_SSLV2_RSA_PADDING);\n-#endif\n-\n #ifdef SSL_OP_SSLEAY_080_CLIENT_DH_BUG\n     SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLEAY_080_CLIENT_DH_BUG);\n #endif\n@@ -378,6 +373,10 @@ ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)\n     SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_CLIENT_RENEGOTIATION);\n #endif\n \n+#ifdef SSL_OP_IGNORE_UNEXPECTED_EOF\n+    SSL_CTX_set_options(ssl->ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);\n+#endif\n+\n #ifdef SSL_MODE_RELEASE_BUFFERS\n     SSL_CTX_set_mode(ssl->ctx, SSL_MODE_RELEASE_BUFFERS);\n #endif\n@@ -859,11 +858,6 @@ ngx_ssl_ciphers(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *ciphers,\n         SSL_CTX_set_options(ssl->ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);\n     }\n \n-#if (OPENSSL_VERSION_NUMBER < 0x10100001L && !defined LIBRESSL_VERSION_NUMBER)\n-    /* a temporary 512-bit RSA key is required for export versions of MSIE */\n-    SSL_CTX_set_tmp_rsa_callback(ssl->ctx, ngx_ssl_rsa512_key_callback);\n-#endif\n-\n     return NGX_OK;\n }\n \n@@ -1116,28 +1110,6 @@ ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)\n }\n \n \n-RSA *\n-ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n-    int key_length)\n-{\n-    static RSA  *key;\n-\n-    if (key_length != 512) {\n-        return NULL;\n-    }\n-\n-#if (OPENSSL_VERSION_NUMBER < 0x10100003L && !defined OPENSSL_NO_DEPRECATED)\n-\n-    if (key == NULL) {\n-        key = RSA_generate_key(512, RSA_F4, NULL, NULL);\n-    }\n-\n-#endif\n-\n-    return key;\n-}\n-\n-\n ngx_array_t *\n ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file)\n {\n@@ -1350,7 +1322,6 @@ ngx_ssl_passwords_cleanup(void *data)\n ngx_int_t\n ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n {\n-    DH   *dh;\n     BIO  *bio;\n \n     if (file->len == 0) {\n@@ -1368,6 +1339,10 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n         return NGX_ERROR;\n     }\n \n+#ifdef SSL_CTX_set_tmp_dh\n+    {\n+    DH  *dh;\n+\n     dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n     if (dh == NULL) {\n         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n@@ -1385,6 +1360,33 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n     }\n \n     DH_free(dh);\n+    }\n+#else\n+    {\n+    EVP_PKEY  *dh;\n+\n+    /*\n+     * PEM_read_bio_DHparams() and SSL_CTX_set_tmp_dh()\n+     * are deprecated in OpenSSL 3.0\n+     */\n+\n+    dh = PEM_read_bio_Parameters(bio, NULL);\n+    if (dh == NULL) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"PEM_read_bio_Parameters(\\\"%s\\\") failed\", file->data);\n+        BIO_free(bio);\n+        return NGX_ERROR;\n+    }\n+\n+    if (SSL_CTX_set0_tmp_dh_pkey(ssl->ctx, dh) != 1) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set0_tmp_dh_pkey(\\%s\\\") failed\", file->data);\n+        BIO_free(bio);\n+        return NGX_ERROR;\n+    }\n+    }\n+#endif\n+\n     BIO_free(bio);\n \n     return NGX_OK;\n@@ -3246,7 +3248,7 @@ ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, char *fmt, ...)\n \n         for ( ;; ) {\n \n-            n = ERR_peek_error_line_data(NULL, NULL, &data, &flags);\n+            n = ERR_peek_error_data(&data, &flags);\n \n             if (n == 0) {\n                 break;\nDiff:\n@@ -12,6 +12,8 @@\n #include <ngx_config.h>\n #include <ngx_core.h>\n \n+#define OPENSSL_SUPPRESS_DEPRECATED\n+\n #include <openssl/ssl.h>\n #include <openssl/err.h>\n #include <openssl/bn.h>\n@@ -27,7 +29,6 @@\n #include <openssl/ocsp.h>\n #endif\n #include <openssl/rand.h>\n-#include <openssl/rsa.h>\n #include <openssl/x509.h>\n #include <openssl/x509v3.h>\n \n@@ -64,6 +65,16 @@\n #endif\n \n \n+#if (OPENSSL_VERSION_NUMBER >= 0x30000000L && !defined SSL_get_peer_certificate)\n+#define SSL_get_peer_certificate(s)  SSL_get1_peer_certificate(s)\n+#endif\n+\n+\n+#if (OPENSSL_VERSION_NUMBER < 0x30000000L && !defined ERR_peek_error_data)\n+#define ERR_peek_error_data(d, f)    ERR_peek_error_line_data(NULL, NULL, d, f)\n+#endif\n+\n+\n typedef struct ngx_ssl_ocsp_s  ngx_ssl_ocsp_t;\n \n \n@@ -196,8 +207,6 @@ ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n-RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n-    int key_length);\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\n ngx_array_t *ngx_ssl_preserve_passwords(ngx_conf_t *cf,\n     ngx_array_t *passwords);\nDiff:\n@@ -2002,6 +2002,14 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n     }\n \n     if (r->headers_in.transfer_encoding) {\n+        if (r->http_version < NGX_HTTP_VERSION_11) {\n+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                          \"client sent HTTP/1.0 request with \"\n+                          \"\\\"Transfer-Encoding\\\" header\");\n+            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+            return NGX_ERROR;\n+        }\n+\n         if (r->headers_in.transfer_encoding->value.len == 7\n             && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                                (u_char *) \"chunked\", 7) == 0)\n"
    },
    {
        "commit_sha": "3d9a627c514a3fe40b318ff71a94ee99ee229e06",
        "commit_index": "Commit 110",
        "commit_diff": "Diff:\n@@ -461,3 +461,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n+a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021001\n-#define NGINX_VERSION      \"1.21.1\"\n+#define nginx_version      1021002\n+#define NGINX_VERSION      \"1.21.2\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1376,7 +1376,13 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n         return NGX_ERROR;\n     }\n \n-    SSL_CTX_set_tmp_dh(ssl->ctx, dh);\n+    if (SSL_CTX_set_tmp_dh(ssl->ctx, dh) != 1) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set_tmp_dh(\\\"%s\\\") failed\", file->data);\n+        DH_free(dh);\n+        BIO_free(bio);\n+        return NGX_ERROR;\n+    }\n \n     DH_free(dh);\n     BIO_free(bio);\n@@ -1740,6 +1746,9 @@ ngx_ssl_handshake(ngx_connection_t *c)\n         c->recv_chain = ngx_ssl_recv_chain;\n         c->send_chain = ngx_ssl_send_chain;\n \n+        c->read->ready = 1;\n+        c->write->ready = 1;\n+\n #ifndef SSL_OP_NO_RENEGOTIATION\n #if OPENSSL_VERSION_NUMBER < 0x10100000L\n #ifdef SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS\n@@ -1885,6 +1894,9 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->recv_chain = ngx_ssl_recv_chain;\n         c->send_chain = ngx_ssl_send_chain;\n \n+        c->read->ready = 1;\n+        c->write->ready = 1;\n+\n         rc = ngx_ssl_ocsp_validate(c);\n \n         if (rc == NGX_ERROR) {\n"
    },
    {
        "commit_sha": "71486f4cacf065c8de85310bea500af9ac9d445a",
        "commit_index": "Commit 109",
        "commit_diff": "Diff:\n@@ -5,6 +5,125 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.1\" date=\"2021-07-06\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx для метода CONNECT всегда возвращает ошибку.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error for the CONNECT method.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в запросе одновременно присутствуют строки заголовка \"Content-Length\"\n+и \"Transfer-Encoding\".\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if both \"Content-Length\" and \"Transfer-Encoding\" header lines\n+are present in the request.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в строке запроса используются пробелы или управляющие символы.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if spaces or control characters are used in the request line.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в имени заголовка используются пробелы или управляющие символы.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if spaces or control characters are used in a header name.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в строке \"Host\" заголовка запроса\n+используются пробелы или управляющие символы.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if spaces or control characters\n+are used in the \"Host\" request header line.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+оптимизация тестирования конфигурации\n+при использовании большого количества listen-сокетов.\n+</para>\n+<para lang=\"en\">\n+optimization of configuration testing\n+when using many listening sockets.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не экранировал\n+символы \"\"\", \"&lt;\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", и \"}\"\n+при проксировании с изменением URI запроса.\n+</para>\n+<para lang=\"en\">\n+nginx did not escape\n+\"\"\", \"&lt;\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", and \"}\" characters\n+when proxying with changed URI.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL-переменные могли быть пустыми при записи в лог;\n+ошибка появилась в 1.19.5.\n+</para>\n+<para lang=\"en\">\n+SSL variables might be empty when used in logs;\n+the bug had appeared in 1.19.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+keepalive-соединения с gRPC-бэкендами могли не закрываться\n+после получения GOAWAY-фрейма.\n+</para>\n+<para lang=\"en\">\n+keepalive connections with gRPC backends might not be closed\n+after receiving a GOAWAY frame.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+уменьшено потребление памяти для долгоживущих запросов\n+при проксировании с использованием более 64 буферов.\n+</para>\n+<para lang=\"en\">\n+reduced memory consumption for long-lived requests\n+when proxying with more than 64 buffers.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.0\" date=\"2021-05-25\">\n \n <change type=\"security\">\nDiff:\n@@ -10,7 +10,7 @@\n #include <ngx_event.h>\n \n \n-#define NGX_WSABUFS  8\n+#define NGX_WSABUFS  64\n \n \n ssize_t\n@@ -57,6 +57,10 @@ ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n             wsabuf->len += n;\n \n         } else {\n+            if (vec.nelts == vec.nalloc) {\n+                break;\n+            }\n+\n             wsabuf = ngx_array_push(&vec);\n             if (wsabuf == NULL) {\n                 return NGX_ERROR;\nDiff:\n@@ -10,7 +10,7 @@\n #include <ngx_event.h>\n \n \n-#define NGX_WSABUFS  8\n+#define NGX_WSABUFS  64\n \n \n ngx_chain_t *\n@@ -47,7 +47,7 @@ ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n     vec.elts = wsabufs;\n     vec.size = sizeof(WSABUF);\n-    vec.nalloc = NGX_WSABUFS;\n+    vec.nalloc = ngx_min(NGX_WSABUFS, ngx_max_wsabufs);\n     vec.pool = c->pool;\n \n     for ( ;; ) {\n@@ -59,10 +59,8 @@ ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         /* create the WSABUF and coalesce the neighbouring bufs */\n \n-        for (cl = in;\n-             cl && vec.nelts < ngx_max_wsabufs && send < limit;\n-             cl = cl->next)\n-        {\n+        for (cl = in; cl && send < limit; cl = cl->next) {\n+\n             if (ngx_buf_special(cl->buf)) {\n                 continue;\n             }\n@@ -77,6 +75,10 @@ ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                 wsabuf->len += cl->buf->last - cl->buf->pos;\n \n             } else {\n+                if (vec.nelts == vec.nalloc) {\n+                    break;\n+                }\n+\n                 wsabuf = ngx_array_push(&vec);\n                 if (wsabuf == NULL) {\n                     return NGX_CHAIN_ERROR;\n@@ -169,7 +171,7 @@ ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n         vec.elts = wsabufs;\n         vec.nelts = 0;\n         vec.size = sizeof(WSABUF);\n-        vec.nalloc = NGX_WSABUFS;\n+        vec.nalloc = ngx_min(NGX_WSABUFS, ngx_max_wsabufs);\n         vec.pool = c->pool;\n \n         send = 0;\n@@ -178,10 +180,8 @@ ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         /* create the WSABUF and coalesce the neighbouring bufs */\n \n-        for (cl = in;\n-             cl && vec.nelts < ngx_max_wsabufs && send < limit;\n-             cl = cl->next)\n-        {\n+        for (cl = in; cl && send < limit; cl = cl->next) {\n+\n             if (ngx_buf_special(cl->buf)) {\n                 continue;\n             }\n@@ -196,6 +196,10 @@ ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                 wsabuf->len += cl->buf->last - cl->buf->pos;\n \n             } else {\n+                if (vec.nelts == vec.nalloc) {\n+                    break;\n+                }\n+\n                 wsabuf = ngx_array_push(&vec);\n                 if (wsabuf == NULL) {\n                     return NGX_CHAIN_ERROR;\n"
    },
    {
        "commit_sha": "8c16d356dc5d13d078099eca3bf48e1fcd932f92",
        "commit_index": "Commit 108",
        "commit_diff": "Diff:\n@@ -2019,10 +2019,12 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n                 break;\n             }\n \n-            /* there was error while a header line parsing */\n+            /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                          \"upstream sent invalid header\");\n+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                          \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                          r->header_end - r->header_name_start,\n+                          r->header_name_start, *r->header_end);\n \n             return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n         }\nDiff:\n@@ -2019,10 +2019,12 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n             return NGX_AGAIN;\n         }\n \n-        /* there was error while a header line parsing */\n+        /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                      \"upstream sent invalid header\");\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\nDiff:\n@@ -1140,10 +1140,12 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n             return NGX_AGAIN;\n         }\n \n-        /* there was error while a header line parsing */\n+        /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                      \"upstream sent invalid header\");\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\nDiff:\n@@ -1361,10 +1361,12 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n             return NGX_AGAIN;\n         }\n \n-        /* there was error while a header line parsing */\n+        /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                      \"upstream sent invalid header\");\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\nDiff:\n@@ -894,6 +894,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 }\n \n                 if (ch <= 0x20 || ch == 0x7f || ch == ':') {\n+                    r->header_end = p;\n                     return NGX_HTTP_PARSE_INVALID_HEADER;\n                 }\n \n@@ -962,6 +963,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n             }\n \n             if (ch <= 0x20 || ch == 0x7f) {\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             }\n \n@@ -984,6 +986,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 r->header_end = p;\n                 goto done;\n             case '\\0':\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             default:\n                 r->header_start = p;\n@@ -1007,6 +1010,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 r->header_end = p;\n                 goto done;\n             case '\\0':\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             }\n             break;\n@@ -1022,6 +1026,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n             case LF:\n                 goto done;\n             case '\\0':\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             default:\n                 state = sw_value;\nDiff:\n@@ -1541,7 +1541,9 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n         ngx_log_error(NGX_LOG_INFO, c->log, 0,\n-                      \"client sent invalid header line\");\n+                      \"client sent invalid header line: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n         break;\n@@ -2193,15 +2195,16 @@ ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool, ngx_uint_t alloc)\n             }\n             break;\n \n-        case '\\0':\n-            return NGX_DECLINED;\n-\n         default:\n \n             if (ngx_path_separator(ch)) {\n                 return NGX_DECLINED;\n             }\n \n+            if (ch <= 0x20 || ch == 0x7f) {\n+                return NGX_DECLINED;\n+            }\n+\n             if (ch >= 'A' && ch <= 'Z') {\n                 alloc = 1;\n             }\nDiff:\n@@ -96,7 +96,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n             iov->iov_len += n;\n \n         } else {\n-            if (vec.nelts >= IOV_MAX) {\n+            if (vec.nelts == vec.nalloc) {\n                 break;\n             }\n \n"
    },
    {
        "commit_sha": "952b2a4f258cb765ed7a51d31f616c164c368a2c",
        "commit_index": "Commit 107",
        "commit_diff": "Diff:\n@@ -3384,7 +3384,7 @@ ngx_http_grpc_validate_header_name(ngx_http_request_t *r, ngx_str_t *s)\n             return NGX_ERROR;\n         }\n \n-        if (ch == '\\0' || ch == CR || ch == LF) {\n+        if (ch <= 0x20 || ch == 0x7f) {\n             return NGX_ERROR;\n         }\n     }\nDiff:\n@@ -11,7 +11,7 @@\n \n \n static uint32_t  usual[] = {\n-    0xffffdbfe, /* 1111 1111 1111 1111  1101 1011 1111 1110 */\n+    0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n \n                 /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n     0x7fff37d6, /* 0111 1111 1111 1111  0011 0111 1101 0110 */\n@@ -24,7 +24,7 @@ static uint32_t  usual[] = {\n #endif\n \n                 /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n+    0x7fffffff, /* 0111 1111 1111 1111  1111 1111 1111 1111 */\n \n     0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n@@ -528,9 +528,10 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             case '+':\n                 r->plus_in_uri = 1;\n                 break;\n-            case '\\0':\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n             default:\n+                if (ch < 0x20 || ch == 0x7f) {\n+                    return NGX_HTTP_PARSE_INVALID_REQUEST;\n+                }\n                 state = sw_check_uri;\n                 break;\n             }\n@@ -592,8 +593,11 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             case '+':\n                 r->plus_in_uri = 1;\n                 break;\n-            case '\\0':\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n+            default:\n+                if (ch < 0x20 || ch == 0x7f) {\n+                    return NGX_HTTP_PARSE_INVALID_REQUEST;\n+                }\n+                break;\n             }\n             break;\n \n@@ -621,8 +625,11 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             case '#':\n                 r->complex_uri = 1;\n                 break;\n-            case '\\0':\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n+            default:\n+                if (ch < 0x20 || ch == 0x7f) {\n+                    return NGX_HTTP_PARSE_INVALID_REQUEST;\n+                }\n+                break;\n             }\n             break;\n \n@@ -886,7 +893,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                     break;\n                 }\n \n-                if (ch == '\\0') {\n+                if (ch <= 0x20 || ch == 0x7f || ch == ':') {\n                     return NGX_HTTP_PARSE_INVALID_HEADER;\n                 }\n \n@@ -954,7 +961,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 break;\n             }\n \n-            if (ch == '\\0') {\n+            if (ch <= 0x20 || ch == 0x7f) {\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             }\n \n@@ -1118,8 +1125,6 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             }\n \n             switch (ch) {\n-            case ' ':\n-                return NGX_ERROR;\n             case '.':\n                 r->complex_uri = 1;\n                 state = sw_uri;\n@@ -1150,6 +1155,9 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n                 r->plus_in_uri = 1;\n                 break;\n             default:\n+                if (ch <= 0x20 || ch == 0x7f) {\n+                    return NGX_ERROR;\n+                }\n                 state = sw_check_uri;\n                 break;\n             }\n@@ -1177,8 +1185,6 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             case '.':\n                 r->uri_ext = p + 1;\n                 break;\n-            case ' ':\n-                return NGX_ERROR;\n #if (NGX_WIN32)\n             case '\\\\':\n                 r->complex_uri = 1;\n@@ -1200,6 +1206,11 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             case '+':\n                 r->plus_in_uri = 1;\n                 break;\n+            default:\n+                if (ch <= 0x20 || ch == 0x7f) {\n+                    return NGX_ERROR;\n+                }\n+                break;\n             }\n             break;\n \n@@ -1211,11 +1222,14 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             }\n \n             switch (ch) {\n-            case ' ':\n-                return NGX_ERROR;\n             case '#':\n                 r->complex_uri = 1;\n                 break;\n+            default:\n+                if (ch <= 0x20 || ch == 0x7f) {\n+                    return NGX_ERROR;\n+                }\n+                break;\n             }\n             break;\n         }\nDiff:\n@@ -3457,7 +3457,7 @@ ngx_http_v2_validate_header(ngx_http_request_t *r, ngx_http_v2_header_t *header)\n             continue;\n         }\n \n-        if (ch == '\\0' || ch == LF || ch == CR || ch == ':'\n+        if (ch <= 0x20 || ch == 0x7f || ch == ':'\n             || (ch >= 'A' && ch <= 'Z'))\n         {\n             ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n"
    },
    {
        "commit_sha": "088e1573181e16912544b2bc10ef7da1061ccc63",
        "commit_index": "Commit 106",
        "commit_diff": "Diff:\n@@ -1186,7 +1186,7 @@ ngx_http_proxy_create_key(ngx_http_request_t *r)\n \n     loc_len = (r->valid_location && ctx->vars.uri.len) ? plcf->location.len : 0;\n \n-    if (r->quoted_uri || r->space_in_uri || r->internal) {\n+    if (r->quoted_uri || r->internal) {\n         escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len,\n                                     r->uri.len - loc_len, NGX_ESCAPE_URI);\n     } else {\n@@ -1299,7 +1299,7 @@ ngx_http_proxy_create_request(ngx_http_request_t *r)\n         loc_len = (r->valid_location && ctx->vars.uri.len) ?\n                       plcf->location.len : 0;\n \n-        if (r->quoted_uri || r->space_in_uri || r->internal) {\n+        if (r->quoted_uri || r->internal) {\n             escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len,\n                                         r->uri.len - loc_len, NGX_ESCAPE_URI);\n         }\nDiff:\n@@ -116,10 +116,8 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n         sw_host_end,\n         sw_host_ip_literal,\n         sw_port,\n-        sw_host_http_09,\n         sw_after_slash_in_uri,\n         sw_check_uri,\n-        sw_check_uri_http_09,\n         sw_uri,\n         sw_http_09,\n         sw_http_H,\n@@ -398,7 +396,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                  */\n                 r->uri_start = r->schema_end + 1;\n                 r->uri_end = r->schema_end + 2;\n-                state = sw_host_http_09;\n+                state = sw_http_09;\n                 break;\n             default:\n                 return NGX_HTTP_PARSE_INVALID_REQUEST;\n@@ -472,35 +470,13 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                  */\n                 r->uri_start = r->schema_end + 1;\n                 r->uri_end = r->schema_end + 2;\n-                state = sw_host_http_09;\n-                break;\n-            default:\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n-            }\n-            break;\n-\n-        /* space+ after \"http://host[:port] \" */\n-        case sw_host_http_09:\n-            switch (ch) {\n-            case ' ':\n-                break;\n-            case CR:\n-                r->http_minor = 9;\n-                state = sw_almost_done;\n-                break;\n-            case LF:\n-                r->http_minor = 9;\n-                goto done;\n-            case 'H':\n-                r->http_protocol.data = p;\n-                state = sw_http_H;\n+                state = sw_http_09;\n                 break;\n             default:\n                 return NGX_HTTP_PARSE_INVALID_REQUEST;\n             }\n             break;\n \n-\n         /* check \"/.\", \"//\", \"%\", and \"\\\" (Win32) in URI */\n         case sw_after_slash_in_uri:\n \n@@ -512,7 +488,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             switch (ch) {\n             case ' ':\n                 r->uri_end = p;\n-                state = sw_check_uri_http_09;\n+                state = sw_http_09;\n                 break;\n             case CR:\n                 r->uri_end = p;\n@@ -584,7 +560,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 break;\n             case ' ':\n                 r->uri_end = p;\n-                state = sw_check_uri_http_09;\n+                state = sw_http_09;\n                 break;\n             case CR:\n                 r->uri_end = p;\n@@ -621,31 +597,6 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             }\n             break;\n \n-        /* space+ after URI */\n-        case sw_check_uri_http_09:\n-            switch (ch) {\n-            case ' ':\n-                break;\n-            case CR:\n-                r->http_minor = 9;\n-                state = sw_almost_done;\n-                break;\n-            case LF:\n-                r->http_minor = 9;\n-                goto done;\n-            case 'H':\n-                r->http_protocol.data = p;\n-                state = sw_http_H;\n-                break;\n-            default:\n-                r->space_in_uri = 1;\n-                state = sw_check_uri;\n-                p--;\n-                break;\n-            }\n-            break;\n-\n-\n         /* URI */\n         case sw_uri:\n \n@@ -692,10 +643,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 state = sw_http_H;\n                 break;\n             default:\n-                r->space_in_uri = 1;\n-                state = sw_uri;\n-                p--;\n-                break;\n+                return NGX_HTTP_PARSE_INVALID_REQUEST;\n             }\n             break;\n \n@@ -1171,9 +1119,7 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n \n             switch (ch) {\n             case ' ':\n-                r->space_in_uri = 1;\n-                state = sw_check_uri;\n-                break;\n+                return NGX_ERROR;\n             case '.':\n                 r->complex_uri = 1;\n                 state = sw_uri;\n@@ -1232,8 +1178,7 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n                 r->uri_ext = p + 1;\n                 break;\n             case ' ':\n-                r->space_in_uri = 1;\n-                break;\n+                return NGX_ERROR;\n #if (NGX_WIN32)\n             case '\\\\':\n                 r->complex_uri = 1;\n@@ -1267,8 +1212,7 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n \n             switch (ch) {\n             case ' ':\n-                r->space_in_uri = 1;\n-                break;\n+                return NGX_ERROR;\n             case '#':\n                 r->complex_uri = 1;\n                 break;\nDiff:\n@@ -1279,7 +1279,7 @@ ngx_http_process_request_uri(ngx_http_request_t *r)\n     r->unparsed_uri.len = r->uri_end - r->uri_start;\n     r->unparsed_uri.data = r->uri_start;\n \n-    r->valid_unparsed_uri = (r->space_in_uri || r->empty_path_in_uri) ? 0 : 1;\n+    r->valid_unparsed_uri = r->empty_path_in_uri ? 0 : 1;\n \n     if (r->uri_ext) {\n         if (r->args_start) {\nDiff:\n@@ -477,9 +477,6 @@ struct ngx_http_request_s {\n     /* URI with \"+\" */\n     unsigned                          plus_in_uri:1;\n \n-    /* URI with \" \" */\n-    unsigned                          space_in_uri:1;\n-\n     /* URI with empty path */\n     unsigned                          empty_path_in_uri:1;\n \n"
    },
    {
        "commit_sha": "a9aaee9d2c151b52e4278e45e3de89345da81b7c",
        "commit_index": "Commit 105",
        "commit_diff": "Diff:\n@@ -1493,39 +1493,52 @@ ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n     uint32_t       *escape;\n     static u_char   hex[] = \"0123456789ABCDEF\";\n \n-                    /* \" \", \"#\", \"%\", \"?\", %00-%1F, %7F-%FF */\n+    /*\n+     * Per RFC 3986 only the following chars are allowed in URIs unescaped:\n+     *\n+     * unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+     * gen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n+     * sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+     *               / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+     *\n+     * And \"%\" can appear as a part of escaping itself.  The following\n+     * characters are not allowed and need to be escaped: %00-%1F, %7F-%FF,\n+     * \" \", \"\"\", \"<\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", \"}\".\n+     */\n+\n+                    /* \" \", \"#\", \"%\", \"?\", not allowed */\n \n     static uint32_t   uri[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x80000029, /* 1000 0000 0000 0000  0000 0000 0010 1001 */\n+        0xd000002d, /* 1101 0000 0000 0000  0000 0000 0010 1101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"#\", \"%\", \"&\", \"+\", \"?\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"#\", \"%\", \"&\", \"+\", \";\", \"?\", not allowed */\n \n     static uint32_t   args[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x88000869, /* 1000 1000 0000 0000  0000 1000 0110 1001 */\n+        0xd800086d, /* 1101 1000 0000 0000  0000 1000 0110 1101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n@@ -1553,39 +1566,39 @@ ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"#\", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"#\", \"\"\", \"%\", \"'\", not allowed */\n \n     static uint32_t   html[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x000000ad, /* 0000 0000 0000 0000  0000 0000 1010 1101 */\n+        0x500000ad, /* 0101 0000 0000 0000  0000 0000 1010 1101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"\"\", \"'\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"\"\", \"'\", not allowed */\n \n     static uint32_t   refresh[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x00000085, /* 0000 0000 0000 0000  0000 0000 1000 0101 */\n+        0x50000085, /* 0101 0000 0000 0000  0000 0000 1000 0101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xd8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\nDiff:\n@@ -246,6 +246,11 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                         r->method = NGX_HTTP_OPTIONS;\n                     }\n \n+                    if (ngx_str7_cmp(m, 'C', 'O', 'N', 'N', 'E', 'C', 'T', ' '))\n+                    {\n+                        r->method = NGX_HTTP_CONNECT;\n+                    }\n+\n                     break;\n \n                 case 8:\nDiff:\n@@ -2004,8 +2004,15 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n             && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                                (u_char *) \"chunked\", 7) == 0)\n         {\n-            r->headers_in.content_length = NULL;\n-            r->headers_in.content_length_n = -1;\n+            if (r->headers_in.content_length) {\n+                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                              \"client sent \\\"Content-Length\\\" and \"\n+                              \"\\\"Transfer-Encoding\\\" headers \"\n+                              \"at the same time\");\n+                ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+                return NGX_ERROR;\n+            }\n+\n             r->headers_in.chunked = 1;\n \n         } else {\n@@ -2025,6 +2032,13 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n         }\n     }\n \n+    if (r->method == NGX_HTTP_CONNECT) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent CONNECT method\");\n+        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+        return NGX_ERROR;\n+    }\n+\n     if (r->method == NGX_HTTP_TRACE) {\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                       \"client sent TRACE method\");\nDiff:\n@@ -25,22 +25,23 @@\n #define NGX_HTTP_VERSION_11                1001\n #define NGX_HTTP_VERSION_20                2000\n \n-#define NGX_HTTP_UNKNOWN                   0x0001\n-#define NGX_HTTP_GET                       0x0002\n-#define NGX_HTTP_HEAD                      0x0004\n-#define NGX_HTTP_POST                      0x0008\n-#define NGX_HTTP_PUT                       0x0010\n-#define NGX_HTTP_DELETE                    0x0020\n-#define NGX_HTTP_MKCOL                     0x0040\n-#define NGX_HTTP_COPY                      0x0080\n-#define NGX_HTTP_MOVE                      0x0100\n-#define NGX_HTTP_OPTIONS                   0x0200\n-#define NGX_HTTP_PROPFIND                  0x0400\n-#define NGX_HTTP_PROPPATCH                 0x0800\n-#define NGX_HTTP_LOCK                      0x1000\n-#define NGX_HTTP_UNLOCK                    0x2000\n-#define NGX_HTTP_PATCH                     0x4000\n-#define NGX_HTTP_TRACE                     0x8000\n+#define NGX_HTTP_UNKNOWN                   0x00000001\n+#define NGX_HTTP_GET                       0x00000002\n+#define NGX_HTTP_HEAD                      0x00000004\n+#define NGX_HTTP_POST                      0x00000008\n+#define NGX_HTTP_PUT                       0x00000010\n+#define NGX_HTTP_DELETE                    0x00000020\n+#define NGX_HTTP_MKCOL                     0x00000040\n+#define NGX_HTTP_COPY                      0x00000080\n+#define NGX_HTTP_MOVE                      0x00000100\n+#define NGX_HTTP_OPTIONS                   0x00000200\n+#define NGX_HTTP_PROPFIND                  0x00000400\n+#define NGX_HTTP_PROPPATCH                 0x00000800\n+#define NGX_HTTP_LOCK                      0x00001000\n+#define NGX_HTTP_UNLOCK                    0x00002000\n+#define NGX_HTTP_PATCH                     0x00004000\n+#define NGX_HTTP_TRACE                     0x00008000\n+#define NGX_HTTP_CONNECT                   0x00010000\n \n #define NGX_HTTP_CONNECTION_CLOSE          1\n #define NGX_HTTP_CONNECTION_KEEP_ALIVE     2\nDiff:\n@@ -3606,7 +3606,8 @@ ngx_http_v2_parse_method(ngx_http_request_t *r, ngx_str_t *value)\n         { 4, \"LOCK\",      NGX_HTTP_LOCK },\n         { 6, \"UNLOCK\",    NGX_HTTP_UNLOCK },\n         { 5, \"PATCH\",     NGX_HTTP_PATCH },\n-        { 5, \"TRACE\",     NGX_HTTP_TRACE }\n+        { 5, \"TRACE\",     NGX_HTTP_TRACE },\n+        { 7, \"CONNECT\",   NGX_HTTP_CONNECT }\n     }, *test;\n \n     if (r->method_name.len) {\n"
    },
    {
        "commit_sha": "40aa805d30a36109be61148e7ec989861cde65de",
        "commit_index": "Commit 104",
        "commit_diff": "Diff:\n@@ -47,6 +47,9 @@ struct ngx_rbtree_s {\n     (tree)->sentinel = s;                                                     \\\n     (tree)->insert = i\n \n+#define ngx_rbtree_data(node, type, link)                                     \\\n+    (type *) ((u_char *) (node) - offsetof(type, link))\n+\n \n void ngx_rbtree_insert(ngx_rbtree_t *tree, ngx_rbtree_node_t *node);\n void ngx_rbtree_delete(ngx_rbtree_t *tree, ngx_rbtree_node_t *node);\nDiff:\n@@ -51,9 +51,7 @@ typedef struct {\n } ngx_resolver_an_t;\n \n \n-#define ngx_resolver_node(n)                                                 \\\n-    (ngx_resolver_node_t *)                                                  \\\n-        ((u_char *) (n) - offsetof(ngx_resolver_node_t, node))\n+#define ngx_resolver_node(n)  ngx_rbtree_data(n, ngx_resolver_node_t, node)\n \n \n static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec);\nDiff:\n@@ -73,7 +73,7 @@ ngx_event_expire_timers(void)\n             return;\n         }\n \n-        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));\n+        ev = ngx_rbtree_data(node, ngx_event_t, timer);\n \n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,\n                        \"event timer del: %d: %M\",\n@@ -113,7 +113,7 @@ ngx_event_no_timers_left(void)\n          node;\n          node = ngx_rbtree_next(&ngx_event_timer_rbtree, node))\n     {\n-        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));\n+        ev = ngx_rbtree_data(node, ngx_event_t, timer);\n \n         if (!ev->cancelable) {\n             return NGX_AGAIN;\nDiff:\n@@ -1999,13 +1999,6 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n         }\n     }\n \n-    if (r->method == NGX_HTTP_TRACE) {\n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n-                      \"client sent TRACE method\");\n-        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n-        return NGX_ERROR;\n-    }\n-\n     if (r->headers_in.transfer_encoding) {\n         if (r->headers_in.transfer_encoding->value.len == 7\n             && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n@@ -2032,6 +2025,13 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n         }\n     }\n \n+    if (r->method == NGX_HTTP_TRACE) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent TRACE method\");\n+        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \n"
    },
    {
        "commit_sha": "6046005076be24f36e26da26938bf8ca29d3c690",
        "commit_index": "Commit 103",
        "commit_diff": "Diff:\n@@ -3008,6 +3008,12 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n done:\n \n+    if (c->ssl->shutdown_without_free) {\n+        c->ssl->shutdown_without_free = 0;\n+        c->recv = ngx_recv;\n+        return rc;\n+    }\n+\n     SSL_free(c->ssl->connection);\n     c->ssl = NULL;\n     c->recv = ngx_recv;\nDiff:\n@@ -100,6 +100,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    buffer:1;\n     unsigned                    no_wait_shutdown:1;\n     unsigned                    no_send_shutdown:1;\n+    unsigned                    shutdown_without_free:1;\n     unsigned                    handshake_buffer_set:1;\n     unsigned                    try_early_data:1;\n     unsigned                    in_early:1;\nDiff:\n@@ -121,6 +121,7 @@ typedef struct {\n     unsigned                   done:1;\n     unsigned                   status:1;\n     unsigned                   rst:1;\n+    unsigned                   goaway:1;\n \n     ngx_http_request_t        *request;\n \n@@ -1210,6 +1211,7 @@ ngx_http_grpc_reinit_request(ngx_http_request_t *r)\n     ctx->done = 0;\n     ctx->status = 0;\n     ctx->rst = 0;\n+    ctx->goaway = 0;\n     ctx->connection = NULL;\n \n     return NGX_OK;\n@@ -1565,6 +1567,7 @@ ngx_http_grpc_body_output_filter(void *data, ngx_chain_t *in)\n             && ctx->out == NULL\n             && ctx->output_closed\n             && !ctx->output_blocked\n+            && !ctx->goaway\n             && ctx->state == ngx_http_grpc_st_start)\n         {\n             u->keepalive = 1;\n@@ -1714,6 +1717,8 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n                 return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n             }\n \n+            ctx->goaway = 1;\n+\n             continue;\n         }\n \n@@ -1907,6 +1912,7 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n                         && ctx->out == NULL\n                         && ctx->output_closed\n                         && !ctx->output_blocked\n+                        && !ctx->goaway\n                         && b->last == b->pos)\n                     {\n                         u->keepalive = 1;\n@@ -2035,6 +2041,7 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                     if (ctx->in == NULL\n                         && ctx->output_closed\n                         && !ctx->output_blocked\n+                        && !ctx->goaway\n                         && ctx->state == ngx_http_grpc_st_start)\n                     {\n                         u->keepalive = 1;\n@@ -2170,6 +2177,8 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n             }\n \n             ctx->rst = 1;\n+\n+            continue;\n         }\n \n         if (ctx->type == NGX_HTTP_V2_GOAWAY_FRAME) {\n@@ -2204,6 +2213,8 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                 return NGX_ERROR;\n             }\n \n+            ctx->goaway = 1;\n+\n             continue;\n         }\n \n@@ -3475,6 +3486,8 @@ ngx_http_grpc_parse_rst_stream(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n         return NGX_AGAIN;\n     }\n \n+    ctx->state = ngx_http_grpc_st_start;\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -3419,6 +3419,8 @@ ngx_http_set_lingering_close(ngx_connection_t *c)\n     if (c->ssl) {\n         ngx_int_t  rc;\n \n+        c->ssl->shutdown_without_free = 1;\n+\n         rc = ngx_ssl_shutdown(c);\n \n         if (rc == NGX_ERROR) {\nDiff:\n@@ -295,7 +295,7 @@ ngx_os_status(ngx_log_t *log)\n         osviex_stub = (ngx_osviex_stub_t *) &osvi.wServicePackMinor;\n \n         ngx_log_error(NGX_LOG_INFO, log, 0,\n-                      \"OS: %ud build:%ud, \\\"%s\\\", suite:%Xd, type:%ud\",\n+                      \"OS: %ui build:%ud, \\\"%s\\\", suite:%Xd, type:%ud\",\n                       ngx_win32_version, osvi.dwBuildNumber, osvi.szCSDVersion,\n                       osviex_stub->wSuiteMask, osviex_stub->wProductType);\n \n@@ -305,7 +305,7 @@ ngx_os_status(ngx_log_t *log)\n             /* Win9x build */\n \n             ngx_log_error(NGX_LOG_INFO, log, 0,\n-                          \"OS: %u build:%ud.%ud.%ud, \\\"%s\\\"\",\n+                          \"OS: %ui build:%ud.%ud.%ud, \\\"%s\\\"\",\n                           ngx_win32_version,\n                           osvi.dwBuildNumber >> 24,\n                           (osvi.dwBuildNumber >> 16) & 0xff,\n@@ -321,7 +321,7 @@ ngx_os_status(ngx_log_t *log)\n              * and we do not support VER_PLATFORM_WIN32s at all\n              */\n \n-            ngx_log_error(NGX_LOG_INFO, log, 0, \"OS: %ud build:%ud, \\\"%s\\\"\",\n+            ngx_log_error(NGX_LOG_INFO, log, 0, \"OS: %ui build:%ud, \\\"%s\\\"\",\n                           ngx_win32_version, osvi.dwBuildNumber,\n                           osvi.szCSDVersion);\n         }\n"
    },
    {
        "commit_sha": "b6c0a37554e300aa230ea2b8d7fe53dd8604f602",
        "commit_index": "Commit 102",
        "commit_diff": "Diff:\n@@ -152,6 +152,7 @@ syn keyword ngxDirective contained auth_jwt_header_set\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n+syn keyword ngxDirective contained auth_jwt_type\n syn keyword ngxDirective contained auth_request\n syn keyword ngxDirective contained auth_request_set\n syn keyword ngxDirective contained autoindex\n@@ -332,16 +333,20 @@ syn keyword ngxDirective contained index\n syn keyword ngxDirective contained iocp_threads\n syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n+syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n syn keyword ngxDirective contained js_filter\n+syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n syn keyword ngxDirective contained js_set\n+syn keyword ngxDirective contained js_var\n syn keyword ngxDirective contained keepalive\n syn keyword ngxDirective contained keepalive_disable\n syn keyword ngxDirective contained keepalive_requests\n+syn keyword ngxDirective contained keepalive_time\n syn keyword ngxDirective contained keepalive_timeout\n syn keyword ngxDirective contained keyval\n syn keyword ngxDirective contained keyval_zone\n@@ -373,6 +378,7 @@ syn keyword ngxDirective contained log_subrequest\n syn keyword ngxDirective contained map_hash_bucket_size\n syn keyword ngxDirective contained map_hash_max_size\n syn keyword ngxDirective contained master_process\n+syn keyword ngxDirective contained max_errors\n syn keyword ngxDirective contained max_ranges\n syn keyword ngxDirective contained memcached_bind\n syn keyword ngxDirective contained memcached_buffer_size\n@@ -1080,6 +1086,8 @@ syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_mess\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n+syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info\n+syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info_string\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_last_message_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_location\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_message_id_custom_etag_header\n@@ -2368,9 +2376,9 @@ syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n \" IP2Location Nginx\n \" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+syn keyword ngxDirectiveThirdParty contained ip2location_addresstype\n syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n+syn keyword ngxDirectiveThirdParty contained ip2location_category\n syn keyword ngxDirectiveThirdParty contained ip2location_city\n syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n@@ -2384,6 +2392,8 @@ syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2location_region\n syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n@@ -2403,6 +2413,7 @@ syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_provider\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\nDiff:\n@@ -2896,9 +2896,12 @@ ngx_int_t\n ngx_ssl_shutdown(ngx_connection_t *c)\n {\n     int         n, sslerr, mode;\n+    ngx_int_t   rc;\n     ngx_err_t   err;\n     ngx_uint_t  tries;\n \n+    rc = NGX_OK;\n+\n     ngx_ssl_ocsp_cleanup(c);\n \n     if (SSL_in_init(c->ssl->connection)) {\n@@ -2908,11 +2911,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n          * Avoid calling SSL_shutdown() if handshake wasn't completed.\n          */\n \n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n-        c->recv = ngx_recv;\n-\n-        return NGX_OK;\n+        goto done;\n     }\n \n     if (c->timedout || c->error || c->buffered) {\n@@ -2954,11 +2953,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n \n         if (n == 1) {\n-            SSL_free(c->ssl->connection);\n-            c->ssl = NULL;\n-            c->recv = ngx_recv;\n-\n-            return NGX_OK;\n+            goto done;\n         }\n \n         if (n == 0 && tries-- > 1) {\n@@ -2984,11 +2979,11 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n             }\n \n             if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             ngx_add_timer(c->read, 3000);\n@@ -2997,23 +2992,27 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         }\n \n         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n-            SSL_free(c->ssl->connection);\n-            c->ssl = NULL;\n-            c->recv = ngx_recv;\n-\n-            return NGX_OK;\n+            goto done;\n         }\n \n         err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n         ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n \n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n-        c->recv = ngx_recv;\n-\n-        return NGX_ERROR;\n+        break;\n     }\n+\n+failed:\n+\n+    rc = NGX_ERROR;\n+\n+done:\n+\n+    SSL_free(c->ssl->connection);\n+    c->ssl = NULL;\n+    c->recv = ngx_recv;\n+\n+    return rc;\n }\n \n \nDiff:\n@@ -28,6 +28,7 @@ static ngx_int_t ngx_mail_smtp_starttls(ngx_mail_session_t *s,\n     ngx_connection_t *c);\n static ngx_int_t ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c);\n \n static ngx_int_t ngx_mail_smtp_discard_command(ngx_mail_session_t *s,\n     ngx_connection_t *c, char *err);\n@@ -36,6 +37,7 @@ static void ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s,\n \n \n static u_char  smtp_ok[] = \"250 2.0.0 OK\" CRLF;\n+static u_char  smtp_noop[] = \"255 2.0.0 OK\" CRLF;\n static u_char  smtp_bye[] = \"221 2.0.0 Bye\" CRLF;\n static u_char  smtp_starttls[] = \"220 2.0.0 Start TLS\" CRLF;\n static u_char  smtp_next[] = \"334 \" CRLF;\n@@ -511,6 +513,7 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n                 break;\n \n             case NGX_SMTP_NOOP:\n+                rc = ngx_mail_smtp_noop(s, c);\n                 break;\n \n             case NGX_SMTP_STARTTLS:\n@@ -825,6 +828,20 @@ ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)\n }\n \n \n+static ngx_int_t\n+ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    if (s->args.nelts > 10) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        ngx_mail_close_connection(c);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_str_set(&s->out, smtp_noop);\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n"
    },
    {
        "commit_sha": "b6674d1e46c661049e07fcc14cdfa2c6d7ace516",
        "commit_index": "Commit 101",
        "commit_diff": "Diff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021000\n-#define NGINX_VERSION      \"1.21.0\"\n+#define nginx_version      1021001\n+#define NGINX_VERSION      \"1.21.1\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -495,21 +495,24 @@ ngx_open_listening_sockets(ngx_cycle_t *cycle)\n                 return NGX_ERROR;\n             }\n \n-            if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n-                           (const void *) &reuseaddr, sizeof(int))\n-                == -1)\n-            {\n-                ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n-                              \"setsockopt(SO_REUSEADDR) %V failed\",\n-                              &ls[i].addr_text);\n+            if (ls[i].type != SOCK_DGRAM || !ngx_test_config) {\n \n-                if (ngx_close_socket(s) == -1) {\n+                if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n+                               (const void *) &reuseaddr, sizeof(int))\n+                    == -1)\n+                {\n                     ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n-                                  ngx_close_socket_n \" %V failed\",\n+                                  \"setsockopt(SO_REUSEADDR) %V failed\",\n                                   &ls[i].addr_text);\n-                }\n \n-                return NGX_ERROR;\n+                    if (ngx_close_socket(s) == -1) {\n+                        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                      ngx_close_socket_n \" %V failed\",\n+                                      &ls[i].addr_text);\n+                    }\n+\n+                    return NGX_ERROR;\n+                }\n             }\n \n #if (NGX_HAVE_REUSEPORT)\nDiff:\n@@ -441,20 +441,23 @@ ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)\n \n #if (NGX_HAVE_REUSEPORT)\n \n-    ls = cycle->listening.elts;\n-    for (i = 0; i < cycle->listening.nelts; i++) {\n+    if (!ngx_test_config) {\n \n-        if (!ls[i].reuseport || ls[i].worker != 0) {\n-            continue;\n-        }\n+        ls = cycle->listening.elts;\n+        for (i = 0; i < cycle->listening.nelts; i++) {\n \n-        if (ngx_clone_listening(cycle, &ls[i]) != NGX_OK) {\n-            return NGX_CONF_ERROR;\n-        }\n+            if (!ls[i].reuseport || ls[i].worker != 0) {\n+                continue;\n+            }\n \n-        /* cloning may change cycle->listening.elts */\n+            if (ngx_clone_listening(cycle, &ls[i]) != NGX_OK) {\n+                return NGX_CONF_ERROR;\n+            }\n \n-        ls = cycle->listening.elts;\n+            /* cloning may change cycle->listening.elts */\n+\n+            ls = cycle->listening.elts;\n+        }\n     }\n \n #endif\n"
    },
    {
        "commit_sha": "745e82984182c30a3a6a8ec930ed2139bedadfb2",
        "commit_index": "Commit 100",
        "commit_diff": "Diff:\n@@ -460,3 +460,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n+df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\nDiff:\n@@ -5,6 +5,100 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.0\" date=\"2021-05-25\">\n+\n+<change type=\"security\">\n+<para lang=\"ru\">\n+при использовании директивы resolver\n+во время обработки ответа DNS-сервера\n+могла происходить перезапись одного байта памяти,\n+что позволяло атакующему,\n+имеющему возможность подделывать UDP-пакеты от DNS-сервера,\n+вызвать падение рабочего процесса\n+или, потенциально, выполнение произвольного кода (CVE-2021-23017).\n+</para>\n+<para lang=\"en\">\n+1-byte memory overwrite might occur\n+during DNS server response processing\n+if the \"resolver\" directive was used,\n+allowing an attacker\n+who is able to forge UDP packets from the DNS server\n+to cause worker process crash\n+or, potentially, arbitrary code execution (CVE-2021-23017).\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директивы proxy_ssl_certificate, proxy_ssl_certificate_key,\n+grpc_ssl_certificate, grpc_ssl_certificate_key,\n+uwsgi_ssl_certificate и uwsgi_ssl_certificate_key\n+поддерживают переменные.\n+</para>\n+<para lang=\"en\">\n+variables support\n+in the \"proxy_ssl_certificate\", \"proxy_ssl_certificate_key\"\n+\"grpc_ssl_certificate\", \"grpc_ssl_certificate_key\",\n+\"uwsgi_ssl_certificate\", and \"uwsgi_ssl_certificate_key\" directives.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива max_errors в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+the \"max_errors\" directive in the mail proxy module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+почтовый прокси-сервер поддерживает POP3 и IMAP pipelining.\n+</para>\n+<para lang=\"en\">\n+the mail proxy module supports POP3 and IMAP pipelining.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+параметр fastopen директивы listen в модуле stream.<br/>\n+Спасибо Anbang Wen.\n+</para>\n+<para lang=\"en\">\n+the \"fastopen\" parameter of the \"listen\" directive in the stream module.<br/>\n+Thanks to Anbang Wen.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+специальные символы не экранировались\n+при автоматическом перенаправлении с добавлением завершающего слэша.\n+</para>\n+<para lang=\"en\">\n+special characters were not escaped\n+during automatic redirect with appended trailing slash.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании SMTP pipelining\n+соединения с клиентами в почтовом прокси-сервере\n+могли неожиданно закрываться.\n+</para>\n+<para lang=\"en\">\n+connections with clients in the mail proxy module\n+might be closed unexpectedly\n+when using SMTP pipelining.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.10\" date=\"2021-04-13\">\n \n <change type=\"change\">\nDiff:\n@@ -1798,6 +1798,12 @@ ngx_resolver_process_response(ngx_resolver_t *r, u_char *buf, size_t n,\n     i = sizeof(ngx_resolver_hdr_t);\n \n     while (i < (ngx_uint_t) n) {\n+\n+        if (buf[i] & 0xc0) {\n+            err = \"unexpected compression pointer in DNS response\";\n+            goto done;\n+        }\n+\n         if (buf[i] == '\\0') {\n             goto found;\n         }\n"
    },
    {
        "commit_sha": "38aec593a0ba2b15ff223c02c49ea469926d07a6",
        "commit_index": "Commit 99",
        "commit_diff": "Diff:\n@@ -3939,11 +3939,11 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n {\n     char        *err;\n     u_char      *p, *dst;\n-    ssize_t      len;\n+    size_t       len;\n     ngx_uint_t   i, n;\n \n     p = src;\n-    len = -1;\n+    len = 0;\n \n     /*\n      * compression pointers allow to create endless loop, so we set limit;\n@@ -3958,6 +3958,16 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         }\n \n         if (n & 0xc0) {\n+            if ((n & 0xc0) != 0xc0) {\n+                err = \"invalid label type in DNS response\";\n+                goto invalid;\n+            }\n+\n+            if (p >= last) {\n+                err = \"name is out of DNS response\";\n+                goto invalid;\n+            }\n+\n             n = ((n & 0x3f) << 8) + *p;\n             p = &buf[n];\n \n@@ -3986,7 +3996,7 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         return NGX_OK;\n     }\n \n-    if (len == -1) {\n+    if (len == 0) {\n         ngx_str_null(name);\n         return NGX_OK;\n     }\n@@ -3998,30 +4008,23 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n \n     name->data = dst;\n \n-    n = *src++;\n-\n     for ( ;; ) {\n+        n = *src++;\n+\n+        if (n == 0) {\n+            name->len = dst - name->data - 1;\n+            return NGX_OK;\n+        }\n+\n         if (n & 0xc0) {\n             n = ((n & 0x3f) << 8) + *src;\n             src = &buf[n];\n \n-            n = *src++;\n-\n         } else {\n             ngx_strlow(dst, src, n);\n             dst += n;\n             src += n;\n-\n-            n = *src++;\n-\n-            if (n != 0) {\n-                *dst++ = '.';\n-            }\n-        }\n-\n-        if (n == 0) {\n-            name->len = dst - name->data;\n-            return NGX_OK;\n+            *dst++ = '.';\n         }\n     }\n }\nDiff:\n@@ -1072,14 +1072,37 @@ ngx_http_dav_error(ngx_log_t *log, ngx_err_t err, ngx_int_t not_found,\n static ngx_int_t\n ngx_http_dav_location(ngx_http_request_t *r)\n {\n+    u_char     *p;\n+    size_t      len;\n+    uintptr_t   escape;\n+\n     r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n     if (r->headers_out.location == NULL) {\n         return NGX_ERROR;\n     }\n \n     r->headers_out.location->hash = 1;\n     ngx_str_set(&r->headers_out.location->key, \"Location\");\n-    r->headers_out.location->value = r->uri;\n+\n+    escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n+\n+    if (escape) {\n+        len = r->uri.len + escape;\n+\n+        p = ngx_pnalloc(r->pool, len);\n+        if (p == NULL) {\n+            ngx_http_clear_location(r);\n+            return NGX_ERROR;\n+        }\n+\n+        r->headers_out.location->value.len = len;\n+        r->headers_out.location->value.data = p;\n+\n+        ngx_escape_uri(p, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n+\n+    } else {\n+        r->headers_out.location->value = r->uri;\n+    }\n \n     return NGX_OK;\n }\nDiff:\n@@ -50,6 +50,7 @@ ngx_http_static_handler(ngx_http_request_t *r)\n {\n     u_char                    *last, *location;\n     size_t                     root, len;\n+    uintptr_t                  escape;\n     ngx_str_t                  path;\n     ngx_int_t                  rc;\n     ngx_uint_t                 level;\n@@ -155,14 +156,18 @@ ngx_http_static_handler(ngx_http_request_t *r)\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n-        len = r->uri.len + 1;\n+        escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len,\n+                                    NGX_ESCAPE_URI);\n \n-        if (!clcf->alias && r->args.len == 0) {\n+        if (!clcf->alias && r->args.len == 0 && escape == 0) {\n+            len = r->uri.len + 1;\n             location = path.data + root;\n \n             *last = '/';\n \n         } else {\n+            len = r->uri.len + escape + 1;\n+\n             if (r->args.len) {\n                 len += r->args.len + 1;\n             }\n@@ -173,7 +178,13 @@ ngx_http_static_handler(ngx_http_request_t *r)\n                 return NGX_HTTP_INTERNAL_SERVER_ERROR;\n             }\n \n-            last = ngx_copy(location, r->uri.data, r->uri.len);\n+            if (escape) {\n+                last = (u_char *) ngx_escape_uri(location, r->uri.data,\n+                                                 r->uri.len, NGX_ESCAPE_URI);\n+\n+            } else {\n+                last = ngx_copy(location, r->uri.data, r->uri.len);\n+            }\n \n             *last = '/';\n \nDiff:\n@@ -37,6 +37,8 @@ static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf,\n     ngx_http_core_srv_conf_t *cscf, ngx_http_core_loc_conf_t *pclcf);\n static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf,\n     ngx_http_core_loc_conf_t *pclcf);\n+static ngx_int_t ngx_http_escape_location_name(ngx_conf_t *cf,\n+    ngx_http_core_loc_conf_t *clcf);\n static ngx_int_t ngx_http_cmp_locations(const ngx_queue_t *one,\n     const ngx_queue_t *two);\n static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf,\n@@ -882,6 +884,41 @@ ngx_http_add_location(ngx_conf_t *cf, ngx_queue_t **locations,\n \n     ngx_queue_insert_tail(*locations, &lq->queue);\n \n+    if (ngx_http_escape_location_name(cf, clcf) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_escape_location_name(ngx_conf_t *cf, ngx_http_core_loc_conf_t *clcf)\n+{\n+    u_char     *p;\n+    size_t      len;\n+    uintptr_t   escape;\n+\n+    escape = 2 * ngx_escape_uri(NULL, clcf->name.data, clcf->name.len,\n+                                NGX_ESCAPE_URI);\n+\n+    if (escape) {\n+        len = clcf->name.len + escape;\n+\n+        p = ngx_pnalloc(cf->pool, len);\n+        if (p == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        clcf->escaped_name.len = len;\n+        clcf->escaped_name.data = p;\n+\n+        ngx_escape_uri(p, clcf->name.data, clcf->name.len, NGX_ESCAPE_URI);\n+\n+    } else {\n+        clcf->escaped_name = clcf->name;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -1010,10 +1010,10 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n \n         if (r->args.len == 0) {\n-            r->headers_out.location->value = clcf->name;\n+            r->headers_out.location->value = clcf->escaped_name;\n \n         } else {\n-            len = clcf->name.len + 1 + r->args.len;\n+            len = clcf->escaped_name.len + 1 + r->args.len;\n             p = ngx_pnalloc(r->pool, len);\n \n             if (p == NULL) {\n@@ -1025,7 +1025,7 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,\n             r->headers_out.location->value.len = len;\n             r->headers_out.location->value.data = p;\n \n-            p = ngx_cpymem(p, clcf->name.data, clcf->name.len);\n+            p = ngx_cpymem(p, clcf->escaped_name.data, clcf->escaped_name.len);\n             *p++ = '?';\n             ngx_memcpy(p, r->args.data, r->args.len);\n         }\n@@ -3467,6 +3467,7 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     /*\n      * set by ngx_pcalloc():\n      *\n+     *     clcf->escaped_name = { 0, NULL };\n      *     clcf->root = { 0, NULL };\n      *     clcf->limit_except = 0;\n      *     clcf->post_action = { 0, NULL };\nDiff:\n@@ -302,6 +302,7 @@ typedef struct {\n \n struct ngx_http_core_loc_conf_s {\n     ngx_str_t     name;          /* location name */\n+    ngx_str_t     escaped_name;\n \n #if (NGX_PCRE)\n     ngx_http_regex_t  *regex;\n"
    },
    {
        "commit_sha": "b0826bb59e6d7d89c7e63f35290e5f6ff03bed31",
        "commit_index": "Commit 98",
        "commit_diff": "Diff:\n@@ -1057,12 +1057,14 @@ ngx_http_ssl_certificate(ngx_ssl_conn_t *ssl_conn, void *arg)\n     }\n \n     ngx_http_free_request(r, 0);\n+    c->log->action = \"SSL handshaking\";\n     c->destroyed = 0;\n     return 1;\n \n failed:\n \n     ngx_http_free_request(r, 0);\n+    c->log->action = \"SSL handshaking\";\n     c->destroyed = 0;\n     return 0;\n }\nDiff:\n@@ -510,6 +510,10 @@ ngx_stream_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports)\n             ls->ipv6only = addr[i].opt.ipv6only;\n #endif\n \n+#if (NGX_HAVE_TCP_FASTOPEN)\n+            ls->fastopen = addr[i].opt.fastopen;\n+#endif\n+\n #if (NGX_HAVE_REUSEPORT)\n             ls->reuseport = addr[i].opt.reuseport;\n #endif\nDiff:\n@@ -65,6 +65,9 @@ typedef struct {\n     int                            backlog;\n     int                            rcvbuf;\n     int                            sndbuf;\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+    int                            fastopen;\n+#endif\n     int                            type;\n } ngx_stream_listen_t;\n \nDiff:\n@@ -615,6 +615,10 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ls->type = SOCK_STREAM;\n     ls->ctx = cf->ctx;\n \n+#if (NGX_HAVE_TCP_FASTOPEN)\n+    ls->fastopen = -1;\n+#endif\n+\n #if (NGX_HAVE_INET6)\n     ls->ipv6only = 1;\n #endif\n@@ -635,6 +639,21 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n             continue;\n         }\n \n+#if (NGX_HAVE_TCP_FASTOPEN)\n+        if (ngx_strncmp(value[i].data, \"fastopen=\", 9) == 0) {\n+            ls->fastopen = ngx_atoi(value[i].data + 9, value[i].len - 9);\n+            ls->bind = 1;\n+\n+            if (ls->fastopen == NGX_ERROR) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid fastopen \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            continue;\n+        }\n+#endif\n+\n         if (ngx_strncmp(value[i].data, \"backlog=\", 8) == 0) {\n             ls->backlog = ngx_atoi(value[i].data + 8, value[i].len - 8);\n             ls->bind = 1;\n@@ -859,6 +878,12 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         if (ls->proxy_protocol) {\n             return \"\\\"proxy_protocol\\\" parameter is incompatible with \\\"udp\\\"\";\n         }\n+\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+        if (ls->fastopen != -1) {\n+            return \"\\\"fastopen\\\" parameter is incompatible with \\\"udp\\\"\";\n+        }\n+#endif\n     }\n \n     als = cmcf->listen.elts;\n"
    },
    {
        "commit_sha": "768cd25c7673297c04a370d15e9de3bed3a40216",
        "commit_index": "Commit 97",
        "commit_diff": "Diff:\n@@ -1573,7 +1573,7 @@ ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"\"\", \"'\", %00-%1F, %7F-%FF */\n \n     static uint32_t   refresh[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\nDiff:\n@@ -115,6 +115,8 @@ typedef struct {\n     ngx_msec_t              timeout;\n     ngx_msec_t              resolver_timeout;\n \n+    ngx_uint_t              max_errors;\n+\n     ngx_str_t               server_name;\n \n     u_char                 *file_name;\n@@ -231,6 +233,7 @@ typedef struct {\n     ngx_uint_t              command;\n     ngx_array_t             args;\n \n+    ngx_uint_t              errors;\n     ngx_uint_t              login_attempt;\n \n     /* used to parse POP3/IMAP/SMTP command */\nDiff:\n@@ -85,6 +85,13 @@ static ngx_command_t  ngx_mail_core_commands[] = {\n       offsetof(ngx_mail_core_srv_conf_t, resolver_timeout),\n       NULL },\n \n+    { ngx_string(\"max_errors\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_num_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_core_srv_conf_t, max_errors),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -163,6 +170,8 @@ ngx_mail_core_create_srv_conf(ngx_conf_t *cf)\n     cscf->timeout = NGX_CONF_UNSET_MSEC;\n     cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;\n \n+    cscf->max_errors = NGX_CONF_UNSET_UINT;\n+\n     cscf->resolver = NGX_CONF_UNSET_PTR;\n \n     cscf->file_name = cf->conf_file->file.name.data;\n@@ -182,6 +191,7 @@ ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n                               30000);\n \n+    ngx_conf_merge_uint_value(conf->max_errors, prev->max_errors, 5);\n \n     ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n \nDiff:\n@@ -874,7 +874,20 @@ ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n         return NGX_MAIL_PARSE_INVALID_COMMAND;\n     }\n \n-    if (rc == NGX_IMAP_NEXT || rc == NGX_MAIL_PARSE_INVALID_COMMAND) {\n+    if (rc == NGX_MAIL_PARSE_INVALID_COMMAND) {\n+\n+        s->errors++;\n+\n+        if (s->errors >= cscf->max_errors) {\n+            ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                          \"client sent too many invalid commands\");\n+            s->quit = 1;\n+        }\n+\n+        return rc;\n+    }\n+\n+    if (rc == NGX_IMAP_NEXT) {\n         return rc;\n     }\n \n"
    },
    {
        "commit_sha": "e1da82ff2295f28b074e29a7c683b0a3fa01e4de",
        "commit_index": "Commit 96",
        "commit_diff": "Diff:\n@@ -236,6 +236,7 @@ typedef struct {\n     /* used to parse POP3/IMAP/SMTP command */\n \n     ngx_uint_t              state;\n+    u_char                 *tag_start;\n     u_char                 *cmd_start;\n     u_char                 *arg_start;\n     ngx_uint_t              literal_len;\nDiff:\n@@ -226,6 +226,10 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n         ngx_str_set(&s->out, imap_next);\n     }\n \n+    if (s->buffer->pos < s->buffer->last) {\n+        s->blocked = 1;\n+    }\n+\n     switch (rc) {\n \n     case NGX_DONE:\n@@ -275,13 +279,14 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n \n         if (s->state) {\n             /* preserve tag */\n-            s->arg_start = s->buffer->start + s->tag.len;\n-            s->buffer->pos = s->arg_start;\n-            s->buffer->last = s->arg_start;\n+            s->arg_start = s->buffer->pos;\n \n         } else {\n-            s->buffer->pos = s->buffer->start;\n-            s->buffer->last = s->buffer->start;\n+            if (s->buffer->pos == s->buffer->last) {\n+                s->buffer->pos = s->buffer->start;\n+                s->buffer->last = s->buffer->start;\n+            }\n+\n             s->tag.len = 0;\n         }\n     }\n@@ -459,6 +464,8 @@ ngx_mail_imap_starttls(ngx_mail_session_t *s, ngx_connection_t *c)\n     if (c->ssl == NULL) {\n         sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n         if (sslcf->starttls) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n             c->read->handler = ngx_mail_starttls_handler;\n             return NGX_OK;\n         }\nDiff:\n@@ -231,6 +231,8 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n     ngx_str_t  *arg;\n     enum {\n         sw_start = 0,\n+        sw_tag,\n+        sw_invalid,\n         sw_spaces_before_command,\n         sw_command,\n         sw_spaces_before_argument,\n@@ -253,42 +255,45 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n \n         /* IMAP tag */\n         case sw_start:\n+            s->tag_start = p;\n+            state = sw_tag;\n+\n+            /* fall through */\n+\n+        case sw_tag:\n             switch (ch) {\n             case ' ':\n-                s->tag.len = p - s->buffer->start + 1;\n-                s->tag.data = s->buffer->start;\n+                s->tag.len = p - s->tag_start + 1;\n+                s->tag.data = s->tag_start;\n                 state = sw_spaces_before_command;\n                 break;\n             case CR:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n             case LF:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+                goto invalid;\n             default:\n                 if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')\n                     && (ch < '0' || ch > '9') && ch != '-' && ch != '.'\n                     && ch != '_')\n                 {\n                     goto invalid;\n                 }\n-                if (p - s->buffer->start > 31) {\n+                if (p - s->tag_start > 31) {\n                     goto invalid;\n                 }\n                 break;\n             }\n             break;\n \n+        case sw_invalid:\n+            goto invalid;\n+\n         case sw_spaces_before_command:\n             switch (ch) {\n             case ' ':\n                 break;\n             case CR:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n             case LF:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+                goto invalid;\n             default:\n                 s->cmd_start = p;\n                 state = sw_command;\n@@ -408,6 +413,9 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n                     goto invalid;\n                 }\n \n+                s->cmd.data = s->cmd_start;\n+                s->cmd.len = p - s->cmd_start;\n+\n                 switch (ch) {\n                 case ' ':\n                     state = sw_spaces_before_argument;\n@@ -631,13 +639,40 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n \n invalid:\n \n-    s->state = sw_start;\n+    s->state = sw_invalid;\n     s->quoted = 0;\n     s->backslash = 0;\n     s->no_sync_literal = 0;\n     s->literal_len = 0;\n \n-    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    /* skip invalid command till LF */\n+\n+    for ( /* void */ ; p < s->buffer->last; p++) {\n+        if (*p == LF) {\n+            s->state = sw_start;\n+            s->buffer->pos = p + 1;\n+\n+            /* detect non-synchronizing literals */\n+\n+            if ((size_t) (p - s->buffer->start) > sizeof(\"{1+}\") - 1) {\n+                p--;\n+\n+                if (*p == CR) {\n+                    p--;\n+                }\n+\n+                if (*p == '}' && *(p - 1) == '+') {\n+                    s->quit = 1;\n+                }\n+            }\n+\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+\n+    return NGX_AGAIN;\n }\n \n \nDiff:\n@@ -486,6 +486,10 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n+        if (s->buffer->pos < s->buffer->last) {\n+            ngx_post_event(c->write, &ngx_posted_events);\n+        }\n+\n         ngx_mail_proxy_handler(s->connection->write);\n \n         return;\n"
    },
    {
        "commit_sha": "ada923668e603eac662d101c72ac64ae0618ea8d",
        "commit_index": "Commit 95",
        "commit_diff": "Diff:\n@@ -238,7 +238,6 @@ typedef struct {\n     ngx_uint_t              state;\n     u_char                 *cmd_start;\n     u_char                 *arg_start;\n-    u_char                 *arg_end;\n     ngx_uint_t              literal_len;\n } ngx_mail_session_t;\n \nDiff:\n@@ -101,10 +101,9 @@ ngx_mail_imap_init_protocol(ngx_event_t *rev)\n void\n ngx_mail_imap_auth_state(ngx_event_t *rev)\n {\n-    u_char              *p, *dst, *src, *end;\n-    ngx_str_t           *arg;\n+    u_char              *p;\n     ngx_int_t            rc;\n-    ngx_uint_t           tag, i;\n+    ngx_uint_t           tag;\n     ngx_connection_t    *c;\n     ngx_mail_session_t  *s;\n \n@@ -158,27 +157,6 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n         ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap auth command: %i\",\n                        s->command);\n \n-        if (s->backslash) {\n-\n-            arg = s->args.elts;\n-\n-            for (i = 0; i < s->args.nelts; i++) {\n-                dst = arg[i].data;\n-                end = dst + arg[i].len;\n-\n-                for (src = dst; src < end; dst++) {\n-                    *dst = *src;\n-                    if (*src++ == '\\\\') {\n-                        *dst = *src++;\n-                    }\n-                }\n-\n-                arg[i].len = dst - arg[i].data;\n-            }\n-\n-            s->backslash = 0;\n-        }\n-\n         switch (s->mail_state) {\n \n         case ngx_imap_start:\nDiff:\n@@ -124,10 +124,8 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                 break;\n             case CR:\n                 state = sw_almost_done;\n-                s->arg_end = p;\n                 break;\n             case LF:\n-                s->arg_end = p;\n                 goto done;\n             default:\n                 if (s->args.nelts <= 2) {\n@@ -202,25 +200,13 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n done:\n \n     s->buffer->pos = p + 1;\n-\n-    if (s->arg_start) {\n-        arg = ngx_array_push(&s->args);\n-        if (arg == NULL) {\n-            return NGX_ERROR;\n-        }\n-        arg->len = s->arg_end - s->arg_start;\n-        arg->data = s->arg_start;\n-        s->arg_start = NULL;\n-    }\n-\n     s->state = (s->command != NGX_POP3_AUTH) ? sw_start : sw_argument;\n \n     return NGX_OK;\n \n invalid:\n \n     s->state = sw_invalid;\n-    s->arg_start = NULL;\n \n     /* skip invalid command till LF */\n \n@@ -241,7 +227,7 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n ngx_int_t\n ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n {\n-    u_char      ch, *p, *c;\n+    u_char      ch, *p, *c, *dst, *src, *end;\n     ngx_str_t  *arg;\n     enum {\n         sw_start = 0,\n@@ -279,6 +265,17 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n             case LF:\n                 s->state = sw_start;\n                 return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            default:\n+                if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')\n+                    && (ch < '0' || ch > '9') && ch != '-' && ch != '.'\n+                    && ch != '_')\n+                {\n+                    goto invalid;\n+                }\n+                if (p - s->buffer->start > 31) {\n+                    goto invalid;\n+                }\n+                break;\n             }\n             break;\n \n@@ -436,10 +433,8 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n                 break;\n             case CR:\n                 state = sw_almost_done;\n-                s->arg_end = p;\n                 break;\n             case LF:\n-                s->arg_end = p;\n                 goto done;\n             case '\"':\n                 if (s->args.nelts <= 2) {\n@@ -486,6 +481,22 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n                 }\n                 arg->len = p - s->arg_start;\n                 arg->data = s->arg_start;\n+\n+                if (s->backslash) {\n+                    dst = s->arg_start;\n+                    end = p;\n+\n+                    for (src = dst; src < end; dst++) {\n+                        *dst = *src;\n+                        if (*src++ == '\\\\') {\n+                            *dst = *src++;\n+                        }\n+                    }\n+\n+                    arg->len = dst - s->arg_start;\n+                    s->backslash = 0;\n+                }\n+\n                 s->arg_start = NULL;\n \n                 switch (ch) {\n@@ -614,30 +625,13 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n done:\n \n     s->buffer->pos = p + 1;\n-\n-    if (s->arg_start) {\n-        arg = ngx_array_push(&s->args);\n-        if (arg == NULL) {\n-            return NGX_ERROR;\n-        }\n-        arg->len = s->arg_end - s->arg_start;\n-        arg->data = s->arg_start;\n-\n-        s->arg_start = NULL;\n-        s->cmd_start = NULL;\n-        s->quoted = 0;\n-        s->no_sync_literal = 0;\n-        s->literal_len = 0;\n-    }\n-\n     s->state = (s->command != NGX_IMAP_AUTHENTICATE) ? sw_start : sw_argument;\n \n     return NGX_OK;\n \n invalid:\n \n     s->state = sw_start;\n-    s->arg_start = NULL;\n     s->quoted = 0;\n     s->backslash = 0;\n     s->no_sync_literal = 0;\n@@ -786,10 +780,8 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n                 break;\n             case CR:\n                 state = sw_almost_done;\n-                s->arg_end = p;\n                 break;\n             case LF:\n-                s->arg_end = p;\n                 goto done;\n             default:\n                 if (s->args.nelts <= 10) {\n@@ -849,25 +841,13 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n done:\n \n     s->buffer->pos = p + 1;\n-\n-    if (s->arg_start) {\n-        arg = ngx_array_push(&s->args);\n-        if (arg == NULL) {\n-            return NGX_ERROR;\n-        }\n-        arg->len = s->arg_end - s->arg_start;\n-        arg->data = s->arg_start;\n-        s->arg_start = NULL;\n-    }\n-\n     s->state = (s->command != NGX_SMTP_AUTH) ? sw_start : sw_argument;\n \n     return NGX_OK;\n \n invalid:\n \n     s->state = sw_invalid;\n-    s->arg_start = NULL;\n \n     /* skip invalid command till LF */\n \n"
    },
    {
        "commit_sha": "4cc650233ca808dcfb9ae2696ae6d7438b672ed7",
        "commit_index": "Commit 94",
        "commit_diff": "Diff:\n@@ -21,6 +21,8 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n     ngx_str_t  *arg;\n     enum {\n         sw_start = 0,\n+        sw_command,\n+        sw_invalid,\n         sw_spaces_before_argument,\n         sw_argument,\n         sw_almost_done\n@@ -35,8 +37,14 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n \n         /* POP3 command */\n         case sw_start:\n+            s->cmd_start = p;\n+            state = sw_command;\n+\n+            /* fall through */\n+\n+        case sw_command:\n             if (ch == ' ' || ch == CR || ch == LF) {\n-                c = s->buffer->start;\n+                c = s->cmd_start;\n \n                 if (p - c == 4) {\n \n@@ -85,6 +93,9 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                     goto invalid;\n                 }\n \n+                s->cmd.data = s->cmd_start;\n+                s->cmd.len = p - s->cmd_start;\n+\n                 switch (ch) {\n                 case ' ':\n                     state = sw_spaces_before_argument;\n@@ -104,6 +115,9 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n \n             break;\n \n+        case sw_invalid:\n+            goto invalid;\n+\n         case sw_spaces_before_argument:\n             switch (ch) {\n             case ' ':\n@@ -205,10 +219,22 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n \n invalid:\n \n-    s->state = sw_start;\n+    s->state = sw_invalid;\n     s->arg_start = NULL;\n \n-    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    /* skip invalid command till LF */\n+\n+    for ( /* void */ ; p < s->buffer->last; p++) {\n+        if (*p == LF) {\n+            s->state = sw_start;\n+            s->buffer->pos = p + 1;\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+\n+    return NGX_AGAIN;\n }\n \n \n@@ -611,7 +637,9 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n invalid:\n \n     s->state = sw_start;\n+    s->arg_start = NULL;\n     s->quoted = 0;\n+    s->backslash = 0;\n     s->no_sync_literal = 0;\n     s->literal_len = 0;\n \nDiff:\n@@ -262,6 +262,10 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n         }\n     }\n \n+    if (s->buffer->pos < s->buffer->last) {\n+        s->blocked = 1;\n+    }\n+\n     switch (rc) {\n \n     case NGX_DONE:\n@@ -283,11 +287,14 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n     case NGX_OK:\n \n         s->args.nelts = 0;\n-        s->buffer->pos = s->buffer->start;\n-        s->buffer->last = s->buffer->start;\n+\n+        if (s->buffer->pos == s->buffer->last) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n+        }\n \n         if (s->state) {\n-            s->arg_start = s->buffer->start;\n+            s->arg_start = s->buffer->pos;\n         }\n \n         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n@@ -400,6 +407,8 @@ ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c)\n     if (c->ssl == NULL) {\n         sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n         if (sslcf->starttls) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n             c->read->handler = ngx_mail_starttls_handler;\n             return NGX_OK;\n         }\nDiff:\n@@ -327,6 +327,10 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n+        if (s->buffer->pos < s->buffer->last) {\n+            ngx_post_event(c->write, &ngx_posted_events);\n+        }\n+\n         ngx_mail_proxy_handler(s->connection->write);\n \n         return;\n"
    },
    {
        "commit_sha": "708394b9bc841f74becac9a20b4540a92a19a266",
        "commit_index": "Commit 93",
        "commit_diff": "Diff:\n@@ -51,6 +51,7 @@ types {\n     application/vnd.openxmlformats-officedocument.wordprocessingml.document\n                                                      docx;\n     application/vnd.wap.wmlc                         wmlc;\n+    application/wasm                                 wasm;\n     application/x-7z-compressed                      7z;\n     application/x-cocoa                              cco;\n     application/x-java-archive-diff                  jardiff;\nDiff:\n@@ -843,17 +843,17 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n \n     /* skip invalid command till LF */\n \n-    for (p = s->buffer->pos; p < s->buffer->last; p++) {\n+    for ( /* void */ ; p < s->buffer->last; p++) {\n         if (*p == LF) {\n             s->state = sw_start;\n-            p++;\n-            break;\n+            s->buffer->pos = p + 1;\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n         }\n     }\n \n     s->buffer->pos = p;\n \n-    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    return NGX_AGAIN;\n }\n \n \nDiff:\n@@ -813,13 +813,12 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos == s->buffer->last) {\n-            ngx_mail_proxy_handler(s->connection->write);\n-\n-        } else {\n-            ngx_mail_proxy_handler(c->write);\n+        if (s->buffer->pos < s->buffer->last) {\n+            ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n+        ngx_mail_proxy_handler(s->connection->write);\n+\n         return;\n \n     default:\n"
    },
    {
        "commit_sha": "f435e3a34eb83f5a2249318f0647db8d129f70fb",
        "commit_index": "Commit 92",
        "commit_diff": "Diff:\n@@ -37,9 +37,6 @@ typedef struct {\n     ngx_uint_t                 ssl_verify_depth;\n     ngx_str_t                  ssl_trusted_certificate;\n     ngx_str_t                  ssl_crl;\n-    ngx_str_t                  ssl_certificate;\n-    ngx_str_t                  ssl_certificate_key;\n-    ngx_array_t               *ssl_passwords;\n     ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_grpc_loc_conf_t;\n@@ -425,16 +422,16 @@ static ngx_command_t  ngx_http_grpc_commands[] = {\n \n     { ngx_string(\"grpc_ssl_certificate\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_grpc_loc_conf_t, ssl_certificate),\n+      offsetof(ngx_http_grpc_loc_conf_t, upstream.ssl_certificate),\n       NULL },\n \n     { ngx_string(\"grpc_ssl_certificate_key\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_grpc_loc_conf_t, ssl_certificate_key),\n+      offsetof(ngx_http_grpc_loc_conf_t, upstream.ssl_certificate_key),\n       NULL },\n \n     { ngx_string(\"grpc_ssl_password_file\"),\n@@ -4342,8 +4339,6 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n      *     conf->ssl_ciphers = { 0, NULL };\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n-     *     conf->ssl_certificate = { 0, NULL };\n-     *     conf->ssl_certificate_key = { 0, NULL };\n      */\n \n     conf->upstream.local = NGX_CONF_UNSET_PTR;\n@@ -4367,7 +4362,9 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n-    conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate_key = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n@@ -4471,11 +4468,12 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n-    ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate,\n+                              prev->upstream.ssl_certificate, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate_key,\n+                              prev->upstream.ssl_certificate_key, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_passwords,\n+                              prev->upstream.ssl_passwords, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n                               prev->ssl_conf_commands, NULL);\n@@ -4831,15 +4829,15 @@ ngx_http_grpc_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t  *value;\n \n-    if (glcf->ssl_passwords != NGX_CONF_UNSET_PTR) {\n+    if (glcf->upstream.ssl_passwords != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n-    glcf->ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+    glcf->upstream.ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n \n-    if (glcf->ssl_passwords == NULL) {\n+    if (glcf->upstream.ssl_passwords == NULL) {\n         return NGX_CONF_ERROR;\n     }\n \n@@ -4885,20 +4883,34 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = glcf->upstream.ssl;\n \n-    if (glcf->ssl_certificate.len) {\n+    if (glcf->upstream.ssl_certificate) {\n \n-        if (glcf->ssl_certificate_key.len == 0) {\n+        if (glcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"grpc_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &glcf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &glcf->upstream.ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, glcf->upstream.ssl, &glcf->ssl_certificate,\n-                                &glcf->ssl_certificate_key, glcf->ssl_passwords)\n-            != NGX_OK)\n+        if (glcf->upstream.ssl_certificate->lengths\n+            || glcf->upstream.ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            glcf->upstream.ssl_passwords =\n+                  ngx_ssl_preserve_passwords(cf, glcf->upstream.ssl_passwords);\n+            if (glcf->upstream.ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, glcf->upstream.ssl,\n+                                    &glcf->upstream.ssl_certificate->value,\n+                                    &glcf->upstream.ssl_certificate_key->value,\n+                                    glcf->upstream.ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -124,9 +124,6 @@ typedef struct {\n     ngx_uint_t                     ssl_verify_depth;\n     ngx_str_t                      ssl_trusted_certificate;\n     ngx_str_t                      ssl_crl;\n-    ngx_str_t                      ssl_certificate;\n-    ngx_str_t                      ssl_certificate_key;\n-    ngx_array_t                   *ssl_passwords;\n     ngx_array_t                   *ssl_conf_commands;\n #endif\n } ngx_http_proxy_loc_conf_t;\n@@ -753,16 +750,16 @@ static ngx_command_t  ngx_http_proxy_commands[] = {\n \n     { ngx_string(\"proxy_ssl_certificate\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_proxy_loc_conf_t, ssl_certificate),\n+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ssl_certificate),\n       NULL },\n \n     { ngx_string(\"proxy_ssl_certificate_key\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_proxy_loc_conf_t, ssl_certificate_key),\n+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ssl_certificate_key),\n       NULL },\n \n     { ngx_string(\"proxy_ssl_password_file\"),\n@@ -3345,8 +3342,6 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n      *     conf->ssl_ciphers = { 0, NULL };\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n-     *     conf->ssl_certificate = { 0, NULL };\n-     *     conf->ssl_certificate_key = { 0, NULL };\n      */\n \n     conf->upstream.store = NGX_CONF_UNSET;\n@@ -3401,8 +3396,10 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n+    conf->upstream.ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate_key = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n-    conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n@@ -3742,11 +3739,12 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n-    ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate,\n+                              prev->upstream.ssl_certificate, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate_key,\n+                              prev->upstream.ssl_certificate_key, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_passwords,\n+                              prev->upstream.ssl_passwords, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n                               prev->ssl_conf_commands, NULL);\n@@ -4857,15 +4855,15 @@ ngx_http_proxy_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t  *value;\n \n-    if (plcf->ssl_passwords != NGX_CONF_UNSET_PTR) {\n+    if (plcf->upstream.ssl_passwords != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n-    plcf->ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+    plcf->upstream.ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n \n-    if (plcf->ssl_passwords == NULL) {\n+    if (plcf->upstream.ssl_passwords == NULL) {\n         return NGX_CONF_ERROR;\n     }\n \n@@ -4944,20 +4942,34 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = plcf->upstream.ssl;\n \n-    if (plcf->ssl_certificate.len) {\n+    if (plcf->upstream.ssl_certificate) {\n \n-        if (plcf->ssl_certificate_key.len == 0) {\n+        if (plcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &plcf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &plcf->upstream.ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, plcf->upstream.ssl, &plcf->ssl_certificate,\n-                                &plcf->ssl_certificate_key, plcf->ssl_passwords)\n-            != NGX_OK)\n+        if (plcf->upstream.ssl_certificate->lengths\n+            || plcf->upstream.ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            plcf->upstream.ssl_passwords =\n+                  ngx_ssl_preserve_passwords(cf, plcf->upstream.ssl_passwords);\n+            if (plcf->upstream.ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, plcf->upstream.ssl,\n+                                    &plcf->upstream.ssl_certificate->value,\n+                                    &plcf->upstream.ssl_certificate_key->value,\n+                                    plcf->upstream.ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -54,9 +54,6 @@ typedef struct {\n     ngx_uint_t                 ssl_verify_depth;\n     ngx_str_t                  ssl_trusted_certificate;\n     ngx_str_t                  ssl_crl;\n-    ngx_str_t                  ssl_certificate;\n-    ngx_str_t                  ssl_certificate_key;\n-    ngx_array_t               *ssl_passwords;\n     ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_uwsgi_loc_conf_t;\n@@ -548,16 +545,16 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {\n \n     { ngx_string(\"uwsgi_ssl_certificate\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_uwsgi_loc_conf_t, ssl_certificate),\n+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.ssl_certificate),\n       NULL },\n \n     { ngx_string(\"uwsgi_ssl_certificate_key\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_uwsgi_loc_conf_t, ssl_certificate_key),\n+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.ssl_certificate_key),\n       NULL },\n \n     { ngx_string(\"uwsgi_ssl_password_file\"),\n@@ -1513,7 +1510,9 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n-    conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate_key = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n@@ -1837,11 +1836,12 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n-    ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate,\n+                              prev->upstream.ssl_certificate, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate_key,\n+                              prev->upstream.ssl_certificate_key, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_passwords,\n+                              prev->upstream.ssl_passwords, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n                               prev->ssl_conf_commands, NULL);\n@@ -2376,15 +2376,15 @@ ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t  *value;\n \n-    if (uwcf->ssl_passwords != NGX_CONF_UNSET_PTR) {\n+    if (uwcf->upstream.ssl_passwords != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n-    uwcf->ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+    uwcf->upstream.ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n \n-    if (uwcf->ssl_passwords == NULL) {\n+    if (uwcf->upstream.ssl_passwords == NULL) {\n         return NGX_CONF_ERROR;\n     }\n \n@@ -2430,20 +2430,34 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = uwcf->upstream.ssl;\n \n-    if (uwcf->ssl_certificate.len) {\n+    if (uwcf->upstream.ssl_certificate) {\n \n-        if (uwcf->ssl_certificate_key.len == 0) {\n+        if (uwcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"uwsgi_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &uwcf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &uwcf->upstream.ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, uwcf->upstream.ssl, &uwcf->ssl_certificate,\n-                                &uwcf->ssl_certificate_key, uwcf->ssl_passwords)\n-            != NGX_OK)\n+        if (uwcf->upstream.ssl_certificate->lengths\n+            || uwcf->upstream.ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            uwcf->upstream.ssl_passwords =\n+                  ngx_ssl_preserve_passwords(cf, uwcf->upstream.ssl_passwords);\n+            if (uwcf->upstream.ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, uwcf->upstream.ssl,\n+                                    &uwcf->upstream.ssl_certificate->value,\n+                                    &uwcf->upstream.ssl_certificate_key->value,\n+                                    uwcf->upstream.ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -275,6 +275,44 @@ ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+char *\n+ngx_http_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t                          *value;\n+    ngx_http_complex_value_t          **cv;\n+    ngx_http_compile_complex_value_t    ccv;\n+\n+    cv = (ngx_http_complex_value_t **) (p + cmd->offset);\n+\n+    if (*cv != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    *cv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));\n+    if (*cv == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n+\n+    ccv.cf = cf;\n+    ccv.value = &value[1];\n+    ccv.complex_value = *cv;\n+    ccv.zero = 1;\n+\n+    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n char *\n ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf)\nDiff:\n@@ -216,6 +216,8 @@ size_t ngx_http_complex_value_size(ngx_http_request_t *r,\n ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv);\n char *ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+char *ngx_http_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n char *ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \nDiff:\n@@ -187,6 +187,8 @@ static void ngx_http_upstream_ssl_handshake(ngx_http_request_t *,\n static void ngx_http_upstream_ssl_save_session(ngx_connection_t *c);\n static ngx_int_t ngx_http_upstream_ssl_name(ngx_http_request_t *r,\n     ngx_http_upstream_t *u, ngx_connection_t *c);\n+static ngx_int_t ngx_http_upstream_ssl_certificate(ngx_http_request_t *r,\n+    ngx_http_upstream_t *u, ngx_connection_t *c);\n #endif\n \n \n@@ -1692,6 +1694,16 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,\n         }\n     }\n \n+    if (u->conf->ssl_certificate && (u->conf->ssl_certificate->lengths\n+                                     || u->conf->ssl_certificate_key->lengths))\n+    {\n+        if (ngx_http_upstream_ssl_certificate(r, u, c) != NGX_OK) {\n+            ngx_http_upstream_finalize_request(r, u,\n+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+    }\n+\n     if (u->conf->ssl_session_reuse) {\n         c->ssl->save_session = ngx_http_upstream_ssl_save_session;\n \n@@ -1912,6 +1924,45 @@ ngx_http_upstream_ssl_name(ngx_http_request_t *r, ngx_http_upstream_t *u,\n     return NGX_OK;\n }\n \n+\n+static ngx_int_t\n+ngx_http_upstream_ssl_certificate(ngx_http_request_t *r,\n+    ngx_http_upstream_t *u, ngx_connection_t *c)\n+{\n+    ngx_str_t  cert, key;\n+\n+    if (ngx_http_complex_value(r, u->conf->ssl_certificate, &cert)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                   \"http upstream ssl cert: \\\"%s\\\"\", cert.data);\n+\n+    if (*cert.data == '\\0') {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_http_complex_value(r, u->conf->ssl_certificate_key, &key)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                   \"http upstream ssl key: \\\"%s\\\"\", key.data);\n+\n+    if (ngx_ssl_connection_certificate(c, r->pool, &cert, &key,\n+                                       u->conf->ssl_passwords)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n #endif\n \n \nDiff:\n@@ -234,6 +234,10 @@ typedef struct {\n     ngx_http_complex_value_t        *ssl_name;\n     ngx_flag_t                       ssl_server_name;\n     ngx_flag_t                       ssl_verify;\n+\n+    ngx_http_complex_value_t        *ssl_certificate;\n+    ngx_http_complex_value_t        *ssl_certificate_key;\n+    ngx_array_t                     *ssl_passwords;\n #endif\n \n     ngx_str_t                        module;\nDiff:\n@@ -46,8 +46,8 @@ typedef struct {\n     ngx_uint_t                       ssl_verify_depth;\n     ngx_str_t                        ssl_trusted_certificate;\n     ngx_str_t                        ssl_crl;\n-    ngx_str_t                        ssl_certificate;\n-    ngx_str_t                        ssl_certificate_key;\n+    ngx_stream_complex_value_t      *ssl_certificate;\n+    ngx_stream_complex_value_t      *ssl_certificate_key;\n     ngx_array_t                     *ssl_passwords;\n     ngx_array_t                     *ssl_conf_commands;\n \n@@ -101,6 +101,7 @@ static void ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s);\n static void ngx_stream_proxy_ssl_handshake(ngx_connection_t *pc);\n static void ngx_stream_proxy_ssl_save_session(ngx_connection_t *c);\n static ngx_int_t ngx_stream_proxy_ssl_name(ngx_stream_session_t *s);\n+static ngx_int_t ngx_stream_proxy_ssl_certificate(ngx_stream_session_t *s);\n static ngx_int_t ngx_stream_proxy_set_ssl(ngx_conf_t *cf,\n     ngx_stream_proxy_srv_conf_t *pscf);\n \n@@ -318,14 +319,14 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {\n \n     { ngx_string(\"proxy_ssl_certificate\"),\n       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_stream_set_complex_value_zero_slot,\n       NGX_STREAM_SRV_CONF_OFFSET,\n       offsetof(ngx_stream_proxy_srv_conf_t, ssl_certificate),\n       NULL },\n \n     { ngx_string(\"proxy_ssl_certificate_key\"),\n       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_stream_set_complex_value_zero_slot,\n       NGX_STREAM_SRV_CONF_OFFSET,\n       offsetof(ngx_stream_proxy_srv_conf_t, ssl_certificate_key),\n       NULL },\n@@ -1060,6 +1061,15 @@ ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s)\n         }\n     }\n \n+    if (pscf->ssl_certificate && (pscf->ssl_certificate->lengths\n+                                  || pscf->ssl_certificate_key->lengths))\n+    {\n+        if (ngx_stream_proxy_ssl_certificate(s) != NGX_OK) {\n+            ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+    }\n+\n     if (pscf->ssl_session_reuse) {\n         pc->ssl->save_session = ngx_stream_proxy_ssl_save_session;\n \n@@ -1247,6 +1257,50 @@ ngx_stream_proxy_ssl_name(ngx_stream_session_t *s)\n     return NGX_OK;\n }\n \n+\n+static ngx_int_t\n+ngx_stream_proxy_ssl_certificate(ngx_stream_session_t *s)\n+{\n+    ngx_str_t                     cert, key;\n+    ngx_connection_t             *c;\n+    ngx_stream_proxy_srv_conf_t  *pscf;\n+\n+    c = s->upstream->peer.connection;\n+\n+    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);\n+\n+    if (ngx_stream_complex_value(s, pscf->ssl_certificate, &cert)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                   \"stream upstream ssl cert: \\\"%s\\\"\", cert.data);\n+\n+    if (*cert.data == '\\0') {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_stream_complex_value(s, pscf->ssl_certificate_key, &key)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                   \"stream upstream ssl key: \\\"%s\\\"\", key.data);\n+\n+    if (ngx_ssl_connection_certificate(c, c->pool, &cert, &key,\n+                                       pscf->ssl_passwords)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n #endif\n \n \n@@ -1979,8 +2033,6 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n      *     conf->ssl_ciphers = { 0, NULL };\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n-     *     conf->ssl_certificate = { 0, NULL };\n-     *     conf->ssl_certificate_key = { 0, NULL };\n      *\n      *     conf->ssl = NULL;\n      *     conf->upstream = NULL;\n@@ -2008,6 +2060,8 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->ssl_server_name = NGX_CONF_UNSET;\n     conf->ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n+    conf->ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->ssl_certificate_key = NGX_CONF_UNSET_PTR;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n@@ -2083,11 +2137,11 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n+    ngx_conf_merge_ptr_value(conf->ssl_certificate,\n+                              prev->ssl_certificate, NULL);\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n+    ngx_conf_merge_ptr_value(conf->ssl_certificate_key,\n+                              prev->ssl_certificate_key, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n@@ -2131,20 +2185,34 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = pscf->ssl;\n \n-    if (pscf->ssl_certificate.len) {\n+    if (pscf->ssl_certificate) {\n \n-        if (pscf->ssl_certificate_key.len == 0) {\n+        if (pscf->ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &pscf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &pscf->ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, pscf->ssl, &pscf->ssl_certificate,\n-                                &pscf->ssl_certificate_key, pscf->ssl_passwords)\n-            != NGX_OK)\n+        if (pscf->ssl_certificate->lengths\n+            || pscf->ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            pscf->ssl_passwords =\n+                           ngx_ssl_preserve_passwords(cf, pscf->ssl_passwords);\n+            if (pscf->ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, pscf->ssl,\n+                                    &pscf->ssl_certificate->value,\n+                                    &pscf->ssl_certificate_key->value,\n+                                    pscf->ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -277,6 +277,44 @@ ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n }\n \n \n+char *\n+ngx_stream_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t                            *value;\n+    ngx_stream_complex_value_t          **cv;\n+    ngx_stream_compile_complex_value_t    ccv;\n+\n+    cv = (ngx_stream_complex_value_t **) (p + cmd->offset);\n+\n+    if (*cv != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    *cv = ngx_palloc(cf->pool, sizeof(ngx_stream_complex_value_t));\n+    if (*cv == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));\n+\n+    ccv.cf = cf;\n+    ccv.value = &value[1];\n+    ccv.complex_value = *cv;\n+    ccv.zero = 1;\n+\n+    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n char *\n ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf)\nDiff:\n@@ -112,6 +112,8 @@ ngx_int_t ngx_stream_compile_complex_value(\n     ngx_stream_compile_complex_value_t *ccv);\n char *ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+char *ngx_stream_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n char *ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \n"
    },
    {
        "commit_sha": "889755d7df5b93df119b636d97f660e9d56f612c",
        "commit_index": "Commit 91",
        "commit_diff": "Diff:\n@@ -16,7 +16,7 @@\n \n typedef struct {\n     ngx_http_complex_value_t  *realm;\n-    ngx_http_complex_value_t   user_file;\n+    ngx_http_complex_value_t  *user_file;\n } ngx_http_auth_basic_loc_conf_t;\n \n \n@@ -107,7 +107,7 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n \n     alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_basic_module);\n \n-    if (alcf->realm == NULL || alcf->user_file.value.data == NULL) {\n+    if (alcf->realm == NULL || alcf->user_file == NULL) {\n         return NGX_DECLINED;\n     }\n \n@@ -133,7 +133,7 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    if (ngx_http_complex_value(r, &alcf->user_file, &user_file) != NGX_OK) {\n+    if (ngx_http_complex_value(r, alcf->user_file, &user_file) != NGX_OK) {\n         return NGX_ERROR;\n     }\n \n@@ -357,6 +357,9 @@ ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf)\n         return NULL;\n     }\n \n+    conf->realm = NGX_CONF_UNSET_PTR;\n+    conf->user_file = NGX_CONF_UNSET_PTR;\n+\n     return conf;\n }\n \n@@ -367,13 +370,8 @@ ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_http_auth_basic_loc_conf_t  *prev = parent;\n     ngx_http_auth_basic_loc_conf_t  *conf = child;\n \n-    if (conf->realm == NULL) {\n-        conf->realm = prev->realm;\n-    }\n-\n-    if (conf->user_file.value.data == NULL) {\n-        conf->user_file = prev->user_file;\n-    }\n+    ngx_conf_merge_ptr_value(conf->realm, prev->realm, NULL);\n+    ngx_conf_merge_ptr_value(conf->user_file, prev->user_file, NULL);\n \n     return NGX_CONF_OK;\n }\n@@ -406,17 +404,22 @@ ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_str_t                         *value;\n     ngx_http_compile_complex_value_t   ccv;\n \n-    if (alcf->user_file.value.data) {\n+    if (alcf->user_file != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n+    alcf->user_file = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));\n+    if (alcf->user_file == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     value = cf->args->elts;\n \n     ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n \n     ccv.cf = cf;\n     ccv.value = &value[1];\n-    ccv.complex_value = &alcf->user_file;\n+    ccv.complex_value = alcf->user_file;\n     ccv.zero = 1;\n     ccv.conf_prefix = 1;\n \nDiff:\n@@ -4331,7 +4331,6 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n      *     conf->upstream.ignore_headers = 0;\n      *     conf->upstream.next_upstream = 0;\n      *     conf->upstream.hide_headers_hash = { NULL, 0 };\n-     *     conf->upstream.ssl_name = NULL;\n      *\n      *     conf->headers.lengths = NULL;\n      *     conf->headers.values = NULL;\n@@ -4364,6 +4363,7 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n \n #if (NGX_HTTP_SSL)\n     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -4459,10 +4459,8 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\n \n-    if (conf->upstream.ssl_name == NULL) {\n-        conf->upstream.ssl_name = prev->upstream.ssl_name;\n-    }\n-\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_name,\n+                              prev->upstream.ssl_name, NULL);\n     ngx_conf_merge_value(conf->upstream.ssl_server_name,\n                               prev->upstream.ssl_server_name, 0);\n     ngx_conf_merge_value(conf->upstream.ssl_verify,\nDiff:\n@@ -3327,9 +3327,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n      *     conf->upstream.hide_headers_hash = { NULL, 0 };\n      *     conf->upstream.store_lengths = NULL;\n      *     conf->upstream.store_values = NULL;\n-     *     conf->upstream.ssl_name = NULL;\n      *\n-     *     conf->method = NULL;\n      *     conf->location = NULL;\n      *     conf->url = { 0, NULL };\n      *     conf->headers.lengths = NULL;\n@@ -3400,6 +3398,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n \n #if (NGX_HTTP_SSL)\n     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -3410,10 +3409,13 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     /* \"proxy_cyclic_temp_file\" is disabled */\n     conf->upstream.cyclic_temp_file = 0;\n \n+    conf->upstream.change_buffering = 1;\n+\n     conf->headers_source = NGX_CONF_UNSET_PTR;\n \n+    conf->method = NGX_CONF_UNSET_PTR;\n+\n     conf->redirect = NGX_CONF_UNSET;\n-    conf->upstream.change_buffering = 1;\n \n     conf->cookie_domains = NGX_CONF_UNSET_PTR;\n     conf->cookie_paths = NGX_CONF_UNSET_PTR;\n@@ -3708,10 +3710,6 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #endif\n \n-    if (conf->method == NULL) {\n-        conf->method = prev->method;\n-    }\n-\n     ngx_conf_merge_value(conf->upstream.pass_request_headers,\n                               prev->upstream.pass_request_headers, 1);\n     ngx_conf_merge_value(conf->upstream.pass_request_body,\n@@ -3732,10 +3730,8 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\n \n-    if (conf->upstream.ssl_name == NULL) {\n-        conf->upstream.ssl_name = prev->upstream.ssl_name;\n-    }\n-\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_name,\n+                              prev->upstream.ssl_name, NULL);\n     ngx_conf_merge_value(conf->upstream.ssl_server_name,\n                               prev->upstream.ssl_server_name, 0);\n     ngx_conf_merge_value(conf->upstream.ssl_verify,\n@@ -3761,6 +3757,8 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #endif\n \n+    ngx_conf_merge_ptr_value(conf->method, prev->method, NULL);\n+\n     ngx_conf_merge_value(conf->redirect, prev->redirect, 1);\n \n     if (conf->redirect) {\nDiff:\n@@ -302,11 +302,12 @@ ngx_http_secure_link_create_conf(ngx_conf_t *cf)\n     /*\n      * set by ngx_pcalloc():\n      *\n-     *     conf->variable = NULL;\n-     *     conf->md5 = NULL;\n      *     conf->secret = { 0, NULL };\n      */\n \n+    conf->variable = NGX_CONF_UNSET_PTR;\n+    conf->md5 = NGX_CONF_UNSET_PTR;\n+\n     return conf;\n }\n \n@@ -318,6 +319,9 @@ ngx_http_secure_link_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_http_secure_link_conf_t *conf = child;\n \n     if (conf->secret.data) {\n+        ngx_conf_init_ptr_value(conf->variable, NULL);\n+        ngx_conf_init_ptr_value(conf->md5, NULL);\n+\n         if (conf->variable || conf->md5) {\n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"\\\"secure_link_secret\\\" cannot be mixed with \"\n@@ -328,13 +332,8 @@ ngx_http_secure_link_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_OK;\n     }\n \n-    if (conf->variable == NULL) {\n-        conf->variable = prev->variable;\n-    }\n-\n-    if (conf->md5 == NULL) {\n-        conf->md5 = prev->md5;\n-    }\n+    ngx_conf_merge_ptr_value(conf->variable, prev->variable, NULL);\n+    ngx_conf_merge_ptr_value(conf->md5, prev->md5, NULL);\n \n     if (conf->variable == NULL && conf->md5 == NULL) {\n         conf->secret = prev->secret;\nDiff:\n@@ -1509,6 +1509,7 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)\n \n #if (NGX_HTTP_SSL)\n     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -1824,10 +1825,8 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\n \n-    if (conf->upstream.ssl_name == NULL) {\n-        conf->upstream.ssl_name = prev->upstream.ssl_name;\n-    }\n-\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_name,\n+                              prev->upstream.ssl_name, NULL);\n     ngx_conf_merge_value(conf->upstream.ssl_server_name,\n                               prev->upstream.ssl_server_name, 0);\n     ngx_conf_merge_value(conf->upstream.ssl_verify,\nDiff:\n@@ -3479,8 +3479,6 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n      *     clcf->exact_match = 0;\n      *     clcf->auto_redirect = 0;\n      *     clcf->alias = 0;\n-     *     clcf->limit_rate = NULL;\n-     *     clcf->limit_rate_after = NULL;\n      *     clcf->gzip_proxied = 0;\n      *     clcf->keepalive_disable = 0;\n      */\n@@ -3512,6 +3510,8 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     clcf->send_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->send_lowat = NGX_CONF_UNSET_SIZE;\n     clcf->postpone_output = NGX_CONF_UNSET_SIZE;\n+    clcf->limit_rate = NGX_CONF_UNSET_PTR;\n+    clcf->limit_rate_after = NGX_CONF_UNSET_PTR;\n     clcf->keepalive_time = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_header = NGX_CONF_UNSET;\n@@ -3743,13 +3743,9 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_size_value(conf->postpone_output, prev->postpone_output,\n                               1460);\n \n-    if (conf->limit_rate == NULL) {\n-        conf->limit_rate = prev->limit_rate;\n-    }\n-\n-    if (conf->limit_rate_after == NULL) {\n-        conf->limit_rate_after = prev->limit_rate_after;\n-    }\n+    ngx_conf_merge_ptr_value(conf->limit_rate, prev->limit_rate, NULL);\n+    ngx_conf_merge_ptr_value(conf->limit_rate_after,\n+                              prev->limit_rate_after, NULL);\n \n     ngx_conf_merge_msec_value(conf->keepalive_time,\n                               prev->keepalive_time, 3600000);\nDiff:\n@@ -250,7 +250,7 @@ ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cv = (ngx_http_complex_value_t **) (p + cmd->offset);\n \n-    if (*cv != NULL) {\n+    if (*cv != NGX_CONF_UNSET_PTR && *cv != NULL) {\n         return \"is duplicate\";\n     }\n \nDiff:\n@@ -1977,14 +1977,11 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n      *\n      *     conf->ssl_protocols = 0;\n      *     conf->ssl_ciphers = { 0, NULL };\n-     *     conf->ssl_name = NULL;\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n      *     conf->ssl_certificate = { 0, NULL };\n      *     conf->ssl_certificate_key = { 0, NULL };\n      *\n-     *     conf->upload_rate = NULL;\n-     *     conf->download_rate = NULL;\n      *     conf->ssl = NULL;\n      *     conf->upstream = NULL;\n      *     conf->upstream_value = NULL;\n@@ -1994,6 +1991,8 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->timeout = NGX_CONF_UNSET_MSEC;\n     conf->next_upstream_timeout = NGX_CONF_UNSET_MSEC;\n     conf->buffer_size = NGX_CONF_UNSET_SIZE;\n+    conf->upload_rate = NGX_CONF_UNSET_PTR;\n+    conf->download_rate = NGX_CONF_UNSET_PTR;\n     conf->requests = NGX_CONF_UNSET_UINT;\n     conf->responses = NGX_CONF_UNSET_UINT;\n     conf->next_upstream_tries = NGX_CONF_UNSET_UINT;\n@@ -2005,6 +2004,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n #if (NGX_STREAM_SSL)\n     conf->ssl_enable = NGX_CONF_UNSET;\n     conf->ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->ssl_name = NGX_CONF_UNSET_PTR;\n     conf->ssl_server_name = NGX_CONF_UNSET;\n     conf->ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -2034,13 +2034,9 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_size_value(conf->buffer_size,\n                               prev->buffer_size, 16384);\n \n-    if (conf->upload_rate == NULL) {\n-        conf->upload_rate = prev->upload_rate;\n-    }\n+    ngx_conf_merge_ptr_value(conf->upload_rate, prev->upload_rate, NULL);\n \n-    if (conf->download_rate == NULL) {\n-        conf->download_rate = prev->download_rate;\n-    }\n+    ngx_conf_merge_ptr_value(conf->download_rate, prev->download_rate, NULL);\n \n     ngx_conf_merge_uint_value(conf->requests,\n                               prev->requests, 0);\n@@ -2073,9 +2069,7 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers, \"DEFAULT\");\n \n-    if (conf->ssl_name == NULL) {\n-        conf->ssl_name = prev->ssl_name;\n-    }\n+    ngx_conf_merge_ptr_value(conf->ssl_name, prev->ssl_name, NULL);\n \n     ngx_conf_merge_value(conf->ssl_server_name, prev->ssl_server_name, 0);\n \nDiff:\n@@ -252,7 +252,7 @@ ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n \n     cv = (ngx_stream_complex_value_t **) (p + cmd->offset);\n \n-    if (*cv != NULL) {\n+    if (*cv != NGX_CONF_UNSET_PTR && *cv != NULL) {\n         return \"is duplicate\";\n     }\n \n"
    },
    {
        "commit_sha": "446cb56f1e2069ced7871e3a063504d3cc5323aa",
        "commit_index": "Commit 90",
        "commit_diff": "Diff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019010\n-#define NGINX_VERSION      \"1.19.10\"\n+#define nginx_version      1021000\n+#define NGINX_VERSION      \"1.21.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -833,20 +833,23 @@ ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n     ngx_str_t                  l;\n     ngx_mail_core_srv_conf_t  *cscf;\n \n-    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);\n+    if (s->buffer->last < s->buffer->end) {\n \n-    if (n == NGX_ERROR || n == 0) {\n-        ngx_mail_close_connection(c);\n-        return NGX_ERROR;\n-    }\n+        n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);\n \n-    if (n > 0) {\n-        s->buffer->last += n;\n-    }\n+        if (n == NGX_ERROR || n == 0) {\n+            ngx_mail_close_connection(c);\n+            return NGX_ERROR;\n+        }\n \n-    if (n == NGX_AGAIN) {\n-        if (s->buffer->pos == s->buffer->last) {\n-            return NGX_AGAIN;\n+        if (n > 0) {\n+            s->buffer->last += n;\n+        }\n+\n+        if (n == NGX_AGAIN) {\n+            if (s->buffer->pos == s->buffer->last) {\n+                return NGX_AGAIN;\n+            }\n         }\n     }\n \nDiff:\n@@ -398,6 +398,8 @@ ngx_pass_open_channel(ngx_cycle_t *cycle)\n     ngx_int_t      i;\n     ngx_channel_t  ch;\n \n+    ngx_memzero(&ch, sizeof(ngx_channel_t));\n+\n     ch.command = NGX_CMD_OPEN_CHANNEL;\n     ch.pid = ngx_processes[ngx_process_slot].pid;\n     ch.slot = ngx_process_slot;\n"
    },
    {
        "commit_sha": "cf6f5b1d4d85c98b4e2e2fb6f694f996d944851a",
        "commit_index": "Commit 89",
        "commit_diff": "Diff:\n@@ -459,3 +459,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n+ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\nDiff:\n@@ -5,6 +5,49 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.10\" date=\"2021-04-13\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+в директиве keepalive_requests значение по умолчанию изменено на 1000.\n+</para>\n+<para lang=\"en\">\n+the default value of the \"keepalive_requests\" directive was changed to 1000.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива keepalive_time.\n+</para>\n+<para lang=\"en\">\n+the \"keepalive_time\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $connection_time.\n+</para>\n+<para lang=\"en\">\n+the $connection_time variable.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании zlib-ng\n+в логах появлялись сообщения \"gzip filter failed to use preallocated memory\".\n+</para>\n+<para lang=\"en\">\n+\"gzip filter failed to use preallocated memory\" alerts appeared in logs\n+when using zlib-ng.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.9\" date=\"2021-03-30\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -102,7 +102,7 @@ ngx_mail_pop3_init_protocol(ngx_event_t *rev)\n             return;\n         }\n \n-        s->buffer = ngx_create_temp_buf(c->pool, 128);\n+        s->buffer = ngx_create_temp_buf(c->pool, 1000);\n         if (s->buffer == NULL) {\n             ngx_mail_session_internal_server_error(s);\n             return;\n@@ -316,7 +316,7 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n \n     arg = s->args.elts;\n     s->login.len = arg[0].len;\n-    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n+    s->login.data = ngx_pnalloc(c->pool, 100);\n     if (s->login.data == NULL) {\n         return NGX_ERROR;\n     }\n"
    },
    {
        "commit_sha": "c82616a792165418dc3091344c1e78fee40aa305",
        "commit_index": "Commit 88",
        "commit_diff": "Diff:\n@@ -159,7 +159,7 @@ ngx_http_upstream_init_keepalive(ngx_conf_t *cf,\n \n     ngx_conf_init_msec_value(kcf->time, 3600000);\n     ngx_conf_init_msec_value(kcf->timeout, 60000);\n-    ngx_conf_init_uint_value(kcf->requests, 100);\n+    ngx_conf_init_uint_value(kcf->requests, 1000);\n \n     if (kcf->original_init_upstream(cf, us) != NGX_OK) {\n         return NGX_ERROR;\nDiff:\n@@ -3758,7 +3758,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_sec_value(conf->keepalive_header,\n                               prev->keepalive_header, 0);\n     ngx_conf_merge_uint_value(conf->keepalive_requests,\n-                              prev->keepalive_requests, 100);\n+                              prev->keepalive_requests, 1000);\n     ngx_conf_merge_uint_value(conf->lingering_close,\n                               prev->lingering_close, NGX_HTTP_LINGERING_ON);\n     ngx_conf_merge_msec_value(conf->lingering_time,\nDiff:\n@@ -133,6 +133,8 @@ static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_http_variable_connection_time(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n \n static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n@@ -346,6 +348,9 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n     { ngx_string(\"connection_requests\"), NULL,\n       ngx_http_variable_connection_requests, 0, 0, 0 },\n \n+    { ngx_string(\"connection_time\"), NULL, ngx_http_variable_connection_time,\n+      0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n+\n     { ngx_string(\"nginx_version\"), NULL, ngx_http_variable_nginx_version,\n       0, 0, 0 },\n \n@@ -2262,6 +2267,31 @@ ngx_http_variable_connection_requests(ngx_http_request_t *r,\n }\n \n \n+static ngx_int_t\n+ngx_http_variable_connection_time(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    u_char          *p;\n+    ngx_msec_int_t   ms;\n+\n+    p = ngx_pnalloc(r->pool, NGX_TIME_T_LEN + 4);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ms = ngx_current_msec - r->connection->start_time;\n+    ms = ngx_max(ms, 0);\n+\n+    v->len = ngx_sprintf(p, \"%T.%03M\", (time_t) ms / 1000, ms % 1000) - p;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = p;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_variable_nginx_version(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n"
    },
    {
        "commit_sha": "be9210d1b8e5446bba7c010089eb0deb2db455e5",
        "commit_index": "Commit 87",
        "commit_diff": "Diff:\n@@ -164,6 +164,7 @@ struct ngx_connection_s {\n \n     ngx_atomic_uint_t   number;\n \n+    ngx_msec_t          start_time;\n     ngx_uint_t          requests;\n \n     unsigned            buffered:8;\nDiff:\n@@ -4459,6 +4459,8 @@ ngx_udp_connect(ngx_resolver_connection_t *rec)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     ngx_log_debug3(NGX_LOG_DEBUG_EVENT, &rec->log, 0,\n                    \"connect to %V, fd:%d #%uA\", &rec->server, s, c->number);\n \n@@ -4545,6 +4547,8 @@ ngx_tcp_connect(ngx_resolver_connection_t *rec)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     if (ngx_add_conn) {\n         if (ngx_add_conn(c) == NGX_ERROR) {\n             goto failed;\nDiff:\n@@ -256,6 +256,8 @@ ngx_event_accept(ngx_event_t *ev)\n \n         c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+        c->start_time = ngx_current_msec;\n+\n #if (NGX_STAT_STUB)\n         (void) ngx_atomic_fetch_add(ngx_stat_handled, 1);\n #endif\nDiff:\n@@ -80,6 +80,8 @@ ngx_event_acceptex(ngx_event_t *rev)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     ls->handler(c);\n \n     return;\nDiff:\n@@ -193,6 +193,8 @@ ngx_event_connect_peer(ngx_peer_connection_t *pc)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     if (ngx_add_conn) {\n         if (ngx_add_conn(c) == NGX_ERROR) {\n             goto failed;\nDiff:\n@@ -363,6 +363,8 @@ ngx_event_recvmsg(ngx_event_t *ev)\n \n         c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+        c->start_time = ngx_current_msec;\n+\n #if (NGX_STAT_STUB)\n         (void) ngx_atomic_fetch_add(ngx_stat_handled, 1);\n #endif\nDiff:\n@@ -13,6 +13,7 @@\n typedef struct {\n     ngx_uint_t                         max_cached;\n     ngx_uint_t                         requests;\n+    ngx_msec_t                         time;\n     ngx_msec_t                         timeout;\n \n     ngx_queue_t                        cache;\n@@ -86,6 +87,13 @@ static ngx_command_t  ngx_http_upstream_keepalive_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"keepalive_time\"),\n+      NGX_HTTP_UPS_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_upstream_keepalive_srv_conf_t, time),\n+      NULL },\n+\n     { ngx_string(\"keepalive_timeout\"),\n       NGX_HTTP_UPS_CONF|NGX_CONF_TAKE1,\n       ngx_conf_set_msec_slot,\n@@ -149,6 +157,7 @@ ngx_http_upstream_init_keepalive(ngx_conf_t *cf,\n     kcf = ngx_http_conf_upstream_srv_conf(us,\n                                           ngx_http_upstream_keepalive_module);\n \n+    ngx_conf_init_msec_value(kcf->time, 3600000);\n     ngx_conf_init_msec_value(kcf->timeout, 60000);\n     ngx_conf_init_uint_value(kcf->requests, 100);\n \n@@ -326,6 +335,10 @@ ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc, void *data,\n         goto invalid;\n     }\n \n+    if (ngx_current_msec - c->start_time > kp->conf->time) {\n+        goto invalid;\n+    }\n+\n     if (!u->keepalive) {\n         goto invalid;\n     }\n@@ -513,6 +526,7 @@ ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf)\n      *     conf->max_cached = 0;\n      */\n \n+    conf->time = NGX_CONF_UNSET_MSEC;\n     conf->timeout = NGX_CONF_UNSET_MSEC;\n     conf->requests = NGX_CONF_UNSET_UINT;\n \nDiff:\n@@ -495,6 +495,13 @@ static ngx_command_t  ngx_http_core_commands[] = {\n       offsetof(ngx_http_core_loc_conf_t, limit_rate_after),\n       NULL },\n \n+    { ngx_string(\"keepalive_time\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_core_loc_conf_t, keepalive_time),\n+      NULL },\n+\n     { ngx_string(\"keepalive_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE12,\n       ngx_http_core_keepalive,\n@@ -1335,6 +1342,11 @@ ngx_http_update_location_config(ngx_http_request_t *r)\n         } else if (r->connection->requests >= clcf->keepalive_requests) {\n             r->keepalive = 0;\n \n+        } else if (ngx_current_msec - r->connection->start_time\n+                   > clcf->keepalive_time)\n+        {\n+            r->keepalive = 0;\n+\n         } else if (r->headers_in.msie6\n                    && r->method == NGX_HTTP_POST\n                    && (clcf->keepalive_disable\n@@ -3500,6 +3512,7 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     clcf->send_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->send_lowat = NGX_CONF_UNSET_SIZE;\n     clcf->postpone_output = NGX_CONF_UNSET_SIZE;\n+    clcf->keepalive_time = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_header = NGX_CONF_UNSET;\n     clcf->keepalive_requests = NGX_CONF_UNSET_UINT;\n@@ -3738,6 +3751,8 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->limit_rate_after = prev->limit_rate_after;\n     }\n \n+    ngx_conf_merge_msec_value(conf->keepalive_time,\n+                              prev->keepalive_time, 3600000);\n     ngx_conf_merge_msec_value(conf->keepalive_timeout,\n                               prev->keepalive_timeout, 75000);\n     ngx_conf_merge_sec_value(conf->keepalive_header,\nDiff:\n@@ -362,6 +362,7 @@ struct ngx_http_core_loc_conf_s {\n \n     ngx_msec_t    client_body_timeout;     /* client_body_timeout */\n     ngx_msec_t    send_timeout;            /* send_timeout */\n+    ngx_msec_t    keepalive_time;          /* keepalive_time */\n     ngx_msec_t    keepalive_timeout;       /* keepalive_timeout */\n     ngx_msec_t    lingering_time;          /* lingering_time */\n     ngx_msec_t    lingering_timeout;       /* lingering_timeout */\nDiff:\n@@ -1369,7 +1369,9 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n                                         ngx_http_core_module);\n \n     if (clcf->keepalive_timeout == 0\n-        || h2c->connection->requests >= clcf->keepalive_requests)\n+        || h2c->connection->requests >= clcf->keepalive_requests\n+        || ngx_current_msec - h2c->connection->start_time\n+           > clcf->keepalive_time)\n     {\n         h2c->goaway = 1;\n \n"
    },
    {
        "commit_sha": "694827984465a2c7d51317494e23afaa325b0759",
        "commit_index": "Commit 86",
        "commit_diff": "Diff:\n@@ -86,6 +86,31 @@ if [ $ngx_found = yes ]; then\n                       ee.data.ptr = NULL;\n                       epoll_ctl(efd, EPOLL_CTL_ADD, fd, &ee)\"\n     . auto/feature\n+\n+\n+    # eventfd()\n+\n+    ngx_feature=\"eventfd()\"\n+    ngx_feature_name=\"NGX_HAVE_EVENTFD\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <sys/eventfd.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"(void) eventfd(0, 0)\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n+    fi\n+\n+\n+    if [ $ngx_found = no ]; then\n+\n+        ngx_feature=\"eventfd() (SYS_eventfd)\"\n+        ngx_feature_incs=\"#include <sys/syscall.h>\"\n+        ngx_feature_test=\"(void) SYS_eventfd\"\n+        . auto/feature\n+    fi\n fi\n \n \nDiff:\n@@ -582,29 +582,6 @@ Currently file AIO is supported on FreeBSD 4.3+ and Linux 2.6.22+ only\n END\n         exit 1\n     fi\n-\n-else\n-\n-    ngx_feature=\"eventfd()\"\n-    ngx_feature_name=\"NGX_HAVE_EVENTFD\"\n-    ngx_feature_run=no\n-    ngx_feature_incs=\"#include <sys/eventfd.h>\"\n-    ngx_feature_path=\n-    ngx_feature_libs=\n-    ngx_feature_test=\"(void) eventfd(0, 0)\"\n-    . auto/feature\n-\n-    if [ $ngx_found = yes ]; then\n-        have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n-    fi\n-\n-    if [ $ngx_found = no ]; then\n-\n-        ngx_feature=\"eventfd() (SYS_eventfd)\"\n-        ngx_feature_incs=\"#include <sys/syscall.h>\"\n-        ngx_feature_test=\"(void) SYS_eventfd\"\n-        . auto/feature\n-    fi\n fi\n \n \nDiff:\n@@ -277,7 +277,7 @@ ngx_http_v2_init(ngx_event_t *rev)\n     h2scf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_v2_module);\n \n     h2c->concurrent_pushes = h2scf->concurrent_pushes;\n-    h2c->priority_limit = h2scf->concurrent_streams;\n+    h2c->priority_limit = ngx_max(h2scf->concurrent_streams, 100);\n \n     h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);\n     if (h2c->pool == NULL) {\n"
    },
    {
        "commit_sha": "e01b386381b3f1947e9c11da761e0709e3898951",
        "commit_index": "Commit 85",
        "commit_diff": "Diff:\n@@ -458,3 +458,4 @@ dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n+da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019009\n-#define NGINX_VERSION      \"1.19.9\"\n+#define nginx_version      1019010\n+#define NGINX_VERSION      \"1.19.10\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -56,7 +56,7 @@ typedef struct {\n     unsigned             done:1;\n     unsigned             nomem:1;\n     unsigned             buffering:1;\n-    unsigned             intel:1;\n+    unsigned             zlib_ng:1;\n \n     size_t               zin;\n     size_t               zout;\n@@ -213,7 +213,7 @@ static ngx_str_t  ngx_http_gzip_ratio = ngx_string(\"gzip_ratio\");\n static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;\n static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;\n \n-static ngx_uint_t  ngx_http_gzip_assume_intel;\n+static ngx_uint_t  ngx_http_gzip_assume_zlib_ng;\n \n \n static ngx_int_t\n@@ -501,28 +501,30 @@ ngx_http_gzip_filter_memory(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)\n      * 8K is for zlib deflate_state, it takes\n      *  *) 5816 bytes on i386 and sparc64 (32-bit mode)\n      *  *) 5920 bytes on amd64 and sparc64\n+     *\n+     * A zlib variant from Intel (https://github.com/jtkukunas/zlib)\n+     * uses additional 16-byte padding in one of window-sized buffers.\n      */\n \n-    if (!ngx_http_gzip_assume_intel) {\n-        ctx->allocated = 8192 + (1 << (wbits + 2)) + (1 << (memlevel + 9));\n+    if (!ngx_http_gzip_assume_zlib_ng) {\n+        ctx->allocated = 8192 + 16 + (1 << (wbits + 2))\n+                         + (1 << (memlevel + 9));\n \n     } else {\n         /*\n-         * A zlib variant from Intel, https://github.com/jtkukunas/zlib.\n-         * It can force window bits to 13 for fast compression level,\n-         * on processors with SSE 4.2 it uses 64K hash instead of scaling\n-         * it from the specified memory level, and also introduces\n-         * 16-byte padding in one out of the two window-sized buffers.\n+         * Another zlib variant, https://github.com/zlib-ng/zlib-ng.\n+         * It forces window bits to 13 for fast compression level,\n+         * uses 16-byte padding in one of window-sized buffers, and\n+         * uses 128K hash.\n          */\n \n         if (conf->level == 1) {\n             wbits = ngx_max(wbits, 13);\n         }\n \n         ctx->allocated = 8192 + 16 + (1 << (wbits + 2))\n-                         + (1 << (ngx_max(memlevel, 8) + 8))\n-                         + (1 << (memlevel + 8));\n-        ctx->intel = 1;\n+                         + 131072 + (1 << (memlevel + 8));\n+        ctx->zlib_ng = 1;\n     }\n }\n \n@@ -945,13 +947,13 @@ ngx_http_gzip_filter_alloc(void *opaque, u_int items, u_int size)\n         return p;\n     }\n \n-    if (ctx->intel) {\n+    if (ctx->zlib_ng) {\n         ngx_log_error(NGX_LOG_ALERT, ctx->request->connection->log, 0,\n                       \"gzip filter failed to use preallocated memory: \"\n                       \"%ud of %ui\", items * size, ctx->allocated);\n \n     } else {\n-        ngx_http_gzip_assume_intel = 1;\n+        ngx_http_gzip_assume_zlib_ng = 1;\n     }\n \n     p = ngx_palloc(ctx->request->pool, items * size);\n"
    },
    {
        "commit_sha": "6427fa365645a6bac84bbdbaa5c2ff57cf49d83a",
        "commit_index": "Commit 84",
        "commit_diff": "Diff:\n@@ -5,6 +5,68 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.9\" date=\"2021-03-30\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не собирался с почтовым прокси-сервером,\n+но без модуля ngx_mail_ssl_module;\n+ошибка появилась в 1.19.8.\n+</para>\n+<para lang=\"en\">\n+nginx could not be built with the mail proxy module,\n+but without the ngx_mail_ssl_module;\n+the bug had appeared in 1.19.8.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при работе с gRPC-бэкендами могли возникать ошибки\n+\"upstream sent response body larger than indicated content length\";\n+ошибка появилась в 1.19.1.\n+</para>\n+<para lang=\"en\">\n+\"upstream sent response body larger than indicated content length\"\n+errors might occur when working with gRPC backends;\n+the bug had appeared in 1.19.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если клиент закрывал соединение в момент отбрасывания тела запроса,\n+nginx мог не закрыть соединение до истечения keepalive-таймаута.\n+</para>\n+<para lang=\"en\">\n+nginx might not close a connection till keepalive timeout expiration\n+if the connection was closed by the client while discarding the request body.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при ожидании задержки limit_req или auth_delay, а также при работе с бэкендами\n+nginx мог не обнаружить, что соединение уже закрыто клиентом.\n+</para>\n+<para lang=\"en\">\n+nginx might not detect that a connection was already closed by the client\n+when waiting for auth_delay or limit_req delay, or when working with backends.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в методе обработки соединений eventport.\n+</para>\n+<para lang=\"en\">\n+in the eventport method.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.8\" date=\"2021-03-09\">\n \n <change type=\"feature\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1j\n+OPENSSL =\topenssl-1.1.1k\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -310,8 +310,13 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n \n     r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_DELAYED;\n \n-    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    if (r->connection->read->ready) {\n+        ngx_post_event(r->connection->read, &ngx_posted_events);\n+\n+    } else {\n+        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n     }\n \n     r->read_event_handler = ngx_http_test_reading;\nDiff:\n@@ -1190,8 +1190,13 @@ ngx_http_core_auth_delay(ngx_http_request_t *r)\n     ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                   \"delaying unauthorized request\");\n \n-    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    if (r->connection->read->ready) {\n+        ngx_post_event(r->connection->read, &ngx_posted_events);\n+\n+    } else {\n+        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n     }\n \n     r->read_event_handler = ngx_http_test_reading;\nDiff:\n@@ -608,9 +608,14 @@ ngx_http_upstream_init_request(ngx_http_request_t *r)\n \n     if (!u->store && !r->post_action && !u->conf->ignore_client_abort) {\n \n-        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n-            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-            return;\n+        if (r->connection->read->ready) {\n+            ngx_post_event(r->connection->read, &ngx_posted_events);\n+\n+        } else {\n+            if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+                return;\n+            }\n         }\n \n         r->read_event_handler = ngx_http_upstream_rd_check_broken_connection;\n"
    },
    {
        "commit_sha": "eb445eef09f765a70688f8208f16b036b8a90006",
        "commit_index": "Commit 83",
        "commit_diff": "Diff:\n@@ -1563,13 +1563,28 @@ ngx_resolver_udp_read(ngx_event_t *rev)\n     do {\n         n = ngx_udp_recv(c, buf, NGX_RESOLVER_UDP_SIZE);\n \n-        if (n < 0) {\n-            return;\n+        if (n == NGX_AGAIN) {\n+            break;\n+        }\n+\n+        if (n == NGX_ERROR) {\n+            goto failed;\n         }\n \n         ngx_resolver_process_response(rec->resolver, buf, n, 0);\n \n     } while (rev->ready);\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    return;\n+\n+failed:\n+\n+    ngx_close_connection(rec->udp);\n+    rec->udp = NULL;\n }\n \n \nDiff:\n@@ -399,7 +399,7 @@ ngx_eventport_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)\n             return NGX_ERROR;\n         }\n \n-    } else {\n+    } else if (ev->active) {\n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ev->log, 0,\n                        \"eventport del event: fd:%d\", c->fd);\n \nDiff:\n@@ -607,6 +607,12 @@ ngx_http_upstream_init_request(ngx_http_request_t *r)\n     u->store = u->conf->store;\n \n     if (!u->store && !r->post_action && !u->conf->ignore_client_abort) {\n+\n+        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+\n         r->read_event_handler = ngx_http_upstream_rd_check_broken_connection;\n         r->write_event_handler = ngx_http_upstream_wr_check_broken_connection;\n     }\n@@ -3011,9 +3017,7 @@ ngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)\n                 return;\n             }\n \n-            if (u->peer.connection->read->ready || u->length == 0) {\n-                ngx_http_upstream_process_non_buffered_upstream(r, u);\n-            }\n+            ngx_http_upstream_process_non_buffered_upstream(r, u);\n         }\n \n         return;\n"
    },
    {
        "commit_sha": "0c261e83a537d3a7304bc30cd6e43e6b1bf63532",
        "commit_index": "Commit 82",
        "commit_diff": "Diff:\n@@ -257,9 +257,7 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n         ngx_shmtx_unlock(&ngx_accept_mutex);\n     }\n \n-    if (delta) {\n-        ngx_event_expire_timers();\n-    }\n+    ngx_event_expire_timers();\n \n     ngx_event_process_posted(cycle, &ngx_posted_events);\n }\nDiff:\n@@ -2662,11 +2662,6 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n         ngx_del_timer(c->write);\n     }\n \n-    if (c->read->eof) {\n-        ngx_http_close_request(r, 0);\n-        return;\n-    }\n-\n     ngx_http_finalize_connection(r);\n }\n \n@@ -2765,6 +2760,11 @@ ngx_http_finalize_connection(ngx_http_request_t *r)\n \n     r = r->main;\n \n+    if (r->connection->read->eof) {\n+        ngx_http_close_request(r, 0);\n+        return;\n+    }\n+\n     if (r->reading_body) {\n         r->keepalive = 0;\n         r->lingering_close = 1;\nDiff:\n@@ -1368,7 +1368,9 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n     clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n                                         ngx_http_core_module);\n \n-    if (h2c->connection->requests >= clcf->keepalive_requests) {\n+    if (clcf->keepalive_timeout == 0\n+        || h2c->connection->requests >= clcf->keepalive_requests)\n+    {\n         h2c->goaway = 1;\n \n         if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n"
    },
    {
        "commit_sha": "8800bfab7df046cfc66021ceaecc6c60e17a4aaa",
        "commit_index": "Commit 81",
        "commit_diff": "Diff:\n@@ -457,3 +457,4 @@ dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n 8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\n f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n+8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\nDiff:\n@@ -985,6 +985,12 @@ if [ $MAIL != NO ]; then\n     ngx_module_srcs=src/mail/ngx_mail_proxy_module.c\n \n     . auto/module\n+\n+    ngx_module_name=ngx_mail_realip_module\n+    ngx_module_deps=\n+    ngx_module_srcs=src/mail/ngx_mail_realip_module.c\n+\n+    . auto/module\n fi\n \n \nDiff:\n@@ -5,6 +5,68 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.8\" date=\"2021-03-09\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+в директиве proxy_cookie_flags теперь\n+флаги можно задавать с помощью переменных.\n+</para>\n+<para lang=\"en\">\n+flags in the \"proxy_cookie_flags\" directive\n+can now contain variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+параметр proxy_protocol в директиве listen,\n+директивы proxy_protocol и set_real_ip_from\n+в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_protocol\" parameter of the \"listen\" directive,\n+the \"proxy_protocol\" and \"set_real_ip_from\" directives\n+in mail proxy.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+HTTP/2-соединения сразу закрывались\n+при использовании \"keepalive_timeout 0\";\n+ошибка появилась в 1.19.7.\n+</para>\n+<para lang=\"en\">\n+HTTP/2 connections were immediately closed\n+when using \"keepalive_timeout 0\";\n+the bug had appeared in 1.19.7.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+некоторые ошибки логгировались как неизвестные,\n+если nginx был собран с glibc 2.32.\n+</para>\n+<para lang=\"en\">\n+some errors were logged as unknown\n+if nginx was built with glibc 2.32.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в методе обработки соединений eventport.\n+</para>\n+<para lang=\"en\">\n+in the eventport method.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.7\" date=\"2021-02-16\">\n \n <change type=\"change\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1i\n+OPENSSL =\topenssl-1.1.1j\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019008\n-#define NGINX_VERSION      \"1.19.8\"\n+#define nginx_version      1019009\n+#define NGINX_VERSION      \"1.19.9\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -2074,17 +2074,6 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                     return NGX_ERROR;\n                 }\n \n-                if (ctx->length != -1) {\n-                    if ((off_t) ctx->rest > ctx->length) {\n-                        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                                      \"upstream sent response body larger \"\n-                                      \"than indicated content length\");\n-                        return NGX_ERROR;\n-                    }\n-\n-                    ctx->length -= ctx->rest;\n-                }\n-\n                 if (ctx->rest > ctx->recv_window) {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                                   \"upstream violated stream flow control, \"\n@@ -2450,13 +2439,37 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n             b->pos = b->last;\n             buf->last = b->pos;\n \n+            if (ctx->length != -1) {\n+\n+                if (buf->last - buf->pos > ctx->length) {\n+                    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                  \"upstream sent response body larger \"\n+                                  \"than indicated content length\");\n+                    return NGX_ERROR;\n+                }\n+\n+                ctx->length -= buf->last - buf->pos;\n+            }\n+\n             return NGX_AGAIN;\n         }\n \n         b->pos += ctx->rest - ctx->padding;\n         buf->last = b->pos;\n         ctx->rest = ctx->padding;\n \n+        if (ctx->length != -1) {\n+\n+            if (buf->last - buf->pos > ctx->length) {\n+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                              \"upstream sent response body larger \"\n+                              \"than indicated content length\");\n+                return NGX_ERROR;\n+            }\n+\n+            ctx->length -= buf->last - buf->pos;\n+        }\n+\n     done:\n \n         if (ctx->padding) {\nDiff:\n@@ -405,6 +405,7 @@ ngx_mail_add_addrs(ngx_conf_t *cf, ngx_mail_port_t *mport,\n #if (NGX_MAIL_SSL)\n         addrs[i].conf.ssl = addr[i].opt.ssl;\n #endif\n+        addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;\n         addrs[i].conf.addr_text = addr[i].opt.addr_text;\n     }\n \n@@ -439,6 +440,7 @@ ngx_mail_add_addrs6(ngx_conf_t *cf, ngx_mail_port_t *mport,\n #if (NGX_MAIL_SSL)\n         addrs6[i].conf.ssl = addr[i].opt.ssl;\n #endif\n+        addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;\n         addrs6[i].conf.addr_text = addr[i].opt.addr_text;\n     }\n \nDiff:\n@@ -41,6 +41,7 @@ typedef struct {\n     unsigned                ipv6only:1;\n #endif\n     unsigned                so_keepalive:2;\n+    unsigned                proxy_protocol:1;\n #if (NGX_HAVE_KEEPALIVE_TUNABLE)\n     int                     tcp_keepidle;\n     int                     tcp_keepintvl;\n@@ -55,7 +56,8 @@ typedef struct {\n typedef struct {\n     ngx_mail_conf_ctx_t    *ctx;\n     ngx_str_t               addr_text;\n-    ngx_uint_t              ssl;    /* unsigned   ssl:1; */\n+    unsigned                ssl:1;\n+    unsigned                proxy_protocol:1;\n } ngx_mail_addr_conf_t;\n \n typedef struct {\n@@ -176,6 +178,7 @@ typedef enum {\n typedef struct {\n     ngx_peer_connection_t   upstream;\n     ngx_buf_t              *buffer;\n+    ngx_uint_t              proxy_protocol;  /* unsigned  proxy_protocol:1; */\n } ngx_mail_proxy_ctx_t;\n \n \n@@ -406,6 +409,7 @@ char *ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n /* STUB */\n void ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer);\n void ngx_mail_auth_http_init(ngx_mail_session_t *s);\n+ngx_int_t ngx_mail_realip_handler(ngx_mail_session_t *s);\n /**/\n \n \nDiff:\n@@ -1135,10 +1135,10 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n     size_t                     len;\n     ngx_buf_t                 *b;\n     ngx_str_t                  login, passwd;\n+    ngx_connection_t          *c;\n #if (NGX_MAIL_SSL)\n     ngx_str_t                  verify, subject, issuer, serial, fingerprint,\n                                raw_cert, cert;\n-    ngx_connection_t          *c;\n     ngx_mail_ssl_conf_t       *sslcf;\n #endif\n     ngx_mail_core_srv_conf_t  *cscf;\n@@ -1151,9 +1151,10 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n         return NULL;\n     }\n \n+    c = s->connection;\n+\n #if (NGX_MAIL_SSL)\n \n-    c = s->connection;\n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n     if (c->ssl && sslcf->verify) {\n@@ -1227,6 +1228,17 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n           + ahcf->header.len\n           + sizeof(CRLF) - 1;\n \n+    if (c->proxy_protocol) {\n+        len += sizeof(\"Proxy-Protocol-Addr: \") - 1\n+                     + c->proxy_protocol->src_addr.len + sizeof(CRLF) - 1\n+               + sizeof(\"Proxy-Protocol-Port: \") - 1\n+                     + sizeof(\"65535\") - 1 + sizeof(CRLF) - 1\n+               + sizeof(\"Proxy-Protocol-Server-Addr: \") - 1\n+                     + c->proxy_protocol->dst_addr.len + sizeof(CRLF) - 1\n+               + sizeof(\"Proxy-Protocol-Server-Port: \") - 1\n+                     + sizeof(\"65535\") - 1 + sizeof(CRLF) - 1;\n+    }\n+\n     if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n         len += sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len\n                      + sizeof(CRLF) - 1\n@@ -1314,6 +1326,26 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n         *b->last++ = CR; *b->last++ = LF;\n     }\n \n+    if (c->proxy_protocol) {\n+        b->last = ngx_cpymem(b->last, \"Proxy-Protocol-Addr: \",\n+                             sizeof(\"Proxy-Protocol-Addr: \") - 1);\n+        b->last = ngx_copy(b->last, c->proxy_protocol->src_addr.data,\n+                           c->proxy_protocol->src_addr.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+        b->last = ngx_sprintf(b->last, \"Proxy-Protocol-Port: %d\" CRLF,\n+                              c->proxy_protocol->src_port);\n+\n+        b->last = ngx_cpymem(b->last, \"Proxy-Protocol-Server-Addr: \",\n+                             sizeof(\"Proxy-Protocol-Server-Addr: \") - 1);\n+        b->last = ngx_copy(b->last, c->proxy_protocol->dst_addr.data,\n+                           c->proxy_protocol->dst_addr.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+        b->last = ngx_sprintf(b->last, \"Proxy-Protocol-Server-Port: %d\" CRLF,\n+                              c->proxy_protocol->dst_port);\n+    }\n+\n     if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n \n         /* HELO, MAIL FROM, and RCPT TO can't contain CRLF, no need to escape */\nDiff:\n@@ -548,6 +548,11 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n         }\n \n+        if (ngx_strcmp(value[i].data, \"proxy_protocol\") == 0) {\n+            ls->proxy_protocol = 1;\n+            continue;\n+        }\n+\n         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                            \"the invalid \\\"%V\\\" parameter\", &value[i]);\n         return NGX_CONF_ERROR;\nDiff:\n@@ -11,6 +11,7 @@\n #include <ngx_mail.h>\n \n \n+static void ngx_mail_proxy_protocol_handler(ngx_event_t *rev);\n static void ngx_mail_init_session_handler(ngx_event_t *rev);\n static void ngx_mail_init_session(ngx_connection_t *c);\n \n@@ -168,6 +169,22 @@ ngx_mail_init_connection(ngx_connection_t *c)\n     rev = c->read;\n     rev->handler = ngx_mail_init_session_handler;\n \n+    if (addr_conf->proxy_protocol) {\n+        c->log->action = \"reading PROXY protocol\";\n+\n+        rev->handler = ngx_mail_proxy_protocol_handler;\n+\n+        if (!rev->ready) {\n+            ngx_add_timer(rev, cscf->timeout);\n+\n+            if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+                ngx_mail_close_connection(c);\n+            }\n+\n+            return;\n+        }\n+    }\n+\n     if (ngx_use_accept_mutex) {\n         ngx_post_event(rev, &ngx_posted_events);\n         return;\n@@ -178,18 +195,94 @@ ngx_mail_init_connection(ngx_connection_t *c)\n \n \n static void\n-ngx_mail_init_session_handler(ngx_event_t *rev)\n+ngx_mail_proxy_protocol_handler(ngx_event_t *rev)\n {\n-    ngx_connection_t    *c;\n-    ngx_mail_session_t  *s;\n+    u_char                    *p, buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+    size_t                     size;\n+    ssize_t                    n;\n+    ngx_err_t                  err;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n \n     c = rev->data;\n     s = c->data;\n \n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail PROXY protocol handler\");\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    n = recv(c->fd, (char *) buf, sizeof(buf), MSG_PEEK);\n+\n+    err = ngx_socket_errno;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, \"recv(): %z\", n);\n+\n+    if (n == -1) {\n+        if (err == NGX_EAGAIN) {\n+            rev->ready = 0;\n+\n+            if (!rev->timer_set) {\n+                cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+                ngx_add_timer(rev, cscf->timeout);\n+            }\n+\n+            if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+                ngx_mail_close_connection(c);\n+            }\n+\n+            return;\n+        }\n+\n+        ngx_connection_error(c, err, \"recv() failed\");\n+\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    p = ngx_proxy_protocol_read(c, buf, buf + n);\n+\n+    if (p == NULL) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    size = p - buf;\n+\n+    if (c->recv(c, buf, size) != (ssize_t) size) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (ngx_mail_realip_handler(s) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    ngx_mail_init_session_handler(rev);\n+}\n+\n+\n+static void\n+ngx_mail_init_session_handler(ngx_event_t *rev)\n+{\n+    ngx_connection_t  *c;\n+\n+    c = rev->data;\n+\n #if (NGX_MAIL_SSL)\n     {\n+    ngx_mail_session_t   *s;\n     ngx_mail_ssl_conf_t  *sslcf;\n \n+    s = c->data;\n+\n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n     if (sslcf->enable || s->ssl) {\n@@ -242,9 +335,10 @@ ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)\n \n         s = c->data;\n \n-        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n-\n-        ngx_add_timer(c->read, cscf->timeout);\n+        if (!c->read->timer_set) {\n+            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+            ngx_add_timer(c->read, cscf->timeout);\n+        }\n \n         c->ssl->handler = ngx_mail_ssl_handshake_handler;\n \nDiff:\n@@ -17,6 +17,7 @@ typedef struct {\n     ngx_flag_t  pass_error_message;\n     ngx_flag_t  xclient;\n     ngx_flag_t  smtp_auth;\n+    ngx_flag_t  proxy_protocol;\n     size_t      buffer_size;\n     ngx_msec_t  timeout;\n } ngx_mail_proxy_conf_t;\n@@ -26,7 +27,8 @@ static void ngx_mail_proxy_block_read(ngx_event_t *rev);\n static void ngx_mail_proxy_pop3_handler(ngx_event_t *rev);\n static void ngx_mail_proxy_imap_handler(ngx_event_t *rev);\n static void ngx_mail_proxy_smtp_handler(ngx_event_t *rev);\n-static void ngx_mail_proxy_dummy_handler(ngx_event_t *ev);\n+static void ngx_mail_proxy_write_handler(ngx_event_t *wev);\n+static ngx_int_t ngx_mail_proxy_send_proxy_protocol(ngx_mail_session_t *s);\n static ngx_int_t ngx_mail_proxy_read_response(ngx_mail_session_t *s,\n     ngx_uint_t state);\n static void ngx_mail_proxy_handler(ngx_event_t *ev);\n@@ -82,6 +84,13 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {\n       offsetof(ngx_mail_proxy_conf_t, smtp_auth),\n       NULL },\n \n+    { ngx_string(\"proxy_protocol\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, proxy_protocol),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -156,7 +165,7 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n     p->upstream.connection->pool = s->connection->pool;\n \n     s->connection->read->handler = ngx_mail_proxy_block_read;\n-    p->upstream.connection->write->handler = ngx_mail_proxy_dummy_handler;\n+    p->upstream.connection->write->handler = ngx_mail_proxy_write_handler;\n \n     pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n \n@@ -167,6 +176,8 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n         return;\n     }\n \n+    s->proxy->proxy_protocol = pcf->proxy_protocol;\n+\n     s->out.len = 0;\n \n     switch (s->protocol) {\n@@ -186,6 +197,12 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n         s->mail_state = ngx_smtp_start;\n         break;\n     }\n+\n+    if (rc == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    ngx_mail_proxy_write_handler(p->upstream.connection->write);\n }\n \n \n@@ -230,6 +247,17 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (s->proxy->proxy_protocol) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"mail proxy pop3 busy\");\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n     rc = ngx_mail_proxy_read_response(s, 0);\n \n     if (rc == NGX_AGAIN) {\n@@ -353,6 +381,17 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (s->proxy->proxy_protocol) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"mail proxy imap busy\");\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n@@ -499,6 +538,17 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (s->proxy->proxy_protocol) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"mail proxy smtp busy\");\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n@@ -799,19 +849,92 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n \n \n static void\n-ngx_mail_proxy_dummy_handler(ngx_event_t *wev)\n+ngx_mail_proxy_write_handler(ngx_event_t *wev)\n {\n     ngx_connection_t    *c;\n     ngx_mail_session_t  *s;\n \n-    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0, \"mail proxy dummy handler\");\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0, \"mail proxy write handler\");\n+\n+    c = wev->data;\n+    s = c->data;\n+\n+    if (s->proxy->proxy_protocol) {\n+        if (ngx_mail_proxy_send_proxy_protocol(s) != NGX_OK) {\n+            return;\n+        }\n+\n+        s->proxy->proxy_protocol = 0;\n+    }\n \n     if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n-        c = wev->data;\n-        s = c->data;\n+        ngx_mail_proxy_internal_server_error(s);\n+    }\n \n-        ngx_mail_proxy_close_session(s);\n+    if (c->read->ready) {\n+        ngx_post_event(c->read, &ngx_posted_events);\n+    }\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_proxy_send_proxy_protocol(ngx_mail_session_t *s)\n+{\n+    u_char            *p;\n+    ssize_t            n, size;\n+    ngx_connection_t  *c;\n+    u_char             buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+\n+    s->connection->log->action = \"sending PROXY protocol header to upstream\";\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                   \"mail proxy send PROXY protocol header\");\n+\n+    p = ngx_proxy_protocol_write(s->connection, buf,\n+                                 buf + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+    if (p == NULL) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    c = s->proxy->upstream.connection;\n+\n+    size = p - buf;\n+\n+    n = c->send(c, buf, size);\n+\n+    if (n == NGX_AGAIN) {\n+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return NGX_ERROR;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    if (n == NGX_ERROR) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    if (n != size) {\n+\n+        /*\n+         * PROXY protocol specification:\n+         * The sender must always ensure that the header\n+         * is sent at once, so that the transport layer\n+         * maintains atomicity along the path to the receiver.\n+         */\n+\n+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                      \"could not send PROXY protocol header at once\");\n+\n+        ngx_mail_proxy_internal_server_error(s);\n+\n+        return NGX_ERROR;\n     }\n+\n+    return NGX_OK;\n }\n \n \n@@ -1212,6 +1335,7 @@ ngx_mail_proxy_create_conf(ngx_conf_t *cf)\n     pcf->pass_error_message = NGX_CONF_UNSET;\n     pcf->xclient = NGX_CONF_UNSET;\n     pcf->smtp_auth = NGX_CONF_UNSET;\n+    pcf->proxy_protocol = NGX_CONF_UNSET;\n     pcf->buffer_size = NGX_CONF_UNSET_SIZE;\n     pcf->timeout = NGX_CONF_UNSET_MSEC;\n \n@@ -1229,6 +1353,7 @@ ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);\n     ngx_conf_merge_value(conf->xclient, prev->xclient, 1);\n     ngx_conf_merge_value(conf->smtp_auth, prev->smtp_auth, 0);\n+    ngx_conf_merge_value(conf->proxy_protocol, prev->proxy_protocol, 0);\n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n                               (size_t) ngx_pagesize);\n     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);\nDiff:\n@@ -0,0 +1,269 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+\n+\n+typedef struct {\n+    ngx_array_t       *from;     /* array of ngx_cidr_t */\n+} ngx_mail_realip_srv_conf_t;\n+\n+\n+static ngx_int_t ngx_mail_realip_set_addr(ngx_mail_session_t *s,\n+    ngx_addr_t *addr);\n+static char *ngx_mail_realip_from(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static void *ngx_mail_realip_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_mail_realip_merge_srv_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+\n+\n+static ngx_command_t  ngx_mail_realip_commands[] = {\n+\n+    { ngx_string(\"set_real_ip_from\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_mail_realip_from,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_realip_module_ctx = {\n+    NULL,                                  /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_realip_create_srv_conf,       /* create server configuration */\n+    ngx_mail_realip_merge_srv_conf         /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_realip_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_realip_module_ctx,           /* module context */\n+    ngx_mail_realip_commands,              /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+ngx_int_t\n+ngx_mail_realip_handler(ngx_mail_session_t *s)\n+{\n+    ngx_addr_t                   addr;\n+    ngx_connection_t            *c;\n+    ngx_mail_realip_srv_conf_t  *rscf;\n+\n+    rscf = ngx_mail_get_module_srv_conf(s, ngx_mail_realip_module);\n+\n+    if (rscf->from == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    c = s->connection;\n+\n+    if (c->proxy_protocol == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data,\n+                       c->proxy_protocol->src_addr.len)\n+        != NGX_OK)\n+    {\n+        return NGX_OK;\n+    }\n+\n+    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n+\n+    return ngx_mail_realip_set_addr(s, &addr);\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_realip_set_addr(ngx_mail_session_t *s, ngx_addr_t *addr)\n+{\n+    size_t             len;\n+    u_char            *p;\n+    u_char             text[NGX_SOCKADDR_STRLEN];\n+    ngx_connection_t  *c;\n+\n+    c = s->connection;\n+\n+    len = ngx_sock_ntop(addr->sockaddr, addr->socklen, text,\n+                        NGX_SOCKADDR_STRLEN, 0);\n+    if (len == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_pnalloc(c->pool, len);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(p, text, len);\n+\n+    c->sockaddr = addr->sockaddr;\n+    c->socklen = addr->socklen;\n+    c->addr_text.len = len;\n+    c->addr_text.data = p;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_realip_from(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_realip_srv_conf_t *rscf = conf;\n+\n+    ngx_int_t             rc;\n+    ngx_str_t            *value;\n+    ngx_url_t             u;\n+    ngx_cidr_t            c, *cidr;\n+    ngx_uint_t            i;\n+    struct sockaddr_in   *sin;\n+#if (NGX_HAVE_INET6)\n+    struct sockaddr_in6  *sin6;\n+#endif\n+\n+    value = cf->args->elts;\n+\n+    if (rscf->from == NULL) {\n+        rscf->from = ngx_array_create(cf->pool, 2,\n+                                      sizeof(ngx_cidr_t));\n+        if (rscf->from == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+\n+    if (ngx_strcmp(value[1].data, \"unix:\") == 0) {\n+        cidr = ngx_array_push(rscf->from);\n+        if (cidr == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        cidr->family = AF_UNIX;\n+        return NGX_CONF_OK;\n+    }\n+\n+#endif\n+\n+    rc = ngx_ptocidr(&value[1], &c);\n+\n+    if (rc != NGX_ERROR) {\n+        if (rc == NGX_DONE) {\n+            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                               \"low address bits of %V are meaningless\",\n+                               &value[1]);\n+        }\n+\n+        cidr = ngx_array_push(rscf->from);\n+        if (cidr == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        *cidr = c;\n+\n+        return NGX_CONF_OK;\n+    }\n+\n+    ngx_memzero(&u, sizeof(ngx_url_t));\n+    u.host = value[1];\n+\n+    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {\n+        if (u.err) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"%s in set_real_ip_from \\\"%V\\\"\",\n+                               u.err, &u.host);\n+        }\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cidr = ngx_array_push_n(rscf->from, u.naddrs);\n+    if (cidr == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ngx_memzero(cidr, u.naddrs * sizeof(ngx_cidr_t));\n+\n+    for (i = 0; i < u.naddrs; i++) {\n+        cidr[i].family = u.addrs[i].sockaddr->sa_family;\n+\n+        switch (cidr[i].family) {\n+\n+#if (NGX_HAVE_INET6)\n+        case AF_INET6:\n+            sin6 = (struct sockaddr_in6 *) u.addrs[i].sockaddr;\n+            cidr[i].u.in6.addr = sin6->sin6_addr;\n+            ngx_memset(cidr[i].u.in6.mask.s6_addr, 0xff, 16);\n+            break;\n+#endif\n+\n+        default: /* AF_INET */\n+            sin = (struct sockaddr_in *) u.addrs[i].sockaddr;\n+            cidr[i].u.in.addr = sin->sin_addr.s_addr;\n+            cidr[i].u.in.mask = 0xffffffff;\n+            break;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static void *\n+ngx_mail_realip_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_realip_srv_conf_t  *conf;\n+\n+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_realip_srv_conf_t));\n+    if (conf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc():\n+     *\n+     *     conf->from = NULL;\n+     */\n+\n+    return conf;\n+}\n+\n+\n+static char *\n+ngx_mail_realip_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_realip_srv_conf_t *prev = parent;\n+    ngx_mail_realip_srv_conf_t *conf = child;\n+\n+    if (conf->from == NULL) {\n+        conf->from = prev->from;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -15,7 +15,7 @@ static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,\n     ngx_int_t type);\n static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,\n     ngx_uint_t respawn);\n-static void ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch);\n+static void ngx_pass_open_channel(ngx_cycle_t *cycle);\n static void ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo);\n static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle);\n static void ngx_master_process_exit(ngx_cycle_t *cycle);\n@@ -335,35 +335,25 @@ ngx_single_process_cycle(ngx_cycle_t *cycle)\n static void\n ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)\n {\n-    ngx_int_t      i;\n-    ngx_channel_t  ch;\n+    ngx_int_t  i;\n \n     ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"start worker processes\");\n \n-    ngx_memzero(&ch, sizeof(ngx_channel_t));\n-\n-    ch.command = NGX_CMD_OPEN_CHANNEL;\n-\n     for (i = 0; i < n; i++) {\n \n         ngx_spawn_process(cycle, ngx_worker_process_cycle,\n                           (void *) (intptr_t) i, \"worker process\", type);\n \n-        ch.pid = ngx_processes[ngx_process_slot].pid;\n-        ch.slot = ngx_process_slot;\n-        ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-        ngx_pass_open_channel(cycle, &ch);\n+        ngx_pass_open_channel(cycle);\n     }\n }\n \n \n static void\n ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n {\n-    ngx_uint_t       i, manager, loader;\n-    ngx_path_t     **path;\n-    ngx_channel_t    ch;\n+    ngx_uint_t    i, manager, loader;\n+    ngx_path_t  **path;\n \n     manager = 0;\n     loader = 0;\n@@ -388,14 +378,7 @@ ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n                       &ngx_cache_manager_ctx, \"cache manager process\",\n                       respawn ? NGX_PROCESS_JUST_RESPAWN : NGX_PROCESS_RESPAWN);\n \n-    ngx_memzero(&ch, sizeof(ngx_channel_t));\n-\n-    ch.command = NGX_CMD_OPEN_CHANNEL;\n-    ch.pid = ngx_processes[ngx_process_slot].pid;\n-    ch.slot = ngx_process_slot;\n-    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-    ngx_pass_open_channel(cycle, &ch);\n+    ngx_pass_open_channel(cycle);\n \n     if (loader == 0) {\n         return;\n@@ -405,19 +388,20 @@ ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n                       &ngx_cache_loader_ctx, \"cache loader process\",\n                       respawn ? NGX_PROCESS_JUST_SPAWN : NGX_PROCESS_NORESPAWN);\n \n-    ch.command = NGX_CMD_OPEN_CHANNEL;\n-    ch.pid = ngx_processes[ngx_process_slot].pid;\n-    ch.slot = ngx_process_slot;\n-    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-    ngx_pass_open_channel(cycle, &ch);\n+    ngx_pass_open_channel(cycle);\n }\n \n \n static void\n-ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)\n+ngx_pass_open_channel(ngx_cycle_t *cycle)\n {\n-    ngx_int_t  i;\n+    ngx_int_t      i;\n+    ngx_channel_t  ch;\n+\n+    ch.command = NGX_CMD_OPEN_CHANNEL;\n+    ch.pid = ngx_processes[ngx_process_slot].pid;\n+    ch.slot = ngx_process_slot;\n+    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n \n     for (i = 0; i < ngx_last_process; i++) {\n \n@@ -430,14 +414,14 @@ ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)\n \n         ngx_log_debug6(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n                       \"pass channel s:%i pid:%P fd:%d to s:%i pid:%P fd:%d\",\n-                      ch->slot, ch->pid, ch->fd,\n+                      ch.slot, ch.pid, ch.fd,\n                       i, ngx_processes[i].pid,\n                       ngx_processes[i].channel[0]);\n \n         /* TODO: NGX_AGAIN */\n \n         ngx_write_channel(ngx_processes[i].channel[0],\n-                          ch, sizeof(ngx_channel_t), cycle->log);\n+                          &ch, sizeof(ngx_channel_t), cycle->log);\n     }\n }\n \n@@ -621,12 +605,7 @@ ngx_reap_children(ngx_cycle_t *cycle)\n                 }\n \n \n-                ch.command = NGX_CMD_OPEN_CHANNEL;\n-                ch.pid = ngx_processes[ngx_process_slot].pid;\n-                ch.slot = ngx_process_slot;\n-                ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-                ngx_pass_open_channel(cycle, &ch);\n+                ngx_pass_open_channel(cycle);\n \n                 live = 1;\n \n"
    },
    {
        "commit_sha": "5d6fe736bc87bcd1e923e853efbd7c81ba54ac4d",
        "commit_index": "Commit 80",
        "commit_diff": "Diff:\n@@ -197,6 +197,7 @@ typedef struct {\n \n     ngx_uint_t              mail_state;\n \n+    unsigned                ssl:1;\n     unsigned                protocol:3;\n     unsigned                blocked:1;\n     unsigned                quit:1;\nDiff:\n@@ -1224,22 +1224,38 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n           + sizeof(\"Client-IP: \") - 1 + s->connection->addr_text.len\n                 + sizeof(CRLF) - 1\n           + sizeof(\"Client-Host: \") - 1 + s->host.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SMTP-From: \") - 1 + s->smtp_from.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SMTP-To: \") - 1 + s->smtp_to.len + sizeof(CRLF) - 1\n-#if (NGX_MAIL_SSL)\n-          + sizeof(\"Auth-SSL: on\" CRLF) - 1\n-          + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Issuer: \") - 1 + issuer.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Serial: \") - 1 + serial.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Fingerprint: \") - 1 + fingerprint.len\n-              + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Cert: \") - 1 + cert.len + sizeof(CRLF) - 1\n-#endif\n           + ahcf->header.len\n           + sizeof(CRLF) - 1;\n \n+    if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+        len += sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SMTP-From: \") - 1 + s->smtp_from.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SMTP-To: \") - 1 + s->smtp_to.len\n+                     + sizeof(CRLF) - 1;\n+    }\n+\n+#if (NGX_MAIL_SSL)\n+\n+    if (c->ssl) {\n+        len += sizeof(\"Auth-SSL: on\" CRLF) - 1\n+               + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Issuer: \") - 1 + issuer.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Serial: \") - 1 + serial.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Fingerprint: \") - 1 + fingerprint.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Cert: \") - 1 + cert.len\n+                     + sizeof(CRLF) - 1;\n+    }\n+\n+#endif\n+\n     b = ngx_create_temp_buf(pool, len);\n     if (b == NULL) {\n         return NULL;\nDiff:\n@@ -11,6 +11,7 @@\n #include <ngx_mail.h>\n \n \n+static void ngx_mail_init_session_handler(ngx_event_t *rev);\n static void ngx_mail_init_session(ngx_connection_t *c);\n \n #if (NGX_MAIL_SSL)\n@@ -26,6 +27,7 @@ ngx_mail_init_connection(ngx_connection_t *c)\n {\n     size_t                     len;\n     ngx_uint_t                 i;\n+    ngx_event_t               *rev;\n     ngx_mail_port_t           *port;\n     struct sockaddr           *sa;\n     struct sockaddr_in        *sin;\n@@ -129,6 +131,10 @@ ngx_mail_init_connection(ngx_connection_t *c)\n     s->main_conf = addr_conf->ctx->main_conf;\n     s->srv_conf = addr_conf->ctx->srv_conf;\n \n+#if (NGX_MAIL_SSL)\n+    s->ssl = addr_conf->ssl;\n+#endif\n+\n     s->addr_text = &addr_conf->addr_text;\n \n     c->data = s;\n@@ -159,13 +165,34 @@ ngx_mail_init_connection(ngx_connection_t *c)\n \n     c->log_error = NGX_ERROR_INFO;\n \n+    rev = c->read;\n+    rev->handler = ngx_mail_init_session_handler;\n+\n+    if (ngx_use_accept_mutex) {\n+        ngx_post_event(rev, &ngx_posted_events);\n+        return;\n+    }\n+\n+    rev->handler(rev);\n+}\n+\n+\n+static void\n+ngx_mail_init_session_handler(ngx_event_t *rev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n #if (NGX_MAIL_SSL)\n     {\n     ngx_mail_ssl_conf_t  *sslcf;\n \n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n-    if (sslcf->enable || addr_conf->ssl) {\n+    if (sslcf->enable || s->ssl) {\n         c->log->action = \"SSL handshaking\";\n \n         ngx_mail_ssl_init_connection(&sslcf->ssl, c);\n@@ -338,6 +365,8 @@ ngx_mail_init_session(ngx_connection_t *c)\n \n     s = c->data;\n \n+    c->log->action = \"sending client greeting line\";\n+\n     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n \n     s->protocol = cscf->protocol->type;\n"
    },
    {
        "commit_sha": "362a8e1dbcc66f71d7b5799b5043d1d741cc5096",
        "commit_index": "Commit 79",
        "commit_diff": "Diff:\n@@ -722,11 +722,6 @@ ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n     }\n \n     if (n == NGX_AGAIN) {\n-        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-            ngx_mail_session_internal_server_error(s);\n-            return NGX_ERROR;\n-        }\n-\n         if (s->buffer->pos == s->buffer->last) {\n             return NGX_AGAIN;\n         }\nDiff:\n@@ -136,7 +136,16 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n \n     rc = ngx_mail_read_command(s, c);\n \n-    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+    if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n         return;\n     }\n \n@@ -299,6 +308,11 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n         }\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n     ngx_mail_send(c->write);\n }\n \nDiff:\n@@ -151,7 +151,16 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n \n     rc = ngx_mail_read_command(s, c);\n \n-    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+    if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n         return;\n     }\n \n@@ -281,6 +290,11 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n             s->arg_start = s->buffer->start;\n         }\n \n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n         ngx_mail_send(c->write);\n     }\n }\nDiff:\n@@ -233,6 +233,11 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n     rc = ngx_mail_proxy_read_response(s, 0);\n \n     if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n         return;\n     }\n \n@@ -314,6 +319,11 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n     s->proxy->buffer->pos = s->proxy->buffer->start;\n     s->proxy->buffer->last = s->proxy->buffer->start;\n }\n@@ -346,6 +356,11 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n         return;\n     }\n \n@@ -448,6 +463,11 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n     s->proxy->buffer->pos = s->proxy->buffer->start;\n     s->proxy->buffer->last = s->proxy->buffer->start;\n }\n@@ -482,6 +502,11 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n         return;\n     }\n \n@@ -763,6 +788,11 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n     s->proxy->buffer->pos = s->proxy->buffer->start;\n     s->proxy->buffer->last = s->proxy->buffer->start;\n }\nDiff:\n@@ -462,7 +462,16 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n \n     rc = ngx_mail_read_command(s, c);\n \n-    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+    if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n         return;\n     }\n \n@@ -574,6 +583,11 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n             s->arg_start = s->buffer->pos;\n         }\n \n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n         ngx_mail_send(c->write);\n     }\n }\n"
    },
    {
        "commit_sha": "61e477d55ab327a6fa5eb2acbccb4e8343305daf",
        "commit_index": "Commit 78",
        "commit_diff": "Diff:\n@@ -123,6 +123,12 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n     if (s->out.len) {\n         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap send handler busy\");\n         s->blocked = 1;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n         return;\n     }\n \nDiff:\n@@ -138,6 +138,12 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n     if (s->out.len) {\n         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"pop3 send handler busy\");\n         s->blocked = 1;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n         return;\n     }\n \nDiff:\n@@ -449,6 +449,12 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n     if (s->out.len) {\n         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"smtp send handler busy\");\n         s->blocked = 1;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n         return;\n     }\n \n"
    },
    {
        "commit_sha": "e62b66650012ece710ea6b259ba3bde6bd5c3ef3",
        "commit_index": "Commit 77",
        "commit_diff": "Diff:\n@@ -318,7 +318,7 @@ ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags)\n             return NGX_OK;\n         }\n \n-        if (rev->oneshot && !rev->ready) {\n+        if (rev->oneshot && rev->ready) {\n             if (ngx_del_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {\n                 return NGX_ERROR;\n             }\nDiff:\n@@ -4841,9 +4841,9 @@ ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -4913,9 +4913,9 @@ ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -1274,9 +1274,9 @@ ngx_http_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -2398,9 +2398,9 @@ ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -682,7 +682,7 @@ ngx_mail_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\nDiff:\n@@ -1026,9 +1026,9 @@ ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -1061,9 +1061,9 @@ ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \n"
    },
    {
        "commit_sha": "89a48e1ea86dbc02c24570490ed12e32017887a3",
        "commit_index": "Commit 76",
        "commit_diff": "Diff:\n@@ -727,17 +727,33 @@ ngx_feature_test=\"char buf[1]; struct iovec vec[1]; ssize_t n;\n . auto/feature\n \n \n-ngx_feature=\"sys_nerr\"\n-ngx_feature_name=\"NGX_SYS_NERR\"\n-ngx_feature_run=value\n-ngx_feature_incs='#include <errno.h>\n-                  #include <stdio.h>'\n+# strerrordesc_np(), introduced in glibc 2.32\n+\n+ngx_feature=\"strerrordesc_np()\"\n+ngx_feature_name=\"NGX_HAVE_STRERRORDESC_NP\"\n+ngx_feature_run=no\n+ngx_feature_incs='#include <string.h>'\n ngx_feature_path=\n ngx_feature_libs=\n-ngx_feature_test='printf(\"%d\", sys_nerr);'\n+ngx_feature_test=\"char *p; p = strerrordesc_np(0);\n+                  if (p == NULL) return 1\"\n . auto/feature\n \n \n+if [ $ngx_found = no ]; then\n+\n+    ngx_feature=\"sys_nerr\"\n+    ngx_feature_name=\"NGX_SYS_NERR\"\n+    ngx_feature_run=value\n+    ngx_feature_incs='#include <errno.h>\n+                      #include <stdio.h>'\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test='printf(\"%d\", sys_nerr);'\n+    . auto/feature\n+fi\n+\n+\n if [ $ngx_found = no ]; then\n \n     # Cygiwn defines _sys_nerr\nDiff:\n@@ -56,7 +56,7 @@ typedef struct {\n #endif\n     } cookie;\n \n-    ngx_uint_t                     flags;\n+    ngx_array_t                    flags_values;\n     ngx_uint_t                     regex;\n } ngx_http_proxy_cookie_flags_t;\n \n@@ -2916,12 +2916,14 @@ static ngx_int_t\n ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n     ngx_array_t *flags)\n {\n-    ngx_str_t                       pattern;\n+    ngx_str_t                       pattern, value;\n #if (NGX_PCRE)\n     ngx_int_t                       rc;\n #endif\n-    ngx_uint_t                      i;\n+    ngx_uint_t                      i, m, f, nelts;\n     ngx_keyval_t                   *attr;\n+    ngx_conf_bitmask_t             *mask;\n+    ngx_http_complex_value_t       *flags_values;\n     ngx_http_proxy_cookie_flags_t  *pcf;\n \n     attr = attrs->elts;\n@@ -2965,7 +2967,47 @@ ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n         return NGX_DECLINED;\n     }\n \n-    return ngx_http_proxy_edit_cookie_flags(r, attrs, pcf[i].flags);\n+    nelts = pcf[i].flags_values.nelts;\n+    flags_values = pcf[i].flags_values.elts;\n+\n+    mask = ngx_http_proxy_cookie_flags_masks;\n+    f = 0;\n+\n+    for (i = 0; i < nelts; i++) {\n+\n+        if (ngx_http_complex_value(r, &flags_values[i], &value) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (value.len == 0) {\n+            continue;\n+        }\n+\n+        for (m = 0; mask[m].name.len != 0; m++) {\n+\n+            if (mask[m].name.len != value.len\n+                || ngx_strncasecmp(mask[m].name.data, value.data, value.len)\n+                   != 0)\n+            {\n+                continue;\n+            }\n+\n+            f |= mask[m].mask;\n+\n+            break;\n+        }\n+\n+        if (mask[m].name.len == 0) {\n+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                           \"invalid proxy_cookie_flags flag \\\"%V\\\"\", &value);\n+        }\n+    }\n+\n+    if (f == 0) {\n+        return NGX_DECLINED;\n+    }\n+\n+    return ngx_http_proxy_edit_cookie_flags(r, attrs, f);\n }\n \n \n@@ -4514,8 +4556,8 @@ ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_proxy_loc_conf_t *plcf = conf;\n \n     ngx_str_t                         *value;\n-    ngx_uint_t                         i, m;\n-    ngx_conf_bitmask_t                *mask;\n+    ngx_uint_t                         i;\n+    ngx_http_complex_value_t          *cv;\n     ngx_http_proxy_cookie_flags_t     *pcf;\n     ngx_http_compile_complex_value_t   ccv;\n #if (NGX_PCRE)\n@@ -4599,32 +4641,27 @@ ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         }\n     }\n \n-    mask = ngx_http_proxy_cookie_flags_masks;\n-    pcf->flags = 0;\n+    if (ngx_array_init(&pcf->flags_values, cf->pool, cf->args->nelts - 2,\n+                       sizeof(ngx_http_complex_value_t))\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n \n     for (i = 2; i < cf->args->nelts; i++) {\n-        for (m = 0; mask[m].name.len != 0; m++) {\n-\n-            if (mask[m].name.len != value[i].len\n-                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)\n-            {\n-                continue;\n-            }\n \n-            if (pcf->flags & mask[m].mask) {\n-                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n-                                   \"duplicate parameter \\\"%V\\\"\", &value[i]);\n-                return NGX_CONF_ERROR;\n-            }\n+        cv = ngx_array_push(&pcf->flags_values);\n+        if (cv == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n \n-            pcf->flags |= mask[m].mask;\n+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n \n-            break;\n-        }\n+        ccv.cf = cf;\n+        ccv.value = &value[i];\n+        ccv.complex_value = cv;\n \n-        if (mask[m].name.len == 0) {\n-            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n-                               \"invalid parameter \\\"%V\\\"\", &value[i]);\n+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n             return NGX_CONF_ERROR;\n         }\n     }\nDiff:\n@@ -9,6 +9,49 @@\n #include <ngx_core.h>\n \n \n+static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n+\n+\n+#if (NGX_HAVE_STRERRORDESC_NP)\n+\n+/*\n+ * The strerrordesc_np() function, introduced in glibc 2.32, is\n+ * async-signal-safe.  This makes it possible to use it directly,\n+ * without copying error messages.\n+ */\n+\n+\n+u_char *\n+ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n+{\n+    size_t       len;\n+    const char  *msg;\n+\n+    msg = strerrordesc_np(err);\n+\n+    if (msg == NULL) {\n+        msg = (char *) ngx_unknown_error.data;\n+        len = ngx_unknown_error.len;\n+\n+    } else {\n+        len = ngx_strlen(msg);\n+    }\n+\n+    size = ngx_min(size, len);\n+\n+    return ngx_cpymem(errstr, msg, size);\n+}\n+\n+\n+ngx_int_t\n+ngx_strerror_init(void)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+#else\n+\n /*\n  * The strerror() messages are copied because:\n  *\n@@ -26,7 +69,6 @@\n \n \n static ngx_str_t  *ngx_sys_errlist;\n-static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n static ngx_err_t   ngx_first_error;\n static ngx_err_t   ngx_last_error;\n \n@@ -164,3 +206,5 @@ ngx_strerror_init(void)\n \n     return NGX_ERROR;\n }\n+\n+#endif\n"
    },
    {
        "commit_sha": "348b50dbb52e7d6faad7d75ce9331dd9860131c4",
        "commit_index": "Commit 75",
        "commit_diff": "Diff:\n@@ -753,34 +753,6 @@ if [ $ngx_found = no ]; then\n fi\n \n \n-if [ $ngx_found = no ]; then\n-\n-    # Solaris has no sys_nerr\n-    ngx_feature='maximum errno'\n-    ngx_feature_name=NGX_SYS_NERR\n-    ngx_feature_run=value\n-    ngx_feature_incs='#include <errno.h>\n-                      #include <string.h>\n-                      #include <stdio.h>'\n-    ngx_feature_path=\n-    ngx_feature_libs=\n-    ngx_feature_test='int  n;\n-                      char *p;\n-                      for (n = 1; n < 1000; n++) {\n-                          errno = 0;\n-                          p = strerror(n);\n-                          if (errno == EINVAL\n-                              || p == NULL\n-                              || strncmp(p, \"Unknown error\", 13) == 0)\n-                          {\n-                              break;\n-                          }\n-                      }\n-                      printf(\"%d\", n);'\n-    . auto/feature\n-fi\n-\n-\n ngx_feature=\"localtime_r()\"\n ngx_feature_name=\"NGX_HAVE_LOCALTIME_R\"\n ngx_feature_run=no\nDiff:\n@@ -25,6 +25,7 @@ struct ngx_buf_s {\n \n     u_char          *start;         /* start of buffer */\n     u_char          *end;           /* end of buffer */\n+    ngx_int_t        rev;\n     ngx_buf_tag_t    tag;\n     ngx_file_t      *file;\n     ngx_buf_t       *shadow;\nDiff:\n@@ -647,6 +647,7 @@ ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx)\n             return NGX_ERROR;\n         }\n \n+        dst->rev = src->rev;\n         dst->last += n;\n \n         if (sendfile) {\nDiff:\n@@ -48,6 +48,7 @@\n typedef struct {\n     off_t        start;\n     off_t        end;\n+    ngx_int_t    rev;\n     ngx_str_t    content_range;\n } ngx_http_range_t;\n \n@@ -274,6 +275,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n                                   cutlim;\n     ngx_uint_t                    suffix;\n     ngx_http_range_t             *range;\n+    ngx_uint_t                    rev;\n     ngx_http_range_filter_ctx_t  *mctx;\n \n     if (r != r->main) {\n@@ -293,6 +295,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n \n     p = r->headers_in.range->value.data + 6;\n     size = 0;\n+    rev = 0;\n     content_length = r->headers_out.content_length_n;\n \n     cutoff = NGX_MAX_OFF_T_VALUE / 10;\n@@ -332,8 +335,22 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n             }\n \n         } else {\n-            suffix = 1;\n             p++;\n+            if (*p == 'r') {\n+                p++;\n+                while (*p == ' ') { p++; }\n+\n+                if (*p++ != ',') {\n+                    return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n+                }\n+\n+                while (*p == ' ') { p++; }\n+\n+                rev = 1;\n+                continue;\n+            } else {\n+                suffix = 1;\n+            }\n         }\n \n         if (*p < '0' || *p > '9') {\n@@ -376,6 +393,8 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n \n             range->start = start;\n             range->end = end;\n+            range->rev = rev;\n+            rev = 0;\n \n             if (size > NGX_MAX_OFF_T_VALUE - (end - start)) {\n                 return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n@@ -721,6 +740,8 @@ ngx_http_range_singlepart_body(ngx_http_request_t *r,\n         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"http range body buf: %O-%O\", start, last);\n \n+        buf->rev = range->rev;\n+\n         if (ngx_buf_special(buf)) {\n \n             if (range->end <= start) {\n@@ -889,6 +910,7 @@ ngx_http_range_multipart_body(ngx_http_request_t *r,\n         b->memory = buf->memory;\n         b->mmap = buf->mmap;\n         b->file = buf->file;\n+        b->rev = range[i].rev;\n \n         if (buf->in_file) {\n             b->file_pos = buf->file_pos + range[i].start;\nDiff:\n@@ -27,15 +27,22 @@\n \n static ngx_str_t  *ngx_sys_errlist;\n static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n+static ngx_err_t   ngx_first_error;\n+static ngx_err_t   ngx_last_error;\n \n \n u_char *\n ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n {\n     ngx_str_t  *msg;\n \n-    msg = ((ngx_uint_t) err < NGX_SYS_NERR) ? &ngx_sys_errlist[err]:\n-                                              &ngx_unknown_error;\n+    if (err >= ngx_first_error && err < ngx_last_error) {\n+        msg = &ngx_sys_errlist[err - ngx_first_error];\n+\n+    } else {\n+        msg = &ngx_unknown_error;\n+    }\n+\n     size = ngx_min(size, msg->len);\n \n     return ngx_cpymem(errstr, msg->data, size);\n@@ -50,20 +57,92 @@ ngx_strerror_init(void)\n     size_t      len;\n     ngx_err_t   err;\n \n+#if (NGX_SYS_NERR)\n+    ngx_first_error = 0;\n+    ngx_last_error = NGX_SYS_NERR;\n+\n+#elif (EPERM > 1000 && EPERM < 0x7fffffff - 1000)\n+\n+    /*\n+     * If number of errors is not known, and EPERM error code has large\n+     * but reasonable value, guess possible error codes based on the error\n+     * messages returned by strerror(), starting from EPERM.  Notably,\n+     * this covers GNU/Hurd, where errors start at 0x40000001.\n+     */\n+\n+    for (err = EPERM; err > EPERM - 1000; err--) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_first_error = err;\n+    }\n+\n+    for (err = EPERM; err < EPERM + 1000; err++) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_last_error = err + 1;\n+    }\n+\n+#else\n+\n+    /*\n+     * If number of errors is not known, guess it based on the error\n+     * messages returned by strerror().\n+     */\n+\n+    ngx_first_error = 0;\n+\n+    for (err = 0; err < 1000; err++) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_last_error = err + 1;\n+    }\n+\n+#endif\n+\n     /*\n      * ngx_strerror() is not ready to work at this stage, therefore,\n      * malloc() is used and possible errors are logged using strerror().\n      */\n \n-    len = NGX_SYS_NERR * sizeof(ngx_str_t);\n+    len = (ngx_last_error - ngx_first_error) * sizeof(ngx_str_t);\n \n     ngx_sys_errlist = malloc(len);\n     if (ngx_sys_errlist == NULL) {\n         goto failed;\n     }\n \n-    for (err = 0; err < NGX_SYS_NERR; err++) {\n+    for (err = ngx_first_error; err < ngx_last_error; err++) {\n         msg = strerror(err);\n+\n+        if (msg == NULL) {\n+            ngx_sys_errlist[err - ngx_first_error] = ngx_unknown_error;\n+            continue;\n+        }\n+\n         len = ngx_strlen(msg);\n \n         p = malloc(len);\n@@ -72,8 +151,8 @@ ngx_strerror_init(void)\n         }\n \n         ngx_memcpy(p, msg, len);\n-        ngx_sys_errlist[err].len = len;\n-        ngx_sys_errlist[err].data = p;\n+        ngx_sys_errlist[err - ngx_first_error].len = len;\n+        ngx_sys_errlist[err - ngx_first_error].data = p;\n     }\n \n     return NGX_OK;\nDiff:\n@@ -41,6 +41,49 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\n  */\n \n #define NGX_SENDFILE_MAXSIZE  2147483647L\n+#define NGX_SENDFILE_R_MAXSIZE  100L\n+\n+ssize_t\n+ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+    struct stat sb;\n+    u_char *buf;\n+    u_char *rev;\n+    ssize_t n;\n+\n+    if (fstat(file->file->fd, &sb) != 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    buf = ngx_palloc(c->pool, ngx_file_size(&sb));\n+\n+    if (buf == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (read( file->file->fd, buf, ngx_file_size(&sb)) == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    lseek(file->file->fd, 0, SEEK_SET);\n+\n+    rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);\n+\n+    if ( rev == NULL ) {\n+        return NGX_ERROR;\n+    }\n+\n+    for ( int i = file->file_pos + size - 1, j = 0; i >= file->file_pos; i--, j++) {\n+        rev[j] = buf[i];\n+    }\n+\n+    n = c->send(c, rev, size);\n+\n+    ngx_pfree(c->pool, buf);\n+    ngx_free(rev);\n+\n+    return n;\n+}\n \n \n ngx_chain_t *\n@@ -256,7 +299,11 @@ ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"sendfile: @%O %uz\", file->file_pos, size);\n \n-    n = sendfile(c->fd, file->file->fd, &offset, size);\n+    if (file->rev) {\n+        n = ngx_sendfile_r(c, file, size);\n+    } else {\n+        n = sendfile(c->fd, file->file->fd, &offset, size);\n+    }\n \n     if (n == -1) {\n         err = ngx_errno;\nDiff:\n@@ -149,6 +149,14 @@ ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,\n \n         size = in->buf->last - in->buf->pos;\n \n+        if (in->buf->rev) {\n+            for (int i = 0, j = size - 1; i < j; i++, j--) {\n+                u_char c = in->buf->start[i];\n+                in->buf->start[i] = in->buf->start[j];\n+                in->buf->start[j] = c;\n+            }\n+        }\n+\n         if (size > limit - total) {\n             size = limit - total;\n         }\n"
    },
    {
        "commit_sha": "a3b385ddb67baf04474906564f2929b8bc17a90f",
        "commit_index": "Commit 74",
        "commit_diff": "Diff:\n@@ -2414,26 +2414,26 @@ syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n \n \" highlight\n \n-hi link ngxComment Comment\n-hi link ngxParamComment Comment\n-hi link ngxListenComment Comment\n-hi link ngxVariable Identifier\n-hi link ngxVariableString PreProc\n-hi link ngxString String\n-hi link ngxListenString String\n-\n-hi link ngxBoolean Boolean\n-hi link ngxDirectiveBlock Statement\n-hi link ngxDirectiveImportant Type\n-hi link ngxDirectiveListen Type\n-hi link ngxDirectiveControl Keyword\n-hi link ngxDirectiveError Constant\n-hi link ngxDirectiveDeprecated Error\n-hi link ngxDirective Identifier\n-hi link ngxDirectiveThirdParty Special\n-hi link ngxDirectiveThirdPartyDeprecated Error\n-\n-hi link ngxListenOptions Keyword\n-hi link ngxListenOptionsDeprecated Error\n+hi def link ngxComment Comment\n+hi def link ngxParamComment Comment\n+hi def link ngxListenComment Comment\n+hi def link ngxVariable Identifier\n+hi def link ngxVariableString PreProc\n+hi def link ngxString String\n+hi def link ngxListenString String\n+\n+hi def link ngxBoolean Boolean\n+hi def link ngxDirectiveBlock Statement\n+hi def link ngxDirectiveImportant Type\n+hi def link ngxDirectiveListen Type\n+hi def link ngxDirectiveControl Keyword\n+hi def link ngxDirectiveError Constant\n+hi def link ngxDirectiveDeprecated Error\n+hi def link ngxDirective Identifier\n+hi def link ngxDirectiveThirdParty Special\n+hi def link ngxDirectiveThirdPartyDeprecated Error\n+\n+hi def link ngxListenOptions Keyword\n+hi def link ngxListenOptionsDeprecated Error\n \n let b:current_syntax = \"nginx\"\nDiff:\n@@ -1014,6 +1014,10 @@ ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store)\n \n     c = ngx_ssl_get_connection(ssl_conn);\n \n+    if (!(c->log->log_level & NGX_LOG_DEBUG_EVENT)) {\n+        return 1;\n+    }\n+\n     cert = X509_STORE_CTX_get_current_cert(x509_store);\n     err = X509_STORE_CTX_get_error(x509_store);\n     depth = X509_STORE_CTX_get_error_depth(x509_store);\n@@ -1970,6 +1974,10 @@ ngx_ssl_handshake_log(ngx_connection_t *c)\n #endif\n     SSL_CIPHER  *cipher;\n \n+    if (!(c->log->log_level & NGX_LOG_DEBUG_EVENT)) {\n+        return;\n+    }\n+\n     cipher = SSL_get_current_cipher(c->ssl->connection);\n \n     if (cipher) {\nDiff:\n@@ -238,6 +238,7 @@ ngx_http_v2_init(ngx_event_t *rev)\n     ngx_http_v2_srv_conf_t    *h2scf;\n     ngx_http_v2_main_conf_t   *h2mcf;\n     ngx_http_v2_connection_t  *h2c;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     c = rev->data;\n     hc = c->data;\n@@ -325,8 +326,10 @@ ngx_http_v2_init(ngx_event_t *rev)\n     rev->handler = ngx_http_v2_read_handler;\n     c->write->handler = ngx_http_v2_write_handler;\n \n-    if (c->read->timer_set) {\n-        ngx_del_timer(c->read);\n+    if (!rev->timer_set) {\n+        cscf = ngx_http_get_module_srv_conf(hc->conf_ctx,\n+                                            ngx_http_core_module);\n+        ngx_add_timer(rev, cscf->client_header_timeout);\n     }\n \n     c->idle = 1;\n"
    },
    {
        "commit_sha": "d1ce151b94d260edc5c18638fe1c94573fb3b257",
        "commit_index": "Commit 73",
        "commit_diff": "Diff:\n@@ -48,4 +48,6 @@ default:\tbuild\n \n clean:\n \trm -rf Makefile $NGX_OBJS\n+\n+.PHONY:\tdefault clean\n END\nDiff:\n@@ -215,4 +215,6 @@ upgrade:\n \ttest -f $NGX_PID_PATH.oldbin\n \n \tkill -QUIT \\`cat $NGX_PID_PATH.oldbin\\`\n+\n+.PHONY:\tbuild install modules upgrade\n END\nDiff:\n@@ -83,7 +83,7 @@ static time_t ngx_ssl_parse_time(\n #if OPENSSL_VERSION_NUMBER > 0x10100000L\n     const\n #endif\n-    ASN1_TIME *asn1time);\n+    ASN1_TIME *asn1time, ngx_log_t *log);\n \n static void *ngx_openssl_create_conf(ngx_cycle_t *cycle);\n static char *ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n@@ -1019,21 +1019,43 @@ ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store)\n     depth = X509_STORE_CTX_get_error_depth(x509_store);\n \n     sname = X509_get_subject_name(cert);\n-    subject = sname ? X509_NAME_oneline(sname, NULL, 0) : \"(none)\";\n+\n+    if (sname) {\n+        subject = X509_NAME_oneline(sname, NULL, 0);\n+        if (subject == NULL) {\n+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"X509_NAME_oneline() failed\");\n+        }\n+\n+    } else {\n+        subject = NULL;\n+    }\n \n     iname = X509_get_issuer_name(cert);\n-    issuer = iname ? X509_NAME_oneline(iname, NULL, 0) : \"(none)\";\n+\n+    if (iname) {\n+        issuer = X509_NAME_oneline(iname, NULL, 0);\n+        if (issuer == NULL) {\n+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"X509_NAME_oneline() failed\");\n+        }\n+\n+    } else {\n+        issuer = NULL;\n+    }\n \n     ngx_log_debug5(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"verify:%d, error:%d, depth:%d, \"\n                    \"subject:\\\"%s\\\", issuer:\\\"%s\\\"\",\n-                   ok, err, depth, subject, issuer);\n+                   ok, err, depth,\n+                   subject ? subject : \"(none)\",\n+                   issuer ? issuer : \"(none)\");\n \n-    if (sname) {\n+    if (subject) {\n         OPENSSL_free(subject);\n     }\n \n-    if (iname) {\n+    if (issuer) {\n         OPENSSL_free(issuer);\n     }\n #endif\n@@ -4795,11 +4817,13 @@ ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n \n     if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_print_ex() failed\");\n         goto failed;\n     }\n \n@@ -4847,11 +4871,13 @@ ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n \n     if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_print_ex() failed\");\n         goto failed;\n     }\n \n@@ -4900,6 +4926,11 @@ ngx_ssl_get_subject_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,\n     }\n \n     p = X509_NAME_oneline(name, NULL, 0);\n+    if (p == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_oneline() failed\");\n+        X509_free(cert);\n+        return NGX_ERROR;\n+    }\n \n     for (len = 0; p[len]; len++) { /* void */ }\n \n@@ -4943,6 +4974,11 @@ ngx_ssl_get_issuer_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,\n     }\n \n     p = X509_NAME_oneline(name, NULL, 0);\n+    if (p == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_oneline() failed\");\n+        X509_free(cert);\n+        return NGX_ERROR;\n+    }\n \n     for (len = 0; p[len]; len++) { /* void */ }\n \n@@ -4979,6 +5015,7 @@ ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5017,6 +5054,7 @@ ngx_ssl_get_fingerprint(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n     }\n \n     if (!X509_digest(cert, EVP_sha1(), buf, &len)) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_digest() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5090,6 +5128,7 @@ ngx_ssl_get_client_v_start(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5134,6 +5173,7 @@ ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5176,9 +5216,9 @@ ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n     }\n \n #if OPENSSL_VERSION_NUMBER > 0x10100000L\n-    end = ngx_ssl_parse_time(X509_get0_notAfter(cert));\n+    end = ngx_ssl_parse_time(X509_get0_notAfter(cert), c->log);\n #else\n-    end = ngx_ssl_parse_time(X509_get_notAfter(cert));\n+    end = ngx_ssl_parse_time(X509_get_notAfter(cert), c->log);\n #endif\n \n     if (end == (time_t) NGX_ERROR) {\n@@ -5213,7 +5253,7 @@ ngx_ssl_parse_time(\n #if OPENSSL_VERSION_NUMBER > 0x10100000L\n     const\n #endif\n-    ASN1_TIME *asn1time)\n+    ASN1_TIME *asn1time, ngx_log_t *log)\n {\n     BIO     *bio;\n     char    *value;\n@@ -5229,6 +5269,7 @@ ngx_ssl_parse_time(\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, log, 0, \"BIO_new() failed\");\n         return NGX_ERROR;\n     }\n \n"
    },
    {
        "commit_sha": "d466d7f3a6ef8b18648e883506058841206f4267",
        "commit_index": "Commit 72",
        "commit_diff": "Diff:\n@@ -456,3 +456,4 @@ a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n 8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\n f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n+3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\nDiff:\n@@ -5,6 +5,92 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.7\" date=\"2021-02-16\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+обработка соединений в HTTP/2 была изменена\n+и теперь более соответствует HTTP/1.x;\n+директивы http2_recv_timeout, http2_idle_timeout\n+и http2_max_requests упразднены,\n+вместо них следует использовать директивы\n+keepalive_timeout и keepalive_requests.\n+</para>\n+<para lang=\"en\">\n+connections handling in HTTP/2 has been changed\n+to better match HTTP/1.x;\n+the \"http2_recv_timeout\", \"http2_idle_timeout\",\n+and \"http2_max_requests\" directives have been removed,\n+the \"keepalive_timeout\" and \"keepalive_requests\" directives\n+should be used instead.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+директивы http2_max_field_size и http2_max_header_size упразднены,\n+вместо них следует использовать директиву large_client_header_buffers.\n+</para>\n+<para lang=\"en\">\n+the \"http2_max_field_size\" and \"http2_max_header_size\" directives\n+have been removed,\n+the \"large_client_header_buffers\" directive should be used instead.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь при исчерпании свободных соединений\n+nginx закрывает не только keepalive-соединения,\n+но и соединения в lingering close.\n+</para>\n+<para lang=\"en\">\n+now, if free worker connections are exhausted,\n+nginx starts closing not only keepalive connections,\n+but also connections in lingering close.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения \"zero size buf in output\",\n+если бэкенд возвращал некорректный ответ\n+при небуферизированном проксировании;\n+ошибка появилась в 1.19.1.\n+</para>\n+<para lang=\"en\">\n+\"zero size buf in output\" alerts might appear in logs\n+if an upstream server returned an incorrect response\n+during unbuffered proxying;\n+the bug had appeared in 1.19.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании директивы return\n+вместе с image_filter или xslt_stylesheet\n+HEAD-запросы обрабатывались некорректно.\n+</para>\n+<para lang=\"en\">\n+HEAD requests were handled incorrectly\n+if the \"return\" directive was used\n+with the \"image_filter\" or \"xslt_stylesheet\" directives.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве add_trailer.\n+</para>\n+<para lang=\"en\">\n+in the \"add_trailer\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.6\" date=\"2020-12-15\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019007\n-#define NGINX_VERSION      \"1.19.7\"\n+#define nginx_version      1019008\n+#define NGINX_VERSION      \"1.19.8\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "293cb0505aebb016ce21d86be69ba0aff109caf0",
        "commit_index": "Commit 71",
        "commit_diff": "Diff:\n@@ -1198,6 +1198,7 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n     ngx_http_v2_node_t        *node;\n     ngx_http_v2_stream_t      *stream;\n     ngx_http_v2_srv_conf_t    *h2scf;\n+    ngx_http_core_srv_conf_t  *cscf;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG;\n@@ -1299,11 +1300,15 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n     }\n \n+    cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    h2c->state.header_limit = cscf->large_client_header_buffers.size\n+                              * cscf->large_client_header_buffers.num;\n+\n     h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n                                          ngx_http_v2_module);\n \n-    h2c->state.header_limit = h2scf->max_header_size;\n-\n     if (h2c->processing >= h2scf->concurrent_streams) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                       \"concurrent streams exceeded %ui\", h2c->processing);\n@@ -1485,10 +1490,10 @@ static u_char *\n ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   alloc;\n-    ngx_int_t                len;\n-    ngx_uint_t               huff;\n-    ngx_http_v2_srv_conf_t  *h2scf;\n+    size_t                     alloc;\n+    ngx_int_t                  len;\n+    ngx_uint_t                 huff;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)\n         && h2c->state.length < NGX_HTTP_V2_INT_OCTETS)\n@@ -1535,12 +1540,12 @@ ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c, u_char *pos,\n                    \"http2 %s string, len:%i\",\n                    huff ? \"encoded\" : \"raw\", len);\n \n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n+    cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n \n-    if ((size_t) len > h2scf->max_field_size) {\n+    if ((size_t) len > cscf->large_client_header_buffers.size) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n-                      \"client exceeded http2_max_field_size limit\");\n+                      \"client sent too large header field\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n     }\n@@ -1755,7 +1760,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n \n     if (len > h2c->state.header_limit) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n-                      \"client exceeded http2_max_header_size limit\");\n+                      \"client sent too large header\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n     }\nDiff:\n@@ -52,6 +52,14 @@ static ngx_conf_deprecated_t  ngx_http_v2_max_requests_deprecated = {\n     ngx_conf_deprecated, \"http2_max_requests\", \"keepalive_requests\"\n };\n \n+static ngx_conf_deprecated_t  ngx_http_v2_max_field_size_deprecated = {\n+    ngx_conf_deprecated, \"http2_max_field_size\", \"large_client_header_buffers\"\n+};\n+\n+static ngx_conf_deprecated_t  ngx_http_v2_max_header_size_deprecated = {\n+    ngx_conf_deprecated, \"http2_max_header_size\", \"large_client_header_buffers\"\n+};\n+\n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n     { ngx_http_v2_recv_buffer_size };\n@@ -104,17 +112,17 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_max_field_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_size_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, max_field_size),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_max_field_size_deprecated },\n \n     { ngx_string(\"http2_max_header_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_size_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, max_header_size),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_max_header_size_deprecated },\n \n     { ngx_string(\"http2_body_preread_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n@@ -311,9 +319,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n     h2scf->concurrent_streams = NGX_CONF_UNSET_UINT;\n     h2scf->concurrent_pushes = NGX_CONF_UNSET_UINT;\n \n-    h2scf->max_field_size = NGX_CONF_UNSET_SIZE;\n-    h2scf->max_header_size = NGX_CONF_UNSET_SIZE;\n-\n     h2scf->preread_size = NGX_CONF_UNSET_SIZE;\n \n     h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;\n@@ -335,11 +340,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->concurrent_pushes,\n                               prev->concurrent_pushes, 10);\n \n-    ngx_conf_merge_size_value(conf->max_field_size, prev->max_field_size,\n-                              4096);\n-    ngx_conf_merge_size_value(conf->max_header_size, prev->max_header_size,\n-                              16384);\n-\n     ngx_conf_merge_size_value(conf->preread_size, prev->preread_size, 65536);\n \n     ngx_conf_merge_uint_value(conf->streams_index_mask,\nDiff:\n@@ -24,8 +24,6 @@ typedef struct {\n     size_t                          pool_size;\n     ngx_uint_t                      concurrent_streams;\n     ngx_uint_t                      concurrent_pushes;\n-    size_t                          max_field_size;\n-    size_t                          max_header_size;\n     size_t                          preread_size;\n     ngx_uint_t                      streams_index_mask;\n } ngx_http_v2_srv_conf_t;\n"
    },
    {
        "commit_sha": "15551314f9d63eb1185d0bccd53d24c84709b3b8",
        "commit_index": "Commit 70",
        "commit_diff": "Diff:\n@@ -325,6 +325,10 @@ ngx_http_v2_init(ngx_event_t *rev)\n     rev->handler = ngx_http_v2_read_handler;\n     c->write->handler = ngx_http_v2_write_handler;\n \n+    if (c->read->timer_set) {\n+        ngx_del_timer(c->read);\n+    }\n+\n     c->idle = 1;\n     ngx_reusable_connection(c, 0);\n \n@@ -455,14 +459,6 @@ ngx_http_v2_read_handler(ngx_event_t *rev)\n \n     h2c->blocked = 0;\n \n-    if (h2c->processing || h2c->pushing) {\n-        if (rev->timer_set) {\n-            ngx_del_timer(rev);\n-        }\n-\n-        return;\n-    }\n-\n     ngx_http_v2_handle_connection(h2c);\n }\n \n@@ -637,8 +633,7 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n {\n     ngx_int_t                  rc;\n     ngx_connection_t          *c;\n-    ngx_http_v2_srv_conf_t    *h2scf;\n-    ngx_http_core_srv_conf_t  *cscf;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     if (h2c->last_out || h2c->processing || h2c->pushing) {\n         return;\n@@ -675,15 +670,16 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    if (!c->read->timer_set) {\n+        ngx_add_timer(c->read, clcf->keepalive_timeout);\n+    }\n+\n     ngx_reusable_connection(c, 1);\n \n     if (h2c->state.incomplete) {\n-        if (!c->read->timer_set) {\n-            cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                                ngx_http_core_module);\n-            ngx_add_timer(c->read, cscf->client_header_timeout);\n-        }\n-\n         return;\n     }\n \n@@ -708,11 +704,6 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n     if (c->write->timer_set) {\n         ngx_del_timer(c->write);\n     }\n-\n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n-\n-    ngx_add_timer(c->read, h2scf->idle_timeout);\n }\n \n \n@@ -1200,12 +1191,14 @@ static u_char *\n ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   size;\n-    ngx_uint_t               padded, priority, depend, dependency, excl, weight;\n-    ngx_uint_t               status;\n-    ngx_http_v2_node_t      *node;\n-    ngx_http_v2_stream_t    *stream;\n-    ngx_http_v2_srv_conf_t  *h2scf;\n+    size_t                     size;\n+    ngx_uint_t                 padded, priority, depend, dependency, excl,\n+                               weight;\n+    ngx_uint_t                 status;\n+    ngx_http_v2_node_t        *node;\n+    ngx_http_v2_stream_t      *stream;\n+    ngx_http_v2_srv_conf_t    *h2scf;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG;\n     priority = h2c->state.flags & NGX_HTTP_V2_PRIORITY_FLAG;\n@@ -1364,7 +1357,10 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n         ngx_http_v2_set_dependency(h2c, node, depend, excl);\n     }\n \n-    if (h2c->connection->requests >= h2scf->max_requests) {\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    if (h2c->connection->requests >= clcf->keepalive_requests) {\n         h2c->goaway = 1;\n \n         if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n@@ -3293,6 +3289,10 @@ ngx_http_v2_create_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t push)\n \n     h2c->priority_limit += h2scf->concurrent_streams;\n \n+    if (h2c->connection->read->timer_set) {\n+        ngx_del_timer(h2c->connection->read);\n+    }\n+\n     return stream;\n }\n \n@@ -4659,6 +4659,7 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n     ngx_connection_t          *c;\n     ngx_http_v2_srv_conf_t    *h2scf;\n     ngx_http_v2_connection_t  *h2c;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     c = rev->data;\n     h2c = c->data;\n@@ -4690,10 +4691,10 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n \n #endif\n \n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n \n-    if (h2c->idle++ > 10 * h2scf->max_requests) {\n+    if (h2c->idle++ > 10 * clcf->keepalive_requests) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                       \"http2 flood detected\");\n         ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n@@ -4703,9 +4704,8 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n     c->destroyed = 0;\n     ngx_reusable_connection(c, 0);\n \n-    if (c->read->timer_set) {\n-        ngx_del_timer(c->read);\n-    }\n+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                         ngx_http_v2_module);\n \n     h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);\n     if (h2c->pool == NULL) {\nDiff:\n@@ -44,6 +44,14 @@ static ngx_conf_deprecated_t  ngx_http_v2_recv_timeout_deprecated = {\n     ngx_conf_deprecated, \"http2_recv_timeout\", \"client_header_timeout\"\n };\n \n+static ngx_conf_deprecated_t  ngx_http_v2_idle_timeout_deprecated = {\n+    ngx_conf_deprecated, \"http2_idle_timeout\", \"keepalive_timeout\"\n+};\n+\n+static ngx_conf_deprecated_t  ngx_http_v2_max_requests_deprecated = {\n+    ngx_conf_deprecated, \"http2_max_requests\", \"keepalive_requests\"\n+};\n+\n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n     { ngx_http_v2_recv_buffer_size };\n@@ -89,10 +97,10 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_max_requests\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_num_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, max_requests),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_max_requests_deprecated },\n \n     { ngx_string(\"http2_max_field_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n@@ -131,10 +139,10 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_idle_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_msec_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, idle_timeout),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_idle_timeout_deprecated },\n \n     { ngx_string(\"http2_chunk_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n@@ -302,7 +310,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n \n     h2scf->concurrent_streams = NGX_CONF_UNSET_UINT;\n     h2scf->concurrent_pushes = NGX_CONF_UNSET_UINT;\n-    h2scf->max_requests = NGX_CONF_UNSET_UINT;\n \n     h2scf->max_field_size = NGX_CONF_UNSET_SIZE;\n     h2scf->max_header_size = NGX_CONF_UNSET_SIZE;\n@@ -311,8 +318,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n \n     h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;\n \n-    h2scf->idle_timeout = NGX_CONF_UNSET_MSEC;\n-\n     return h2scf;\n }\n \n@@ -329,7 +334,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->concurrent_streams, 128);\n     ngx_conf_merge_uint_value(conf->concurrent_pushes,\n                               prev->concurrent_pushes, 10);\n-    ngx_conf_merge_uint_value(conf->max_requests, prev->max_requests, 1000);\n \n     ngx_conf_merge_size_value(conf->max_field_size, prev->max_field_size,\n                               4096);\n@@ -341,9 +345,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->streams_index_mask,\n                               prev->streams_index_mask, 32 - 1);\n \n-    ngx_conf_merge_msec_value(conf->idle_timeout,\n-                              prev->idle_timeout, 180000);\n-\n     return NGX_CONF_OK;\n }\n \nDiff:\n@@ -24,12 +24,10 @@ typedef struct {\n     size_t                          pool_size;\n     ngx_uint_t                      concurrent_streams;\n     ngx_uint_t                      concurrent_pushes;\n-    ngx_uint_t                      max_requests;\n     size_t                          max_field_size;\n     size_t                          max_header_size;\n     size_t                          preread_size;\n     ngx_uint_t                      streams_index_mask;\n-    ngx_msec_t                      idle_timeout;\n } ngx_http_v2_srv_conf_t;\n \n \n"
    },
    {
        "commit_sha": "23c1e2b92733c8e2464fdf99a18c272357c23a9b",
        "commit_index": "Commit 69",
        "commit_diff": "Diff:\n@@ -635,9 +635,10 @@ ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c)\n static void\n ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n {\n-    ngx_int_t                rc;\n-    ngx_connection_t        *c;\n-    ngx_http_v2_srv_conf_t  *h2scf;\n+    ngx_int_t                  rc;\n+    ngx_connection_t          *c;\n+    ngx_http_v2_srv_conf_t    *h2scf;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     if (h2c->last_out || h2c->processing || h2c->pushing) {\n         return;\n@@ -676,10 +677,13 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n \n     ngx_reusable_connection(c, 1);\n \n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n     if (h2c->state.incomplete) {\n-        ngx_add_timer(c->read, h2scf->recv_timeout);\n+        if (!c->read->timer_set) {\n+            cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                                ngx_http_core_module);\n+            ngx_add_timer(c->read, cscf->client_header_timeout);\n+        }\n+\n         return;\n     }\n \n@@ -705,6 +709,9 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n         ngx_del_timer(c->write);\n     }\n \n+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                         ngx_http_v2_module);\n+\n     ngx_add_timer(c->read, h2scf->idle_timeout);\n }\n \n@@ -4696,6 +4703,10 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n     c->destroyed = 0;\n     ngx_reusable_connection(c, 0);\n \n+    if (c->read->timer_set) {\n+        ngx_del_timer(c->read);\n+    }\n+\n     h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);\n     if (h2c->pool == NULL) {\n         ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\nDiff:\n@@ -36,6 +36,13 @@ static char *ngx_http_v2_preread_size(ngx_conf_t *cf, void *post, void *data);\n static char *ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post,\n     void *data);\n static char *ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data);\n+static char *ngx_http_v2_obsolete(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+\n+\n+static ngx_conf_deprecated_t  ngx_http_v2_recv_timeout_deprecated = {\n+    ngx_conf_deprecated, \"http2_recv_timeout\", \"client_header_timeout\"\n+};\n \n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n@@ -117,10 +124,10 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_recv_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_msec_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, recv_timeout),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_recv_timeout_deprecated },\n \n     { ngx_string(\"http2_idle_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n@@ -304,7 +311,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n \n     h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;\n \n-    h2scf->recv_timeout = NGX_CONF_UNSET_MSEC;\n     h2scf->idle_timeout = NGX_CONF_UNSET_MSEC;\n \n     return h2scf;\n@@ -335,8 +341,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->streams_index_mask,\n                               prev->streams_index_mask, 32 - 1);\n \n-    ngx_conf_merge_msec_value(conf->recv_timeout,\n-                              prev->recv_timeout, 30000);\n     ngx_conf_merge_msec_value(conf->idle_timeout,\n                               prev->idle_timeout, 180000);\n \n@@ -539,3 +543,17 @@ ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data)\n \n     return NGX_CONF_OK;\n }\n+\n+\n+static char *\n+ngx_http_v2_obsolete(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_conf_deprecated_t  *d = cmd->post;\n+\n+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                       \"the \\\"%s\\\" directive is obsolete, \"\n+                       \"use the \\\"%s\\\" directive instead\",\n+                       d->old_name, d->new_name);\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -29,7 +29,6 @@ typedef struct {\n     size_t                          max_header_size;\n     size_t                          preread_size;\n     ngx_uint_t                      streams_index_mask;\n-    ngx_msec_t                      recv_timeout;\n     ngx_msec_t                      idle_timeout;\n } ngx_http_v2_srv_conf_t;\n \n"
    },
    {
        "commit_sha": "d478cc4a5c0325c870178a6ab96b1fead6a2722d",
        "commit_index": "Commit 68",
        "commit_diff": "Diff:\n@@ -4078,14 +4078,6 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n         }\n \n-        if (ngx_strcmp(value[n].data, \"spdy\") == 0) {\n-            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n-                               \"invalid parameter \\\"spdy\\\": \"\n-                               \"ngx_http_spdy_module was superseded \"\n-                               \"by ngx_http_v2_module\");\n-            continue;\n-        }\n-\n         if (ngx_strncmp(value[n].data, \"so_keepalive=\", 13) == 0) {\n \n             if (ngx_strcmp(&value[n].data[13], \"on\") == 0) {\nDiff:\n@@ -326,6 +326,7 @@ ngx_http_v2_init(ngx_event_t *rev)\n     c->write->handler = ngx_http_v2_write_handler;\n \n     c->idle = 1;\n+    ngx_reusable_connection(c, 0);\n \n     ngx_http_v2_read_handler(rev);\n }\nDiff:\n@@ -36,8 +36,6 @@ static char *ngx_http_v2_preread_size(ngx_conf_t *cf, void *post, void *data);\n static char *ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post,\n     void *data);\n static char *ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data);\n-static char *ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd,\n-    void *conf);\n \n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n@@ -152,62 +150,6 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n       0,\n       NULL },\n \n-    { ngx_string(\"spdy_recv_buffer_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_MAIN_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_pool_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_max_concurrent_streams\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_streams_index_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_recv_timeout\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_keepalive_timeout\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_headers_comp\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_chunk_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_LOC_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n       ngx_null_command\n };\n \n@@ -597,14 +539,3 @@ ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data)\n \n     return NGX_CONF_OK;\n }\n-\n-\n-static char *\n-ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n-{\n-    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n-                       \"invalid directive \\\"%V\\\": ngx_http_spdy_module \"\n-                       \"was superseded by ngx_http_v2_module\", &cmd->name);\n-\n-    return NGX_CONF_OK;\n-}\n"
    },
    {
        "commit_sha": "f94e971864b13c255ea3210e8d93964d3a7d445a",
        "commit_index": "Commit 67",
        "commit_diff": "Diff:\n@@ -1313,6 +1313,7 @@ ngx_drain_connections(ngx_cycle_t *cycle)\n                       cycle->connection_n);\n     }\n \n+    c = NULL;\n     n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);\n \n     for (i = 0; i < n; i++) {\n@@ -1329,6 +1330,21 @@ ngx_drain_connections(ngx_cycle_t *cycle)\n         c->close = 1;\n         c->read->handler(c->read);\n     }\n+\n+    if (cycle->free_connection_n == 0 && c && c->reusable) {\n+\n+        /*\n+         * if no connections were freed, try to reuse the last\n+         * connection again: this should free it as long as\n+         * previous reuse moved it to lingering close\n+         */\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                       \"reusing connection again\");\n+\n+        c->close = 1;\n+        c->read->handler(c->read);\n+    }\n }\n \n \nDiff:\n@@ -3456,6 +3456,9 @@ ngx_http_set_lingering_close(ngx_connection_t *c)\n         return;\n     }\n \n+    c->close = 0;\n+    ngx_reusable_connection(c, 1);\n+\n     ngx_add_timer(rev, clcf->lingering_timeout);\n \n     if (rev->ready) {\n@@ -3480,7 +3483,7 @@ ngx_http_lingering_close_handler(ngx_event_t *rev)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                    \"http lingering close handler\");\n \n-    if (rev->timedout) {\n+    if (rev->timedout || c->close) {\n         ngx_http_close_request(r, 0);\n         return;\n     }\nDiff:\n@@ -362,6 +362,11 @@ ngx_http_v2_read_handler(ngx_event_t *rev)\n             return;\n         }\n \n+        if (!h2c->processing && !h2c->pushing) {\n+            ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n+            return;\n+        }\n+\n         if (!h2c->goaway) {\n             h2c->goaway = 1;\n \n@@ -668,6 +673,8 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    ngx_reusable_connection(c, 1);\n+\n     h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n                                          ngx_http_v2_module);\n     if (h2c->state.incomplete) {\n@@ -689,7 +696,6 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n #endif\n \n     c->destroyed = 1;\n-    ngx_reusable_connection(c, 1);\n \n     c->write->handler = ngx_http_empty_handler;\n     c->read->handler = ngx_http_v2_idle_handler;\n@@ -767,6 +773,9 @@ ngx_http_v2_lingering_close(ngx_connection_t *c)\n         return;\n     }\n \n+    c->close = 0;\n+    ngx_reusable_connection(c, 1);\n+\n     ngx_add_timer(rev, clcf->lingering_timeout);\n \n     if (rev->ready) {\n@@ -791,7 +800,7 @@ ngx_http_v2_lingering_close_handler(ngx_event_t *rev)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                    \"http2 lingering close handler\");\n \n-    if (rev->timedout) {\n+    if (rev->timedout || c->close) {\n         ngx_http_close_connection(c);\n         return;\n     }\n"
    },
    {
        "commit_sha": "820973d0b13159b6d3f797083a26f8cb732f94ab",
        "commit_index": "Commit 66",
        "commit_diff": "Diff:\n@@ -1,6 +1,6 @@\n /* \n- * Copyright (C) 2002-2019 Igor Sysoev\n- * Copyright (C) 2011-2019 Nginx, Inc.\n+ * Copyright (C) 2002-2021 Igor Sysoev\n+ * Copyright (C) 2011-2021 Nginx, Inc.\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\nDiff:\n@@ -575,6 +575,10 @@ ngx_http_clean_header(ngx_http_request_t *r)\n     r->headers_out.headers.part.next = NULL;\n     r->headers_out.headers.last = &r->headers_out.headers.part;\n \n+    r->headers_out.trailers.part.nelts = 0;\n+    r->headers_out.trailers.part.next = NULL;\n+    r->headers_out.trailers.last = &r->headers_out.trailers.part;\n+\n     r->headers_out.content_length_n = -1;\n     r->headers_out.last_modified_time = -1;\n }\nDiff:\n@@ -807,6 +807,10 @@ ngx_http_v2_lingering_close_handler(ngx_event_t *rev)\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, \"lingering read: %z\", n);\n \n+        if (n == NGX_AGAIN) {\n+            break;\n+        }\n+\n         if (n == NGX_ERROR || n == 0) {\n             ngx_http_close_connection(c);\n             return;\n"
    },
    {
        "commit_sha": "d337352da75856f57f0d17b861013bfd1f271f49",
        "commit_index": "Commit 65",
        "commit_diff": "Diff:\n@@ -45,8 +45,6 @@ struct ngx_listening_s {\n     size_t              pool_size;\n     /* should be here because of the AcceptEx() preread */\n     size_t              post_accept_buffer_size;\n-    /* should be here because of the deferred accept */\n-    ngx_msec_t          post_accept_timeout;\n \n     ngx_listening_t    *previous;\n     ngx_connection_t   *connection;\nDiff:\n@@ -1714,7 +1714,6 @@ ngx_http_add_listening(ngx_conf_t *cf, ngx_http_conf_addr_t *addr)\n \n     cscf = addr->default_server;\n     ls->pool_size = cscf->connection_pool_size;\n-    ls->post_accept_timeout = cscf->client_header_timeout;\n \n     clcf = cscf->ctx->loc_conf[ngx_http_core_module.ctx_index];\n \nDiff:\n@@ -216,16 +216,17 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n void\n ngx_http_init_connection(ngx_connection_t *c)\n {\n-    ngx_uint_t              i;\n-    ngx_event_t            *rev;\n-    struct sockaddr_in     *sin;\n-    ngx_http_port_t        *port;\n-    ngx_http_in_addr_t     *addr;\n-    ngx_http_log_ctx_t     *ctx;\n-    ngx_http_connection_t  *hc;\n+    ngx_uint_t                 i;\n+    ngx_event_t               *rev;\n+    struct sockaddr_in        *sin;\n+    ngx_http_port_t           *port;\n+    ngx_http_in_addr_t        *addr;\n+    ngx_http_log_ctx_t        *ctx;\n+    ngx_http_connection_t     *hc;\n+    ngx_http_core_srv_conf_t  *cscf;\n #if (NGX_HAVE_INET6)\n-    struct sockaddr_in6    *sin6;\n-    ngx_http_in6_addr_t    *addr6;\n+    struct sockaddr_in6       *sin6;\n+    ngx_http_in6_addr_t       *addr6;\n #endif\n \n     hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));\n@@ -371,7 +372,9 @@ ngx_http_init_connection(ngx_connection_t *c)\n         return;\n     }\n \n-    ngx_add_timer(rev, c->listening->post_accept_timeout);\n+    cscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_core_module);\n+\n+    ngx_add_timer(rev, cscf->client_header_timeout);\n     ngx_reusable_connection(c, 1);\n \n     if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n@@ -445,7 +448,7 @@ ngx_http_wait_request_handler(ngx_event_t *rev)\n     if (n == NGX_AGAIN) {\n \n         if (!rev->timer_set) {\n-            ngx_add_timer(rev, c->listening->post_accept_timeout);\n+            ngx_add_timer(rev, cscf->client_header_timeout);\n             ngx_reusable_connection(c, 1);\n         }\n \n@@ -663,6 +666,7 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n     ngx_http_connection_t     *hc;\n     ngx_http_ssl_srv_conf_t   *sscf;\n     ngx_http_core_loc_conf_t  *clcf;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     c = rev->data;\n     hc = c->data;\n@@ -694,7 +698,9 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n             rev->ready = 0;\n \n             if (!rev->timer_set) {\n-                ngx_add_timer(rev, c->listening->post_accept_timeout);\n+                cscf = ngx_http_get_module_srv_conf(hc->conf_ctx,\n+                                                    ngx_http_core_module);\n+                ngx_add_timer(rev, cscf->client_header_timeout);\n                 ngx_reusable_connection(c, 1);\n             }\n \n@@ -769,7 +775,9 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n             if (rc == NGX_AGAIN) {\n \n                 if (!rev->timer_set) {\n-                    ngx_add_timer(rev, c->listening->post_accept_timeout);\n+                    cscf = ngx_http_get_module_srv_conf(hc->conf_ctx,\n+                                                        ngx_http_core_module);\n+                    ngx_add_timer(rev, cscf->client_header_timeout);\n                 }\n \n                 c->ssl->handler = ngx_http_ssl_handshake_handler;\n"
    },
    {
        "commit_sha": "8a24fcd0efefe8fd7a96dbd12cf7fb1fb0b45c05",
        "commit_index": "Commit 64",
        "commit_diff": "Diff:\n@@ -2334,6 +2334,13 @@ ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)\n \n     u = r->upstream;\n \n+    if (u->length == 0) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+        return NGX_OK;\n+    }\n+\n     for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {\n         ll = &cl->next;\n     }\nDiff:\n@@ -103,16 +103,6 @@ ngx_http_stub_status_handler(ngx_http_request_t *r)\n     ngx_str_set(&r->headers_out.content_type, \"text/plain\");\n     r->headers_out.content_type_lowcase = NULL;\n \n-    if (r->method == NGX_HTTP_HEAD) {\n-        r->headers_out.status = NGX_HTTP_OK;\n-\n-        rc = ngx_http_send_header(r);\n-\n-        if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n-            return rc;\n-        }\n-    }\n-\n     size = sizeof(\"Active connections:  \\n\") + NGX_ATOMIC_T_LEN\n            + sizeof(\"server accepts handled requests\\n\") - 1\n            + 6 + 3 * NGX_ATOMIC_T_LEN\nDiff:\n@@ -1782,7 +1782,7 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n         }\n     }\n \n-    if (r->method == NGX_HTTP_HEAD || (r != r->main && val.len == 0)) {\n+    if (r != r->main && val.len == 0) {\n         return ngx_http_send_header(r);\n     }\n \nDiff:\n@@ -3721,6 +3721,13 @@ ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)\n \n     u = r->upstream;\n \n+    if (u->length == 0) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+        return NGX_OK;\n+    }\n+\n     for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {\n         ll = &cl->next;\n     }\n"
    },
    {
        "commit_sha": "53335c3504c246149c5e3568716dc100b79f6aab",
        "commit_index": "Commit 63",
        "commit_diff": "Diff:\n@@ -455,3 +455,4 @@ a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n 3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\n dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n 8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\n+f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\nDiff:\n@@ -268,6 +268,7 @@ syn keyword ngxDirective contained grpc_socket_keepalive\n syn keyword ngxDirective contained grpc_ssl_certificate\n syn keyword ngxDirective contained grpc_ssl_certificate_key\n syn keyword ngxDirective contained grpc_ssl_ciphers\n+syn keyword ngxDirective contained grpc_ssl_conf_command\n syn keyword ngxDirective contained grpc_ssl_crl\n syn keyword ngxDirective contained grpc_ssl_name\n syn keyword ngxDirective contained grpc_ssl_password_file\n@@ -447,6 +448,7 @@ syn keyword ngxDirective contained proxy_cache_use_stale\n syn keyword ngxDirective contained proxy_cache_valid\n syn keyword ngxDirective contained proxy_connect_timeout\n syn keyword ngxDirective contained proxy_cookie_domain\n+syn keyword ngxDirective contained proxy_cookie_flags\n syn keyword ngxDirective contained proxy_cookie_path\n syn keyword ngxDirective contained proxy_download_rate\n syn keyword ngxDirective contained proxy_force_ranges\n@@ -480,11 +482,13 @@ syn keyword ngxDirective contained proxy_send_timeout\n syn keyword ngxDirective contained proxy_session_drop\n syn keyword ngxDirective contained proxy_set_body\n syn keyword ngxDirective contained proxy_set_header\n+syn keyword ngxDirective contained proxy_smtp_auth\n syn keyword ngxDirective contained proxy_socket_keepalive\n syn keyword ngxDirective contained proxy_ssl\n syn keyword ngxDirective contained proxy_ssl_certificate\n syn keyword ngxDirective contained proxy_ssl_certificate_key\n syn keyword ngxDirective contained proxy_ssl_ciphers\n+syn keyword ngxDirective contained proxy_ssl_conf_command\n syn keyword ngxDirective contained proxy_ssl_crl\n syn keyword ngxDirective contained proxy_ssl_name\n syn keyword ngxDirective contained proxy_ssl_password_file\n@@ -592,6 +596,7 @@ syn keyword ngxDirective contained ssl_certificate\n syn keyword ngxDirective contained ssl_certificate_key\n syn keyword ngxDirective contained ssl_ciphers\n syn keyword ngxDirective contained ssl_client_certificate\n+syn keyword ngxDirective contained ssl_conf_command\n syn keyword ngxDirective contained ssl_crl\n syn keyword ngxDirective contained ssl_dhparam\n syn keyword ngxDirective contained ssl_early_data\n@@ -605,6 +610,7 @@ syn keyword ngxDirective contained ssl_password_file\n syn keyword ngxDirective contained ssl_prefer_server_ciphers\n syn keyword ngxDirective contained ssl_preread\n syn keyword ngxDirective contained ssl_protocols\n+syn keyword ngxDirective contained ssl_reject_handshake\n syn keyword ngxDirective contained ssl_session_cache\n syn keyword ngxDirective contained ssl_session_ticket_key\n syn keyword ngxDirective contained ssl_session_tickets\n@@ -643,6 +649,7 @@ syn keyword ngxDirective contained user\n syn keyword ngxDirective contained userid\n syn keyword ngxDirective contained userid_domain\n syn keyword ngxDirective contained userid_expires\n+syn keyword ngxDirective contained userid_flags\n syn keyword ngxDirective contained userid_mark\n syn keyword ngxDirective contained userid_name\n syn keyword ngxDirective contained userid_p3p\n@@ -693,6 +700,7 @@ syn keyword ngxDirective contained uwsgi_socket_keepalive\n syn keyword ngxDirective contained uwsgi_ssl_certificate\n syn keyword ngxDirective contained uwsgi_ssl_certificate_key\n syn keyword ngxDirective contained uwsgi_ssl_ciphers\n+syn keyword ngxDirective contained uwsgi_ssl_conf_command\n syn keyword ngxDirective contained uwsgi_ssl_crl\n syn keyword ngxDirective contained uwsgi_ssl_name\n syn keyword ngxDirective contained uwsgi_ssl_password_file\n@@ -738,6 +746,7 @@ syn keyword ngxDirective contained zone_sync_ssl\n syn keyword ngxDirective contained zone_sync_ssl_certificate\n syn keyword ngxDirective contained zone_sync_ssl_certificate_key\n syn keyword ngxDirective contained zone_sync_ssl_ciphers\n+syn keyword ngxDirective contained zone_sync_ssl_conf_command\n syn keyword ngxDirective contained zone_sync_ssl_crl\n syn keyword ngxDirective contained zone_sync_ssl_name\n syn keyword ngxDirective contained zone_sync_ssl_password_file\n@@ -1329,6 +1338,8 @@ syn keyword ngxDirectiveThirdParty contained body_filter_by_lua_file\n syn keyword ngxDirectiveThirdParty contained content_by_lua\n syn keyword ngxDirectiveThirdParty contained content_by_lua_block\n syn keyword ngxDirectiveThirdParty contained content_by_lua_file\n+syn keyword ngxDirectiveThirdParty contained exit_worker_by_lua_block\n+syn keyword ngxDirectiveThirdParty contained exit_worker_by_lua_file\n syn keyword ngxDirectiveThirdParty contained header_filter_by_lua\n syn keyword ngxDirectiveThirdParty contained header_filter_by_lua_block\n syn keyword ngxDirectiveThirdParty contained header_filter_by_lua_file\n@@ -1370,6 +1381,7 @@ syn keyword ngxDirectiveThirdParty contained lua_ssl_crl\n syn keyword ngxDirectiveThirdParty contained lua_ssl_protocols\n syn keyword ngxDirectiveThirdParty contained lua_ssl_trusted_certificate\n syn keyword ngxDirectiveThirdParty contained lua_ssl_verify_depth\n+syn keyword ngxDirectiveThirdParty contained lua_thread_cache_max_entries\n syn keyword ngxDirectiveThirdParty contained lua_transform_underscores_in_response_headers\n syn keyword ngxDirectiveThirdParty contained lua_use_default_type\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua\n@@ -2285,6 +2297,7 @@ syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_i\n syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_key\n syn keyword ngxDirectiveThirdParty contained testcookie_refresh_status\n syn keyword ngxDirectiveThirdParty contained testcookie_refresh_template\n+syn keyword ngxDirectiveThirdParty contained testcookie_samesite\n syn keyword ngxDirectiveThirdParty contained testcookie_secret\n syn keyword ngxDirectiveThirdParty contained testcookie_secure_flag\n syn keyword ngxDirectiveThirdParty contained testcookie_session\n@@ -2355,28 +2368,46 @@ syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n \" IP2Location Nginx\n \" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location\n-syn keyword ngxDirectiveThirdParty contained ip2location_access_type\n syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n+syn keyword ngxDirectiveThirdParty contained ip2location_city\n+syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n+syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n+syn keyword ngxDirectiveThirdParty contained ip2location_domain\n+syn keyword ngxDirectiveThirdParty contained ip2location_elevation\n+syn keyword ngxDirectiveThirdParty contained ip2location_iddcode\n+syn keyword ngxDirectiveThirdParty contained ip2location_isp\n+syn keyword ngxDirectiveThirdParty contained ip2location_latitude\n+syn keyword ngxDirectiveThirdParty contained ip2location_longitude\n+syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n+syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n+syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n+syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n+syn keyword ngxDirectiveThirdParty contained ip2location_region\n+syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n+syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n+syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationcode\n+syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationname\n+syn keyword ngxDirectiveThirdParty contained ip2location_zipcode\n \n \" IP2Proxy module for Nginx\n \" https://github.com/ip2location/ip2proxy-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2proxy\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_access_type\n syn keyword ngxDirectiveThirdParty contained ip2proxy_as\n syn keyword ngxDirectiveThirdParty contained ip2proxy_asn\n syn keyword ngxDirectiveThirdParty contained ip2proxy_city\n syn keyword ngxDirectiveThirdParty contained ip2proxy_country_long\n syn keyword ngxDirectiveThirdParty contained ip2proxy_country_short\n syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\n syn keyword ngxDirectiveThirdParty contained ip2proxy_region\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_reverse_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_threat\n syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n \n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019006\n-#define NGINX_VERSION      \"1.19.6\"\n+#define nginx_version      1019007\n+#define NGINX_VERSION      \"1.19.7\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "d013ba38c39e20ad16581ae8fb32604e094851b1",
        "commit_index": "Commit 62",
        "commit_diff": "Diff:\n@@ -5,6 +5,55 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.6\" date=\"2020-12-15\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+ошибки \"no live upstreams\",\n+если server в блоке upstream был помечен как down.\n+</para>\n+<para lang=\"en\">\n+\"no live upstreams\" errors\n+if a \"server\" inside \"upstream\" block was marked as \"down\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTPS в рабочем процессе мог произойти segmentation fault;\n+ошибка появилась в 1.19.5.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process if HTTPS was used;\n+the bug had appeared in 1.19.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx возвращал ошибку 400 на запросы вида\n+<nobr>\"GET http://example.com?args HTTP/1.0\"</nobr>.\n+</para>\n+<para lang=\"en\">\n+nginx returned the 400 response on requests like\n+<nobr>\"GET http://example.com?args HTTP/1.0\"</nobr>.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модулях ngx_http_flv_module и ngx_http_mp4_module.<br/>\n+Спасибо Chris Newton.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_flv_module and ngx_http_mp4_module.<br/>\n+Thanks to Chris Newton.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.5\" date=\"2020-11-24\">\n \n <change type=\"feature\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1h\n+OPENSSL =\topenssl-1.1.1i\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -156,12 +156,6 @@ ngx_http_flv_handler(ngx_http_request_t *r)\n     }\n \n     if (!of.is_file) {\n-\n-        if (ngx_close_file(of.fd) == NGX_FILE_ERROR) {\n-            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n-                          ngx_close_file_n \" \\\"%s\\\" failed\", path.data);\n-        }\n-\n         return NGX_DECLINED;\n     }\n \nDiff:\n@@ -521,12 +521,6 @@ ngx_http_mp4_handler(ngx_http_request_t *r)\n     }\n \n     if (!of.is_file) {\n-\n-        if (ngx_close_file(of.fd) == NGX_FILE_ERROR) {\n-            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n-                          ngx_close_file_n \" \\\"%s\\\" failed\", path.data);\n-        }\n-\n         return NGX_DECLINED;\n     }\n \n"
    },
    {
        "commit_sha": "e40beb7d097687ea6e71ec899ffc397da9c3800c",
        "commit_index": "Commit 61",
        "commit_diff": "Diff:\n@@ -380,6 +380,12 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 r->uri_start = p;\n                 state = sw_after_slash_in_uri;\n                 break;\n+            case '?':\n+                r->uri_start = p;\n+                r->args_start = p + 1;\n+                r->empty_path_in_uri = 1;\n+                state = sw_uri;\n+                break;\n             case ' ':\n                 /*\n                  * use single \"/\" from request line to preserve pointers,\n@@ -446,6 +452,13 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 r->uri_start = p;\n                 state = sw_after_slash_in_uri;\n                 break;\n+            case '?':\n+                r->port_end = p;\n+                r->uri_start = p;\n+                r->args_start = p + 1;\n+                r->empty_path_in_uri = 1;\n+                state = sw_uri;\n+                break;\n             case ' ':\n                 r->port_end = p;\n                 /*\n@@ -1287,6 +1300,10 @@ ngx_http_parse_complex_uri(ngx_http_request_t *r, ngx_uint_t merge_slashes)\n     r->uri_ext = NULL;\n     r->args_start = NULL;\n \n+    if (r->empty_path_in_uri) {\n+        *u++ = '/';\n+    }\n+\n     ch = *p++;\n \n     while (p <= r->uri_end) {\nDiff:\n@@ -1239,9 +1239,13 @@ ngx_http_process_request_uri(ngx_http_request_t *r)\n         r->uri.len = r->uri_end - r->uri_start;\n     }\n \n-    if (r->complex_uri || r->quoted_uri) {\n+    if (r->complex_uri || r->quoted_uri || r->empty_path_in_uri) {\n \n-        r->uri.data = ngx_pnalloc(r->pool, r->uri.len + 1);\n+        if (r->empty_path_in_uri) {\n+            r->uri.len++;\n+        }\n+\n+        r->uri.data = ngx_pnalloc(r->pool, r->uri.len);\n         if (r->uri.data == NULL) {\n             ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n             return NGX_ERROR;\n@@ -1265,7 +1269,7 @@ ngx_http_process_request_uri(ngx_http_request_t *r)\n     r->unparsed_uri.len = r->uri_end - r->uri_start;\n     r->unparsed_uri.data = r->uri_start;\n \n-    r->valid_unparsed_uri = r->space_in_uri ? 0 : 1;\n+    r->valid_unparsed_uri = (r->space_in_uri || r->empty_path_in_uri) ? 0 : 1;\n \n     if (r->uri_ext) {\n         if (r->args_start) {\nDiff:\n@@ -479,6 +479,9 @@ struct ngx_http_request_s {\n     /* URI with \" \" */\n     unsigned                          space_in_uri:1;\n \n+    /* URI with empty path */\n+    unsigned                          empty_path_in_uri:1;\n+\n     unsigned                          invalid_header:1;\n \n     unsigned                          add_uri_to_alias:1;\n"
    },
    {
        "commit_sha": "97559791e32b97d724a97f478bcf0028b43c68ec",
        "commit_index": "Commit 60",
        "commit_diff": "Diff:\n@@ -2880,6 +2880,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n         SSL_free(c->ssl->connection);\n         c->ssl = NULL;\n+        c->recv = ngx_recv;\n \n         return NGX_OK;\n     }\n@@ -2925,6 +2926,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         if (n == 1) {\n             SSL_free(c->ssl->connection);\n             c->ssl = NULL;\n+            c->recv = ngx_recv;\n \n             return NGX_OK;\n         }\n@@ -2967,6 +2969,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n             SSL_free(c->ssl->connection);\n             c->ssl = NULL;\n+            c->recv = ngx_recv;\n \n             return NGX_OK;\n         }\n@@ -2977,6 +2980,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n         SSL_free(c->ssl->connection);\n         c->ssl = NULL;\n+        c->recv = ngx_recv;\n \n         return NGX_ERROR;\n     }\nDiff:\n@@ -3416,8 +3416,6 @@ ngx_http_set_lingering_close(ngx_connection_t *c)\n             c->ssl->handler = ngx_http_set_lingering_close;\n             return;\n         }\n-\n-        c->recv = ngx_recv;\n     }\n #endif\n \nDiff:\n@@ -10,8 +10,8 @@\n #include <ngx_http.h>\n \n \n-#define ngx_http_upstream_tries(p) ((p)->number                               \\\n-                                    + ((p)->next ? (p)->next->number : 0))\n+#define ngx_http_upstream_tries(p) ((p)->tries                                \\\n+                                    + ((p)->next ? (p)->next->tries : 0))\n \n \n static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(\n@@ -32,7 +32,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n     ngx_http_upstream_srv_conf_t *us)\n {\n     ngx_url_t                      u;\n-    ngx_uint_t                     i, j, n, w;\n+    ngx_uint_t                     i, j, n, w, t;\n     ngx_http_upstream_server_t    *server;\n     ngx_http_upstream_rr_peer_t   *peer, **peerp;\n     ngx_http_upstream_rr_peers_t  *peers, *backup;\n@@ -44,6 +44,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (server[i].backup) {\n@@ -52,6 +53,10 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -75,6 +80,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n         peers->number = n;\n         peers->weighted = (w != n);\n         peers->total_weight = w;\n+        peers->tries = t;\n         peers->name = &us->host;\n \n         n = 0;\n@@ -110,6 +116,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (!server[i].backup) {\n@@ -118,6 +125,10 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -139,6 +150,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n         backup->number = n;\n         backup->weighted = (w != n);\n         backup->total_weight = w;\n+        backup->tries = t;\n         backup->name = &us->host;\n \n         n = 0;\n@@ -214,6 +226,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n     peers->number = n;\n     peers->weighted = 0;\n     peers->total_weight = n;\n+    peers->tries = n;\n     peers->name = &us->host;\n \n     peerp = &peers->peer;\n@@ -332,6 +345,7 @@ ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,\n \n     peers->single = (ur->naddrs == 1);\n     peers->number = ur->naddrs;\n+    peers->tries = ur->naddrs;\n     peers->name = &ur->host;\n \n     if (ur->sockaddr) {\nDiff:\n@@ -68,6 +68,7 @@ struct ngx_http_upstream_rr_peers_s {\n #endif\n \n     ngx_uint_t                      total_weight;\n+    ngx_uint_t                      tries;\n \n     unsigned                        single:1;\n     unsigned                        weighted:1;\nDiff:\n@@ -739,8 +739,6 @@ ngx_http_v2_lingering_close(ngx_connection_t *c)\n             c->ssl->handler = ngx_http_v2_lingering_close;\n             return;\n         }\n-\n-        c->recv = ngx_recv;\n     }\n #endif\n \nDiff:\n@@ -10,8 +10,8 @@\n #include <ngx_stream.h>\n \n \n-#define ngx_stream_upstream_tries(p) ((p)->number                             \\\n-                                      + ((p)->next ? (p)->next->number : 0))\n+#define ngx_stream_upstream_tries(p) ((p)->tries                              \\\n+                                      + ((p)->next ? (p)->next->tries : 0))\n \n \n static ngx_stream_upstream_rr_peer_t *ngx_stream_upstream_get_peer(\n@@ -38,7 +38,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n     ngx_stream_upstream_srv_conf_t *us)\n {\n     ngx_url_t                        u;\n-    ngx_uint_t                       i, j, n, w;\n+    ngx_uint_t                       i, j, n, w, t;\n     ngx_stream_upstream_server_t    *server;\n     ngx_stream_upstream_rr_peer_t   *peer, **peerp;\n     ngx_stream_upstream_rr_peers_t  *peers, *backup;\n@@ -50,6 +50,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (server[i].backup) {\n@@ -58,6 +59,10 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -81,6 +86,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n         peers->number = n;\n         peers->weighted = (w != n);\n         peers->total_weight = w;\n+        peers->tries = t;\n         peers->name = &us->host;\n \n         n = 0;\n@@ -116,6 +122,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (!server[i].backup) {\n@@ -124,6 +131,10 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -145,6 +156,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n         backup->number = n;\n         backup->weighted = (w != n);\n         backup->total_weight = w;\n+        backup->tries = t;\n         backup->name = &us->host;\n \n         n = 0;\n@@ -220,6 +232,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n     peers->number = n;\n     peers->weighted = 0;\n     peers->total_weight = n;\n+    peers->tries = n;\n     peers->name = &us->host;\n \n     peerp = &peers->peer;\n@@ -342,6 +355,7 @@ ngx_stream_upstream_create_round_robin_peer(ngx_stream_session_t *s,\n \n     peers->single = (ur->naddrs == 1);\n     peers->number = ur->naddrs;\n+    peers->tries = ur->naddrs;\n     peers->name = &ur->host;\n \n     if (ur->sockaddr) {\nDiff:\n@@ -66,6 +66,7 @@ struct ngx_stream_upstream_rr_peers_s {\n #endif\n \n     ngx_uint_t                       total_weight;\n+    ngx_uint_t                       tries;\n \n     unsigned                         single:1;\n     unsigned                         weighted:1;\n"
    },
    {
        "commit_sha": "3775e888959690eb7e51f74e20b9d9ed3c91235a",
        "commit_index": "Commit 59",
        "commit_diff": "Diff:\n@@ -454,3 +454,4 @@ cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n 3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\n dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n+8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\nDiff:\n@@ -5,6 +5,62 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.5\" date=\"2020-11-24\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+ключ -e.\n+</para>\n+<para lang=\"en\">\n+the -e switch.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+при сборке дополнительных модулей\n+теперь можно указывать одни и те же исходные файлы в разных модулях.\n+</para>\n+<para lang=\"en\">\n+the same source files can now be specified in different modules\n+while building addon modules.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL shutdown не работал\n+при закрытии соединений с ожиданием дополнительных данных (lingering close).\n+</para>\n+<para lang=\"en\">\n+SSL shutdown did not work\n+when lingering close was used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при работе с gRPC-бэкендами\n+могли возникать ошибки \"upstream sent frame for closed stream\".\n+</para>\n+<para lang=\"en\">\n+\"upstream sent frame for closed stream\" errors might occur\n+when working with gRPC backends.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+во внутреннем API для обработки тела запроса.\n+</para>\n+<para lang=\"en\">\n+in request body filters internal API.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.4\" date=\"2020-10-27\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019005\n-#define NGINX_VERSION      \"1.19.5\"\n+#define nginx_version      1019006\n+#define NGINX_VERSION      \"1.19.6\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "321af6d662e93178297f68924fb9186995573d6b",
        "commit_index": "Commit 58",
        "commit_diff": "Diff:\n@@ -87,6 +87,10 @@ have=NGX_PID_PATH value=\"\\\"$NGX_PID_PATH\\\"\" . auto/define\n have=NGX_LOCK_PATH value=\"\\\"$NGX_LOCK_PATH\\\"\" . auto/define\n have=NGX_ERROR_LOG_PATH value=\"\\\"$NGX_ERROR_LOG_PATH\\\"\" . auto/define\n \n+if [ \".$NGX_ERROR_LOG_PATH\" = \".\" ]; then\n+    have=NGX_ERROR_LOG_STDERR . auto/have\n+fi\n+\n have=NGX_HTTP_LOG_PATH value=\"\\\"$NGX_HTTP_LOG_PATH\\\"\" . auto/define\n have=NGX_HTTP_CLIENT_TEMP_PATH value=\"\\\"$NGX_HTTP_CLIENT_TEMP_PATH\\\"\"\n . auto/define\nDiff:\n@@ -25,7 +25,7 @@\n .\\\" SUCH DAMAGE.\n .\\\"\n .\\\"\n-.Dd December 5, 2019\n+.Dd November 5, 2020\n .Dt NGINX 8\n .Os\n .Sh NAME\n@@ -35,6 +35,7 @@\n .Nm\n .Op Fl ?hqTtVv\n .Op Fl c Ar file\n+.Op Fl e Ar file\n .Op Fl g Ar directives\n .Op Fl p Ar prefix\n .Op Fl s Ar signal\n@@ -54,6 +55,12 @@ Print help.\n .It Fl c Ar file\n Use an alternative configuration\n .Ar file .\n+.It Fl e Ar file\n+Use an alternative error log\n+.Ar file .\n+Special value\n+.Cm stderr\n+indicates that the standard error output should be used.\n .It Fl g Ar directives\n Set global configuration directives.\n See\n@@ -198,10 +205,10 @@ Development of\n started in 2002, with the first public release on October 4, 2004.\n .Sh AUTHORS\n .An -nosplit\n-.An Igor Sysoev Aq igor@sysoev.ru .\n+.An Igor Sysoev Aq Mt igor@sysoev.ru .\n .Pp\n This manual page was originally written by\n-.An Sergey A. Osokin Aq osa@FreeBSD.org.ru\n+.An Sergey A. Osokin Aq Mt osa@FreeBSD.org.ru\n as a result of compiling many\n .Nm\n documents from all over the world.\nDiff:\n@@ -197,6 +197,7 @@ static ngx_uint_t   ngx_show_help;\n static ngx_uint_t   ngx_show_version;\n static ngx_uint_t   ngx_show_configure;\n static u_char      *ngx_prefix;\n+static u_char      *ngx_error_log;\n static u_char      *ngx_conf_file;\n static u_char      *ngx_conf_params;\n static char        *ngx_signal;\n@@ -244,7 +245,7 @@ main(int argc, char *const *argv)\n     ngx_pid = ngx_getpid();\n     ngx_parent = ngx_getppid();\n \n-    log = ngx_log_init(ngx_prefix);\n+    log = ngx_log_init(ngx_prefix, ngx_error_log);\n     if (log == NULL) {\n         return 1;\n     }\n@@ -407,9 +408,9 @@ ngx_show_version_info(void)\n \n     if (ngx_show_help) {\n         ngx_write_stderr(\n-            \"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] \"\n-                         \"[-p prefix] [-g directives]\" NGX_LINEFEED\n-                         NGX_LINEFEED\n+            \"Usage: nginx [-?hvVtTq] [-s signal] [-p prefix]\" NGX_LINEFEED\n+            \"             [-e filename] [-c filename] [-g directives]\"\n+                          NGX_LINEFEED NGX_LINEFEED\n             \"Options:\" NGX_LINEFEED\n             \"  -?,-h         : this help\" NGX_LINEFEED\n             \"  -v            : show version and exit\" NGX_LINEFEED\n@@ -427,6 +428,12 @@ ngx_show_version_info(void)\n                                NGX_LINEFEED\n #else\n             \"  -p prefix     : set prefix path (default: NONE)\" NGX_LINEFEED\n+#endif\n+            \"  -e filename   : set error log file (default: \"\n+#ifdef NGX_ERROR_LOG_STDERR\n+                               \"stderr)\" NGX_LINEFEED\n+#else\n+                               NGX_ERROR_LOG_PATH \")\" NGX_LINEFEED\n #endif\n             \"  -c filename   : set configuration file (default: \" NGX_CONF_PATH\n                                \")\" NGX_LINEFEED\n@@ -814,6 +821,24 @@ ngx_get_options(int argc, char *const *argv)\n                 ngx_log_stderr(0, \"option \\\"-p\\\" requires directory name\");\n                 return NGX_ERROR;\n \n+            case 'e':\n+                if (*p) {\n+                    ngx_error_log = p;\n+\n+                } else if (argv[++i]) {\n+                    ngx_error_log = (u_char *) argv[i];\n+\n+                } else {\n+                    ngx_log_stderr(0, \"option \\\"-e\\\" requires file name\");\n+                    return NGX_ERROR;\n+                }\n+\n+                if (ngx_strcmp(ngx_error_log, \"stderr\") == 0) {\n+                    ngx_error_log = (u_char *) \"\";\n+                }\n+\n+                goto next;\n+\n             case 'c':\n                 if (*p) {\n                     ngx_conf_file = p;\n@@ -1006,6 +1031,14 @@ ngx_process_options(ngx_cycle_t *cycle)\n         }\n     }\n \n+    if (ngx_error_log) {\n+        cycle->error_log.len = ngx_strlen(ngx_error_log);\n+        cycle->error_log.data = ngx_error_log;\n+\n+    } else {\n+        ngx_str_set(&cycle->error_log, NGX_ERROR_LOG_PATH);\n+    }\n+\n     if (ngx_conf_params) {\n         cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n         cycle->conf_param.data = ngx_conf_params;\nDiff:\n@@ -133,6 +133,15 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n         return NULL;\n     }\n \n+    cycle->error_log.len = old_cycle->error_log.len;\n+    cycle->error_log.data = ngx_pnalloc(pool, old_cycle->error_log.len + 1);\n+    if (cycle->error_log.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    ngx_cpystrn(cycle->error_log.data, old_cycle->error_log.data,\n+                old_cycle->error_log.len + 1);\n+\n     cycle->conf_file.len = old_cycle->conf_file.len;\n     cycle->conf_file.data = ngx_pnalloc(pool, old_cycle->conf_file.len + 1);\n     if (cycle->conf_file.data == NULL) {\nDiff:\n@@ -96,6 +96,7 @@ struct ngx_cycle_s {\n     ngx_str_t                 conf_param;\n     ngx_str_t                 conf_prefix;\n     ngx_str_t                 prefix;\n+    ngx_str_t                 error_log;\n     ngx_str_t                 lock_file;\n     ngx_str_t                 hostname;\n     ngx_black_list_t         *black_list;\nDiff:\n@@ -315,21 +315,19 @@ ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err)\n \n \n ngx_log_t *\n-ngx_log_init(u_char *prefix)\n+ngx_log_init(u_char *prefix, u_char *error_log)\n {\n     u_char  *p, *name;\n     size_t   nlen, plen;\n \n     ngx_log.file = &ngx_log_file;\n     ngx_log.log_level = NGX_LOG_NOTICE;\n \n-    name = (u_char *) NGX_ERROR_LOG_PATH;\n-\n-    /*\n-     * we use ngx_strlen() here since BCC warns about\n-     * condition is always false and unreachable code\n-     */\n+    if (error_log == NULL) {\n+        error_log = (u_char *) NGX_ERROR_LOG_PATH;\n+    }\n \n+    name = error_log;\n     nlen = ngx_strlen(name);\n \n     if (nlen == 0) {\n@@ -369,7 +367,7 @@ ngx_log_init(u_char *prefix)\n                 *p++ = '/';\n             }\n \n-            ngx_cpystrn(p, (u_char *) NGX_ERROR_LOG_PATH, nlen + 1);\n+            ngx_cpystrn(p, error_log, nlen + 1);\n \n             p = name;\n         }\n@@ -403,8 +401,7 @@ ngx_log_init(u_char *prefix)\n ngx_int_t\n ngx_log_open_default(ngx_cycle_t *cycle)\n {\n-    ngx_log_t         *log;\n-    static ngx_str_t   error_log = ngx_string(NGX_ERROR_LOG_PATH);\n+    ngx_log_t  *log;\n \n     if (ngx_log_get_file_log(&cycle->new_log) != NULL) {\n         return NGX_OK;\n@@ -425,7 +422,7 @@ ngx_log_open_default(ngx_cycle_t *cycle)\n \n     log->log_level = NGX_LOG_ERR;\n \n-    log->file = ngx_conf_open_file(cycle, &error_log);\n+    log->file = ngx_conf_open_file(cycle, &cycle->error_log);\n     if (log->file == NULL) {\n         return NGX_ERROR;\n     }\nDiff:\n@@ -228,7 +228,7 @@ void ngx_cdecl ngx_log_debug_core(ngx_log_t *log, ngx_err_t err,\n \n /*********************************/\n \n-ngx_log_t *ngx_log_init(u_char *prefix);\n+ngx_log_t *ngx_log_init(u_char *prefix, u_char *error_log);\n void ngx_cdecl ngx_log_abort(ngx_err_t err, const char *fmt, ...);\n void ngx_cdecl ngx_log_stderr(ngx_err_t err, const char *fmt, ...);\n u_char *ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err);\nDiff:\n@@ -1969,6 +1969,7 @@ ngx_http_grpc_filter_init(void *data)\n         }\n \n         u->length = 0;\n+        ctx->done = 1;\n \n     } else {\n         u->length = 1;\n"
    },
    {
        "commit_sha": "5f09a4176c11def7d740dbbaa0e756b43dac4d54",
        "commit_index": "Commit 57",
        "commit_diff": "Diff:\n@@ -502,6 +502,7 @@ fi\n for ngx_module in $DYNAMIC_MODULES\n do\n     eval ngx_module_srcs=\"\\$${ngx_module}_SRCS\"\n+    eval ngx_module_shrd=\"\\$${ngx_module}_SHRD\"\n     eval eval ngx_module_libs=\"\\\\\\\"\\$${ngx_module}_LIBS\\\\\\\"\"\n \n     eval ngx_module_modules=\"\\$${ngx_module}_MODULES\"\n@@ -567,7 +568,7 @@ END\n         | sed -e \"s/\\(.*\\.\\)c/\\1$ngx_objext/\"`\n \n     ngx_module_objs=\n-    for ngx_src in $ngx_module_srcs\n+    for ngx_src in $ngx_module_srcs $ngx_module_shrd\n     do\n         case \"$ngx_src\" in\n             src/*)\nDiff:\n@@ -17,7 +17,6 @@ if [ \"$ngx_module_link\" = DYNAMIC ]; then\n     done\n \n     DYNAMIC_MODULES=\"$DYNAMIC_MODULES $ngx_module\"\n-    eval ${ngx_module}_SRCS=\\\"$ngx_module_srcs\\\"\n \n     eval ${ngx_module}_MODULES=\\\"$ngx_module_name\\\"\n \n@@ -31,6 +30,30 @@ if [ \"$ngx_module_link\" = DYNAMIC ]; then\n         eval ${ngx_module}_ORDER=\\\"$ngx_module_order\\\"\n     fi\n \n+    srcs=\n+    shrd=\n+    for src in $ngx_module_srcs\n+    do\n+        found=no\n+        for old in $DYNAMIC_MODULES_SRCS\n+        do\n+            if [ $src = $old ]; then\n+                found=yes\n+                break\n+            fi\n+        done\n+\n+        if [ $found = no ]; then\n+            srcs=\"$srcs $src\"\n+        else\n+            shrd=\"$shrd $src\"\n+        fi\n+    done\n+    eval ${ngx_module}_SRCS=\\\"$srcs\\\"\n+    eval ${ngx_module}_SHRD=\\\"$shrd\\\"\n+\n+    DYNAMIC_MODULES_SRCS=\"$DYNAMIC_MODULES_SRCS $srcs\"\n+\n     if test -n \"$ngx_module_incs\"; then\n         CORE_INCS=\"$CORE_INCS $ngx_module_incs\"\n     fi\n@@ -107,7 +130,24 @@ elif [ \"$ngx_module_link\" = ADDON ]; then\n     eval ${ngx_module_type}_MODULES=\\\"\\$${ngx_module_type}_MODULES \\\n                                       $ngx_module_name\\\"\n \n-    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_module_srcs\"\n+    srcs=\n+    for src in $ngx_module_srcs\n+    do\n+        found=no\n+        for old in $NGX_ADDON_SRCS\n+        do\n+            if [ $src = $old ]; then\n+                found=yes\n+                break\n+            fi\n+        done\n+\n+        if [ $found = no ]; then\n+            srcs=\"$srcs $src\"\n+        fi\n+    done\n+\n+    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $srcs\"\n \n     if test -n \"$ngx_module_incs\"; then\n         eval ${ngx_var}_INCS=\\\"\\$${ngx_var}_INCS $ngx_module_incs\\\"\nDiff:\n@@ -132,6 +132,7 @@ STREAM_UPSTREAM_ZONE=YES\n STREAM_SSL_PREREAD=NO\n \n DYNAMIC_MODULES=\n+DYNAMIC_MODULES_SRCS=\n \n NGX_ADDONS=\n NGX_ADDON_SRCS=\n"
    },
    {
        "commit_sha": "0ed6842232de0c2cd7aa1089437d32c316138b98",
        "commit_index": "Commit 56",
        "commit_diff": "Diff:\n@@ -313,7 +313,7 @@ $ngx_obj:\t\\$(CORE_DEPS) \\$(HTTP_DEPS)$ngx_cont$ngx_src\n END\n \n         fi\n-     done\n+    done\n \n fi\n \n@@ -343,7 +343,7 @@ $ngx_obj:\t\\$(CORE_DEPS) \\$(MAIL_DEPS)$ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \n@@ -373,7 +373,7 @@ $ngx_obj:\t\\$(CORE_DEPS) \\$(STREAM_DEPS)$ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \n@@ -399,7 +399,7 @@ $ngx_obj:\t\\$(CORE_DEPS) $ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \n@@ -431,7 +431,7 @@ $ngx_obj:\t\\$(ADDON_DEPS)$ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \nDiff:\n@@ -134,6 +134,7 @@ STREAM_SSL_PREREAD=NO\n DYNAMIC_MODULES=\n \n NGX_ADDONS=\n+NGX_ADDON_SRCS=\n NGX_ADDON_DEPS=\n DYNAMIC_ADDONS=\n \nDiff:\n@@ -137,8 +137,9 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n     } else {\n         /* set rb->rest */\n \n-        if (ngx_http_request_body_filter(r, NULL) != NGX_OK) {\n-            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        rc = ngx_http_request_body_filter(r, NULL);\n+\n+        if (rc != NGX_OK) {\n             goto done;\n         }\n     }\n"
    },
    {
        "commit_sha": "103f9035b970172746680da65b11ef09cc4a9c81",
        "commit_index": "Commit 55",
        "commit_diff": "Diff:\n@@ -53,7 +53,7 @@ static void ngx_http_request_finalizer(ngx_http_request_t *r);\n \n static void ngx_http_set_keepalive(ngx_http_request_t *r);\n static void ngx_http_keepalive_handler(ngx_event_t *ev);\n-static void ngx_http_set_lingering_close(ngx_http_request_t *r);\n+static void ngx_http_set_lingering_close(ngx_connection_t *c);\n static void ngx_http_lingering_close_handler(ngx_event_t *ev);\n static ngx_int_t ngx_http_post_action(ngx_http_request_t *r);\n static void ngx_http_close_request(ngx_http_request_t *r, ngx_int_t error);\n@@ -2773,7 +2773,7 @@ ngx_http_finalize_connection(ngx_http_request_t *r)\n                 || r->header_in->pos < r->header_in->last\n                 || r->connection->read->ready)))\n     {\n-        ngx_http_set_lingering_close(r);\n+        ngx_http_set_lingering_close(r->connection);\n         return;\n     }\n \n@@ -3387,22 +3387,43 @@ ngx_http_keepalive_handler(ngx_event_t *rev)\n \n \n static void\n-ngx_http_set_lingering_close(ngx_http_request_t *r)\n+ngx_http_set_lingering_close(ngx_connection_t *c)\n {\n     ngx_event_t               *rev, *wev;\n-    ngx_connection_t          *c;\n+    ngx_http_request_t        *r;\n     ngx_http_core_loc_conf_t  *clcf;\n \n-    c = r->connection;\n+    r = c->data;\n \n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n \n+    if (r->lingering_time == 0) {\n+        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n+    }\n+\n+#if (NGX_HTTP_SSL)\n+    if (c->ssl) {\n+        ngx_int_t  rc;\n+\n+        rc = ngx_ssl_shutdown(c);\n+\n+        if (rc == NGX_ERROR) {\n+            ngx_http_close_request(r, 0);\n+            return;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->ssl->handler = ngx_http_set_lingering_close;\n+            return;\n+        }\n+\n+        c->recv = ngx_recv;\n+    }\n+#endif\n+\n     rev = c->read;\n     rev->handler = ngx_http_lingering_close_handler;\n \n-    r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n-    ngx_add_timer(rev, clcf->lingering_timeout);\n-\n     if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n         ngx_http_close_request(r, 0);\n         return;\n@@ -3425,6 +3446,8 @@ ngx_http_set_lingering_close(ngx_http_request_t *r)\n         return;\n     }\n \n+    ngx_add_timer(rev, clcf->lingering_timeout);\n+\n     if (rev->ready) {\n         ngx_http_lingering_close_handler(rev);\n     }\nDiff:\n@@ -305,6 +305,9 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n                         return NGX_AGAIN;\n                     }\n \n+                    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                                  \"busy buffers after request body flush\");\n+\n                     return NGX_HTTP_INTERNAL_SERVER_ERROR;\n                 }\n \n@@ -674,6 +677,7 @@ ngx_http_discarded_request_body_handler(ngx_http_request_t *r)\n     if (rc == NGX_OK) {\n         r->discard_body = 0;\n         r->lingering_close = 0;\n+        r->lingering_time = 0;\n         ngx_http_finalize_request(r, NGX_DONE);\n         return;\n     }\nDiff:\n@@ -60,7 +60,7 @@ typedef struct {\n static void ngx_http_v2_read_handler(ngx_event_t *rev);\n static void ngx_http_v2_write_handler(ngx_event_t *wev);\n static void ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c);\n-static void ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c);\n+static void ngx_http_v2_lingering_close(ngx_connection_t *c);\n static void ngx_http_v2_lingering_close_handler(ngx_event_t *rev);\n \n static u_char *ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c,\n@@ -664,7 +664,7 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n     }\n \n     if (h2c->goaway) {\n-        ngx_http_v2_lingering_close(h2c);\n+        ngx_http_v2_lingering_close(c);\n         return;\n     }\n \n@@ -703,13 +703,13 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n \n \n static void\n-ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n+ngx_http_v2_lingering_close(ngx_connection_t *c)\n {\n     ngx_event_t               *rev, *wev;\n-    ngx_connection_t          *c;\n+    ngx_http_v2_connection_t  *h2c;\n     ngx_http_core_loc_conf_t  *clcf;\n \n-    c = h2c->connection;\n+    h2c = c->data;\n \n     clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n                                         ngx_http_core_module);\n@@ -719,12 +719,34 @@ ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    if (h2c->lingering_time == 0) {\n+        h2c->lingering_time = ngx_time()\n+                              + (time_t) (clcf->lingering_time / 1000);\n+    }\n+\n+#if (NGX_HTTP_SSL)\n+    if (c->ssl) {\n+        ngx_int_t  rc;\n+\n+        rc = ngx_ssl_shutdown(c);\n+\n+        if (rc == NGX_ERROR) {\n+            ngx_http_close_connection(c);\n+            return;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->ssl->handler = ngx_http_v2_lingering_close;\n+            return;\n+        }\n+\n+        c->recv = ngx_recv;\n+    }\n+#endif\n+\n     rev = c->read;\n     rev->handler = ngx_http_v2_lingering_close_handler;\n \n-    h2c->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n-    ngx_add_timer(rev, clcf->lingering_timeout);\n-\n     if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n         ngx_http_close_connection(c);\n         return;\n@@ -747,6 +769,8 @@ ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    ngx_add_timer(rev, clcf->lingering_timeout);\n+\n     if (rev->ready) {\n         ngx_http_v2_lingering_close_handler(rev);\n     }\n@@ -4757,7 +4781,7 @@ ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n         return;\n     }\n \n-    ngx_http_v2_lingering_close(h2c);\n+    ngx_http_v2_lingering_close(c);\n }\n \n \n"
    },
    {
        "commit_sha": "a30cd46ea3c5321763ec1e489c3a70b0e62a8b6b",
        "commit_index": "Commit 54",
        "commit_diff": "Diff:\n@@ -11,6 +11,8 @@\n \n static u_char *ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64,\n     u_char zero, ngx_uint_t hexadecimal, ngx_uint_t width);\n+static u_char *ngx_sprintf_str(u_char *buf, u_char *last, u_char *src,\n+    size_t len, ngx_uint_t hexadecimal);\n static void ngx_encode_base64_internal(ngx_str_t *dst, ngx_str_t *src,\n     const u_char *basis, ngx_uint_t padding);\n static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst, ngx_str_t *src,\n@@ -101,10 +103,10 @@ ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src)\n  *    %M                        ngx_msec_t\n  *    %r                        rlim_t\n  *    %p                        void *\n- *    %V                        ngx_str_t *\n- *    %v                        ngx_variable_value_t *\n- *    %s                        null-terminated string\n- *    %*s                       length and string\n+ *    %[x|X]V                   ngx_str_t *\n+ *    %[x|X]v                   ngx_variable_value_t *\n+ *    %[x|X]s                   null-terminated string\n+ *    %*[x|X]s                  length and string\n  *    %Z                        '\\0'\n  *    %N                        '\\n'\n  *    %c                        char\n@@ -165,7 +167,7 @@ ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)\n     u_char                *p, zero;\n     int                    d;\n     double                 f;\n-    size_t                 len, slen;\n+    size_t                 slen;\n     int64_t                i64;\n     uint64_t               ui64, frac;\n     ngx_msec_t             ms;\n@@ -250,34 +252,23 @@ ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)\n             case 'V':\n                 v = va_arg(args, ngx_str_t *);\n \n-                len = ngx_min(((size_t) (last - buf)), v->len);\n-                buf = ngx_cpymem(buf, v->data, len);\n+                buf = ngx_sprintf_str(buf, last, v->data, v->len, hex);\n                 fmt++;\n \n                 continue;\n \n             case 'v':\n                 vv = va_arg(args, ngx_variable_value_t *);\n \n-                len = ngx_min(((size_t) (last - buf)), vv->len);\n-                buf = ngx_cpymem(buf, vv->data, len);\n+                buf = ngx_sprintf_str(buf, last, vv->data, vv->len, hex);\n                 fmt++;\n \n                 continue;\n \n             case 's':\n                 p = va_arg(args, u_char *);\n \n-                if (slen == (size_t) -1) {\n-                    while (*p && buf < last) {\n-                        *buf++ = *p++;\n-                    }\n-\n-                } else {\n-                    len = ngx_min(((size_t) (last - buf)), slen);\n-                    buf = ngx_cpymem(buf, p, len);\n-                }\n-\n+                buf = ngx_sprintf_str(buf, last, p, slen, hex);\n                 fmt++;\n \n                 continue;\n@@ -576,6 +567,64 @@ ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64, u_char zero,\n }\n \n \n+static u_char *\n+ngx_sprintf_str(u_char *buf, u_char *last, u_char *src, size_t len,\n+    ngx_uint_t hexadecimal)\n+{\n+    static u_char   hex[] = \"0123456789abcdef\";\n+    static u_char   HEX[] = \"0123456789ABCDEF\";\n+\n+    if (hexadecimal == 0) {\n+\n+        if (len == (size_t) -1) {\n+            while (*src && buf < last) {\n+                *buf++ = *src++;\n+            }\n+\n+        } else {\n+            len = ngx_min((size_t) (last - buf), len);\n+            buf = ngx_cpymem(buf, src, len);\n+        }\n+\n+    } else if (hexadecimal == 1) {\n+\n+        if (len == (size_t) -1) {\n+\n+            while (*src && buf < last - 1) {\n+                *buf++ = hex[*src >> 4];\n+                *buf++ = hex[*src++ & 0xf];\n+            }\n+\n+        } else {\n+\n+            while (len-- && buf < last - 1) {\n+                *buf++ = hex[*src >> 4];\n+                *buf++ = hex[*src++ & 0xf];\n+            }\n+        }\n+\n+    } else { /* hexadecimal == 2 */\n+\n+        if (len == (size_t) -1) {\n+\n+            while (*src && buf < last - 1) {\n+                *buf++ = HEX[*src >> 4];\n+                *buf++ = HEX[*src++ & 0xf];\n+            }\n+\n+        } else {\n+\n+            while (len-- && buf < last - 1) {\n+                *buf++ = HEX[*src >> 4];\n+                *buf++ = HEX[*src++ & 0xf];\n+            }\n+        }\n+    }\n+\n+    return buf;\n+}\n+\n+\n /*\n  * We use ngx_strcasecmp()/ngx_strncasecmp() for 7-bit ASCII strings only,\n  * and implement our own ngx_strcasecmp()/ngx_strncasecmp()\nDiff:\n@@ -4057,9 +4057,6 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n     ngx_ssl_session_ticket_key_t  *key;\n     const EVP_MD                  *digest;\n     const EVP_CIPHER              *cipher;\n-#if (NGX_DEBUG)\n-    u_char                         buf[32];\n-#endif\n \n     c = ngx_ssl_get_connection(ssl_conn);\n     ssl_ctx = c->ssl->session_ctx;\n@@ -4081,8 +4078,8 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         /* encrypt session ticket */\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket encrypt, key: \\\"%*s\\\" (%s session)\",\n-                       ngx_hex_dump(buf, key[0].name, 16) - buf, buf,\n+                       \"ssl session ticket encrypt, key: \\\"%*xs\\\" (%s session)\",\n+                       (size_t) 16, key[0].name,\n                        SSL_session_reused(ssl_conn) ? \"reused\" : \"new\");\n \n         if (key[0].size == 48) {\n@@ -4128,17 +4125,16 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         }\n \n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*s\\\" not found\",\n-                       ngx_hex_dump(buf, name, 16) - buf, buf);\n+                       \"ssl session ticket decrypt, key: \\\"%*xs\\\" not found\",\n+                       (size_t) 16, name);\n \n         return 0;\n \n     found:\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*s\\\"%s\",\n-                       ngx_hex_dump(buf, key[i].name, 16) - buf, buf,\n-                       (i == 0) ? \" (default)\" : \"\");\n+                       \"ssl session ticket decrypt, key: \\\"%*xs\\\"%s\",\n+                       (size_t) 16, key[i].name, (i == 0) ? \" (default)\" : \"\");\n \n         if (key[i].size == 48) {\n             cipher = EVP_aes_128_cbc();\nDiff:\n@@ -2662,16 +2662,8 @@ ngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx)\n     p = ngx_cpymem(p, serial->data, serial->length);\n     ngx_memzero(p, 20 - serial->length);\n \n-#if (NGX_DEBUG)\n-    {\n-        u_char  buf[120];\n-\n-        ngx_hex_dump(buf, ctx->key.data, ctx->key.len);\n-\n-        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n-                       \"ssl ocsp key %*s\", sizeof(buf), buf);\n-    }\n-#endif\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp key %xV\", &ctx->key);\n \n     return NGX_OK;\n }\nDiff:\n@@ -1141,20 +1141,11 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n \n     f->flags |= NGX_HTTP_V2_END_HEADERS_FLAG;\n \n-#if (NGX_DEBUG)\n-    if (r->connection->log->log_level & NGX_LOG_DEBUG_HTTP) {\n-        u_char  buf[512];\n-        size_t  n, m;\n-\n-        n = ngx_min(b->last - b->pos, 256);\n-        m = ngx_hex_dump(buf, b->pos, n) - buf;\n-\n-        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"grpc header: %*s%s, len: %uz\",\n-                       m, buf, b->last - b->pos > 256 ? \"...\" : \"\",\n-                       b->last - b->pos);\n-    }\n-#endif\n+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"grpc header: %*xs%s, len: %uz\",\n+                   (size_t) ngx_min(b->last - b->pos, 256), b->pos,\n+                   b->last - b->pos > 256 ? \"...\" : \"\",\n+                   b->last - b->pos);\n \n     if (r->request_body_no_buffering) {\n \n@@ -1604,20 +1595,11 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n     u = r->upstream;\n     b = &u->buffer;\n \n-#if (NGX_DEBUG)\n-    if (r->connection->log->log_level & NGX_LOG_DEBUG_HTTP) {\n-        u_char  buf[512];\n-        size_t  n, m;\n-\n-        n = ngx_min(b->last - b->pos, 256);\n-        m = ngx_hex_dump(buf, b->pos, n) - buf;\n-\n-        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"grpc response: %*s%s, len: %uz\",\n-                       m, buf, b->last - b->pos > 256 ? \"...\" : \"\",\n-                       b->last - b->pos);\n-    }\n-#endif\n+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"grpc response: %*xs%s, len: %uz\",\n+                   (size_t) ngx_min(b->last - b->pos, 256),\n+                   b->pos, b->last - b->pos > 256 ? \"...\" : \"\",\n+                   b->last - b->pos);\n \n     ctx = ngx_http_grpc_get_ctx(r);\n \nDiff:\n@@ -3058,13 +3058,6 @@ ngx_http_set_keepalive(ngx_http_request_t *r)\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, \"set http keepalive handler\");\n \n-    if (r->discard_body) {\n-        r->write_event_handler = ngx_http_request_empty_handler;\n-        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n-        ngx_add_timer(rev, clcf->lingering_timeout);\n-        return;\n-    }\n-\n     c->log->action = \"closing request\";\n \n     hc = r->http_connection;\n"
    },
    {
        "commit_sha": "4de2ffdf50d807887af6ac08a637a52713d58450",
        "commit_index": "Commit 53",
        "commit_diff": "Diff:\n@@ -453,3 +453,4 @@ cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n 062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\n a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n 3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\n+dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\nDiff:\n@@ -5,6 +5,40 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.4\" date=\"2020-10-27\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директивы ssl_conf_command, proxy_ssl_conf_command, grpc_ssl_conf_command\n+и uwsgi_ssl_conf_command.\n+</para>\n+<para lang=\"en\">\n+the \"ssl_conf_command\", \"proxy_ssl_conf_command\", \"grpc_ssl_conf_command\",\n+and \"uwsgi_ssl_conf_command\" directives.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива ssl_reject_handshake.\n+</para>\n+<para lang=\"en\">\n+the \"ssl_reject_handshake\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива proxy_smtp_auth в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_smtp_auth\" directive in mail proxy.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.3\" date=\"2020-09-29\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019004\n-#define NGINX_VERSION      \"1.19.4\"\n+#define nginx_version      1019005\n+#define NGINX_VERSION      \"1.19.5\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "37233162ab2dbfec2a30a6499a7c908f6cc8700e",
        "commit_index": "Commit 52",
        "commit_diff": "Diff:\n@@ -1793,6 +1793,13 @@ ngx_ssl_handshake(ngx_connection_t *c)\n         return NGX_ERROR;\n     }\n \n+    if (c->ssl->handshake_rejected) {\n+        ngx_connection_error(c, err, \"handshake rejected\");\n+        ERR_clear_error();\n+\n+        return NGX_ERROR;\n+    }\n+\n     c->read->error = 1;\n \n     ngx_ssl_connection_error(c, sslerr, err, \"SSL_do_handshake() failed\");\n@@ -3354,8 +3361,9 @@ ngx_ssl_session_id_context(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n         }\n     }\n \n-    if (SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index) == NULL) {\n-\n+    if (SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index) == NULL\n+        && certificates != NULL)\n+    {\n         /*\n          * If certificates are loaded dynamically, we use certificate\n          * names as specified in the configuration (with variables).\nDiff:\n@@ -95,6 +95,7 @@ struct ngx_ssl_connection_s {\n     u_char                      early_buf;\n \n     unsigned                    handshaked:1;\n+    unsigned                    handshake_rejected:1;\n     unsigned                    renegotiation:1;\n     unsigned                    buffer:1;\n     unsigned                    no_wait_shutdown:1;\nDiff:\n@@ -294,6 +294,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, conf_commands),\n       &ngx_http_ssl_conf_command_post },\n \n+    { ngx_string(\"ssl_reject_handshake\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, reject_handshake),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -614,6 +621,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->enable = NGX_CONF_UNSET;\n     sscf->prefer_server_ciphers = NGX_CONF_UNSET;\n     sscf->early_data = NGX_CONF_UNSET;\n+    sscf->reject_handshake = NGX_CONF_UNSET;\n     sscf->buffer_size = NGX_CONF_UNSET_SIZE;\n     sscf->verify = NGX_CONF_UNSET_UINT;\n     sscf->verify_depth = NGX_CONF_UNSET_UINT;\n@@ -660,6 +668,7 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                          prev->prefer_server_ciphers, 0);\n \n     ngx_conf_merge_value(conf->early_data, prev->early_data, 0);\n+    ngx_conf_merge_value(conf->reject_handshake, prev->reject_handshake, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n                          (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n@@ -707,38 +716,35 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     if (conf->enable) {\n \n-        if (conf->certificates == NULL) {\n-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n-                          \"no \\\"ssl_certificate\\\" is defined for \"\n-                          \"the \\\"ssl\\\" directive in %s:%ui\",\n-                          conf->file, conf->line);\n-            return NGX_CONF_ERROR;\n-        }\n+        if (conf->certificates) {\n+            if (conf->certificate_keys == NULL) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"no \\\"ssl_certificate_key\\\" is defined for \"\n+                              \"the \\\"ssl\\\" directive in %s:%ui\",\n+                              conf->file, conf->line);\n+                return NGX_CONF_ERROR;\n+            }\n \n-        if (conf->certificate_keys == NULL) {\n-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n-                          \"no \\\"ssl_certificate_key\\\" is defined for \"\n-                          \"the \\\"ssl\\\" directive in %s:%ui\",\n-                          conf->file, conf->line);\n-            return NGX_CONF_ERROR;\n-        }\n+            if (conf->certificate_keys->nelts < conf->certificates->nelts) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"no \\\"ssl_certificate_key\\\" is defined \"\n+                              \"for certificate \\\"%V\\\" and \"\n+                              \"the \\\"ssl\\\" directive in %s:%ui\",\n+                              ((ngx_str_t *) conf->certificates->elts)\n+                              + conf->certificates->nelts - 1,\n+                              conf->file, conf->line);\n+                return NGX_CONF_ERROR;\n+            }\n \n-        if (conf->certificate_keys->nelts < conf->certificates->nelts) {\n+        } else if (!conf->reject_handshake) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n-                          \"no \\\"ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\" and \"\n+                          \"no \\\"ssl_certificate\\\" is defined for \"\n                           \"the \\\"ssl\\\" directive in %s:%ui\",\n-                          ((ngx_str_t *) conf->certificates->elts)\n-                          + conf->certificates->nelts - 1,\n                           conf->file, conf->line);\n             return NGX_CONF_ERROR;\n         }\n \n-    } else {\n-\n-        if (conf->certificates == NULL) {\n-            return NGX_CONF_OK;\n-        }\n+    } else if (conf->certificates) {\n \n         if (conf->certificate_keys == NULL\n             || conf->certificate_keys->nelts < conf->certificates->nelts)\n@@ -750,6 +756,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                           + conf->certificates->nelts - 1);\n             return NGX_CONF_ERROR;\n         }\n+\n+    } else if (!conf->reject_handshake) {\n+        return NGX_CONF_OK;\n     }\n \n     if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {\n@@ -808,7 +817,7 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n #endif\n \n-    } else {\n+    } else if (conf->certificates) {\n \n         /* configure certificates */\n \n@@ -947,6 +956,10 @@ ngx_http_ssl_compile_certificates(ngx_conf_t *cf,\n     ngx_http_complex_value_t          *cv;\n     ngx_http_compile_complex_value_t   ccv;\n \n+    if (conf->certificates == NULL) {\n+        return NGX_OK;\n+    }\n+\n     cert = conf->certificates->elts;\n     key = conf->certificate_keys->elts;\n     nelts = conf->certificates->nelts;\n@@ -1327,7 +1340,33 @@ ngx_http_ssl_init(ngx_conf_t *cf)\n             cscf = addr[a].default_server;\n             sscf = cscf->ctx->srv_conf[ngx_http_ssl_module.ctx_index];\n \n-            if (sscf->certificates == NULL) {\n+            if (sscf->certificates) {\n+                continue;\n+            }\n+\n+            if (!sscf->reject_handshake) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"no \\\"ssl_certificate\\\" is defined for \"\n+                              \"the \\\"listen ... ssl\\\" directive in %s:%ui\",\n+                              cscf->file_name, cscf->line);\n+                return NGX_ERROR;\n+            }\n+\n+            /*\n+             * if no certificates are defined in the default server,\n+             * check all non-default server blocks\n+             */\n+\n+            cscfp = addr[a].servers.elts;\n+            for (s = 0; s < addr[a].servers.nelts; s++) {\n+\n+                cscf = cscfp[s];\n+                sscf = cscf->ctx->srv_conf[ngx_http_ssl_module.ctx_index];\n+\n+                if (sscf->certificates || sscf->reject_handshake) {\n+                    continue;\n+                }\n+\n                 ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                               \"no \\\"ssl_certificate\\\" is defined for \"\n                               \"the \\\"listen ... ssl\\\" directive in %s:%ui\",\nDiff:\n@@ -21,6 +21,7 @@ typedef struct {\n \n     ngx_flag_t                      prefer_server_ciphers;\n     ngx_flag_t                      early_data;\n+    ngx_flag_t                      reject_handshake;\n \n     ngx_uint_t                      protocols;\n \nDiff:\n@@ -885,10 +885,14 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n         return SSL_TLSEXT_ERR_ALERT_FATAL;\n     }\n \n+    hc = c->data;\n+\n     servername = SSL_get_servername(ssl_conn, TLSEXT_NAMETYPE_host_name);\n \n     if (servername == NULL) {\n-        return SSL_TLSEXT_ERR_OK;\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                       \"SSL server name: null\");\n+        goto done;\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n@@ -897,40 +901,35 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n     host.len = ngx_strlen(servername);\n \n     if (host.len == 0) {\n-        return SSL_TLSEXT_ERR_OK;\n+        goto done;\n     }\n \n     host.data = (u_char *) servername;\n \n     rc = ngx_http_validate_host(&host, c->pool, 1);\n \n     if (rc == NGX_ERROR) {\n-        *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        goto error;\n     }\n \n     if (rc == NGX_DECLINED) {\n-        return SSL_TLSEXT_ERR_OK;\n+        goto done;\n     }\n \n-    hc = c->data;\n-\n     rc = ngx_http_find_virtual_server(c, hc->addr_conf->virtual_names, &host,\n                                       NULL, &cscf);\n \n     if (rc == NGX_ERROR) {\n-        *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        goto error;\n     }\n \n     if (rc == NGX_DECLINED) {\n-        return SSL_TLSEXT_ERR_OK;\n+        goto done;\n     }\n \n     hc->ssl_servername = ngx_palloc(c->pool, sizeof(ngx_str_t));\n     if (hc->ssl_servername == NULL) {\n-        *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        goto error;\n     }\n \n     *hc->ssl_servername = host;\n@@ -947,8 +946,7 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n \n     if (sscf->ssl.ctx) {\n         if (SSL_set_SSL_CTX(ssl_conn, sscf->ssl.ctx) == NULL) {\n-            *ad = SSL_AD_INTERNAL_ERROR;\n-            return SSL_TLSEXT_ERR_ALERT_FATAL;\n+            goto error;\n         }\n \n         /*\n@@ -974,7 +972,22 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n #endif\n     }\n \n+done:\n+\n+    sscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_ssl_module);\n+\n+    if (sscf->reject_handshake) {\n+        c->ssl->handshake_rejected = 1;\n+        *ad = SSL_AD_UNRECOGNIZED_NAME;\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+    }\n+\n     return SSL_TLSEXT_ERR_OK;\n+\n+error:\n+\n+    *ad = SSL_AD_INTERNAL_ERROR;\n+    return SSL_TLSEXT_ERR_ALERT_FATAL;\n }\n \n #endif\n"
    },
    {
        "commit_sha": "cf9f6cfee8da4c9b7bb78b873ac59d73449bf93c",
        "commit_index": "Commit 51",
        "commit_diff": "Diff:\n@@ -40,6 +40,7 @@ typedef struct {\n     ngx_str_t                  ssl_certificate;\n     ngx_str_t                  ssl_certificate_key;\n     ngx_array_t               *ssl_passwords;\n+    ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_grpc_loc_conf_t;\n \n@@ -208,6 +209,8 @@ static char *ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd,\n #if (NGX_HTTP_SSL)\n static char *ngx_http_grpc_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n+static char *ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n static ngx_int_t ngx_http_grpc_set_ssl(ngx_conf_t *cf,\n     ngx_http_grpc_loc_conf_t *glcf);\n #endif\n@@ -242,6 +245,9 @@ static ngx_conf_bitmask_t  ngx_http_grpc_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_http_grpc_ssl_conf_command_post =\n+    { ngx_http_grpc_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -438,6 +444,13 @@ static ngx_command_t  ngx_http_grpc_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"grpc_ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_grpc_loc_conf_t, ssl_conf_commands),\n+      &ngx_http_grpc_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -4359,6 +4372,7 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     /* the hardcoded values */\n@@ -4469,6 +4483,9 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_certificate_key, \"\");\n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl && ngx_http_grpc_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -4836,6 +4853,17 @@ ngx_http_grpc_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n {\n@@ -4926,6 +4954,12 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n \n #endif\n \n+    if (ngx_ssl_conf_commands(cf, glcf->upstream.ssl, glcf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -127,6 +127,7 @@ typedef struct {\n     ngx_str_t                      ssl_certificate;\n     ngx_str_t                      ssl_certificate_key;\n     ngx_array_t                   *ssl_passwords;\n+    ngx_array_t                   *ssl_conf_commands;\n #endif\n } ngx_http_proxy_loc_conf_t;\n \n@@ -229,6 +230,10 @@ static char *ngx_http_proxy_ssl_password_file(ngx_conf_t *cf,\n #endif\n \n static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf, void *post, void *data);\n+#if (NGX_HTTP_SSL)\n+static char *ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+#endif\n \n static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf,\n     ngx_http_proxy_rewrite_t *pr, ngx_str_t *regex, ngx_uint_t caseless);\n@@ -274,6 +279,9 @@ static ngx_conf_bitmask_t  ngx_http_proxy_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_http_proxy_ssl_conf_command_post =\n+    { ngx_http_proxy_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -764,6 +772,13 @@ static ngx_command_t  ngx_http_proxy_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"proxy_ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_proxy_loc_conf_t, ssl_conf_commands),\n+      &ngx_http_proxy_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -3340,6 +3355,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     /* \"proxy_cyclic_temp_file\" is disabled */\n@@ -3687,6 +3703,9 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_certificate_key, \"\");\n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl && ngx_http_proxy_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -4845,6 +4864,17 @@ ngx_http_proxy_lowat_check(ngx_conf_t *cf, void *post, void *data)\n \n #if (NGX_HTTP_SSL)\n \n+static char *\n+ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n {\n@@ -4922,6 +4952,12 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n         return NGX_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, plcf->upstream.ssl, plcf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -57,6 +57,7 @@ typedef struct {\n     ngx_str_t                  ssl_certificate;\n     ngx_str_t                  ssl_certificate_key;\n     ngx_array_t               *ssl_passwords;\n+    ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_uwsgi_loc_conf_t;\n \n@@ -96,6 +97,8 @@ static char *ngx_http_uwsgi_cache_key(ngx_conf_t *cf, ngx_command_t *cmd,\n #if (NGX_HTTP_SSL)\n static char *ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n+static char *ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n static ngx_int_t ngx_http_uwsgi_set_ssl(ngx_conf_t *cf,\n     ngx_http_uwsgi_loc_conf_t *uwcf);\n #endif\n@@ -134,6 +137,9 @@ static ngx_conf_bitmask_t  ngx_http_uwsgi_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_http_uwsgi_ssl_conf_command_post =\n+    { ngx_http_uwsgi_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -561,6 +567,13 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"uwsgi_ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_uwsgi_loc_conf_t, ssl_conf_commands),\n+      &ngx_http_uwsgi_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -1500,6 +1513,7 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     /* \"uwsgi_cyclic_temp_file\" is disabled */\n@@ -1830,6 +1844,9 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_certificate_key, \"\");\n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl && ngx_http_uwsgi_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -2376,6 +2393,17 @@ ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n {\n@@ -2453,6 +2481,12 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n         return NGX_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, uwcf->upstream.ssl, uwcf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -49,6 +49,7 @@ typedef struct {\n     ngx_str_t                        ssl_certificate;\n     ngx_str_t                        ssl_certificate_key;\n     ngx_array_t                     *ssl_passwords;\n+    ngx_array_t                     *ssl_conf_commands;\n \n     ngx_ssl_t                       *ssl;\n #endif\n@@ -94,6 +95,8 @@ static char *ngx_stream_proxy_bind(ngx_conf_t *cf, ngx_command_t *cmd,\n static ngx_int_t ngx_stream_proxy_send_proxy_protocol(ngx_stream_session_t *s);\n static char *ngx_stream_proxy_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n+static char *ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n static void ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s);\n static void ngx_stream_proxy_ssl_handshake(ngx_connection_t *pc);\n static void ngx_stream_proxy_ssl_save_session(ngx_connection_t *c);\n@@ -112,6 +115,9 @@ static ngx_conf_bitmask_t  ngx_stream_proxy_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_stream_proxy_ssl_conf_command_post =\n+    { ngx_stream_proxy_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -331,6 +337,13 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"proxy_ssl_conf_command\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_proxy_srv_conf_t, ssl_conf_commands),\n+      &ngx_stream_proxy_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -1008,6 +1021,17 @@ ngx_stream_proxy_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n }\n \n \n+static char *\n+ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static void\n ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s)\n {\n@@ -1985,6 +2009,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     return conf;\n@@ -2072,6 +2097,9 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl_enable && ngx_stream_proxy_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -2156,6 +2184,12 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n         return NGX_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, pscf->ssl, pscf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \n"
    },
    {
        "commit_sha": "b3754bac8e7e21e674965813c762b7c813e61110",
        "commit_index": "Commit 50",
        "commit_diff": "Diff:\n@@ -1470,6 +1470,78 @@ ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)\n }\n \n \n+ngx_int_t\n+ngx_ssl_conf_commands(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *commands)\n+{\n+    if (commands == NULL) {\n+        return NGX_OK;\n+    }\n+\n+#ifdef SSL_CONF_FLAG_FILE\n+    {\n+    int            type;\n+    u_char        *key, *value;\n+    ngx_uint_t     i;\n+    ngx_keyval_t  *cmd;\n+    SSL_CONF_CTX  *cctx;\n+\n+    cctx = SSL_CONF_CTX_new();\n+    if (cctx == NULL) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CONF_CTX_new() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_FILE);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SERVER);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CERTIFICATE);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SHOW_ERRORS);\n+\n+    SSL_CONF_CTX_set_ssl_ctx(cctx, ssl->ctx);\n+\n+    cmd = commands->elts;\n+    for (i = 0; i < commands->nelts; i++) {\n+\n+        key = cmd[i].key.data;\n+        type = SSL_CONF_cmd_value_type(cctx, (char *) key);\n+\n+        if (type == SSL_CONF_TYPE_FILE || type == SSL_CONF_TYPE_DIR) {\n+            if (ngx_conf_full_name(cf->cycle, &cmd[i].value, 1) != NGX_OK) {\n+                SSL_CONF_CTX_free(cctx);\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        value = cmd[i].value.data;\n+\n+        if (SSL_CONF_cmd(cctx, (char *) key, (char *) value) <= 0) {\n+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                          \"SSL_CONF_cmd(\\\"%s\\\", \\\"%s\\\") failed\", key, value);\n+            SSL_CONF_CTX_free(cctx);\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    if (SSL_CONF_CTX_finish(cctx) != 1) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CONF_finish() failed\");\n+        SSL_CONF_CTX_free(cctx);\n+        return NGX_ERROR;\n+    }\n+\n+    SSL_CONF_CTX_free(cctx);\n+\n+    return NGX_OK;\n+    }\n+#else\n+    ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,\n+                  \"SSL_CONF_cmd() is not available on this platform\");\n+    return NGX_ERROR;\n+#endif\n+}\n+\n+\n ngx_int_t\n ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)\n {\nDiff:\n@@ -203,6 +203,9 @@ ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);\n ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);\n ngx_int_t ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_uint_t enable);\n+ngx_int_t ngx_ssl_conf_commands(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_array_t *commands);\n+\n ngx_int_t ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_uint_t enable);\n ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n@@ -211,6 +214,7 @@ ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n ngx_int_t ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_array_t *paths);\n ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n+\n ngx_int_t ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c,\n     ngx_uint_t flags);\n \nDiff:\n@@ -53,6 +53,9 @@ static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n static char *ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \n+static char *ngx_http_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+\n static ngx_int_t ngx_http_ssl_init(ngx_conf_t *cf);\n \n \n@@ -89,6 +92,10 @@ static ngx_conf_deprecated_t  ngx_http_ssl_deprecated = {\n };\n \n \n+static ngx_conf_post_t  ngx_http_ssl_conf_command_post =\n+    { ngx_http_ssl_conf_command_check };\n+\n+\n static ngx_command_t  ngx_http_ssl_commands[] = {\n \n     { ngx_string(\"ssl\"),\n@@ -280,6 +287,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, early_data),\n       NULL },\n \n+    { ngx_string(\"ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, conf_commands),\n+      &ngx_http_ssl_conf_command_post },\n+\n       ngx_null_command\n };\n \n@@ -606,6 +620,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->certificates = NGX_CONF_UNSET_PTR;\n     sscf->certificate_keys = NGX_CONF_UNSET_PTR;\n     sscf->passwords = NGX_CONF_UNSET_PTR;\n+    sscf->conf_commands = NGX_CONF_UNSET_PTR;\n     sscf->builtin_session_cache = NGX_CONF_UNSET;\n     sscf->session_timeout = NGX_CONF_UNSET;\n     sscf->session_tickets = NGX_CONF_UNSET;\n@@ -675,6 +690,8 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_ptr_value(conf->conf_commands, prev->conf_commands, NULL);\n+\n     ngx_conf_merge_uint_value(conf->ocsp, prev->ocsp, 0);\n     ngx_conf_merge_str_value(conf->ocsp_responder, prev->ocsp_responder, \"\");\n     ngx_conf_merge_ptr_value(conf->ocsp_cache_zone,\n@@ -913,6 +930,10 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, &conf->ssl, conf->conf_commands) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     return NGX_CONF_OK;\n }\n \n@@ -1235,6 +1256,17 @@ ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_ssl_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -48,6 +48,7 @@ typedef struct {\n     ngx_str_t                       ciphers;\n \n     ngx_array_t                    *passwords;\n+    ngx_array_t                    *conf_commands;\n \n     ngx_shm_zone_t                 *shm_zone;\n \nDiff:\n@@ -26,6 +26,9 @@ static char *ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n static char *ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \n+static char *ngx_mail_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+\n \n static ngx_conf_enum_t  ngx_mail_starttls_state[] = {\n     { ngx_string(\"off\"), NGX_MAIL_STARTTLS_OFF },\n@@ -61,6 +64,10 @@ static ngx_conf_deprecated_t  ngx_mail_ssl_deprecated = {\n };\n \n \n+static ngx_conf_post_t  ngx_mail_ssl_conf_command_post =\n+    { ngx_mail_ssl_conf_command_check };\n+\n+\n static ngx_command_t  ngx_mail_ssl_commands[] = {\n \n     { ngx_string(\"ssl\"),\n@@ -196,6 +203,13 @@ static ngx_command_t  ngx_mail_ssl_commands[] = {\n       offsetof(ngx_mail_ssl_conf_t, crl),\n       NULL },\n \n+    { ngx_string(\"ssl_conf_command\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, conf_commands),\n+      &ngx_mail_ssl_conf_command_post },\n+\n       ngx_null_command\n };\n \n@@ -259,6 +273,7 @@ ngx_mail_ssl_create_conf(ngx_conf_t *cf)\n     scf->certificates = NGX_CONF_UNSET_PTR;\n     scf->certificate_keys = NGX_CONF_UNSET_PTR;\n     scf->passwords = NGX_CONF_UNSET_PTR;\n+    scf->conf_commands = NGX_CONF_UNSET_PTR;\n     scf->prefer_server_ciphers = NGX_CONF_UNSET;\n     scf->verify = NGX_CONF_UNSET_UINT;\n     scf->verify_depth = NGX_CONF_UNSET_UINT;\n@@ -316,6 +331,8 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_ptr_value(conf->conf_commands, prev->conf_commands, NULL);\n+\n \n     conf->ssl.log = cf->log;\n \n@@ -461,6 +478,10 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, &conf->ssl, conf->conf_commands) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     return NGX_CONF_OK;\n }\n \n@@ -654,3 +675,14 @@ ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     return NGX_CONF_ERROR;\n }\n+\n+\n+static char *\n+ngx_mail_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -48,6 +48,7 @@ typedef struct {\n     ngx_str_t        ciphers;\n \n     ngx_array_t     *passwords;\n+    ngx_array_t     *conf_commands;\n \n     ngx_shm_zone_t  *shm_zone;\n \nDiff:\n@@ -45,6 +45,10 @@ static char *ngx_stream_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+\n+static char *ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+\n static ngx_int_t ngx_stream_ssl_init(ngx_conf_t *cf);\n \n \n@@ -68,6 +72,10 @@ static ngx_conf_enum_t  ngx_stream_ssl_verify[] = {\n };\n \n \n+static ngx_conf_post_t  ngx_stream_ssl_conf_command_post =\n+    { ngx_stream_ssl_conf_command_check };\n+\n+\n static ngx_command_t  ngx_stream_ssl_commands[] = {\n \n     { ngx_string(\"ssl_handshake_timeout\"),\n@@ -196,6 +204,13 @@ static ngx_command_t  ngx_stream_ssl_commands[] = {\n       offsetof(ngx_stream_ssl_conf_t, crl),\n       NULL },\n \n+    { ngx_string(\"ssl_conf_command\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_ssl_conf_t, conf_commands),\n+      &ngx_stream_ssl_conf_command_post },\n+\n       ngx_null_command\n };\n \n@@ -595,6 +610,7 @@ ngx_stream_ssl_create_conf(ngx_conf_t *cf)\n     scf->certificates = NGX_CONF_UNSET_PTR;\n     scf->certificate_keys = NGX_CONF_UNSET_PTR;\n     scf->passwords = NGX_CONF_UNSET_PTR;\n+    scf->conf_commands = NGX_CONF_UNSET_PTR;\n     scf->prefer_server_ciphers = NGX_CONF_UNSET;\n     scf->verify = NGX_CONF_UNSET_UINT;\n     scf->verify_depth = NGX_CONF_UNSET_UINT;\n@@ -650,6 +666,8 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_ptr_value(conf->conf_commands, prev->conf_commands, NULL);\n+\n \n     conf->ssl.log = cf->log;\n \n@@ -811,6 +829,10 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, &conf->ssl, conf->conf_commands) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     return NGX_CONF_OK;\n }\n \n@@ -1034,6 +1056,17 @@ ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_stream_ssl_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -46,6 +46,7 @@ typedef struct {\n     ngx_str_t        ciphers;\n \n     ngx_array_t     *passwords;\n+    ngx_array_t     *conf_commands;\n \n     ngx_shm_zone_t  *shm_zone;\n \n"
    },
    {
        "commit_sha": "b8e41721d252d4c0d121375038c647c67d24485d",
        "commit_index": "Commit 49",
        "commit_diff": "Diff:\n@@ -1137,7 +1137,7 @@ ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     a = (ngx_array_t **) (p + cmd->offset);\n \n-    if (*a == NULL) {\n+    if (*a == NGX_CONF_UNSET_PTR || *a == NULL) {\n         *a = ngx_array_create(cf->pool, 4, sizeof(ngx_keyval_t));\n         if (*a == NULL) {\n             return NGX_CONF_ERROR;\nDiff:\n@@ -4324,7 +4324,6 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n      *     conf->upstream.hide_headers_hash = { NULL, 0 };\n      *     conf->upstream.ssl_name = NULL;\n      *\n-     *     conf->headers_source = NULL;\n      *     conf->headers.lengths = NULL;\n      *     conf->headers.values = NULL;\n      *     conf->headers.hash = { NULL, 0 };\n@@ -4377,6 +4376,8 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.pass_trailers = 1;\n     conf->upstream.preserve_output = 1;\n \n+    conf->headers_source = NGX_CONF_UNSET_PTR;\n+\n     ngx_str_set(&conf->upstream.module, \"grpc\");\n \n     return conf;\n@@ -4507,9 +4508,10 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         clcf->handler = ngx_http_grpc_handler;\n     }\n \n-    if (conf->headers_source == NULL) {\n+    ngx_conf_merge_ptr_value(conf->headers_source, prev->headers_source, NULL);\n+\n+    if (conf->headers_source == prev->headers_source) {\n         conf->headers = prev->headers;\n-        conf->headers_source = prev->headers_source;\n         conf->host_set = prev->host_set;\n     }\n \nDiff:\n@@ -3268,7 +3268,6 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n      *     conf->method = NULL;\n      *     conf->location = NULL;\n      *     conf->url = { 0, NULL };\n-     *     conf->headers_source = NULL;\n      *     conf->headers.lengths = NULL;\n      *     conf->headers.values = NULL;\n      *     conf->headers.hash = { NULL, 0 };\n@@ -3346,6 +3345,8 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     /* \"proxy_cyclic_temp_file\" is disabled */\n     conf->upstream.cyclic_temp_file = 0;\n \n+    conf->headers_source = NGX_CONF_UNSET_PTR;\n+\n     conf->redirect = NGX_CONF_UNSET;\n     conf->upstream.change_buffering = 1;\n \n@@ -3819,12 +3820,13 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (conf->headers_source == NULL) {\n+    ngx_conf_merge_ptr_value(conf->headers_source, prev->headers_source, NULL);\n+\n+    if (conf->headers_source == prev->headers_source) {\n         conf->headers = prev->headers;\n #if (NGX_HTTP_CACHE)\n         conf->headers_cache = prev->headers_cache;\n #endif\n-        conf->headers_source = prev->headers_source;\n     }\n \n     rc = ngx_http_proxy_init_headers(cf, conf, &conf->headers,\n"
    },
    {
        "commit_sha": "82517d1d5685fe48e8dfac68d6867f114e36475c",
        "commit_index": "Commit 48",
        "commit_diff": "Diff:\n@@ -69,6 +69,8 @@ static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit,\n     ngx_uint_t hash, ngx_str_t *key, ngx_uint_t *ep, ngx_uint_t account);\n static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits,\n     ngx_uint_t n, ngx_uint_t *ep, ngx_http_limit_req_limit_t **limit);\n+static void ngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits,\n+    ngx_uint_t n);\n static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx,\n     ngx_uint_t n);\n \n@@ -223,6 +225,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n         ctx = limit->shm_zone->data;\n \n         if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {\n+            ngx_http_limit_req_unlock(limits, n);\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n@@ -270,21 +273,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n                         &limit->shm_zone->shm.name);\n         }\n \n-        while (n--) {\n-            ctx = limits[n].shm_zone->data;\n-\n-            if (ctx->node == NULL) {\n-                continue;\n-            }\n-\n-            ngx_shmtx_lock(&ctx->shpool->mutex);\n-\n-            ctx->node->count--;\n-\n-            ngx_shmtx_unlock(&ctx->shpool->mutex);\n-\n-            ctx->node = NULL;\n-        }\n+        ngx_http_limit_req_unlock(limits, n);\n \n         if (lrcf->dry_run) {\n             r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN;\n@@ -612,6 +601,29 @@ ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,\n }\n \n \n+static void\n+ngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits, ngx_uint_t n)\n+{\n+    ngx_http_limit_req_ctx_t  *ctx;\n+\n+    while (n--) {\n+        ctx = limits[n].shm_zone->data;\n+\n+        if (ctx->node == NULL) {\n+            continue;\n+        }\n+\n+        ngx_shmtx_lock(&ctx->shpool->mutex);\n+\n+        ctx->node->count--;\n+\n+        ngx_shmtx_unlock(&ctx->shpool->mutex);\n+\n+        ctx->node = NULL;\n+    }\n+}\n+\n+\n static void\n ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx, ngx_uint_t n)\n {\nDiff:\n@@ -162,10 +162,12 @@ typedef enum {\n     ngx_smtp_auth_external,\n     ngx_smtp_helo,\n     ngx_smtp_helo_xclient,\n+    ngx_smtp_helo_auth,\n     ngx_smtp_helo_from,\n     ngx_smtp_xclient,\n     ngx_smtp_xclient_from,\n     ngx_smtp_xclient_helo,\n+    ngx_smtp_xclient_auth,\n     ngx_smtp_from,\n     ngx_smtp_to\n } ngx_smtp_state_e;\nDiff:\n@@ -16,6 +16,7 @@ typedef struct {\n     ngx_flag_t  enable;\n     ngx_flag_t  pass_error_message;\n     ngx_flag_t  xclient;\n+    ngx_flag_t  smtp_auth;\n     size_t      buffer_size;\n     ngx_msec_t  timeout;\n } ngx_mail_proxy_conf_t;\n@@ -74,6 +75,13 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {\n       offsetof(ngx_mail_proxy_conf_t, xclient),\n       NULL },\n \n+    { ngx_string(\"proxy_smtp_auth\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, smtp_auth),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -450,7 +458,7 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n {\n     u_char                    *p;\n     ngx_int_t                  rc;\n-    ngx_str_t                  line;\n+    ngx_str_t                  line, auth, encoded;\n     ngx_buf_t                 *b;\n     ngx_connection_t          *c;\n     ngx_mail_session_t        *s;\n@@ -513,6 +521,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         } else if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n             s->mail_state = ngx_smtp_helo_from;\n \n+        } else if (pcf->smtp_auth) {\n+            s->mail_state = ngx_smtp_helo_auth;\n+\n         } else {\n             s->mail_state = ngx_smtp_helo;\n         }\n@@ -552,7 +563,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         p = ngx_copy(p, s->connection->addr_text.data,\n                      s->connection->addr_text.len);\n \n-        if (s->login.len) {\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+        if (s->login.len && !pcf->smtp_auth) {\n             p = ngx_cpymem(p, \" LOGIN=\", sizeof(\" LOGIN=\") - 1);\n             p = ngx_copy(p, s->login.data, s->login.len);\n         }\n@@ -570,6 +583,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         } else if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n             s->mail_state = ngx_smtp_xclient_from;\n \n+        } else if (pcf->smtp_auth) {\n+            s->mail_state = ngx_smtp_xclient_auth;\n+\n         } else {\n             s->mail_state = ngx_smtp_xclient;\n         }\n@@ -595,8 +611,62 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n                        &s->smtp_helo)\n                    - line.data;\n \n-        s->mail_state = (s->auth_method == NGX_MAIL_AUTH_NONE) ?\n-                            ngx_smtp_helo_from : ngx_smtp_helo;\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+        if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+            s->mail_state = ngx_smtp_helo_from;\n+\n+        } else if (pcf->smtp_auth) {\n+            s->mail_state = ngx_smtp_helo_auth;\n+\n+        } else {\n+            s->mail_state = ngx_smtp_helo;\n+        }\n+\n+        break;\n+\n+    case ngx_smtp_helo_auth:\n+    case ngx_smtp_xclient_auth:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send auth\");\n+\n+        s->connection->log->action = \"sending AUTH to upstream\";\n+\n+        if (s->passwd.data == NULL) {\n+            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                          \"no password available\");\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        auth.len = 1 + s->login.len + 1 + s->passwd.len;\n+        auth.data = ngx_pnalloc(c->pool, auth.len);\n+        if (auth.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        auth.len = ngx_sprintf(auth.data, \"%Z%V%Z%V\", &s->login, &s->passwd)\n+                   - auth.data;\n+\n+        line.len = sizeof(\"AUTH PLAIN \" CRLF) - 1\n+                   + ngx_base64_encoded_length(auth.len);\n+\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        encoded.data = ngx_cpymem(line.data, \"AUTH PLAIN \",\n+                                  sizeof(\"AUTH PLAIN \") - 1);\n+\n+        ngx_encode_base64(&encoded, &auth);\n+\n+        p = encoded.data + encoded.len;\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_smtp_auth_plain;\n \n         break;\n \n@@ -643,6 +713,7 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n \n     case ngx_smtp_helo:\n     case ngx_smtp_xclient:\n+    case ngx_smtp_auth_plain:\n     case ngx_smtp_to:\n \n         b = s->proxy->buffer;\n@@ -824,6 +895,7 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)\n         case ngx_smtp_helo:\n         case ngx_smtp_helo_xclient:\n         case ngx_smtp_helo_from:\n+        case ngx_smtp_helo_auth:\n         case ngx_smtp_from:\n             if (p[0] == '2' && p[1] == '5' && p[2] == '0') {\n                 return NGX_OK;\n@@ -833,11 +905,18 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)\n         case ngx_smtp_xclient:\n         case ngx_smtp_xclient_from:\n         case ngx_smtp_xclient_helo:\n+        case ngx_smtp_xclient_auth:\n             if (p[0] == '2' && (p[1] == '2' || p[1] == '5') && p[2] == '0') {\n                 return NGX_OK;\n             }\n             break;\n \n+        case ngx_smtp_auth_plain:\n+            if (p[0] == '2' && p[1] == '3' && p[2] == '5') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n         case ngx_smtp_to:\n             return NGX_OK;\n         }\n@@ -1102,6 +1181,7 @@ ngx_mail_proxy_create_conf(ngx_conf_t *cf)\n     pcf->enable = NGX_CONF_UNSET;\n     pcf->pass_error_message = NGX_CONF_UNSET;\n     pcf->xclient = NGX_CONF_UNSET;\n+    pcf->smtp_auth = NGX_CONF_UNSET;\n     pcf->buffer_size = NGX_CONF_UNSET_SIZE;\n     pcf->timeout = NGX_CONF_UNSET_MSEC;\n \n@@ -1118,6 +1198,7 @@ ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->enable, prev->enable, 0);\n     ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);\n     ngx_conf_merge_value(conf->xclient, prev->xclient, 1);\n+    ngx_conf_merge_value(conf->smtp_auth, prev->smtp_auth, 0);\n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n                               (size_t) ngx_pagesize);\n     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);\nDiff:\n@@ -14,6 +14,8 @@ extern \"C\" {\n   #include <ngx_mail_pop3_module.h>\n   #include <ngx_mail_imap_module.h>\n   #include <ngx_mail_smtp_module.h>\n+\n+  #include <ngx_stream.h>\n }\n \n // nginx header files should go before other, because they define 64-bit off_t\n"
    },
    {
        "commit_sha": "dd97225891a0890d0c30b154af4aaafb23b6d506",
        "commit_index": "Commit 47",
        "commit_diff": "Diff:\n@@ -452,3 +452,4 @@ c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n 062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\n a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n+3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\nDiff:\n@@ -5,6 +5,112 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.3\" date=\"2020-09-29\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+модуль ngx_stream_set_module.\n+</para>\n+<para lang=\"en\">\n+the ngx_stream_set_module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива proxy_cookie_flags.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_cookie_flags\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива userid_flags.\n+</para>\n+<para lang=\"en\">\n+the \"userid_flags\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+расширение управления кэшированием stale-if-error\n+ошибочно применялось, если бэкенд возвращал ответ\n+с кодом 500, 502, 503, 504, 403, 404 или 429.\n+</para>\n+<para lang=\"en\">\n+the \"stale-if-error\" cache control extension\n+was erroneously applied if backend returned a response\n+with status code 500, 502, 503, 504, 403, 404, or 429.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если использовалось кэширование\n+и бэкенд возвращал ответы с строкой заголовка Vary,\n+в логах могли появляться сообщения \"[crit] cache file ... has too long header\".\n+</para>\n+<para lang=\"en\">\n+\"[crit] cache file ... has too long header\" messages might appear in logs\n+if caching was used\n+and the backend returned responses with the \"Vary\" header line.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании OpenSSL 1.1.1\n+в логах могли появляться сообщения \"[crit] SSL_write() failed\".\n+</para>\n+<para lang=\"en\">\n+\"[crit] SSL_write() failed\" messages might appear in logs\n+when using OpenSSL 1.1.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\";\n+ошибка появилась в 1.19.2.\n+</para>\n+<para lang=\"en\">\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\"\n+messages might appear in logs;\n+the bug had appeared in 1.19.2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2\n+в рабочем процессе мог произойти segmentation fault,\n+если ошибки с кодом 400 с помощью директивы error_page\n+перенаправлялись в проксируемый location.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+when using HTTP/2\n+if errors with code 400 were redirected to a proxied location\n+using the \"error_page\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании HTTP/2 и подзапросов в модуле njs.\n+</para>\n+<para lang=\"en\">\n+socket leak when using HTTP/2 and subrequests in the njs module.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.2\" date=\"2020-08-11\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019003\n-#define NGINX_VERSION      \"1.19.3\"\n+#define nginx_version      1019004\n+#define NGINX_VERSION      \"1.19.4\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "63e121b4d602525610c527bc05659d75c27edf8b",
        "commit_index": "Commit 46",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1g\n+OPENSSL =\topenssl-1.1.1h\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -2679,7 +2679,9 @@ ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n     ngx_keyval_t               *attr;\n     ngx_http_proxy_loc_conf_t  *plcf;\n \n-    ngx_array_init(&attrs, r->pool, 2, sizeof(ngx_keyval_t));\n+    if (ngx_array_init(&attrs, r->pool, 2, sizeof(ngx_keyval_t)) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n \n     if (ngx_http_proxy_parse_cookie(&h->value, &attrs) != NGX_OK) {\n         return NGX_ERROR;\nDiff:\n@@ -15,12 +15,13 @@\n #define NGX_HTTP_USERID_V1    2\n #define NGX_HTTP_USERID_ON    3\n \n-#define NGX_HTTP_USERID_COOKIE_SECURE           0x0001\n-#define NGX_HTTP_USERID_COOKIE_HTTPONLY         0x0002\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE         0x0004\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT  0x0008\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE_LAX     0x0010\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE_NONE    0x0020\n+#define NGX_HTTP_USERID_COOKIE_OFF              0x0002\n+#define NGX_HTTP_USERID_COOKIE_SECURE           0x0004\n+#define NGX_HTTP_USERID_COOKIE_HTTPONLY         0x0008\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE         0x0010\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT  0x0020\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_LAX     0x0040\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_NONE    0x0080\n \n /* 31 Dec 2037 23:55:55 GMT */\n #define NGX_HTTP_USERID_MAX_EXPIRES  2145916555\n@@ -97,6 +98,7 @@ static ngx_conf_enum_t  ngx_http_userid_state[] = {\n \n \n static ngx_conf_bitmask_t  ngx_http_userid_flags[] = {\n+    { ngx_string(\"off\"), NGX_HTTP_USERID_COOKIE_OFF },\n     { ngx_string(\"secure\"), NGX_HTTP_USERID_COOKIE_SECURE },\n     { ngx_string(\"httponly\"), NGX_HTTP_USERID_COOKIE_HTTPONLY },\n     { ngx_string(\"samesite=strict\"),\n@@ -743,7 +745,7 @@ ngx_http_userid_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                               NGX_HTTP_USERID_OFF);\n \n     ngx_conf_merge_bitmask_value(conf->flags, prev->flags,\n-                                 NGX_CONF_BITMASK_SET);\n+                            (NGX_CONF_BITMASK_SET|NGX_HTTP_USERID_COOKIE_OFF));\n \n     ngx_conf_merge_str_value(conf->name, prev->name, \"uid\");\n     ngx_conf_merge_str_value(conf->domain, prev->domain, \"\");\n"
    },
    {
        "commit_sha": "b101d59b3dda654dee1deabc34816e2ca7c96d38",
        "commit_index": "Commit 45",
        "commit_diff": "Diff:\n@@ -128,6 +128,8 @@ struct ngx_connection_s {\n \n     ngx_socket_t        fd;\n \n+    size_t              request_counter; /* total requests to the server */\n+\n     ngx_recv_pt         recv;\n     ngx_send_pt         send;\n     ngx_recv_chain_pt   recv_chain;\nDiff:\n@@ -14,6 +14,7 @@\n \n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_con_his_s         ngx_con_his_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n typedef struct ngx_black_list_s      ngx_black_list_t;\n typedef struct ngx_pool_s            ngx_pool_t;\nDiff:\n@@ -35,6 +35,42 @@ static ngx_connection_t  dumb;\n /* STUB */\n \n \n+void\n+ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con)\n+{\n+    ngx_con_his_t *target = *con_his_list;\n+\n+    if (target) {\n+        while (target->next) {\n+            target = target->next;\n+        }\n+        target->next = new_con;\n+    } else {\n+        *con_his_list = new_con;\n+    }\n+\n+    return;\n+}\n+\n+\n+ngx_con_his_t *\n+ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n+{\n+    ngx_con_his_t *target = con_his_list;\n+    size_t counter = 0;\n+\n+    if (!target || number == 1 || !number) {\n+        return target;\n+    }\n+\n+    for ( ; counter <= number; counter++) {\n+        target = target->next;\n+    }\n+\n+    return target;\n+}\n+\n+\n ngx_cycle_t *\n ngx_init_cycle(ngx_cycle_t *old_cycle)\n {\n@@ -73,6 +109,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n     pool->log = log;\n \n     cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));\n+    ngx_memzero(cycle, sizeof(ngx_cycle_t));\n     if (cycle == NULL) {\n         ngx_destroy_pool(pool);\n         return NULL;\nDiff:\n@@ -43,6 +43,12 @@ typedef struct ngx_black_list_s {\n }ngx_black_list_t;\n \n \n+struct ngx_con_his_s {\n+    ngx_str_t      addr_text;\n+    ngx_con_his_t *next;\n+};\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -83,6 +89,9 @@ struct ngx_cycle_s {\n \n     ngx_cycle_t              *old_cycle;\n \n+    size_t                    connection_counter; /* total connections to the server */\n+    ngx_con_his_t            *connection_history; /* list of all connections made to the server */\n+\n     ngx_str_t                 conf_file;\n     ngx_str_t                 conf_param;\n     ngx_str_t                 conf_prefix;\n@@ -162,6 +171,8 @@ ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n     size_t size, void *tag);\n void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+void ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con);\n+ngx_con_his_t *ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number);\n void ngx_black_list_insert(ngx_black_list_t **black_list,\n     u_char insert_ip[], size_t size, ngx_log_t *log);\n ngx_int_t ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[]);\nDiff:\n@@ -1918,7 +1918,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -1930,7 +1930,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (rn->query6 == NULL || rn->naddrs6 != (u_short) -1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected response for %V\", &name);\n+                          \"unexpected DNS response for %V\", &name);\n             ngx_resolver_free(r, name.data);\n             goto failed;\n         }\n@@ -1949,7 +1949,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (rn->query == NULL || rn->naddrs != (u_short) -1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected response for %V\", &name);\n+                          \"unexpected DNS response for %V\", &name);\n             ngx_resolver_free(r, name.data);\n             goto failed;\n         }\n@@ -1964,7 +1964,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -2149,7 +2149,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -2218,7 +2218,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -2567,7 +2567,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL || rn->query == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -2581,7 +2581,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -2691,7 +2691,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -2734,7 +2734,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -3165,7 +3165,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL || rn->query == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -3174,7 +3174,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -3256,7 +3256,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -3283,7 +3283,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -3952,12 +3952,12 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         }\n \n         if (p >= last) {\n-            err = \"name is out of response\";\n+            err = \"name is out of DNS response\";\n             goto invalid;\n         }\n     }\n \n-    err = \"compression pointers loop\";\n+    err = \"compression pointers loop in DNS response\";\n \n invalid:\n \nDiff:\n@@ -791,6 +791,7 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n     ngx_event_t       *rev, *wev;\n     ngx_queue_t       *queue;\n     ngx_connection_t  *c;\n+    ngx_con_his_t     *new_con_his;\n \n     /* NGX_TIMER_INFINITE == INFTIM */\n \n@@ -898,6 +899,18 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n                 ngx_post_event(rev, queue);\n \n             } else {\n+                if (c->number > cycle->connection_counter) {\n+                    new_con_his = ngx_palloc(cycle->pool, sizeof(ngx_con_his_t));\n+                    ngx_memzero(new_con_his, sizeof(ngx_con_his_t));\n+                    ngx_memcpy(&new_con_his->addr_text, &c->addr_text, sizeof(ngx_str_t));\n+\n+                    ngx_insert_con_his(&cycle->connection_history, new_con_his);\n+\n+                    cycle->connection_counter = c->number;\n+                    rev->connection_counter = c->number;\n+                    rev->connection_history = cycle->connection_history;\n+                }\n+\n                 rev->handler(rev);\n             }\n         }\nDiff:\n@@ -28,6 +28,8 @@ typedef struct {\n \n \n struct ngx_event_s {\n+    size_t           connection_counter;\n+    ngx_con_his_t   *connection_history;\n     void            *data;\n \n     unsigned         write:1;\nDiff:\n@@ -1349,6 +1349,7 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n     c = rev->data;\n     r = c->data;\n     r->cycle = rev->cycle;\n+    r->request_counter = ++c->request_counter;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request header line\");\n@@ -1496,6 +1497,8 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n                 break;\n             }\n \n+            r->connection_counter = rev->connection_counter;\n+            r->connection_history = rev->connection_history;\n             ngx_http_process_request(r);\n \n             break;\nDiff:\n@@ -373,6 +373,9 @@ typedef void (*ngx_http_event_handler_pt)(ngx_http_request_t *r);\n \n \n struct ngx_http_request_s {\n+    size_t                            connection_counter; /* total connections to the server */\n+    size_t                            request_counter; /* total requests to the server */\n+    ngx_con_his_t                    *connection_history;\n     uint32_t                          signature;         /* \"HTTP\" */\n \n     ngx_connection_t                 *connection;\nDiff:\n@@ -2754,6 +2754,10 @@ static ngx_int_t\n ngx_http_get_last_ip_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    ngx_con_his_t *last_ip = ngx_get_con_his(r->connection_history, r->request_counter);\n+    v->data = last_ip->addr_text.data;\n+    v->len = last_ip->addr_text.len;\n+\n     return NGX_OK;\n }\n \n"
    },
    {
        "commit_sha": "f32576b97ade88ec8cd3122a7ea2241c43ed6f79",
        "commit_index": "Commit 44",
        "commit_diff": "Diff:\n@@ -1119,6 +1119,16 @@ if [ $STREAM != NO ]; then\n         . auto/module\n     fi\n \n+    if [ $STREAM_SET = YES ]; then\n+        ngx_module_name=ngx_stream_set_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_set_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_SET\n+\n+        . auto/module\n+    fi\n+\n     if [ $STREAM_UPSTREAM_HASH = YES ]; then\n         ngx_module_name=ngx_stream_upstream_hash_module\n         ngx_module_deps=\nDiff:\n@@ -124,6 +124,7 @@ STREAM_GEOIP=NO\n STREAM_MAP=YES\n STREAM_SPLIT_CLIENTS=YES\n STREAM_RETURN=YES\n+STREAM_SET=YES\n STREAM_UPSTREAM_HASH=YES\n STREAM_UPSTREAM_LEAST_CONN=YES\n STREAM_UPSTREAM_RANDOM=YES\n@@ -324,6 +325,7 @@ use the \\\"--with-mail_ssl_module\\\" option instead\"\n         --without-stream_split_clients_module)\n                                          STREAM_SPLIT_CLIENTS=NO    ;;\n         --without-stream_return_module)  STREAM_RETURN=NO           ;;\n+        --without-stream_set_module)     STREAM_SET=NO              ;;\n         --without-stream_upstream_hash_module)\n                                          STREAM_UPSTREAM_HASH=NO    ;;\n         --without-stream_upstream_least_conn_module)\n@@ -538,6 +540,7 @@ cat << END\n   --without-stream_split_clients_module\n                                      disable ngx_stream_split_clients_module\n   --without-stream_return_module     disable ngx_stream_return_module\n+  --without-stream_set_module        disable ngx_stream_set_module\n   --without-stream_upstream_hash_module\n                                      disable ngx_stream_upstream_hash_module\n   --without-stream_upstream_least_conn_module\nDiff:\n@@ -10,6 +10,19 @@\n #include <ngx_http.h>\n \n \n+#define  NGX_HTTP_PROXY_COOKIE_SECURE           0x0001\n+#define  NGX_HTTP_PROXY_COOKIE_SECURE_ON        0x0002\n+#define  NGX_HTTP_PROXY_COOKIE_SECURE_OFF       0x0004\n+#define  NGX_HTTP_PROXY_COOKIE_HTTPONLY         0x0008\n+#define  NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON      0x0010\n+#define  NGX_HTTP_PROXY_COOKIE_HTTPONLY_OFF     0x0020\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE         0x0040\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT  0x0080\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX     0x0100\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE    0x0200\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_OFF     0x0400\n+\n+\n typedef struct {\n     ngx_array_t                    caches;  /* ngx_http_file_cache_t * */\n } ngx_http_proxy_main_conf_t;\n@@ -18,7 +31,7 @@ typedef struct {\n typedef struct ngx_http_proxy_rewrite_s  ngx_http_proxy_rewrite_t;\n \n typedef ngx_int_t (*ngx_http_proxy_rewrite_pt)(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len,\n+    ngx_str_t *value, size_t prefix, size_t len,\n     ngx_http_proxy_rewrite_t *pr);\n \n struct ngx_http_proxy_rewrite_s {\n@@ -35,6 +48,19 @@ struct ngx_http_proxy_rewrite_s {\n };\n \n \n+typedef struct {\n+    union {\n+        ngx_http_complex_value_t   complex;\n+#if (NGX_PCRE)\n+        ngx_http_regex_t          *regex;\n+#endif\n+    } cookie;\n+\n+    ngx_uint_t                     flags;\n+    ngx_uint_t                     regex;\n+} ngx_http_proxy_cookie_flags_t;\n+\n+\n typedef struct {\n     ngx_str_t                      key_start;\n     ngx_str_t                      schema;\n@@ -72,6 +98,7 @@ typedef struct {\n     ngx_array_t                   *redirects;\n     ngx_array_t                   *cookie_domains;\n     ngx_array_t                   *cookie_paths;\n+    ngx_array_t                   *cookie_flags;\n \n     ngx_http_complex_value_t      *method;\n     ngx_str_t                      location;\n@@ -158,10 +185,16 @@ static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r,\n     ngx_table_elt_t *h, size_t prefix);\n static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r,\n     ngx_table_elt_t *h);\n+static ngx_int_t ngx_http_proxy_parse_cookie(ngx_str_t *value,\n+    ngx_array_t *attrs);\n static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, u_char *value, ngx_array_t *rewrites);\n+    ngx_str_t *value, ngx_array_t *rewrites);\n+static ngx_int_t ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r,\n+    ngx_array_t *attrs, ngx_array_t *flags);\n+static ngx_int_t ngx_http_proxy_edit_cookie_flags(ngx_http_request_t *r,\n+    ngx_array_t *attrs, ngx_uint_t flags);\n static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_str_t *replacement);\n+    ngx_str_t *value, size_t prefix, size_t len, ngx_str_t *replacement);\n \n static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf);\n static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf);\n@@ -180,6 +213,8 @@ static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static char *ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n static char *ngx_http_proxy_store(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n #if (NGX_HTTP_CACHE)\n@@ -282,6 +317,13 @@ static ngx_command_t  ngx_http_proxy_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"proxy_cookie_flags\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1234,\n+      ngx_http_proxy_cookie_flags,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n     { ngx_string(\"proxy_store\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n       ngx_http_proxy_store,\n@@ -845,6 +887,36 @@ static ngx_path_init_t  ngx_http_proxy_temp_path = {\n };\n \n \n+static ngx_conf_bitmask_t  ngx_http_proxy_cookie_flags_masks[] = {\n+\n+    { ngx_string(\"secure\"),\n+      NGX_HTTP_PROXY_COOKIE_SECURE|NGX_HTTP_PROXY_COOKIE_SECURE_ON },\n+\n+    { ngx_string(\"nosecure\"),\n+      NGX_HTTP_PROXY_COOKIE_SECURE|NGX_HTTP_PROXY_COOKIE_SECURE_OFF },\n+\n+    { ngx_string(\"httponly\"),\n+      NGX_HTTP_PROXY_COOKIE_HTTPONLY|NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON },\n+\n+    { ngx_string(\"nohttponly\"),\n+      NGX_HTTP_PROXY_COOKIE_HTTPONLY|NGX_HTTP_PROXY_COOKIE_HTTPONLY_OFF },\n+\n+    { ngx_string(\"samesite=strict\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT },\n+\n+    { ngx_string(\"samesite=lax\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX },\n+\n+    { ngx_string(\"samesite=none\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE },\n+\n+    { ngx_string(\"nosamesite\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_OFF },\n+\n+    { ngx_null_string, 0 }\n+};\n+\n+\n static ngx_int_t\n ngx_http_proxy_handler(ngx_http_request_t *r)\n {\n@@ -906,7 +978,7 @@ ngx_http_proxy_handler(ngx_http_request_t *r)\n         u->rewrite_redirect = ngx_http_proxy_rewrite_redirect;\n     }\n \n-    if (plcf->cookie_domains || plcf->cookie_paths) {\n+    if (plcf->cookie_domains || plcf->cookie_paths || plcf->cookie_flags) {\n         u->rewrite_cookie = ngx_http_proxy_rewrite_cookie;\n     }\n \n@@ -2584,7 +2656,7 @@ ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r, ngx_table_elt_t *h,\n     len = h->value.len - prefix;\n \n     for (i = 0; i < plcf->redirects->nelts; i++) {\n-        rc = pr[i].handler(r, h, prefix, len, &pr[i]);\n+        rc = pr[i].handler(r, &h->value, prefix, len, &pr[i]);\n \n         if (rc != NGX_DECLINED) {\n             return rc;\n@@ -2598,27 +2670,41 @@ ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r, ngx_table_elt_t *h,\n static ngx_int_t\n ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n {\n-    size_t                      prefix;\n     u_char                     *p;\n+    size_t                      len;\n     ngx_int_t                   rc, rv;\n+    ngx_str_t                  *key, *value;\n+    ngx_uint_t                  i;\n+    ngx_array_t                 attrs;\n+    ngx_keyval_t               *attr;\n     ngx_http_proxy_loc_conf_t  *plcf;\n \n-    p = (u_char *) ngx_strchr(h->value.data, ';');\n-    if (p == NULL) {\n-        return NGX_DECLINED;\n+    ngx_array_init(&attrs, r->pool, 2, sizeof(ngx_keyval_t));\n+\n+    if (ngx_http_proxy_parse_cookie(&h->value, &attrs) != NGX_OK) {\n+        return NGX_ERROR;\n     }\n \n-    prefix = p + 1 - h->value.data;\n+    attr = attrs.elts;\n+\n+    if (attr[0].value.data == NULL) {\n+        return NGX_DECLINED;\n+    }\n \n     rv = NGX_DECLINED;\n \n     plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);\n \n-    if (plcf->cookie_domains) {\n-        p = ngx_strcasestrn(h->value.data + prefix, \"domain=\", 7 - 1);\n+    for (i = 1; i < attrs.nelts; i++) {\n+\n+        key = &attr[i].key;\n+        value = &attr[i].value;\n \n-        if (p) {\n-            rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 7,\n+        if (plcf->cookie_domains && key->len == 6\n+            && ngx_strncasecmp(key->data, (u_char *) \"domain\", 6) == 0\n+            && value->data)\n+        {\n+            rc = ngx_http_proxy_rewrite_cookie_value(r, value,\n                                                      plcf->cookie_domains);\n             if (rc == NGX_ERROR) {\n                 return NGX_ERROR;\n@@ -2628,13 +2714,12 @@ ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n                 rv = rc;\n             }\n         }\n-    }\n \n-    if (plcf->cookie_paths) {\n-        p = ngx_strcasestrn(h->value.data + prefix, \"path=\", 5 - 1);\n-\n-        if (p) {\n-            rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 5,\n+        if (plcf->cookie_paths && key->len == 4\n+            && ngx_strncasecmp(key->data, (u_char *) \"path\", 4) == 0\n+            && value->data)\n+        {\n+            rc = ngx_http_proxy_rewrite_cookie_value(r, value,\n                                                      plcf->cookie_paths);\n             if (rc == NGX_ERROR) {\n                 return NGX_ERROR;\n@@ -2646,30 +2731,153 @@ ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n         }\n     }\n \n-    return rv;\n+    if (plcf->cookie_flags) {\n+        rc = ngx_http_proxy_rewrite_cookie_flags(r, &attrs,\n+                                                 plcf->cookie_flags);\n+        if (rc == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (rc != NGX_DECLINED) {\n+            rv = rc;\n+        }\n+\n+        attr = attrs.elts;\n+    }\n+\n+    if (rv != NGX_OK) {\n+        return rv;\n+    }\n+\n+    len = 0;\n+\n+    for (i = 0; i < attrs.nelts; i++) {\n+\n+        if (attr[i].key.data == NULL) {\n+            continue;\n+        }\n+\n+        if (i > 0) {\n+            len += 2;\n+        }\n+\n+        len += attr[i].key.len;\n+\n+        if (attr[i].value.data) {\n+            len += 1 + attr[i].value.len;\n+        }\n+    }\n+\n+    p = ngx_pnalloc(r->pool, len + 1);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    h->value.data = p;\n+    h->value.len = len;\n+\n+    for (i = 0; i < attrs.nelts; i++) {\n+\n+        if (attr[i].key.data == NULL) {\n+            continue;\n+        }\n+\n+        if (i > 0) {\n+            *p++ = ';';\n+            *p++ = ' ';\n+        }\n+\n+        p = ngx_cpymem(p, attr[i].key.data, attr[i].key.len);\n+\n+        if (attr[i].value.data) {\n+            *p++ = '=';\n+            p = ngx_cpymem(p, attr[i].value.data, attr[i].value.len);\n+        }\n+    }\n+\n+    *p = '\\0';\n+\n+    return NGX_OK;\n }\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_table_elt_t *h,\n-    u_char *value, ngx_array_t *rewrites)\n+ngx_http_proxy_parse_cookie(ngx_str_t *value, ngx_array_t *attrs)\n {\n-    size_t                     len, prefix;\n-    u_char                    *p;\n-    ngx_int_t                  rc;\n-    ngx_uint_t                 i;\n-    ngx_http_proxy_rewrite_t  *pr;\n+    u_char        *start, *end, *p, *last;\n+    ngx_str_t      name, val;\n+    ngx_keyval_t  *attr;\n+\n+    start = value->data;\n+    end = value->data + value->len;\n+\n+    for ( ;; ) {\n+\n+        last = (u_char *) ngx_strchr(start, ';');\n+\n+        if (last == NULL) {\n+            last = end;\n+        }\n+\n+        while (start < last && *start == ' ') { start++; }\n+\n+        for (p = start; p < last && *p != '='; p++) { /* void */ }\n+\n+        name.data = start;\n+        name.len = p - start;\n+\n+        while (name.len && name.data[name.len - 1] == ' ') {\n+            name.len--;\n+        }\n+\n+        if (p < last) {\n+\n+            p++;\n+\n+            while (p < last && *p == ' ') { p++; }\n+\n+            val.data = p;\n+            val.len = last - val.data;\n+\n+            while (val.len && val.data[val.len - 1] == ' ') {\n+                val.len--;\n+            }\n+\n+        } else {\n+            ngx_str_null(&val);\n+        }\n+\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n \n-    prefix = value - h->value.data;\n+        attr->key = name;\n+        attr->value = val;\n \n-    p = (u_char *) ngx_strchr(value, ';');\n+        if (last == end) {\n+            break;\n+        }\n+\n+        start = last + 1;\n+    }\n+\n+    return NGX_OK;\n+}\n \n-    len = p ? (size_t) (p - value) : (h->value.len - prefix);\n+\n+static ngx_int_t\n+ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_str_t *value,\n+    ngx_array_t *rewrites)\n+{\n+    ngx_int_t                  rc;\n+    ngx_uint_t                 i;\n+    ngx_http_proxy_rewrite_t  *pr;\n \n     pr = rewrites->elts;\n \n     for (i = 0; i < rewrites->nelts; i++) {\n-        rc = pr[i].handler(r, h, prefix, len, &pr[i]);\n+        rc = pr[i].handler(r, value, 0, value->len, &pr[i]);\n \n         if (rc != NGX_DECLINED) {\n             return rc;\n@@ -2681,8 +2889,194 @@ ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n+ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n+    ngx_array_t *flags)\n+{\n+    ngx_str_t                       pattern;\n+#if (NGX_PCRE)\n+    ngx_int_t                       rc;\n+#endif\n+    ngx_uint_t                      i;\n+    ngx_keyval_t                   *attr;\n+    ngx_http_proxy_cookie_flags_t  *pcf;\n+\n+    attr = attrs->elts;\n+    pcf = flags->elts;\n+\n+    for (i = 0; i < flags->nelts; i++) {\n+\n+#if (NGX_PCRE)\n+        if (pcf[i].regex) {\n+            rc = ngx_http_regex_exec(r, pcf[i].cookie.regex, &attr[0].key);\n+\n+            if (rc == NGX_ERROR) {\n+                return NGX_ERROR;\n+            }\n+\n+            if (rc == NGX_OK) {\n+                break;\n+            }\n+\n+            /* NGX_DECLINED */\n+\n+            continue;\n+        }\n+#endif\n+\n+        if (ngx_http_complex_value(r, &pcf[i].cookie.complex, &pattern)\n+            != NGX_OK)\n+        {\n+            return NGX_ERROR;\n+        }\n+\n+        if (pattern.len == attr[0].key.len\n+            && ngx_strncasecmp(attr[0].key.data, pattern.data, pattern.len)\n+               == 0)\n+        {\n+            break;\n+        }\n+    }\n+\n+    if (i == flags->nelts) {\n+        return NGX_DECLINED;\n+    }\n+\n+    return ngx_http_proxy_edit_cookie_flags(r, attrs, pcf[i].flags);\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_proxy_edit_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n+    ngx_uint_t flags)\n+{\n+    ngx_str_t     *key, *value;\n+    ngx_uint_t     i;\n+    ngx_keyval_t  *attr;\n+\n+    attr = attrs->elts;\n+\n+    for (i = 1; i < attrs->nelts; i++) {\n+        key = &attr[i].key;\n+\n+        if (key->len == 6\n+            && ngx_strncasecmp(key->data, (u_char *) \"secure\", 6) == 0)\n+        {\n+            if (flags & NGX_HTTP_PROXY_COOKIE_SECURE_ON) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SECURE_ON;\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SECURE_OFF) {\n+                key->data = NULL;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (key->len == 8\n+            && ngx_strncasecmp(key->data, (u_char *) \"httponly\", 8) == 0)\n+        {\n+            if (flags & NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON;\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_HTTPONLY_OFF) {\n+                key->data = NULL;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (key->len == 8\n+            && ngx_strncasecmp(key->data, (u_char *) \"samesite\", 8) == 0)\n+        {\n+            value = &attr[i].value;\n+\n+            if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT;\n+\n+                if (value->len != 6\n+                    || ngx_strncasecmp(value->data, (u_char *) \"strict\", 6)\n+                       != 0)\n+                {\n+                    ngx_str_set(key, \"SameSite\");\n+                    ngx_str_set(value, \"Strict\");\n+                }\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX;\n+\n+                if (value->len != 3\n+                    || ngx_strncasecmp(value->data, (u_char *) \"lax\", 3) != 0)\n+                {\n+                    ngx_str_set(key, \"SameSite\");\n+                    ngx_str_set(value, \"Lax\");\n+                }\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE;\n+\n+                if (value->len != 4\n+                    || ngx_strncasecmp(value->data, (u_char *) \"none\", 4) != 0)\n+                {\n+                    ngx_str_set(key, \"SameSite\");\n+                    ngx_str_set(value, \"None\");\n+                }\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_OFF) {\n+                key->data = NULL;\n+            }\n+\n+            continue;\n+        }\n+    }\n+\n+    if (flags & NGX_HTTP_PROXY_COOKIE_SECURE_ON) {\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_str_set(&attr->key, \"Secure\");\n+        ngx_str_null(&attr->value);\n+    }\n+\n+    if (flags & NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON) {\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_str_set(&attr->key, \"HttpOnly\");\n+        ngx_str_null(&attr->value);\n+    }\n+\n+    if (flags & (NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT\n+                 |NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX\n+                 |NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE))\n+    {\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_str_set(&attr->key, \"SameSite\");\n+\n+        if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT) {\n+            ngx_str_set(&attr->value, \"Strict\");\n+\n+        } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX) {\n+            ngx_str_set(&attr->value, \"Lax\");\n+\n+        } else {\n+            ngx_str_set(&attr->value, \"None\");\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r, ngx_str_t *value,\n+    size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n {\n     ngx_str_t  pattern, replacement;\n \n@@ -2691,8 +3085,7 @@ ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,\n     }\n \n     if (pattern.len > len\n-        || ngx_rstrncmp(h->value.data + prefix, pattern.data,\n-                        pattern.len) != 0)\n+        || ngx_rstrncmp(value->data + prefix, pattern.data, pattern.len) != 0)\n     {\n         return NGX_DECLINED;\n     }\n@@ -2701,20 +3094,20 @@ ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    return ngx_http_proxy_rewrite(r, h, prefix, pattern.len, &replacement);\n+    return ngx_http_proxy_rewrite(r, value, prefix, pattern.len, &replacement);\n }\n \n \n #if (NGX_PCRE)\n \n static ngx_int_t\n-ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r, ngx_table_elt_t *h,\n+ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r, ngx_str_t *value,\n     size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n {\n     ngx_str_t  pattern, replacement;\n \n     pattern.len = len;\n-    pattern.data = h->value.data + prefix;\n+    pattern.data = value->data + prefix;\n \n     if (ngx_http_regex_exec(r, pr->pattern.regex, &pattern) != NGX_OK) {\n         return NGX_DECLINED;\n@@ -2724,20 +3117,15 @@ ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r, ngx_table_elt_t *h,\n         return NGX_ERROR;\n     }\n \n-    if (prefix == 0 && h->value.len == len) {\n-        h->value = replacement;\n-        return NGX_OK;\n-    }\n-\n-    return ngx_http_proxy_rewrite(r, h, prefix, len, &replacement);\n+    return ngx_http_proxy_rewrite(r, value, prefix, len, &replacement);\n }\n \n #endif\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n+ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r, ngx_str_t *value,\n+    size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n {\n     u_char     *p;\n     ngx_str_t   pattern, replacement;\n@@ -2746,9 +3134,9 @@ ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    p = h->value.data + prefix;\n+    p = value->data + prefix;\n \n-    if (p[0] == '.') {\n+    if (len && p[0] == '.') {\n         p++;\n         prefix++;\n         len--;\n@@ -2762,18 +3150,23 @@ ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    return ngx_http_proxy_rewrite(r, h, prefix, len, &replacement);\n+    return ngx_http_proxy_rewrite(r, value, prefix, len, &replacement);\n }\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_table_elt_t *h, size_t prefix,\n+ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_str_t *value, size_t prefix,\n     size_t len, ngx_str_t *replacement)\n {\n     u_char  *p, *data;\n     size_t   new_len;\n \n-    new_len = replacement->len + h->value.len - len;\n+    if (len == value->len) {\n+        *value = *replacement;\n+        return NGX_OK;\n+    }\n+\n+    new_len = replacement->len + value->len - len;\n \n     if (replacement->len > len) {\n \n@@ -2782,23 +3175,22 @@ ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_table_elt_t *h, size_t prefix,\n             return NGX_ERROR;\n         }\n \n-        p = ngx_copy(data, h->value.data, prefix);\n+        p = ngx_copy(data, value->data, prefix);\n         p = ngx_copy(p, replacement->data, replacement->len);\n \n-        ngx_memcpy(p, h->value.data + prefix + len,\n-                   h->value.len - len - prefix + 1);\n+        ngx_memcpy(p, value->data + prefix + len,\n+                   value->len - len - prefix + 1);\n \n-        h->value.data = data;\n+        value->data = data;\n \n     } else {\n-        p = ngx_copy(h->value.data + prefix, replacement->data,\n-                     replacement->len);\n+        p = ngx_copy(value->data + prefix, replacement->data, replacement->len);\n \n-        ngx_memmove(p, h->value.data + prefix + len,\n-                    h->value.len - len - prefix + 1);\n+        ngx_memmove(p, value->data + prefix + len,\n+                    value->len - len - prefix + 1);\n     }\n \n-    h->value.len = new_len;\n+    value->len = new_len;\n \n     return NGX_OK;\n }\n@@ -2957,6 +3349,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n \n     conf->cookie_domains = NGX_CONF_UNSET_PTR;\n     conf->cookie_paths = NGX_CONF_UNSET_PTR;\n+    conf->cookie_flags = NGX_CONF_UNSET_PTR;\n \n     conf->http_version = NGX_CONF_UNSET_UINT;\n \n@@ -3352,6 +3745,8 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_ptr_value(conf->cookie_paths, prev->cookie_paths, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->cookie_flags, prev->cookie_flags, NULL);\n+\n     ngx_conf_merge_uint_value(conf->http_version, prev->http_version,\n                               NGX_HTTP_VERSION_10);\n \n@@ -3766,7 +4161,7 @@ ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_compile_complex_value_t   ccv;\n \n     if (plcf->redirect == 0) {\n-        return NGX_CONF_OK;\n+        return \"is duplicate\";\n     }\n \n     plcf->redirect = 1;\n@@ -3775,16 +4170,12 @@ ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     if (cf->args->nelts == 2) {\n         if (ngx_strcmp(value[1].data, \"off\") == 0) {\n-            plcf->redirect = 0;\n-            plcf->redirects = NULL;\n-            return NGX_CONF_OK;\n-        }\n \n-        if (ngx_strcmp(value[1].data, \"false\") == 0) {\n-            ngx_conf_log_error(NGX_LOG_ERR, cf, 0,\n-                           \"invalid parameter \\\"false\\\", use \\\"off\\\" instead\");\n+            if (plcf->redirects) {\n+                return \"is duplicate\";\n+            }\n+\n             plcf->redirect = 0;\n-            plcf->redirects = NULL;\n             return NGX_CONF_OK;\n         }\n \n@@ -3808,7 +4199,9 @@ ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         return NGX_CONF_ERROR;\n     }\n \n-    if (ngx_strcmp(value[1].data, \"default\") == 0) {\n+    if (cf->args->nelts == 2\n+        && ngx_strcmp(value[1].data, \"default\") == 0)\n+    {\n         if (plcf->proxy_lengths) {\n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"\\\"proxy_redirect default\\\" cannot be used \"\n@@ -3911,14 +4304,19 @@ ngx_http_proxy_cookie_domain(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_compile_complex_value_t   ccv;\n \n     if (plcf->cookie_domains == NULL) {\n-        return NGX_CONF_OK;\n+        return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n     if (cf->args->nelts == 2) {\n \n         if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+\n+            if (plcf->cookie_domains != NGX_CONF_UNSET_PTR) {\n+                return \"is duplicate\";\n+            }\n+\n             plcf->cookie_domains = NULL;\n             return NGX_CONF_OK;\n         }\n@@ -3998,14 +4396,19 @@ ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_compile_complex_value_t   ccv;\n \n     if (plcf->cookie_paths == NULL) {\n-        return NGX_CONF_OK;\n+        return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n     if (cf->args->nelts == 2) {\n \n         if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+\n+            if (plcf->cookie_paths != NGX_CONF_UNSET_PTR) {\n+                return \"is duplicate\";\n+            }\n+\n             plcf->cookie_paths = NULL;\n             return NGX_CONF_OK;\n         }\n@@ -4075,6 +4478,131 @@ ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_http_proxy_loc_conf_t *plcf = conf;\n+\n+    ngx_str_t                         *value;\n+    ngx_uint_t                         i, m;\n+    ngx_conf_bitmask_t                *mask;\n+    ngx_http_proxy_cookie_flags_t     *pcf;\n+    ngx_http_compile_complex_value_t   ccv;\n+#if (NGX_PCRE)\n+    ngx_regex_compile_t                rc;\n+    u_char                             errstr[NGX_MAX_CONF_ERRSTR];\n+#endif\n+\n+    if (plcf->cookie_flags == NULL) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (cf->args->nelts == 2) {\n+\n+        if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+\n+            if (plcf->cookie_flags != NGX_CONF_UNSET_PTR) {\n+                return \"is duplicate\";\n+            }\n+\n+            plcf->cookie_flags = NULL;\n+            return NGX_CONF_OK;\n+        }\n+\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"invalid parameter \\\"%V\\\"\", &value[1]);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (plcf->cookie_flags == NGX_CONF_UNSET_PTR) {\n+        plcf->cookie_flags = ngx_array_create(cf->pool, 1,\n+                                        sizeof(ngx_http_proxy_cookie_flags_t));\n+        if (plcf->cookie_flags == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    pcf = ngx_array_push(plcf->cookie_flags);\n+    if (pcf == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    pcf->regex = 0;\n+\n+    if (value[1].data[0] == '~') {\n+        value[1].len--;\n+        value[1].data++;\n+\n+#if (NGX_PCRE)\n+        ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n+\n+        rc.pattern = value[1];\n+        rc.err.len = NGX_MAX_CONF_ERRSTR;\n+        rc.err.data = errstr;\n+        rc.options = NGX_REGEX_CASELESS;\n+\n+        pcf->cookie.regex = ngx_http_regex_compile(cf, &rc);\n+        if (pcf->cookie.regex == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        pcf->regex = 1;\n+#else\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"using regex \\\"%V\\\" requires PCRE library\",\n+                           &value[1]);\n+        return NGX_CONF_ERROR;\n+#endif\n+\n+    } else {\n+\n+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n+\n+        ccv.cf = cf;\n+        ccv.value = &value[1];\n+        ccv.complex_value = &pcf->cookie.complex;\n+\n+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    mask = ngx_http_proxy_cookie_flags_masks;\n+    pcf->flags = 0;\n+\n+    for (i = 2; i < cf->args->nelts; i++) {\n+        for (m = 0; mask[m].name.len != 0; m++) {\n+\n+            if (mask[m].name.len != value[i].len\n+                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)\n+            {\n+                continue;\n+            }\n+\n+            if (pcf->flags & mask[m].mask) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"duplicate parameter \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            pcf->flags |= mask[m].mask;\n+\n+            break;\n+        }\n+\n+        if (mask[m].name.len == 0) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"invalid parameter \\\"%V\\\"\", &value[i]);\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_proxy_rewrite_regex(ngx_conf_t *cf, ngx_http_proxy_rewrite_t *pr,\n     ngx_str_t *regex, ngx_uint_t caseless)\nDiff:\n@@ -15,12 +15,20 @@\n #define NGX_HTTP_USERID_V1    2\n #define NGX_HTTP_USERID_ON    3\n \n+#define NGX_HTTP_USERID_COOKIE_SECURE           0x0001\n+#define NGX_HTTP_USERID_COOKIE_HTTPONLY         0x0002\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE         0x0004\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT  0x0008\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_LAX     0x0010\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_NONE    0x0020\n+\n /* 31 Dec 2037 23:55:55 GMT */\n #define NGX_HTTP_USERID_MAX_EXPIRES  2145916555\n \n \n typedef struct {\n     ngx_uint_t  enable;\n+    ngx_uint_t  flags;\n \n     ngx_int_t   service;\n \n@@ -88,6 +96,19 @@ static ngx_conf_enum_t  ngx_http_userid_state[] = {\n };\n \n \n+static ngx_conf_bitmask_t  ngx_http_userid_flags[] = {\n+    { ngx_string(\"secure\"), NGX_HTTP_USERID_COOKIE_SECURE },\n+    { ngx_string(\"httponly\"), NGX_HTTP_USERID_COOKIE_HTTPONLY },\n+    { ngx_string(\"samesite=strict\"),\n+      NGX_HTTP_USERID_COOKIE_SAMESITE|NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT },\n+    { ngx_string(\"samesite=lax\"),\n+      NGX_HTTP_USERID_COOKIE_SAMESITE|NGX_HTTP_USERID_COOKIE_SAMESITE_LAX },\n+    { ngx_string(\"samesite=none\"),\n+      NGX_HTTP_USERID_COOKIE_SAMESITE|NGX_HTTP_USERID_COOKIE_SAMESITE_NONE },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n static ngx_conf_post_handler_pt  ngx_http_userid_domain_p =\n     ngx_http_userid_domain;\n static ngx_conf_post_handler_pt  ngx_http_userid_path_p = ngx_http_userid_path;\n@@ -138,6 +159,13 @@ static ngx_command_t  ngx_http_userid_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"userid_flags\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE123,\n+      ngx_conf_set_bitmask_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_userid_conf_t, flags),\n+      &ngx_http_userid_flags },\n+\n     { ngx_string(\"userid_p3p\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n       ngx_conf_set_str_slot,\n@@ -374,6 +402,26 @@ ngx_http_userid_set_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,\n         len += conf->domain.len;\n     }\n \n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SECURE) {\n+        len += sizeof(\"; secure\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_HTTPONLY) {\n+        len += sizeof(\"; httponly\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT) {\n+        len += sizeof(\"; samesite=strict\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_LAX) {\n+        len += sizeof(\"; samesite=lax\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_NONE) {\n+        len += sizeof(\"; samesite=none\") - 1;\n+    }\n+\n     cookie = ngx_pnalloc(r->pool, len);\n     if (cookie == NULL) {\n         return NGX_ERROR;\n@@ -413,6 +461,26 @@ ngx_http_userid_set_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,\n \n     p = ngx_copy(p, conf->path.data, conf->path.len);\n \n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SECURE) {\n+        p = ngx_cpymem(p, \"; secure\", sizeof(\"; secure\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_HTTPONLY) {\n+        p = ngx_cpymem(p, \"; httponly\", sizeof(\"; httponly\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT) {\n+        p = ngx_cpymem(p, \"; samesite=strict\", sizeof(\"; samesite=strict\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_LAX) {\n+        p = ngx_cpymem(p, \"; samesite=lax\", sizeof(\"; samesite=lax\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_NONE) {\n+        p = ngx_cpymem(p, \"; samesite=none\", sizeof(\"; samesite=none\") - 1);\n+    }\n+\n     set_cookie = ngx_list_push(&r->headers_out.headers);\n     if (set_cookie == NULL) {\n         return NGX_ERROR;\n@@ -649,6 +717,7 @@ ngx_http_userid_create_conf(ngx_conf_t *cf)\n     /*\n      * set by ngx_pcalloc():\n      *\n+     *     conf->flags = 0;\n      *     conf->name = { 0, NULL };\n      *     conf->domain = { 0, NULL };\n      *     conf->path = { 0, NULL };\n@@ -673,6 +742,9 @@ ngx_http_userid_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->enable, prev->enable,\n                               NGX_HTTP_USERID_OFF);\n \n+    ngx_conf_merge_bitmask_value(conf->flags, prev->flags,\n+                                 NGX_CONF_BITMASK_SET);\n+\n     ngx_conf_merge_str_value(conf->name, prev->name, \"uid\");\n     ngx_conf_merge_str_value(conf->domain, prev->domain, \"\");\n     ngx_conf_merge_str_value(conf->path, prev->path, \"; path=/\");\nDiff:\n@@ -0,0 +1,226 @@\n+\n+/*\n+ * Copyright (C) Pavel Pautov\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_stream.h>\n+\n+\n+typedef struct {\n+    ngx_int_t                   index;\n+    ngx_stream_set_variable_pt  set_handler;\n+    uintptr_t                   data;\n+    ngx_stream_complex_value_t  value;\n+} ngx_stream_set_cmd_t;\n+\n+\n+typedef struct {\n+    ngx_array_t                 commands;\n+} ngx_stream_set_srv_conf_t;\n+\n+\n+static ngx_int_t ngx_stream_set_handler(ngx_stream_session_t *s);\n+static ngx_int_t ngx_stream_set_var(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_stream_set_init(ngx_conf_t *cf);\n+static void *ngx_stream_set_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_stream_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+\n+\n+static ngx_command_t  ngx_stream_set_commands[] = {\n+\n+    { ngx_string(\"set\"),\n+      NGX_STREAM_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_stream_set,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_stream_module_t  ngx_stream_set_module_ctx = {\n+    NULL,                                  /* preconfiguration */\n+    ngx_stream_set_init,                   /* postconfiguration */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_stream_set_create_srv_conf,        /* create server configuration */\n+    NULL                                   /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_stream_set_module = {\n+    NGX_MODULE_V1,\n+    &ngx_stream_set_module_ctx,            /* module context */\n+    ngx_stream_set_commands,               /* module directives */\n+    NGX_STREAM_MODULE,                     /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static ngx_int_t\n+ngx_stream_set_handler(ngx_stream_session_t *s)\n+{\n+    ngx_str_t                     str;\n+    ngx_uint_t                    i;\n+    ngx_stream_set_cmd_t         *cmds;\n+    ngx_stream_set_srv_conf_t    *scf;\n+    ngx_stream_variable_value_t   vv;\n+\n+    scf = ngx_stream_get_module_srv_conf(s, ngx_stream_set_module);\n+    cmds = scf->commands.elts;\n+    vv = ngx_stream_variable_null_value;\n+\n+    for (i = 0; i < scf->commands.nelts; i++) {\n+        if (ngx_stream_complex_value(s, &cmds[i].value, &str) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (cmds[i].set_handler != NULL) {\n+            vv.len = str.len;\n+            vv.data = str.data;\n+            cmds[i].set_handler(s, &vv, cmds[i].data);\n+\n+        } else {\n+            s->variables[cmds[i].index].len = str.len;\n+            s->variables[cmds[i].index].valid = 1;\n+            s->variables[cmds[i].index].no_cacheable = 0;\n+            s->variables[cmds[i].index].not_found = 0;\n+            s->variables[cmds[i].index].data = str.data;\n+        }\n+    }\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+static ngx_int_t\n+ngx_stream_set_var(ngx_stream_session_t *s, ngx_stream_variable_value_t *v,\n+    uintptr_t data)\n+{\n+    *v = ngx_stream_variable_null_value;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_stream_set_init(ngx_conf_t *cf)\n+{\n+    ngx_stream_handler_pt        *h;\n+    ngx_stream_core_main_conf_t  *cmcf;\n+\n+    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);\n+\n+    h = ngx_array_push(&cmcf->phases[NGX_STREAM_PREACCESS_PHASE].handlers);\n+    if (h == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    *h = ngx_stream_set_handler;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void *\n+ngx_stream_set_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_stream_set_srv_conf_t  *conf;\n+\n+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_set_srv_conf_t));\n+    if (conf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc():\n+     *\n+     *     conf->commands = { NULL };\n+     */\n+\n+    return conf;\n+}\n+\n+\n+static char *\n+ngx_stream_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_stream_set_srv_conf_t  *scf = conf;\n+\n+    ngx_str_t                           *args;\n+    ngx_int_t                            index;\n+    ngx_stream_set_cmd_t                *set_cmd;\n+    ngx_stream_variable_t               *v;\n+    ngx_stream_compile_complex_value_t   ccv;\n+\n+    args = cf->args->elts;\n+\n+    if (args[1].data[0] != '$') {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"invalid variable name \\\"%V\\\"\", &args[1]);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    args[1].len--;\n+    args[1].data++;\n+\n+    v = ngx_stream_add_variable(cf, &args[1],\n+                                NGX_STREAM_VAR_CHANGEABLE|NGX_STREAM_VAR_WEAK);\n+    if (v == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    index = ngx_stream_get_variable_index(cf, &args[1]);\n+    if (index == NGX_ERROR) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (v->get_handler == NULL) {\n+        v->get_handler = ngx_stream_set_var;\n+    }\n+\n+    if (scf->commands.elts == NULL) {\n+        if (ngx_array_init(&scf->commands, cf->pool, 1,\n+                           sizeof(ngx_stream_set_cmd_t))\n+            != NGX_OK)\n+        {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    set_cmd = ngx_array_push(&scf->commands);\n+    if (set_cmd == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    set_cmd->index = index;\n+    set_cmd->set_handler = v->set_handler;\n+    set_cmd->data = v->data;\n+\n+    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));\n+\n+    ccv.cf = cf;\n+    ccv.value = &args[2];\n+    ccv.complex_value = &set_cmd->value;\n+\n+    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n"
    },
    {
        "commit_sha": "9f99eae133e5cbed89724ec05f893dbcdaabe398",
        "commit_index": "Commit 43",
        "commit_diff": "Diff:\n@@ -2805,7 +2805,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         return NGX_OK;\n     }\n \n-    if (c->timedout || c->error) {\n+    if (c->timedout || c->error || c->buffered) {\n         mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;\n         SSL_set_quiet_shutdown(c->ssl->connection, 1);\n \nDiff:\n@@ -946,7 +946,10 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n     c->ssl->buffer_size = sscf->buffer_size;\n \n     if (sscf->ssl.ctx) {\n-        SSL_set_SSL_CTX(ssl_conn, sscf->ssl.ctx);\n+        if (SSL_set_SSL_CTX(ssl_conn, sscf->ssl.ctx) == NULL) {\n+            *ad = SSL_AD_INTERNAL_ERROR;\n+            return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        }\n \n         /*\n          * SSL_set_SSL_CTX() only changes certs as of 1.0.0d\nDiff:\n@@ -1058,6 +1058,7 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     size_t                   size;\n     ngx_buf_t               *buf;\n     ngx_int_t                rc;\n+    ngx_connection_t        *fc;\n     ngx_http_request_t      *r;\n     ngx_http_v2_stream_t    *stream;\n     ngx_http_v2_srv_conf_t  *h2scf;\n@@ -1076,6 +1077,7 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     r = stream->request;\n+    fc = r->connection;\n \n     if (r->reading_body && !r->request_body_no_buffering) {\n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n@@ -1084,6 +1086,13 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_state_skip_padded(h2c, pos, end);\n     }\n \n+    if (r->headers_in.content_length_n < 0 && !r->headers_in.chunked) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n+                       \"skipping http2 DATA frame\");\n+\n+        return ngx_http_v2_state_skip_padded(h2c, pos, end);\n+    }\n+\n     size = end - pos;\n \n     if (size >= h2c->state.length) {\n@@ -1101,6 +1110,8 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n             ngx_http_finalize_request(r, rc);\n         }\n \n+        ngx_http_run_posted_requests(fc);\n+\n     } else if (size) {\n         buf = stream->preread;\n \n"
    },
    {
        "commit_sha": "a2976c5adf6f5e5d71a936f24952d06b3c3d8970",
        "commit_index": "Commit 42",
        "commit_diff": "Diff:\n@@ -2573,6 +2573,18 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)\n \n     sslerr = SSL_get_error(c->ssl->connection, n);\n \n+    if (sslerr == SSL_ERROR_ZERO_RETURN) {\n+\n+        /*\n+         * OpenSSL 1.1.1 fails to return SSL_ERROR_SYSCALL if an error\n+         * happens during SSL_write() after close_notify alert from the\n+         * peer, and returns SSL_ERROR_ZERO_RETURN instead,\n+         * https://git.openssl.org/?p=openssl.git;a=commitdiff;h=8051ab2\n+         */\n+\n+        sslerr = SSL_ERROR_SYSCALL;\n+    }\n+\n     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_get_error: %d\", sslerr);\n@@ -2793,7 +2805,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         return NGX_OK;\n     }\n \n-    if (c->timedout) {\n+    if (c->timedout || c->error) {\n         mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;\n         SSL_set_quiet_shutdown(c->ssl->connection, 1);\n \n@@ -2853,6 +2865,13 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n             c->read->handler = ngx_ssl_shutdown_handler;\n             c->write->handler = ngx_ssl_shutdown_handler;\n \n+            if (sslerr == SSL_ERROR_WANT_READ) {\n+                c->read->ready = 0;\n+\n+            } else {\n+                c->write->ready = 0;\n+            }\n+\n             if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                 return NGX_ERROR;\n             }\nDiff:\n@@ -117,6 +117,7 @@ struct ngx_http_cache_s {\n     unsigned                         purged:1;\n     unsigned                         reading:1;\n     unsigned                         secondary:1;\n+    unsigned                         update_variant:1;\n     unsigned                         background:1;\n \n     unsigned                         stale_updating:1;\nDiff:\n@@ -854,7 +854,7 @@ ngx_http_file_cache_exists(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)\n         if (fcn->exists || fcn->uses >= c->min_uses) {\n \n             c->exists = fcn->exists;\n-            if (fcn->body_start) {\n+            if (fcn->body_start && !c->update_variant) {\n                 c->body_start = fcn->body_start;\n             }\n \n@@ -1339,6 +1339,7 @@ ngx_http_file_cache_update_variant(ngx_http_request_t *r, ngx_http_cache_t *c)\n     ngx_shmtx_unlock(&cache->shpool->mutex);\n \n     c->file.name.len = 0;\n+    c->update_variant = 1;\n \n     ngx_memcpy(c->key, c->main, NGX_HTTP_CACHE_KEY_LEN);\n \n"
    },
    {
        "commit_sha": "1d65af14af23681bbebe07a588438d3cdf7e8ac9",
        "commit_index": "Commit 41",
        "commit_diff": "Diff:\n@@ -80,6 +80,7 @@ struct ngx_http_cache_s {\n     ngx_str_t                        vary;\n     u_char                           variant[NGX_HTTP_CACHE_KEY_LEN];\n \n+    size_t                           buffer_size;\n     size_t                           header_start;\n     size_t                           body_start;\n     off_t                            length;\nDiff:\n@@ -294,6 +294,8 @@ ngx_http_file_cache_open(ngx_http_request_t *r)\n         cln->data = c;\n     }\n \n+    c->buffer_size = c->body_start;\n+\n     rc = ngx_http_file_cache_exists(cache, c);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n@@ -1230,7 +1232,7 @@ ngx_http_file_cache_reopen(ngx_http_request_t *r, ngx_http_cache_t *c)\n \n     c->secondary = 1;\n     c->file.name.len = 0;\n-    c->body_start = c->buf->end - c->buf->start;\n+    c->body_start = c->buffer_size;\n \n     ngx_memcpy(c->key, c->variant, NGX_HTTP_CACHE_KEY_LEN);\n \nDiff:\n@@ -953,6 +953,13 @@ ngx_http_v2_state_data(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                    \"http2 DATA frame\");\n \n+    if (h2c->state.sid == 0) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent DATA frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n     if (size > h2c->recv_window) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                       \"client violated connection flow control: \"\n@@ -2095,6 +2102,16 @@ static u_char *\n ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n+                   \"http2 SETTINGS frame\");\n+\n+    if (h2c->state.sid) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent SETTINGS frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n     if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {\n \n         if (h2c->state.length != 0) {\n@@ -2118,9 +2135,6 @@ ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n     }\n \n-    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n-                   \"http2 SETTINGS frame\");\n-\n     return ngx_http_v2_state_settings_params(h2c, pos, end);\n }\n \n@@ -2269,6 +2283,13 @@ ngx_http_v2_state_ping(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                    \"http2 PING frame\");\n \n+    if (h2c->state.sid) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent PING frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n     if (h2c->state.flags & NGX_HTTP_V2_ACK_FLAG) {\n         return ngx_http_v2_state_skip(h2c, pos, end);\n     }\n@@ -2310,6 +2331,13 @@ ngx_http_v2_state_goaway(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_goaway);\n     }\n \n+    if (h2c->state.sid) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent GOAWAY frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n #if (NGX_DEBUG)\n     h2c->state.length -= NGX_HTTP_V2_GOAWAY_SIZE;\n \n"
    },
    {
        "commit_sha": "3bfb1689701efa27ca23e93d99e8b55a4133c666",
        "commit_index": "Commit 40",
        "commit_diff": "Diff:\n@@ -451,3 +451,4 @@ fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n 062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\n+a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\nDiff:\n@@ -5,6 +5,108 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.2\" date=\"2020-08-11\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx начинает закрывать keepalive-соединения,\n+не дожидаясь исчерпания всех свободных соединений,\n+а также пишет об этом предупреждение в лог ошибок.\n+</para>\n+<para lang=\"en\">\n+now nginx starts closing keepalive connections\n+before all free worker connections are exhausted,\n+and logs a warning about this to the error log.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+оптимизация чтения тела запроса\n+при использовании chunked transfer encoding.\n+</para>\n+<para lang=\"en\">\n+optimization of client request body reading\n+when using chunked transfer encoding.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки памяти при использовании директивы ssl_ocsp.\n+</para>\n+<para lang=\"en\">\n+memory leak if the \"ssl_ocsp\" directive was used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения \"zero size buf in output\",\n+если FastCGI-сервер возвращал некорректный ответ;\n+ошибка появилась в 1.19.1.\n+</para>\n+<para lang=\"en\">\n+\"zero size buf in output\" alerts might appear in logs\n+if a FastCGI server returned an incorrect response;\n+the bug had appeared in 1.19.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в рабочем процессе мог произойти segmentation fault,\n+если размеры large_client_header_buffers отличались\n+в разных виртуальных серверах.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+if different large_client_header_buffers sizes were used\n+in different virtual servers.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL shutdown мог не работать.\n+</para>\n+<para lang=\"en\">\n+SSL shutdown might not work.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\".\n+</para>\n+<para lang=\"en\">\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\"\n+messages might appear in logs.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_slice_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_slice_module.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_xslt_filter_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_xslt_filter_module.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.1\" date=\"2020-07-07\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019002\n-#define NGINX_VERSION      \"1.19.2\"\n+#define nginx_version      1019003\n+#define NGINX_VERSION      \"1.19.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -2473,7 +2473,7 @@ ngx_http_upstream_test_next(ngx_http_request_t *r, ngx_http_upstream_t *u)\n #if (NGX_HTTP_CACHE)\n \n         if (u->cache_status == NGX_HTTP_CACHE_EXPIRED\n-            && ((u->conf->cache_use_stale & un->mask) || r->cache->stale_error))\n+            && (u->conf->cache_use_stale & un->mask))\n         {\n             ngx_int_t  rc;\n \n"
    },
    {
        "commit_sha": "c1a2f37aef2d536b6eedaf234ff53f3db69e3e1b",
        "commit_index": "Commit 39",
        "commit_diff": "Diff:\n@@ -1107,12 +1107,9 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)\n         return NULL;\n     }\n \n-    c = ngx_cycle->free_connections;\n+    ngx_drain_connections((ngx_cycle_t *) ngx_cycle);\n \n-    if (c == NULL) {\n-        ngx_drain_connections((ngx_cycle_t *) ngx_cycle);\n-        c = ngx_cycle->free_connections;\n-    }\n+    c = ngx_cycle->free_connections;\n \n     if (c == NULL) {\n         ngx_log_error(NGX_LOG_ALERT, log, 0,\n@@ -1301,6 +1298,21 @@ ngx_drain_connections(ngx_cycle_t *cycle)\n     ngx_queue_t       *q;\n     ngx_connection_t  *c;\n \n+    if (cycle->free_connection_n > cycle->connection_n / 16\n+        || cycle->reusable_connections_n == 0)\n+    {\n+        return;\n+    }\n+\n+    if (cycle->connections_reuse_time != ngx_time()) {\n+        cycle->connections_reuse_time = ngx_time();\n+\n+        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n+                      \"%ui worker_connections are not enough, \"\n+                      \"reusing connections\",\n+                      cycle->connection_n);\n+    }\n+\n     n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);\n \n     for (i = 0; i < n; i++) {\nDiff:\n@@ -62,6 +62,7 @@ struct ngx_cycle_s {\n \n     ngx_queue_t               reusable_connections_queue;\n     ngx_uint_t                reusable_connections_n;\n+    time_t                    connections_reuse_time;\n \n     ngx_array_t               listening;\n     ngx_array_t               paths;\nDiff:\n@@ -3008,6 +3008,12 @@ ngx_http_test_reading(ngx_http_request_t *r)\n         rev->error = 1;\n     }\n \n+#if (NGX_HTTP_SSL)\n+    if (c->ssl) {\n+        c->ssl->no_send_shutdown = 1;\n+    }\n+#endif\n+\n     ngx_log_error(NGX_LOG_INFO, c->log, err,\n                   \"client prematurely closed connection\");\n \n"
    },
    {
        "commit_sha": "cdcdb62b4d43e79851fba5f60d245debbedb0a87",
        "commit_index": "Commit 38",
        "commit_diff": "Diff:\n@@ -2774,8 +2774,9 @@ ngx_ssl_free_buffer(ngx_connection_t *c)\n ngx_int_t\n ngx_ssl_shutdown(ngx_connection_t *c)\n {\n-    int        n, sslerr, mode;\n-    ngx_err_t  err;\n+    int         n, sslerr, mode;\n+    ngx_err_t   err;\n+    ngx_uint_t  tries;\n \n     ngx_ssl_ocsp_cleanup(c);\n \n@@ -2816,55 +2817,71 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n     ngx_ssl_clear_error(c->log);\n \n-    n = SSL_shutdown(c->ssl->connection);\n+    tries = 2;\n+\n+    for ( ;; ) {\n+\n+        /*\n+         * For bidirectional shutdown, SSL_shutdown() needs to be called\n+         * twice: first call sends the \"close notify\" alert and returns 0,\n+         * second call waits for the peer's \"close notify\" alert.\n+         */\n \n-    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n+        n = SSL_shutdown(c->ssl->connection);\n \n-    sslerr = 0;\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n \n-    /* before 0.9.8m SSL_shutdown() returned 0 instead of -1 on errors */\n+        if (n == 1) {\n+            SSL_free(c->ssl->connection);\n+            c->ssl = NULL;\n+\n+            return NGX_OK;\n+        }\n+\n+        if (n == 0 && tries-- > 1) {\n+            continue;\n+        }\n+\n+        /* before 0.9.8m SSL_shutdown() returned 0 instead of -1 on errors */\n \n-    if (n != 1 && ERR_peek_error()) {\n         sslerr = SSL_get_error(c->ssl->connection, n);\n \n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                        \"SSL_get_error: %d\", sslerr);\n-    }\n \n-    if (n == 1 || sslerr == 0 || sslerr == SSL_ERROR_ZERO_RETURN) {\n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n+        if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {\n+            c->read->handler = ngx_ssl_shutdown_handler;\n+            c->write->handler = ngx_ssl_shutdown_handler;\n \n-        return NGX_OK;\n-    }\n+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n \n-    if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {\n-        c->read->handler = ngx_ssl_shutdown_handler;\n-        c->write->handler = ngx_ssl_shutdown_handler;\n+            if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n \n-        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-            return NGX_ERROR;\n-        }\n+            ngx_add_timer(c->read, 3000);\n \n-        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n-            return NGX_ERROR;\n+            return NGX_AGAIN;\n         }\n \n-        if (sslerr == SSL_ERROR_WANT_READ) {\n-            ngx_add_timer(c->read, 30000);\n-        }\n+        if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n+            SSL_free(c->ssl->connection);\n+            c->ssl = NULL;\n \n-        return NGX_AGAIN;\n-    }\n+            return NGX_OK;\n+        }\n \n-    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n+        err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n-    ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n+        ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n \n-    SSL_free(c->ssl->connection);\n-    c->ssl = NULL;\n+        SSL_free(c->ssl->connection);\n+        c->ssl = NULL;\n \n-    return NGX_ERROR;\n+        return NGX_ERROR;\n+    }\n }\n \n \nDiff:\n@@ -1027,6 +1027,8 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     for (cl = in; cl; cl = cl->next) {\n \n+        b = NULL;\n+\n         for ( ;; ) {\n \n             ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n@@ -1061,6 +1063,29 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n                     return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;\n                 }\n \n+                if (b\n+                    && rb->chunked->size <= 128\n+                    && cl->buf->last - cl->buf->pos >= rb->chunked->size)\n+                {\n+                    r->headers_in.content_length_n += rb->chunked->size;\n+\n+                    if (rb->chunked->size < 8) {\n+\n+                        while (rb->chunked->size) {\n+                            *b->last++ = *cl->buf->pos++;\n+                            rb->chunked->size--;\n+                        }\n+\n+                    } else {\n+                        ngx_memmove(b->last, cl->buf->pos, rb->chunked->size);\n+                        b->last += rb->chunked->size;\n+                        cl->buf->pos += rb->chunked->size;\n+                        rb->chunked->size = 0;\n+                    }\n+\n+                    continue;\n+                }\n+\n                 tl = ngx_chain_get_free_buf(r->pool, &rb->free);\n                 if (tl == NULL) {\n                     return NGX_HTTP_INTERNAL_SERVER_ERROR;\nDiff:\n@@ -475,6 +475,7 @@ ngx_http_v2_write_handler(ngx_event_t *wev)\n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                        \"http2 write event timed out\");\n         c->error = 1;\n+        c->timedout = 1;\n         ngx_http_v2_finalize_connection(h2c, 0);\n         return;\n     }\n"
    },
    {
        "commit_sha": "95cab45a870240c81f032fad454e48b582f4be5f",
        "commit_index": "Commit 37",
        "commit_diff": "Diff:\n@@ -2306,6 +2306,18 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             break;\n         }\n \n+        if (f->rest == -2) {\n+            f->rest = r->upstream->headers_in.content_length_n;\n+        }\n+\n+        if (f->rest == 0) {\n+            ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                          \"upstream sent more data than specified in \"\n+                          \"\\\"Content-Length\\\" header\");\n+            p->upstream_done = 1;\n+            break;\n+        }\n+\n         cl = ngx_chain_get_free_buf(p->pool, &p->free);\n         if (cl == NULL) {\n             return NGX_ERROR;\n@@ -2349,11 +2361,7 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             b->last = f->last;\n         }\n \n-        if (f->rest == -2) {\n-            f->rest = r->upstream->headers_in.content_length_n;\n-        }\n-\n-        if (f->rest >= 0) {\n+        if (f->rest > 0) {\n \n             if (b->last - b->pos > f->rest) {\n                 ngx_log_error(NGX_LOG_WARN, p->log, 0,\n@@ -2564,6 +2572,14 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n             break;\n         }\n \n+        if (f->rest == 0) {\n+            ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                          \"upstream sent more data than specified in \"\n+                          \"\\\"Content-Length\\\" header\");\n+            u->length = 0;\n+            break;\n+        }\n+\n         cl = ngx_chain_get_free_buf(r->pool, &u->free_bufs);\n         if (cl == NULL) {\n             return NGX_ERROR;\n@@ -2594,7 +2610,7 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n             b->last = f->last;\n         }\n \n-        if (f->rest >= 0) {\n+        if (f->rest > 0) {\n \n             if (b->last - b->pos > f->rest) {\n                 ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\nDiff:\n@@ -1663,6 +1663,12 @@ ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,\n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http large header copy: %uz\", r->header_in->pos - old);\n \n+    if (r->header_in->pos - old > b->end - b->start) {\n+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                      \"too large header to copy\");\n+        return NGX_ERROR;\n+    }\n+\n     new = b->start;\n \n     ngx_memcpy(new, old, r->header_in->pos - old);\nDiff:\n@@ -12,6 +12,8 @@\n \n static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r);\n static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r);\n+static ngx_int_t ngx_http_copy_pipelined_header(ngx_http_request_t *r,\n+    ngx_buf_t *buf);\n static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r);\n static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r);\n static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r,\n@@ -282,28 +284,12 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n         for ( ;; ) {\n             if (rb->buf->last == rb->buf->end) {\n \n-                if (rb->buf->pos != rb->buf->last) {\n+                /* update chains */\n \n-                    /* pass buffer to request body filter chain */\n+                rc = ngx_http_request_body_filter(r, NULL);\n \n-                    out.buf = rb->buf;\n-                    out.next = NULL;\n-\n-                    rc = ngx_http_request_body_filter(r, &out);\n-\n-                    if (rc != NGX_OK) {\n-                        return rc;\n-                    }\n-\n-                } else {\n-\n-                    /* update chains */\n-\n-                    rc = ngx_http_request_body_filter(r, NULL);\n-\n-                    if (rc != NGX_OK) {\n-                        return rc;\n-                    }\n+                if (rc != NGX_OK) {\n+                    return rc;\n                 }\n \n                 if (rb->busy != NULL) {\n@@ -355,17 +341,15 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n             rb->buf->last += n;\n             r->request_length += n;\n \n-            if (n == rest) {\n-                /* pass buffer to request body filter chain */\n+            /* pass buffer to request body filter chain */\n \n-                out.buf = rb->buf;\n-                out.next = NULL;\n+            out.buf = rb->buf;\n+            out.next = NULL;\n \n-                rc = ngx_http_request_body_filter(r, &out);\n+            rc = ngx_http_request_body_filter(r, &out);\n \n-                if (rc != NGX_OK) {\n-                    return rc;\n-                }\n+            if (rc != NGX_OK) {\n+                return rc;\n             }\n \n             if (rb->rest == 0) {\n@@ -386,21 +370,6 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n \n         if (!c->read->ready) {\n \n-            if (r->request_body_no_buffering\n-                && rb->buf->pos != rb->buf->last)\n-            {\n-                /* pass buffer to request body filter chain */\n-\n-                out.buf = rb->buf;\n-                out.next = NULL;\n-\n-                rc = ngx_http_request_body_filter(r, &out);\n-\n-                if (rc != NGX_OK) {\n-                    return rc;\n-                }\n-            }\n-\n             clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n             ngx_add_timer(c->read, clcf->client_body_timeout);\n \n@@ -412,6 +381,10 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n         }\n     }\n \n+    if (ngx_http_copy_pipelined_header(r, rb->buf) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n     if (c->read->timer_set) {\n         ngx_del_timer(c->read);\n     }\n@@ -425,6 +398,88 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_copy_pipelined_header(ngx_http_request_t *r, ngx_buf_t *buf)\n+{\n+    size_t                     n;\n+    ngx_buf_t                 *b;\n+    ngx_chain_t               *cl;\n+    ngx_http_connection_t     *hc;\n+    ngx_http_core_srv_conf_t  *cscf;\n+\n+    b = r->header_in;\n+    n = buf->last - buf->pos;\n+\n+    if (buf == b || n == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"http body pipelined header: %uz\", n);\n+\n+    /*\n+     * if there is a pipelined request in the client body buffer,\n+     * copy it to the r->header_in buffer if there is enough room,\n+     * or allocate a large client header buffer\n+     */\n+\n+    if (n > (size_t) (b->end - b->last)) {\n+\n+        hc = r->http_connection;\n+\n+        if (hc->free) {\n+            cl = hc->free;\n+            hc->free = cl->next;\n+\n+            b = cl->buf;\n+\n+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                           \"http large header free: %p %uz\",\n+                           b->pos, b->end - b->last);\n+\n+        } else {\n+            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n+            b = ngx_create_temp_buf(r->connection->pool,\n+                                    cscf->large_client_header_buffers.size);\n+            if (b == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            cl = ngx_alloc_chain_link(r->connection->pool);\n+            if (cl == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            cl->buf = b;\n+\n+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                           \"http large header alloc: %p %uz\",\n+                           b->pos, b->end - b->last);\n+        }\n+\n+        cl->next = hc->busy;\n+        hc->busy = cl;\n+        hc->nbusy++;\n+\n+        r->header_in = b;\n+\n+        if (n > (size_t) (b->end - b->last)) {\n+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                          \"too large pipelined header after reading body\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    ngx_memcpy(b->last, buf->pos, n);\n+\n+    b->last += n;\n+    r->request_length -= n;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_write_request_body(ngx_http_request_t *r)\n {\n@@ -670,8 +725,7 @@ ngx_http_read_discarded_request_body(ngx_http_request_t *r)\n \n     for ( ;; ) {\n         if (r->headers_in.content_length_n == 0) {\n-            r->read_event_handler = ngx_http_block_reading;\n-            return NGX_OK;\n+            break;\n         }\n \n         if (!r->connection->read->ready) {\n@@ -705,15 +759,24 @@ ngx_http_read_discarded_request_body(ngx_http_request_t *r)\n             return rc;\n         }\n     }\n+\n+    if (ngx_http_copy_pipelined_header(r, &b) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    r->read_event_handler = ngx_http_block_reading;\n+\n+    return NGX_OK;\n }\n \n \n static ngx_int_t\n ngx_http_discard_request_body_filter(ngx_http_request_t *r, ngx_buf_t *b)\n {\n-    size_t                    size;\n-    ngx_int_t                 rc;\n-    ngx_http_request_body_t  *rb;\n+    size_t                     size;\n+    ngx_int_t                  rc;\n+    ngx_http_request_body_t   *rb;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     if (r->headers_in.chunked) {\n \n@@ -768,7 +831,10 @@ ngx_http_discard_request_body_filter(ngx_http_request_t *r, ngx_buf_t *b)\n \n                 /* set amount of data we want to see next time */\n \n-                r->headers_in.content_length_n = rb->chunked->length;\n+                cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n+                r->headers_in.content_length_n = ngx_max(rb->chunked->length,\n+                               (off_t) cscf->large_client_header_buffers.size);\n                 break;\n             }\n \n@@ -936,6 +1002,7 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n     ngx_chain_t               *cl, *out, *tl, **ll;\n     ngx_http_request_body_t   *rb;\n     ngx_http_core_loc_conf_t  *clcf;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     rb = r->request_body;\n \n@@ -949,8 +1016,10 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n+        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n         r->headers_in.content_length_n = 0;\n-        rb->rest = 3;\n+        rb->rest = cscf->large_client_header_buffers.size;\n     }\n \n     out = NULL;\n@@ -1057,7 +1126,10 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n                 /* set rb->rest, amount of data we want to see next time */\n \n-                rb->rest = rb->chunked->length;\n+                cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n+                rb->rest = ngx_max(rb->chunked->length,\n+                               (off_t) cscf->large_client_header_buffers.size);\n \n                 break;\n             }\n"
    },
    {
        "commit_sha": "ffca2cbabab7a0a041206da058ba2ec5fa6bf516",
        "commit_index": "Commit 36",
        "commit_diff": "Diff:\n@@ -125,20 +125,20 @@ typedef struct {\n #define NGX_CHAIN_ERROR     (ngx_chain_t *) NGX_ERROR\n \n \n-#define ngx_buf_in_memory(b)        (b->temporary || b->memory || b->mmap)\n-#define ngx_buf_in_memory_only(b)   (ngx_buf_in_memory(b) && !b->in_file)\n+#define ngx_buf_in_memory(b)       ((b)->temporary || (b)->memory || (b)->mmap)\n+#define ngx_buf_in_memory_only(b)  (ngx_buf_in_memory(b) && !(b)->in_file)\n \n #define ngx_buf_special(b)                                                   \\\n-    ((b->flush || b->last_buf || b->sync)                                    \\\n-     && !ngx_buf_in_memory(b) && !b->in_file)\n+    (((b)->flush || (b)->last_buf || (b)->sync)                              \\\n+     && !ngx_buf_in_memory(b) && !(b)->in_file)\n \n #define ngx_buf_sync_only(b)                                                 \\\n-    (b->sync                                                                 \\\n-     && !ngx_buf_in_memory(b) && !b->in_file && !b->flush && !b->last_buf)\n+    ((b)->sync && !ngx_buf_in_memory(b)                                      \\\n+     && !(b)->in_file && !(b)->flush && !(b)->last_buf)\n \n #define ngx_buf_size(b)                                                      \\\n-    (ngx_buf_in_memory(b) ? (off_t) (b->last - b->pos):                      \\\n-                            (b->file_last - b->file_pos))\n+    (ngx_buf_in_memory(b) ? (off_t) ((b)->last - (b)->pos):                  \\\n+                            ((b)->file_last - (b)->file_pos))\n \n ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);\n ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs);\n@@ -149,8 +149,8 @@ ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs);\n \n ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool);\n #define ngx_free_chain(pool, cl)                                             \\\n-    cl->next = pool->chain;                                                  \\\n-    pool->chain = cl\n+    (cl)->next = (pool)->chain;                                              \\\n+    (pool)->chain = (cl)\n \n \n \nDiff:\n@@ -883,6 +883,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n \n     ocsp = ngx_pcalloc(c->pool, sizeof(ngx_ssl_ocsp_t));\n     if (ocsp == NULL) {\n+        X509_free(cert);\n         return NGX_ERROR;\n     }\n \n@@ -899,6 +900,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n     if (ocsp->certs) {\n         ocsp->certs = X509_chain_up_ref(ocsp->certs);\n         if (ocsp->certs == NULL) {\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n     }\n@@ -910,13 +912,15 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n         if (store == NULL) {\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"SSL_CTX_get_cert_store() failed\");\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n         store_ctx = X509_STORE_CTX_new();\n         if (store_ctx == NULL) {\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"X509_STORE_CTX_new() failed\");\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n@@ -926,13 +930,15 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"X509_STORE_CTX_init() failed\");\n             X509_STORE_CTX_free(store_ctx);\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n         rc = X509_verify_cert(store_ctx);\n         if (rc <= 0) {\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0, \"X509_verify_cert() failed\");\n             X509_STORE_CTX_free(store_ctx);\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n@@ -941,12 +947,15 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"X509_STORE_CTX_get1_chain() failed\");\n             X509_STORE_CTX_free(store_ctx);\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n         X509_STORE_CTX_free(store_ctx);\n     }\n \n+    X509_free(cert);\n+\n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"ssl ocsp validate, certs:%d\", sk_X509_num(ocsp->certs));\n \nDiff:\n@@ -233,6 +233,7 @@ ngx_http_xslt_header_filter(ngx_http_request_t *r)\n     ngx_http_set_ctx(r, ctx, ngx_http_xslt_filter_module);\n \n     r->main_filter_need_in_memory = 1;\n+    r->allow_ranges = 0;\n \n     return NGX_OK;\n }\n"
    },
    {
        "commit_sha": "cc4b16fc10dcc579d5f697f3ff70c390b5e7c7d2",
        "commit_index": "Commit 35",
        "commit_diff": "Diff:\n@@ -1153,6 +1153,9 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)\n     rev->data = c;\n     wev->data = c;\n \n+    rev->cycle = (ngx_cycle_t*)ngx_cycle;\n+    wev->cycle = (ngx_cycle_t*)ngx_cycle;\n+\n     wev->write = 1;\n \n     return c;\nDiff:\n@@ -15,6 +15,7 @@\n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n+typedef struct ngx_black_list_s      ngx_black_list_t;\n typedef struct ngx_pool_s            ngx_pool_t;\n typedef struct ngx_chain_s           ngx_chain_t;\n typedef struct ngx_log_s             ngx_log_t;\nDiff:\n@@ -1009,6 +1009,7 @@ ngx_int_t\n ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n {\n     size_t      len;\n+    ngx_int_t   rc;\n     ngx_uint_t  create;\n     ngx_file_t  file;\n     u_char      pid[NGX_INT64_LEN + 2];\n@@ -1033,11 +1034,13 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n+    rc = NGX_OK;\n+\n     if (!ngx_test_config) {\n         len = ngx_snprintf(pid, NGX_INT64_LEN + 2, \"%P%N\", ngx_pid) - pid;\n \n         if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {\n-            return NGX_ERROR;\n+            rc = NGX_ERROR;\n         }\n     }\n \n@@ -1046,7 +1049,7 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n                       ngx_close_file_n \" \\\"%s\\\" failed\", file.name.data);\n     }\n \n-    return NGX_OK;\n+    return rc;\n }\n \n \n@@ -1456,3 +1459,84 @@ ngx_shutdown_timer_handler(ngx_event_t *ev)\n         c[i].read->handler(c[i].read);\n     }\n }\n+\n+\n+void\n+ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\n+    size_t size, ngx_log_t *log)\n+{\n+    ngx_black_list_t *reader;\n+    ngx_black_list_t *new_black_list;\n+\n+    u_char* new_str = (u_char*)ngx_alloc(size, log);\n+\n+    for (size_t i = 0; i < size; i++) {\n+        new_str[i] = insert_ip[i];\n+    }\n+\n+    new_black_list = (ngx_black_list_t*)ngx_alloc(sizeof(ngx_black_list_t), log);\n+    new_black_list->IP = (ngx_str_t*)ngx_alloc(sizeof(ngx_str_t), log);;\n+    new_black_list->IP->data = new_str;\n+    new_black_list->IP->len = size;\n+    new_black_list->next = NULL;\n+\n+    reader = *black_list;\n+\n+    if (!reader) {\n+        *black_list = new_black_list;\n+        return;\n+    }\n+\n+    for (reader = reader; reader && reader->next; reader = reader->next) {\n+\n+         if (!ngx_strcmp(insert_ip, reader->IP->data)) {\n+            ngx_destroy_black_list_link(new_black_list);\n+            return;\n+         }\n+    }\n+\n+    reader->next = new_black_list;\n+    new_black_list->prev = reader;\n+\n+    return;\n+}\n+\n+\n+ngx_int_t\n+ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[])\n+{\n+    ngx_black_list_t *reader;\n+\n+    reader = *black_list;\n+\n+    if (reader && !ngx_strcmp(remove_ip, reader->IP->data)) {\n+        ngx_destroy_black_list_link(reader);\n+        return NGX_OK;\n+    }\n+\n+    for (reader = reader->next; reader && reader->next; reader = reader->next) {\n+        if (!ngx_strcmp(remove_ip, reader->IP->data)) {\n+            ngx_double_link_remove(reader);\n+            ngx_destroy_black_list_link(reader);\n+            return NGX_OK;\n+        }\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection)\n+{\n+    ngx_black_list_t *reader = (cycle) ? cycle->black_list : NULL;\n+\n+    for (reader = reader; reader; reader = reader->next) {\n+            if (!ngx_strcmp(connection->addr_text.data, reader->IP->data)) {\n+                ngx_close_connection(connection);\n+                return NGX_ERROR;\n+            }\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -36,6 +36,13 @@ struct ngx_shm_zone_s {\n };\n \n \n+typedef struct ngx_black_list_s {\n+    ngx_str_t         *IP;\n+    ngx_black_list_t  *next;\n+    ngx_black_list_t  *prev;\n+}ngx_black_list_t;\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -81,6 +88,7 @@ struct ngx_cycle_s {\n     ngx_str_t                 prefix;\n     ngx_str_t                 lock_file;\n     ngx_str_t                 hostname;\n+    ngx_black_list_t         *black_list;\n };\n \n \n@@ -123,7 +131,24 @@ typedef struct {\n \n \n #define ngx_is_init_cycle(cycle)  (cycle->conf_ctx == NULL)\n-\n+#define ngx_double_link_insert(x, y)            \\\n+    (x)->next = (y);                            \\\n+    (y)->prev = (x);\n+\n+#define ngx_double_link_remove(x)               \\\n+    if ((x)->prev) (x)->prev->next = (x)->next; \\\n+    if ((x)->next) (x)->next->prev = (x)->prev;\n+\n+#define ngx_destroy_black_list_link(x)          \\\n+    ngx_memzero((x)->IP->data, (x)->IP->len);   \\\n+    ngx_free((x)->IP->data);                    \\\n+    (x)->IP->data = NULL;                       \\\n+    ngx_memzero((x)->IP, sizeof(ngx_str_t));    \\\n+    ngx_free((x)->IP);                          \\\n+    (x)->IP = NULL;                             \\\n+    ngx_memzero((x), sizeof(ngx_black_list_t)); \\\n+    ngx_free((x));                              \\\n+    (x) = NULL;\n \n ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);\n ngx_int_t ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log);\n@@ -136,6 +161,10 @@ ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n     size_t size, void *tag);\n void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+void ngx_black_list_insert(ngx_black_list_t **black_list,\n+    u_char insert_ip[], size_t size, ngx_log_t *log);\n+ngx_int_t ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[]);\n+ngx_int_t ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection);\n \n \n extern volatile ngx_cycle_t  *ngx_cycle;\nDiff:\n@@ -101,6 +101,7 @@ struct ngx_event_s {\n     int              available;\n \n     ngx_event_handler_pt  handler;\n+    ngx_cycle_t          *cycle;\n \n \n #if (NGX_HAVE_IOCP)\nDiff:\n@@ -20,6 +20,10 @@ static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_black_list(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_white_list(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n@@ -199,6 +203,12 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n     { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookies),\n                  ngx_http_process_multi_header_lines },\n \n+    { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n+                 ngx_http_process_black_list },\n+\n+    { ngx_string(\"White-List\"), offsetof(ngx_http_headers_in_t, white_list),\n+                 ngx_http_process_white_list },\n+\n     { ngx_null_string, 0, NULL }\n };\n \n@@ -392,6 +402,10 @@ ngx_http_wait_request_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_is_ip_banned(rev->cycle, c)) {\n+        c->close = 1;\n+    }\n+\n     if (c->close) {\n         ngx_http_close_connection(c);\n         return;\n@@ -1045,6 +1059,7 @@ ngx_http_process_request_line(ngx_event_t *rev)\n \n     c = rev->data;\n     r = c->data;\n+    r->cycle = rev->cycle;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request line\");\n@@ -1330,6 +1345,7 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n \n     c = rev->data;\n     r = c->data;\n+    r->cycle = rev->cycle;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request header line\");\n@@ -3818,3 +3834,97 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,\n \n     return buf;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_process_white_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    enum State {start,\n+                ip};\n+    enum State state = start;\n+    u_char IP_buffer[NGX_IP_LEN + 1] = {0};\n+    ngx_int_t buffer_index = 0;\n+    u_char* reader = h->value.data;\n+    ngx_int_t result = NGX_ERROR;\n+\n+    // Remove each IP given\n+    while (*reader != '\\0') {\n+        switch (state) {\n+\n+        case start:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+                state = ip;\n+            }\n+            break;\n+\n+        case ip:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+            } else if (*reader == ';' ||\n+                     *reader == '\\0' ||\n+                     *reader == '\\n') {\n+                IP_buffer[buffer_index] = '\\0';\n+                buffer_index = 0;\n+                state = start;\n+                result = ngx_black_list_remove(&(r->cycle)->black_list, IP_buffer);\n+                if (result == NGX_ERROR) goto ngx_black_list_remove_fail;\n+            } else {\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        }\n+        reader++;\n+    }\n+\n+    return NGX_OK;\n+\n+ngx_black_list_remove_fail:\n+    return NGX_ERROR;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_process_black_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    enum State {start,\n+                ip};\n+    enum State state = start;\n+    u_char IP_buffer[NGX_IP_LEN + 1] = {0};\n+    ngx_int_t buffer_index = 0;\n+    u_char* reader = h->value.data;\n+\n+    while (*reader != '\\0') {\n+        switch (state) {\n+\n+        case start:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+                state = ip;\n+            }\n+            break;\n+\n+        case ip:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+            } else if (*reader == ';' ||\n+                     *reader == '\\0' ||\n+                     *reader == '\\n') {\n+                IP_buffer[buffer_index] = '\\0';\n+                buffer_index = 0;\n+                state = start;\n+                ngx_black_list_insert(&(r->cycle)->black_list, IP_buffer, NGX_IP_LEN, r->cycle->log);\n+            } else {\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        }\n+        reader++;\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -148,7 +148,8 @@\n #define NGX_HTTP_SSI_BUFFERED              0x01\n #define NGX_HTTP_SUB_BUFFERED              0x02\n #define NGX_HTTP_COPY_BUFFERED             0x04\n-\n+#define NGX_IP_LEN (sizeof(\"000.000.000.000\"))\n+#define ngx_is_valid_ip_char(x) (('0' <= (x) && (x) <= '9') || (x) == '.')\n \n typedef enum {\n     NGX_HTTP_INITING_REQUEST_STATE = 0,\n@@ -239,6 +240,9 @@ typedef struct {\n     off_t                             content_length_n;\n     time_t                            keep_alive_n;\n \n+    ngx_str_t                         black_list;\n+    ngx_str_t                         white_list;\n+\n     unsigned                          connection_type:2;\n     unsigned                          chunked:1;\n     unsigned                          msie:1;\n@@ -421,6 +425,8 @@ struct ngx_http_request_s {\n     ngx_http_post_subrequest_t       *post_subrequest;\n     ngx_http_posted_request_t        *posted_requests;\n \n+    ngx_cycle_t                      *cycle;\n+\n     ngx_int_t                         phase_handler;\n     ngx_http_handler_pt               content_handler;\n     ngx_uint_t                        access_code;\n"
    },
    {
        "commit_sha": "f0301f16e8c73d6c0b9bd4eba864927017c8c76c",
        "commit_index": "Commit 34",
        "commit_diff": "Diff:\n@@ -450,3 +450,4 @@ fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n 5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\n c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n+062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019001\n-#define NGINX_VERSION      \"1.19.1\"\n+#define nginx_version      1019002\n+#define NGINX_VERSION      \"1.19.2\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -180,6 +180,11 @@ ngx_http_slice_header_filter(ngx_http_request_t *r)\n     r->headers_out.content_range->hash = 0;\n     r->headers_out.content_range = NULL;\n \n+    if (r->headers_out.accept_ranges) {\n+        r->headers_out.accept_ranges->hash = 0;\n+        r->headers_out.accept_ranges = NULL;\n+    }\n+\n     r->allow_ranges = 1;\n     r->subrequest_ranges = 1;\n     r->single_range = 1;\n"
    },
    {
        "commit_sha": "7b9df83203cf021c9e89240341347c5bd1582948",
        "commit_index": "Commit 33",
        "commit_diff": "Diff:\n@@ -5,6 +5,130 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.1\" date=\"2020-07-07\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+директивы lingering_close, lingering_time и lingering_timeout\n+теперь работают при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+the \"lingering_close\", \"lingering_time\", and \"lingering_timeout\" directives\n+now work when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь лишние данные, присланные бэкендом, всегда отбрасываются.\n+</para>\n+<para lang=\"en\">\n+now extra data sent by a backend are always discarded.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при получении слишком короткого ответа от FastCGI-сервера\n+nginx пытается отправить клиенту доступную часть ответа,\n+после чего закрывает соединение с клиентом.\n+</para>\n+<para lang=\"en\">\n+now after receiving a too short response from a FastCGI server\n+nginx tries to send the available part of the response to the client,\n+and then closes the client connection.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при получении ответа некорректной длины от gRPC-бэкенда\n+nginx прекращает обработку ответа с ошибкой.\n+</para>\n+<para lang=\"en\">\n+now after receiving a response with incorrect length from a gRPC backend\n+nginx stops response processing with an error.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+параметр min_free в директивах proxy_cache_path, fastcgi_cache_path,\n+scgi_cache_path и uwsgi_cache_path.<br/>\n+Спасибо Adam Bambuch.\n+</para>\n+<para lang=\"en\">\n+the \"min_free\" parameter of the \"proxy_cache_path\", \"fastcgi_cache_path\",\n+\"scgi_cache_path\", and \"uwsgi_cache_path\" directives.<br/>\n+Thanks to Adam Bambuch.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не удалял unix domain listen-сокеты\n+при плавном завершении по сигналу SIGQUIT.\n+</para>\n+<para lang=\"en\">\n+nginx did not delete unix domain listen sockets\n+during graceful shutdown on the SIGQUIT signal.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+UDP-пакеты нулевого размера не проксировались.\n+</para>\n+<para lang=\"en\">\n+zero length UDP datagrams were not proxied.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+проксирование на uwsgi-бэкенды с использованием SSL могло не работать.<br/>\n+Спасибо Guanzhong Chen.\n+</para>\n+<para lang=\"en\">\n+proxying to uwsgi backends using SSL might not work.<br/>\n+Thanks to Guanzhong Chen.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в обработке ошибок при использовании директивы ssl_ocsp.\n+</para>\n+<para lang=\"en\">\n+in error handling when using the \"ssl_ocsp\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании файловых систем XFS и NFS\n+размер кэша на диске мог считаться некорректно.\n+</para>\n+<para lang=\"en\">\n+on XFS and NFS file systems\n+disk cache size might be calculated incorrectly.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если сервер memcached возвращал некорректный ответ,\n+в логах могли появляться сообщения \"negative size buf in writer\".\n+</para>\n+<para lang=\"en\">\n+\"negative size buf in writer\" alerts might appear in logs\n+if a memcached server returned a malformed response.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.0\" date=\"2020-05-26\">\n \n <change type=\"feature\">\nDiff:\n@@ -81,12 +81,15 @@ typedef struct {\n     size_t                         length;\n     size_t                         padding;\n \n+    off_t                          rest;\n+\n     ngx_chain_t                   *free;\n     ngx_chain_t                   *busy;\n \n     unsigned                       fastcgi_stdout:1;\n     unsigned                       large_stderr:1;\n     unsigned                       header_sent:1;\n+    unsigned                       closed:1;\n \n     ngx_array_t                   *split_parts;\n \n@@ -2075,13 +2078,31 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_fastcgi_input_filter_init(void *data)\n {\n-    ngx_http_request_t           *r = data;\n+    ngx_http_request_t  *r = data;\n+\n+    ngx_http_upstream_t          *u;\n+    ngx_http_fastcgi_ctx_t       *f;\n     ngx_http_fastcgi_loc_conf_t  *flcf;\n \n+    u = r->upstream;\n+\n+    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);\n     flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);\n \n-    r->upstream->pipe->length = flcf->keep_conn ?\n-                                (off_t) sizeof(ngx_http_fastcgi_header_t) : -1;\n+    u->pipe->length = flcf->keep_conn ?\n+                      (off_t) sizeof(ngx_http_fastcgi_header_t) : -1;\n+\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n+    {\n+        f->rest = 0;\n+\n+    } else if (r->method == NGX_HTTP_HEAD) {\n+        f->rest = -2;\n+\n+    } else {\n+        f->rest = u->headers_in.content_length_n;\n+    }\n \n     return NGX_OK;\n }\n@@ -2106,6 +2127,15 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n     f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);\n     flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);\n \n+    if (p->upstream_done || f->closed) {\n+        r->upstream->keepalive = 0;\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                       \"http fastcgi data after close\");\n+\n+        return NGX_OK;\n+    }\n+\n     b = NULL;\n     prev = &buf->shadow;\n \n@@ -2128,13 +2158,25 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             if (f->type == NGX_HTTP_FASTCGI_STDOUT && f->length == 0) {\n                 f->state = ngx_http_fastcgi_st_padding;\n \n+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                               \"http fastcgi closed stdout\");\n+\n+                if (f->rest > 0) {\n+                    ngx_log_error(NGX_LOG_ERR, p->log, 0,\n+                                  \"upstream prematurely closed \"\n+                                  \"FastCGI stdout\");\n+\n+                    p->upstream_error = 1;\n+                    p->upstream_eof = 0;\n+                    f->closed = 1;\n+\n+                    break;\n+                }\n+\n                 if (!flcf->keep_conn) {\n                     p->upstream_done = 1;\n                 }\n \n-                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n-                               \"http fastcgi closed stdout\");\n-\n                 continue;\n             }\n \n@@ -2143,6 +2185,18 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n                 ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n                                \"http fastcgi sent end request\");\n \n+                if (f->rest > 0) {\n+                    ngx_log_error(NGX_LOG_ERR, p->log, 0,\n+                                  \"upstream prematurely closed \"\n+                                  \"FastCGI request\");\n+\n+                    p->upstream_error = 1;\n+                    p->upstream_eof = 0;\n+                    f->closed = 1;\n+\n+                    break;\n+                }\n+\n                 if (!flcf->keep_conn) {\n                     p->upstream_done = 1;\n                     break;\n@@ -2289,15 +2343,31 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             f->pos += f->length;\n             b->last = f->pos;\n \n-            continue;\n+        } else {\n+            f->length -= f->last - f->pos;\n+            f->pos = f->last;\n+            b->last = f->last;\n         }\n \n-        f->length -= f->last - f->pos;\n+        if (f->rest == -2) {\n+            f->rest = r->upstream->headers_in.content_length_n;\n+        }\n \n-        b->last = f->last;\n+        if (f->rest >= 0) {\n \n-        break;\n+            if (b->last - b->pos > f->rest) {\n+                ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                              \"upstream sent more data than specified in \"\n+                              \"\\\"Content-Length\\\" header\");\n+\n+                b->last = b->pos + f->rest;\n+                p->upstream_done = 1;\n+\n+                break;\n+            }\n \n+            f->rest -= b->last - b->pos;\n+        }\n     }\n \n     if (flcf->keep_conn) {\n@@ -2391,6 +2461,14 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n \n             if (f->type == NGX_HTTP_FASTCGI_END_REQUEST) {\n \n+                if (f->rest > 0) {\n+                    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                  \"upstream prematurely closed \"\n+                                  \"FastCGI request\");\n+                    u->error = 1;\n+                    break;\n+                }\n+\n                 if (f->pos + f->padding < f->last) {\n                     u->length = 0;\n                     break;\n@@ -2510,13 +2588,27 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n             f->pos += f->length;\n             b->last = f->pos;\n \n-            continue;\n+        } else {\n+            f->length -= f->last - f->pos;\n+            f->pos = f->last;\n+            b->last = f->last;\n         }\n \n-        f->length -= f->last - f->pos;\n-        b->last = f->last;\n+        if (f->rest >= 0) {\n+\n+            if (b->last - b->pos > f->rest) {\n+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                              \"upstream sent more data than specified in \"\n+                              \"\\\"Content-Length\\\" header\");\n \n-        break;\n+                b->last = b->pos + f->rest;\n+                u->length = 0;\n+\n+                break;\n+            }\n+\n+            f->rest -= b->last - b->pos;\n+        }\n     }\n \n     return NGX_OK;\nDiff:\n@@ -84,6 +84,8 @@ typedef struct {\n     ngx_uint_t                 pings;\n     ngx_uint_t                 settings;\n \n+    off_t                      length;\n+\n     ssize_t                    send_window;\n     size_t                     recv_window;\n \n@@ -1953,10 +1955,28 @@ ngx_http_grpc_filter_init(void *data)\n     r = ctx->request;\n     u = r->upstream;\n \n-    u->length = 1;\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED\n+        || r->method == NGX_HTTP_HEAD)\n+    {\n+        ctx->length = 0;\n+\n+    } else {\n+        ctx->length = u->headers_in.content_length_n;\n+    }\n \n     if (ctx->end_stream) {\n+\n+        if (ctx->length > 0) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"upstream prematurely closed stream\");\n+            return NGX_ERROR;\n+        }\n+\n         u->length = 0;\n+\n+    } else {\n+        u->length = 1;\n     }\n \n     return NGX_OK;\n@@ -1999,6 +2019,12 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n \n                 if (ctx->done) {\n \n+                    if (ctx->length > 0) {\n+                        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                      \"upstream prematurely closed stream\");\n+                        return NGX_ERROR;\n+                    }\n+\n                     /*\n                      * We have finished parsing the response and the\n                      * remaining control frames.  If there are unsent\n@@ -2052,6 +2078,17 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                     return NGX_ERROR;\n                 }\n \n+                if (ctx->length != -1) {\n+                    if ((off_t) ctx->rest > ctx->length) {\n+                        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                      \"upstream sent response body larger \"\n+                                      \"than indicated content length\");\n+                        return NGX_ERROR;\n+                    }\n+\n+                    ctx->length -= ctx->rest;\n+                }\n+\n                 if (ctx->rest > ctx->recv_window) {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                                   \"upstream violated stream flow control, \"\nDiff:\n@@ -1916,6 +1916,7 @@ ngx_http_upstream_reinit(ngx_http_request_t *r, ngx_http_upstream_t *u)\n \n     u->keepalive = 0;\n     u->upgrade = 0;\n+    u->error = 0;\n \n     ngx_memzero(&u->headers_in, sizeof(ngx_http_upstream_headers_in_t));\n     u->headers_in.content_length_n = -1;\n@@ -3624,7 +3625,7 @@ ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,\n                     return;\n                 }\n \n-                if (upstream->read->error) {\n+                if (upstream->read->error || u->error) {\n                     ngx_http_upstream_finalize_request(r, u,\n                                                        NGX_HTTP_BAD_GATEWAY);\n                     return;\nDiff:\n@@ -391,6 +391,7 @@ struct ngx_http_upstream_s {\n     unsigned                         buffering:1;\n     unsigned                         keepalive:1;\n     unsigned                         upgrade:1;\n+    unsigned                         error:1;\n \n     unsigned                         request_sent:1;\n     unsigned                         request_body_sent:1;\n"
    },
    {
        "commit_sha": "9ad9396aa1cdecaabf6cdb62b7b426dc79da26d6",
        "commit_index": "Commit 32",
        "commit_diff": "Diff:\n@@ -960,6 +960,22 @@ ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (p->upstream_done) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,\n+                       \"input data after close\");\n+        return NGX_OK;\n+    }\n+\n+    if (p->length == 0) {\n+        p->upstream_done = 1;\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        return NGX_OK;\n+    }\n+\n     cl = ngx_chain_get_free_buf(p->pool, &p->free);\n     if (cl == NULL) {\n         return NGX_ERROR;\n@@ -987,6 +1003,18 @@ ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (b->last - b->pos > p->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        b->last = b->pos + p->length;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     p->length -= b->last - b->pos;\n \n     return NGX_OK;\nDiff:\n@@ -49,6 +49,7 @@ static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r);\n static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r);\n+static ngx_int_t ngx_http_scgi_input_filter_init(void *data);\n static void ngx_http_scgi_abort_request(ngx_http_request_t *r);\n static void ngx_http_scgi_finalize_request(ngx_http_request_t *r, ngx_int_t rc);\n \n@@ -534,6 +535,10 @@ ngx_http_scgi_handler(ngx_http_request_t *r)\n     u->pipe->input_filter = ngx_event_pipe_copy_input_filter;\n     u->pipe->input_ctx = r;\n \n+    u->input_filter_init = ngx_http_scgi_input_filter_init;\n+    u->input_filter = ngx_http_upstream_non_buffered_filter;\n+    u->input_filter_ctx = r;\n+\n     if (!scf->upstream.request_buffering\n         && scf->upstream.pass_request_body\n         && !r->headers_in.chunked)\n@@ -1145,6 +1150,37 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_scgi_input_filter_init(void *data)\n+{\n+    ngx_http_request_t   *r = data;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"http scgi filter init s:%ui l:%O\",\n+                   u->headers_in.status_n, u->headers_in.content_length_n);\n+\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n+    {\n+        u->pipe->length = 0;\n+        u->length = 0;\n+\n+    } else if (r->method == NGX_HTTP_HEAD) {\n+        u->pipe->length = -1;\n+        u->length = -1;\n+\n+    } else {\n+        u->pipe->length = u->headers_in.content_length_n;\n+        u->length = u->headers_in.content_length_n;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static void\n ngx_http_scgi_abort_request(ngx_http_request_t *r)\n {\nDiff:\n@@ -67,6 +67,7 @@ static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r);\n static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r);\n+static ngx_int_t ngx_http_uwsgi_input_filter_init(void *data);\n static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r);\n static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r,\n     ngx_int_t rc);\n@@ -703,6 +704,10 @@ ngx_http_uwsgi_handler(ngx_http_request_t *r)\n     u->pipe->input_filter = ngx_event_pipe_copy_input_filter;\n     u->pipe->input_ctx = r;\n \n+    u->input_filter_init = ngx_http_uwsgi_input_filter_init;\n+    u->input_filter = ngx_http_upstream_non_buffered_filter;\n+    u->input_filter_ctx = r;\n+\n     if (!uwcf->upstream.request_buffering\n         && uwcf->upstream.pass_request_body\n         && !r->headers_in.chunked)\n@@ -1356,6 +1361,37 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_uwsgi_input_filter_init(void *data)\n+{\n+    ngx_http_request_t   *r = data;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"http uwsgi filter init s:%ui l:%O\",\n+                   u->headers_in.status_n, u->headers_in.content_length_n);\n+\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n+    {\n+        u->pipe->length = 0;\n+        u->length = 0;\n+\n+    } else if (r->method == NGX_HTTP_HEAD) {\n+        u->pipe->length = -1;\n+        u->length = -1;\n+\n+    } else {\n+        u->pipe->length = u->headers_in.content_length_n;\n+        u->length = u->headers_in.content_length_n;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static void\n ngx_http_uwsgi_abort_request(ngx_http_request_t *r)\n {\nDiff:\n@@ -77,9 +77,6 @@ static void\n static void\n     ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,\n     ngx_uint_t do_write);\n-static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data);\n-static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data,\n-    ssize_t bytes);\n #if (NGX_THREADS)\n static ngx_int_t ngx_http_upstream_thread_handler(ngx_thread_task_t *task,\n     ngx_file_t *file);\n@@ -3705,14 +3702,14 @@ ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,\n }\n \n \n-static ngx_int_t\n+ngx_int_t\n ngx_http_upstream_non_buffered_filter_init(void *data)\n {\n     return NGX_OK;\n }\n \n \n-static ngx_int_t\n+ngx_int_t\n ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)\n {\n     ngx_http_request_t  *r = data;\n@@ -3748,6 +3745,18 @@ ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)\n         return NGX_OK;\n     }\n \n+    if (bytes > u->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        cl->buf->last = cl->buf->pos + u->length;\n+        u->length = 0;\n+\n+        return NGX_OK;\n+    }\n+\n     u->length -= bytes;\n \n     return NGX_OK;\nDiff:\n@@ -414,6 +414,8 @@ typedef struct {\n \n ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r);\n void ngx_http_upstream_init(ngx_http_request_t *r);\n+ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data);\n+ngx_int_t ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes);\n ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf,\n     ngx_url_t *u, ngx_uint_t flags);\n char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n"
    },
    {
        "commit_sha": "2e4a18b8dcfd88a754a9a95dd9fb6c9393d6aafb",
        "commit_index": "Commit 31",
        "commit_diff": "Diff:\n@@ -485,10 +485,11 @@ ngx_http_memcached_filter(void *data, ssize_t bytes)\n \n     if (u->length == (ssize_t) ctx->rest) {\n \n-        if (ngx_strncmp(b->last,\n+        if (bytes > u->length\n+            || ngx_strncmp(b->last,\n                    ngx_http_memcached_end + NGX_HTTP_MEMCACHED_END - ctx->rest,\n                    bytes)\n-            != 0)\n+               != 0)\n         {\n             ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,\n                           \"memcached sent invalid trailer\");\n@@ -540,7 +541,9 @@ ngx_http_memcached_filter(void *data, ssize_t bytes)\n \n     last += (size_t) (u->length - NGX_HTTP_MEMCACHED_END);\n \n-    if (ngx_strncmp(last, ngx_http_memcached_end, b->last - last) != 0) {\n+    if (bytes > u->length\n+        || ngx_strncmp(last, ngx_http_memcached_end, b->last - last) != 0)\n+    {\n         ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,\n                       \"memcached sent invalid trailer\");\n \nDiff:\n@@ -2015,6 +2015,25 @@ ngx_http_proxy_copy_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (p->upstream_done) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                       \"http proxy data after close\");\n+        return NGX_OK;\n+    }\n+\n+    if (p->length == 0) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        r = p->input_ctx;\n+        r->upstream->keepalive = 0;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     cl = ngx_chain_get_free_buf(p->pool, &p->free);\n     if (cl == NULL) {\n         return NGX_ERROR;\n@@ -2042,20 +2061,23 @@ ngx_http_proxy_copy_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (b->last - b->pos > p->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        b->last = b->pos + p->length;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     p->length -= b->last - b->pos;\n \n     if (p->length == 0) {\n         r = p->input_ctx;\n-        p->upstream_done = 1;\n         r->upstream->keepalive = !r->upstream->headers_in.connection_close;\n-\n-    } else if (p->length < 0) {\n-        r = p->input_ctx;\n-        p->upstream_done = 1;\n-\n-        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n-                      \"upstream sent more data than specified in \"\n-                      \"\\\"Content-Length\\\" header\");\n     }\n \n     return NGX_OK;\n@@ -2082,6 +2104,23 @@ ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_ERROR;\n     }\n \n+    if (p->upstream_done) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                       \"http proxy data after close\");\n+        return NGX_OK;\n+    }\n+\n+    if (p->length == 0) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent data after final chunk\");\n+\n+        r->upstream->keepalive = 0;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     b = NULL;\n     prev = &buf->shadow;\n \n@@ -2144,9 +2183,15 @@ ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n \n             /* a whole response has been parsed successfully */\n \n-            p->upstream_done = 1;\n+            p->length = 0;\n             r->upstream->keepalive = !r->upstream->headers_in.connection_close;\n \n+            if (buf->pos != buf->last) {\n+                ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                              \"upstream sent data after final chunk\");\n+                r->upstream->keepalive = 0;\n+            }\n+\n             break;\n         }\n \n@@ -2161,13 +2206,13 @@ ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n \n         /* invalid response */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, p->log, 0,\n                       \"upstream sent invalid chunked response\");\n \n         return NGX_ERROR;\n     }\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, p->log, 0,\n                    \"http proxy chunked state %ui, length %O\",\n                    ctx->chunked.state, p->length);\n \n@@ -2227,6 +2272,18 @@ ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)\n         return NGX_OK;\n     }\n \n+    if (bytes > u->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        cl->buf->last = cl->buf->pos + u->length;\n+        u->length = 0;\n+\n+        return NGX_OK;\n+    }\n+\n     u->length -= bytes;\n \n     if (u->length == 0) {\n@@ -2313,6 +2370,12 @@ ngx_http_proxy_non_buffered_chunked_filter(void *data, ssize_t bytes)\n             u->keepalive = !u->headers_in.connection_close;\n             u->length = 0;\n \n+            if (buf->pos != buf->last) {\n+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                              \"upstream sent data after final chunk\");\n+                u->keepalive = 0;\n+            }\n+\n             break;\n         }\n \nDiff:\n@@ -60,6 +60,8 @@ typedef struct {\n static void ngx_http_v2_read_handler(ngx_event_t *rev);\n static void ngx_http_v2_write_handler(ngx_event_t *wev);\n static void ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c);\n+static void ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c);\n+static void ngx_http_v2_lingering_close_handler(ngx_event_t *rev);\n \n static u_char *ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c,\n     u_char *pos, u_char *end);\n@@ -661,7 +663,7 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n     }\n \n     if (h2c->goaway) {\n-        ngx_http_close_connection(c);\n+        ngx_http_v2_lingering_close(h2c);\n         return;\n     }\n \n@@ -699,6 +701,113 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n }\n \n \n+static void\n+ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n+{\n+    ngx_event_t               *rev, *wev;\n+    ngx_connection_t          *c;\n+    ngx_http_core_loc_conf_t  *clcf;\n+\n+    c = h2c->connection;\n+\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    if (clcf->lingering_close == NGX_HTTP_LINGERING_OFF) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    rev = c->read;\n+    rev->handler = ngx_http_v2_lingering_close_handler;\n+\n+    h2c->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n+    ngx_add_timer(rev, clcf->lingering_timeout);\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    wev = c->write;\n+    wev->handler = ngx_http_empty_handler;\n+\n+    if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {\n+        if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {\n+            ngx_http_close_connection(c);\n+            return;\n+        }\n+    }\n+\n+    if (ngx_shutdown_socket(c->fd, NGX_WRITE_SHUTDOWN) == -1) {\n+        ngx_connection_error(c, ngx_socket_errno,\n+                             ngx_shutdown_socket_n \" failed\");\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    if (rev->ready) {\n+        ngx_http_v2_lingering_close_handler(rev);\n+    }\n+}\n+\n+\n+static void\n+ngx_http_v2_lingering_close_handler(ngx_event_t *rev)\n+{\n+    ssize_t                    n;\n+    ngx_msec_t                 timer;\n+    ngx_connection_t          *c;\n+    ngx_http_core_loc_conf_t  *clcf;\n+    ngx_http_v2_connection_t  *h2c;\n+    u_char                     buffer[NGX_HTTP_LINGERING_BUFFER_SIZE];\n+\n+    c = rev->data;\n+    h2c = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                   \"http2 lingering close handler\");\n+\n+    if (rev->timedout) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    timer = (ngx_msec_t) h2c->lingering_time - (ngx_msec_t) ngx_time();\n+    if ((ngx_msec_int_t) timer <= 0) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    do {\n+        n = c->recv(c, buffer, NGX_HTTP_LINGERING_BUFFER_SIZE);\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, \"lingering read: %z\", n);\n+\n+        if (n == NGX_ERROR || n == 0) {\n+            ngx_http_close_connection(c);\n+            return;\n+        }\n+\n+    } while (rev->ready);\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+    timer *= 1000;\n+\n+    if (timer > clcf->lingering_timeout) {\n+        timer = clcf->lingering_timeout;\n+    }\n+\n+    ngx_add_timer(rev, timer);\n+}\n+\n+\n static u_char *\n ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n@@ -4541,16 +4650,15 @@ ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n     h2c->blocked = 1;\n \n     if (!c->error && !h2c->goaway) {\n+        h2c->goaway = 1;\n+\n         if (ngx_http_v2_send_goaway(h2c, status) != NGX_ERROR) {\n             (void) ngx_http_v2_send_output_queue(h2c);\n         }\n     }\n \n-    c->error = 1;\n-\n     if (!h2c->processing && !h2c->pushing) {\n-        ngx_http_close_connection(c);\n-        return;\n+        goto done;\n     }\n \n     c->read->handler = ngx_http_empty_handler;\n@@ -4598,10 +4706,18 @@ ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n     h2c->blocked = 0;\n \n     if (h2c->processing || h2c->pushing) {\n+        c->error = 1;\n+        return;\n+    }\n+\n+done:\n+\n+    if (c->error) {\n+        ngx_http_close_connection(c);\n         return;\n     }\n \n-    ngx_http_close_connection(c);\n+    ngx_http_v2_lingering_close(h2c);\n }\n \n \nDiff:\n@@ -157,6 +157,8 @@ struct ngx_http_v2_connection_s {\n     ngx_uint_t                       last_sid;\n     ngx_uint_t                       last_push;\n \n+    time_t                           lingering_time;\n+\n     unsigned                         closed_nodes:8;\n     unsigned                         settings_ack:1;\n     unsigned                         table_update:1;\n"
    },
    {
        "commit_sha": "04e7be036b77ccb14f9858867e11cfe8ce51d2a7",
        "commit_index": "Commit 30",
        "commit_diff": "Diff:\n@@ -920,7 +920,8 @@ ngx_int_t\n ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,\n     ngx_int_t depth)\n {\n-    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);\n+    SSL_CTX_set_verify(ssl->ctx, SSL_CTX_get_verify_mode(ssl->ctx),\n+                       ngx_ssl_verify_callback);\n \n     SSL_CTX_set_verify_depth(ssl->ctx, depth);\n \nDiff:\n@@ -1469,14 +1469,14 @@ ngx_http_server_names(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf,\n                                   NGX_HASH_WILDCARD_KEY);\n \n             if (rc == NGX_ERROR) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (rc == NGX_DECLINED) {\n                 ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                               \"invalid server name or wildcard \\\"%V\\\" on %V\",\n                               &name[n].name, &addr->opt.addr_text);\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (rc == NGX_BUSY) {\nDiff:\n@@ -160,6 +160,7 @@ struct ngx_http_file_cache_s {\n \n     ngx_path_t                      *path;\n \n+    off_t                            min_free;\n     off_t                            max_size;\n     size_t                           bsize;\n \nDiff:\n@@ -1959,7 +1959,7 @@ ngx_http_file_cache_manager(void *data)\n {\n     ngx_http_file_cache_t  *cache = data;\n \n-    off_t       size;\n+    off_t       size, free;\n     time_t      wait;\n     ngx_msec_t  elapsed, next;\n     ngx_uint_t  count, watermark;\n@@ -1988,7 +1988,19 @@ ngx_http_file_cache_manager(void *data)\n                        size, count, (ngx_int_t) watermark);\n \n         if (size < cache->max_size && count < watermark) {\n-            break;\n+\n+            if (!cache->min_free) {\n+                break;\n+            }\n+\n+            free = ngx_fs_available(cache->path->name.data);\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,\n+                           \"http file cache free: %O\", free);\n+\n+            if (free > cache->min_free) {\n+                break;\n+            }\n         }\n \n         wait = ngx_http_file_cache_forced_expire(cache);\n@@ -2304,7 +2316,7 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n {\n     char  *confp = conf;\n \n-    off_t                   max_size;\n+    off_t                   max_size, min_free;\n     u_char                 *last, *p;\n     time_t                  inactive;\n     ssize_t                 size;\n@@ -2341,6 +2353,7 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     name.len = 0;\n     size = 0;\n     max_size = NGX_MAX_OFF_T_VALUE;\n+    min_free = 0;\n \n     value = cf->args->elts;\n \n@@ -2476,6 +2489,29 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n             continue;\n         }\n \n+        if (ngx_strncmp(value[i].data, \"min_free=\", 9) == 0) {\n+\n+#if (NGX_WIN32 || NGX_HAVE_STATFS || NGX_HAVE_STATVFS)\n+\n+            s.len = value[i].len - 9;\n+            s.data = value[i].data + 9;\n+\n+            min_free = ngx_parse_offset(&s);\n+            if (min_free < 0) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid min_free value \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+#else\n+            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                               \"min_free is not supported \"\n+                               \"on this platform, ignored\");\n+#endif\n+\n+            continue;\n+        }\n+\n         if (ngx_strncmp(value[i].data, \"loader_files=\", 13) == 0) {\n \n             loader_files = ngx_atoi(value[i].data + 13, value[i].len - 13);\n@@ -2607,6 +2643,7 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cache->inactive = inactive;\n     cache->max_size = max_size;\n+    cache->min_free = min_free;\n \n     caches = (ngx_array_t *) (confp + cmd->offset);\n \nDiff:\n@@ -884,6 +884,19 @@ ngx_fs_bsize(u_char *name)\n     return (size_t) fs.f_bsize;\n }\n \n+\n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    struct statfs  fs;\n+\n+    if (statfs((char *) name, &fs) == -1) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    return (off_t) fs.f_bavail * fs.f_bsize;\n+}\n+\n #elif (NGX_HAVE_STATVFS)\n \n size_t\n@@ -908,6 +921,19 @@ ngx_fs_bsize(u_char *name)\n     return (size_t) fs.f_frsize;\n }\n \n+\n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    struct statvfs  fs;\n+\n+    if (statvfs((char *) name, &fs) == -1) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    return (off_t) fs.f_bavail * fs.f_frsize;\n+}\n+\n #else\n \n size_t\n@@ -916,4 +942,11 @@ ngx_fs_bsize(u_char *name)\n     return 512;\n }\n \n+\n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    return NGX_MAX_OFF_T_VALUE;\n+}\n+\n #endif\nDiff:\n@@ -349,6 +349,7 @@ ngx_int_t ngx_directio_off(ngx_fd_t fd);\n #endif\n \n size_t ngx_fs_bsize(u_char *name);\n+off_t ngx_fs_available(u_char *name);\n \n \n #if (NGX_HAVE_OPENAT)\nDiff:\n@@ -658,6 +658,19 @@ ngx_fs_bsize(u_char *name)\n }\n \n \n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    ULARGE_INTEGER  navail;\n+\n+    if (GetDiskFreeSpaceEx((const char *) name, &navail, NULL, NULL) == 0) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    return (off_t) navail.QuadPart;\n+}\n+\n+\n static ngx_int_t\n ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n {\nDiff:\n@@ -259,6 +259,7 @@ ngx_int_t ngx_directio_off(ngx_fd_t fd);\n #define ngx_directio_off_n          \"ngx_directio_off_n\"\n \n size_t ngx_fs_bsize(u_char *name);\n+off_t ngx_fs_available(u_char *name);\n \n \n #define ngx_stdout               GetStdHandle(STD_OUTPUT_HANDLE)\n"
    },
    {
        "commit_sha": "50817ecf0ea299752c83e60b62b8153715895f14",
        "commit_index": "Commit 29",
        "commit_diff": "Diff:\n@@ -980,6 +980,7 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         if (ocsp->ncert == n - 1 || (ocf->depth == 2 && ocsp->ncert == 1)) {\n             ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                            \"ssl ocsp validated, certs:%ui\", ocsp->ncert);\n+            rc = NGX_OK;\n             goto done;\n         }\n \n@@ -988,7 +989,8 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n \n         ctx = ngx_ssl_ocsp_start(c->log);\n         if (ctx == NULL) {\n-            goto failed;\n+            rc = NGX_ERROR;\n+            goto done;\n         }\n \n         ocsp->ctx = ctx;\n@@ -1012,8 +1014,9 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         ctx->uri = ocf->uri;\n         ctx->port = ocf->port;\n \n-        if (ngx_ssl_ocsp_responder(c, ctx) != NGX_OK) {\n-            goto failed;\n+        rc = ngx_ssl_ocsp_responder(c, ctx);\n+        if (rc != NGX_OK) {\n+            goto done;\n         }\n \n         if (ctx->uri.len == 0) {\n@@ -1025,7 +1028,7 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         rc = ngx_ssl_ocsp_cache_lookup(ctx);\n \n         if (rc == NGX_ERROR) {\n-            goto failed;\n+            goto done;\n         }\n \n         if (rc == NGX_DECLINED) {\n@@ -1051,12 +1054,12 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n \n done:\n \n-    ocsp->status = NGX_OK;\n-    return;\n-\n-failed:\n+    ocsp->status = rc;\n \n-    ocsp->status = NGX_ERROR;\n+    if (c->ssl->in_ocsp) {\n+        c->ssl->handshaked = 1;\n+        c->ssl->handler(c);\n+    }\n }\n \n \n@@ -1073,38 +1076,34 @@ ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n \n     rc = ngx_ssl_ocsp_verify(ctx);\n     if (rc != NGX_OK) {\n-        ocsp->status = rc;\n-        ngx_ssl_ocsp_done(ctx);\n         goto done;\n     }\n \n     rc = ngx_ssl_ocsp_cache_store(ctx);\n     if (rc != NGX_OK) {\n-        ocsp->status = rc;\n-        ngx_ssl_ocsp_done(ctx);\n         goto done;\n     }\n \n     if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n         ocsp->cert_status = ctx->status;\n-        ocsp->status = NGX_OK;\n-        ngx_ssl_ocsp_done(ctx);\n         goto done;\n     }\n \n     ngx_ssl_ocsp_done(ctx);\n \n     ngx_ssl_ocsp_validate_next(c);\n \n-done:\n+    return;\n \n-    if (ocsp->status == NGX_AGAIN || !c->ssl->in_ocsp) {\n-        return;\n-    }\n+done:\n \n-    c->ssl->handshaked = 1;\n+    ocsp->status = rc;\n+    ngx_ssl_ocsp_done(ctx);\n \n-    c->ssl->handler(c);\n+    if (c->ssl->in_ocsp) {\n+        c->ssl->handshaked = 1;\n+        c->ssl->handler(c);\n+    }\n }\n \n \nDiff:\n@@ -875,6 +875,12 @@ ngx_fs_bsize(u_char *name)\n         return 512;\n     }\n \n+#if (NGX_LINUX)\n+    if ((size_t) fs.f_bsize > ngx_pagesize) {\n+        return 512;\n+    }\n+#endif\n+\n     return (size_t) fs.f_bsize;\n }\n \n@@ -893,6 +899,12 @@ ngx_fs_bsize(u_char *name)\n         return 512;\n     }\n \n+#if (NGX_LINUX)\n+    if ((size_t) fs.f_frsize > ngx_pagesize) {\n+        return 512;\n+    }\n+#endif\n+\n     return (size_t) fs.f_frsize;\n }\n \nDiff:\n@@ -185,7 +185,10 @@ ngx_int_t ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s);\n #define ngx_is_exec(sb)          (((sb)->st_mode & S_IXUSR) == S_IXUSR)\n #define ngx_file_access(sb)      ((sb)->st_mode & 0777)\n #define ngx_file_size(sb)        (sb)->st_size\n-#define ngx_file_fs_size(sb)     ngx_max((sb)->st_size, (sb)->st_blocks * 512)\n+#define ngx_file_fs_size(sb)                                                 \\\n+    (((sb)->st_blocks * 512 > (sb)->st_size                                  \\\n+     && (sb)->st_blocks * 512 < (sb)->st_size + 8 * (sb)->st_blksize)        \\\n+     ? (sb)->st_blocks * 512 : (sb)->st_size)\n #define ngx_file_mtime(sb)       (sb)->st_mtime\n #define ngx_file_uniq(sb)        (sb)->st_ino\n \n"
    },
    {
        "commit_sha": "6b628d0042f26c3d3811bcf56417324b8f5f279e",
        "commit_index": "Commit 28",
        "commit_diff": "Diff:\n@@ -1141,6 +1141,7 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n         r->upstream->request_bufs = cl;\n     }\n \n+    b->flush = 1;\n     cl->next = NULL;\n \n     return NGX_OK;\nDiff:\n@@ -189,6 +189,13 @@ ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, ngx_log_t *log)\n         return cl;\n     }\n \n+    /* zero-sized datagram; pretend to have at least 1 iov */\n+    if (n == 0) {\n+        iov = &vec->iovs[n++];\n+        iov->iov_base = NULL;\n+        iov->iov_len = 0;\n+    }\n+\n     vec->count = n;\n     vec->size = total;\n \nDiff:\n@@ -839,7 +839,7 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n         u->upstream_buf.last = p;\n     }\n \n-    if (c->buffer && c->buffer->pos < c->buffer->last) {\n+    if (c->buffer && c->buffer->pos <= c->buffer->last) {\n         ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,\n                        \"stream proxy add preread buffer: %uz\",\n                        c->buffer->last - c->buffer->pos);\n@@ -853,6 +853,7 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n         *cl->buf = *c->buffer;\n \n         cl->buf->tag = (ngx_buf_tag_t) &ngx_stream_proxy_module;\n+        cl->buf->temporary = (cl->buf->pos == cl->buf->last) ? 0 : 1;\n         cl->buf->flush = 1;\n \n         cl->next = u->upstream_out;\nDiff:\n@@ -234,7 +234,8 @@ ngx_stream_write_filter(ngx_stream_session_t *s, ngx_chain_t *in,\n \n     if (size == 0\n         && !(c->buffered & NGX_LOWLEVEL_BUFFERED)\n-        && !(last && c->need_last_buf))\n+        && !(last && c->need_last_buf)\n+        && !(c->type == SOCK_DGRAM && flush))\n     {\n         if (last || flush || sync) {\n             for (cl = *out; cl; /* void */) {\n"
    },
    {
        "commit_sha": "9a0c2c25227f0d7808d9c6fe8e6c4f657b397be1",
        "commit_index": "Commit 27",
        "commit_diff": "Diff:\n@@ -506,6 +506,7 @@ ngx_add_inherited_sockets(ngx_cycle_t *cycle)\n             ngx_memzero(ls, sizeof(ngx_listening_t));\n \n             ls->fd = (ngx_socket_t) s;\n+            ls->inherited = 1;\n         }\n     }\n \nDiff:\n@@ -1070,7 +1070,8 @@ ngx_close_listening_sockets(ngx_cycle_t *cycle)\n \n         if (ls[i].sockaddr->sa_family == AF_UNIX\n             && ngx_process <= NGX_PROCESS_MASTER\n-            && ngx_new_binary == 0)\n+            && ngx_new_binary == 0\n+            && (!ls[i].inherited || ngx_getppid() != ngx_parent))\n         {\n             u_char *name = ls[i].addr_text.data + sizeof(\"unix:\") - 1;\n \nDiff:\n@@ -520,6 +520,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n                     == NGX_OK)\n                 {\n                     nls[n].fd = ls[i].fd;\n+                    nls[n].inherited = ls[i].inherited;\n                     nls[n].previous = &ls[i];\n                     ls[i].remain = 1;\n \nDiff:\n@@ -920,6 +920,8 @@ ngx_int_t\n ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,\n     ngx_int_t depth)\n {\n+    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);\n+\n     SSL_CTX_set_verify_depth(ssl->ctx, depth);\n \n     if (cert->len == 0) {\nDiff:\n@@ -77,12 +77,11 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)\n     u_char            *p;\n     size_t             size;\n     ngx_int_t          i;\n-    ngx_uint_t         n, sigio;\n+    ngx_uint_t         sigio;\n     sigset_t           set;\n     struct itimerval   itv;\n     ngx_uint_t         live;\n     ngx_msec_t         delay;\n-    ngx_listening_t   *ls;\n     ngx_core_conf_t   *ccf;\n \n     sigemptyset(&set);\n@@ -204,16 +203,7 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)\n         if (ngx_quit) {\n             ngx_signal_worker_processes(cycle,\n                                         ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n-\n-            ls = cycle->listening.elts;\n-            for (n = 0; n < cycle->listening.nelts; n++) {\n-                if (ngx_close_socket(ls[n].fd) == -1) {\n-                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n-                                  ngx_close_socket_n \" %V failed\",\n-                                  &ls[n].addr_text);\n-                }\n-            }\n-            cycle->listening.nelts = 0;\n+            ngx_close_listening_sockets(cycle);\n \n             continue;\n         }\n"
    },
    {
        "commit_sha": "aa6e61499dea555a1c5ef425a6bffc1fb407ec12",
        "commit_index": "Commit 26",
        "commit_diff": "Diff:\n@@ -449,3 +449,4 @@ e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n 5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\n c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n+cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\nDiff:\n@@ -141,6 +141,7 @@ syn keyword ngxDirective contained ancient_browser_value\n syn keyword ngxDirective contained api\n syn keyword ngxDirective contained auth_basic\n syn keyword ngxDirective contained auth_basic_user_file\n+syn keyword ngxDirective contained auth_delay\n syn keyword ngxDirective contained auth_http\n syn keyword ngxDirective contained auth_http_header\n syn keyword ngxDirective contained auth_http_pass_client_cert\n@@ -332,6 +333,7 @@ syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n syn keyword ngxDirective contained js_content\n syn keyword ngxDirective contained js_filter\n+syn keyword ngxDirective contained js_import\n syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n@@ -348,6 +350,7 @@ syn keyword ngxDirective contained large_client_header_buffers\n syn keyword ngxDirective contained least_conn\n syn keyword ngxDirective contained least_time\n syn keyword ngxDirective contained limit_conn\n+syn keyword ngxDirective contained limit_conn_dry_run\n syn keyword ngxDirective contained limit_conn_log_level\n syn keyword ngxDirective contained limit_conn_status\n syn keyword ngxDirective contained limit_conn_zone\n@@ -595,6 +598,9 @@ syn keyword ngxDirective contained ssl_early_data\n syn keyword ngxDirective contained ssl_ecdh_curve\n syn keyword ngxDirective contained ssl_engine\n syn keyword ngxDirective contained ssl_handshake_timeout\n+syn keyword ngxDirective contained ssl_ocsp\n+syn keyword ngxDirective contained ssl_ocsp_cache\n+syn keyword ngxDirective contained ssl_ocsp_responder\n syn keyword ngxDirective contained ssl_password_file\n syn keyword ngxDirective contained ssl_prefer_server_ciphers\n syn keyword ngxDirective contained ssl_preread\n@@ -770,6 +776,7 @@ syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n+syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n \n@@ -791,8 +798,8 @@ syn keyword ngxDirectiveThirdParty contained auth_pam_set_pam_env\n \n \" AJP protocol proxy\n \" https://github.com/yaoweibin/nginx_ajp_module\n-syn keyword ngxDirectiveThirdParty contained ajp_buffer_size\n syn keyword ngxDirectiveThirdParty contained ajp_buffers\n+syn keyword ngxDirectiveThirdParty contained ajp_buffer_size\n syn keyword ngxDirectiveThirdParty contained ajp_busy_buffers_size\n syn keyword ngxDirectiveThirdParty contained ajp_cache\n syn keyword ngxDirectiveThirdParty contained ajp_cache_key\n@@ -818,6 +825,7 @@ syn keyword ngxDirectiveThirdParty contained ajp_pass_header\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_body\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_headers\n syn keyword ngxDirectiveThirdParty contained ajp_read_timeout\n+syn keyword ngxDirectiveThirdParty contained ajp_secret\n syn keyword ngxDirectiveThirdParty contained ajp_send_lowat\n syn keyword ngxDirectiveThirdParty contained ajp_send_timeout\n syn keyword ngxDirectiveThirdParty contained ajp_store\n@@ -854,8 +862,8 @@ syn keyword ngxDirectiveThirdParty contained content_handler_property\n syn keyword ngxDirectiveThirdParty contained content_handler_type\n syn keyword ngxDirectiveThirdParty contained handler_code\n syn keyword ngxDirectiveThirdParty contained handler_name\n-syn keyword ngxDirectiveThirdParty contained handler_type\n syn keyword ngxDirectiveThirdParty contained handlers_lazy_init\n+syn keyword ngxDirectiveThirdParty contained handler_type\n syn keyword ngxDirectiveThirdParty contained header_filter_code\n syn keyword ngxDirectiveThirdParty contained header_filter_name\n syn keyword ngxDirectiveThirdParty contained header_filter_property\n@@ -871,6 +879,10 @@ syn keyword ngxDirectiveThirdParty contained jvm_options\n syn keyword ngxDirectiveThirdParty contained jvm_path\n syn keyword ngxDirectiveThirdParty contained jvm_var\n syn keyword ngxDirectiveThirdParty contained jvm_workers\n+syn keyword ngxDirectiveThirdParty contained log_handler_code\n+syn keyword ngxDirectiveThirdParty contained log_handler_name\n+syn keyword ngxDirectiveThirdParty contained log_handler_property\n+syn keyword ngxDirectiveThirdParty contained log_handler_type\n syn keyword ngxDirectiveThirdParty contained max_balanced_tcp_connections\n syn keyword ngxDirectiveThirdParty contained rewrite_handler_code\n syn keyword ngxDirectiveThirdParty contained rewrite_handler_name\n@@ -879,6 +891,7 @@ syn keyword ngxDirectiveThirdParty contained rewrite_handler_type\n syn keyword ngxDirectiveThirdParty contained shared_map\n syn keyword ngxDirectiveThirdParty contained write_page_size\n \n+\n \" Certificate Transparency\n \" https://github.com/grahamedgecombe/nginx-ct\n syn keyword ngxDirectiveThirdParty contained ssl_ct\n@@ -942,6 +955,7 @@ syn keyword ngxDirectiveThirdParty contained fancyindex_hide_symlinks\n syn keyword ngxDirectiveThirdParty contained fancyindex_ignore\n syn keyword ngxDirectiveThirdParty contained fancyindex_localtime\n syn keyword ngxDirectiveThirdParty contained fancyindex_name_length\n+syn keyword ngxDirectiveThirdParty contained fancyindex_show_dotfiles\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_path\n syn keyword ngxDirectiveThirdParty contained fancyindex_time_format\n \n@@ -991,15 +1005,19 @@ syn keyword ngxDirectiveThirdParty contained nchan_benchmark_publisher_distribut\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscriber_distribution\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscribers_per_channel\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_time\n-syn keyword ngxDirectiveThirdParty contained nchan_channel_event_string\n syn keyword ngxDirectiveThirdParty contained nchan_channel_events_channel_id\n+syn keyword ngxDirectiveThirdParty contained nchan_channel_event_string\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group_accounting\n syn keyword ngxDirectiveThirdParty contained nchan_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_channel_id_split_delimiter\n syn keyword ngxDirectiveThirdParty contained nchan_channel_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_deflate_message_for_websocket\n syn keyword ngxDirectiveThirdParty contained nchan_eventsource_event\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_comment\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_data\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_event\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_interval\n syn keyword ngxDirectiveThirdParty contained nchan_group_location\n syn keyword ngxDirectiveThirdParty contained nchan_group_max_channels\n syn keyword ngxDirectiveThirdParty contained nchan_group_max_messages\n@@ -1047,10 +1065,10 @@ syn keyword ngxDirectiveThirdParty contained nchan_store_messages\n syn keyword ngxDirectiveThirdParty contained nchan_stub_status\n syn keyword ngxDirectiveThirdParty contained nchan_sub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_existing_channels_only\n-syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_message_id\n+syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_last_message_id\n@@ -1987,11 +2005,7 @@ syn keyword ngxDirectiveThirdParty contained concat_unique\n \" update upstreams' config by restful interface\n \" https://github.com/yzprofile/ngx_http_dyups_module\n syn keyword ngxDirectiveThirdParty contained dyups_interface\n-syn keyword ngxDirectiveThirdParty contained dyups_read_msg_log\n-syn keyword ngxDirectiveThirdParty contained dyups_read_msg_timeout\n syn keyword ngxDirectiveThirdParty contained dyups_shm_zone_size\n-syn keyword ngxDirectiveThirdParty contained dyups_trylock\n-syn keyword ngxDirectiveThirdParty contained dyups_upstream_conf\n \n \" add given content to the end of the response according to the condition specified\n \" https://github.com/flygoast/ngx_http_footer_if_filter\n@@ -2308,6 +2322,62 @@ syn keyword ngxDirectiveThirdParty contained user_agent\n \" https://github.com/flygoast/ngx_http_upstream_ketama_chash\n syn keyword ngxDirectiveThirdParty contained ketama_chash\n \n+\" nginx-sticky-module-ng\n+\" https://github.com/ayty-adrianomartins/nginx-sticky-module-ng\n+syn keyword ngxDirectiveThirdParty contained sticky_no_fallback\n+\n+\" dynamic linking and call the function of your application\n+\" https://github.com/Taymindis/nginx-link-function\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_prop\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_req_header\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_ca_cert\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_call\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_download_link_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_shm_size\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_subrequest\n+\n+\" purge content from FastCGI, proxy, SCGI and uWSGI caches\n+\" https://github.com/torden/ngx_cache_purge\n+syn keyword ngxDirectiveThirdParty contained cache_purge_response_type\n+\n+\" set the flags \"HttpOnly\", \"secure\" and \"SameSite\" for cookies\n+\" https://github.com/AirisX/nginx_cookie_flag_module\n+syn keyword ngxDirectiveThirdParty contained set_cookie_flag\n+\n+\" Embed websockify into Nginx (convert any tcp connection into websocket)\n+\" https://github.com/tg123/websockify-nginx-module\n+syn keyword ngxDirectiveThirdParty contained websockify_buffer_size\n+syn keyword ngxDirectiveThirdParty contained websockify_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained websockify_pass\n+syn keyword ngxDirectiveThirdParty contained websockify_read_timeout\n+syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n+\n+\" IP2Location Nginx\n+\" https://github.com/ip2location/ip2location-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2location\n+syn keyword ngxDirectiveThirdParty contained ip2location_access_type\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+\n+\" IP2Proxy module for Nginx\n+\" https://github.com/ip2location/ip2proxy-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_access_type\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_as\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_asn\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_city\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_country_long\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_country_short\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_region\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_reverse_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n \n \n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019000\n-#define NGINX_VERSION      \"1.19.0\"\n+#define nginx_version      1019001\n+#define NGINX_VERSION      \"1.19.1\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "93a3cd3507f0214347dee52e3b93bde2dd4256f3",
        "commit_index": "Commit 25",
        "commit_diff": "Diff:\n@@ -5,6 +5,51 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.0\" date=\"2020-05-26\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+проверка клиентских сертификатов с помощью OCSP.\n+</para>\n+<para lang=\"en\">\n+client certificate validation with OCSP.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при работе с gRPC-бэкендами\n+могли возникать ошибки \"upstream sent frame for closed stream\".\n+</para>\n+<para lang=\"en\">\n+\"upstream sent frame for closed stream\" errors might occur\n+when working with gRPC backends.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+OCSP stapling мог не работать,\n+если не была указана директива resolver.\n+</para>\n+<para lang=\"en\">\n+OCSP stapling might not work\n+if the \"resolver\" directive was not specified.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+соединения с некорректным HTTP/2 preface не логгировались.\n+</para>\n+<para lang=\"en\">\n+connections with incorrect HTTP/2 preface were not logged.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.10\" date=\"2020-04-14\">\n \n <change type=\"feature\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1f\n+OPENSSL =\topenssl-1.1.1g\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -731,9 +731,8 @@ ngx_http_v2_state_preface(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {\n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n-                       \"invalid http2 connection preface \\\"%*s\\\"\",\n-                       sizeof(preface) - 1, pos);\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"invalid connection preface\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n     }\n@@ -754,9 +753,8 @@ ngx_http_v2_state_preface_end(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {\n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n-                       \"invalid http2 connection preface \\\"%*s\\\"\",\n-                       sizeof(preface) - 1, pos);\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"invalid connection preface\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n     }\n"
    },
    {
        "commit_sha": "9b8a4286a7f83cb4dedfefb5599f1d7e2502b39a",
        "commit_index": "Commit 24",
        "commit_diff": "Diff:\n@@ -187,12 +187,13 @@ ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,\n ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n-    ngx_uint_t depth);\n+    ngx_uint_t depth, ngx_shm_zone_t *shm_zone);\n ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n+ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n     int key_length);\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\nDiff:\n@@ -52,11 +52,28 @@ typedef struct {\n     in_port_t                    port;\n     ngx_uint_t                   depth;\n \n+    ngx_shm_zone_t              *shm_zone;\n+\n     ngx_resolver_t              *resolver;\n     ngx_msec_t                   resolver_timeout;\n } ngx_ssl_ocsp_conf_t;\n \n \n+typedef struct {\n+    ngx_rbtree_t                 rbtree;\n+    ngx_rbtree_node_t            sentinel;\n+    ngx_queue_t                  expire_queue;\n+} ngx_ssl_ocsp_cache_t;\n+\n+\n+typedef struct {\n+    ngx_str_node_t               node;\n+    ngx_queue_t                  queue;\n+    int                          status;\n+    time_t                       valid;\n+} ngx_ssl_ocsp_cache_node_t;\n+\n+\n typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;\n \n \n@@ -100,10 +117,13 @@ struct ngx_ssl_ocsp_ctx_s {\n     void                       (*handler)(ngx_ssl_ocsp_ctx_t *ctx);\n     void                        *data;\n \n+    ngx_str_t                    key;\n     ngx_buf_t                   *request;\n     ngx_buf_t                   *response;\n     ngx_peer_connection_t        peer;\n \n+    ngx_shm_zone_t              *shm_zone;\n+\n     ngx_int_t                  (*process)(ngx_ssl_ocsp_ctx_t *ctx);\n \n     ngx_uint_t                   state;\n@@ -164,6 +184,10 @@ static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx);\n \n+static ngx_int_t ngx_ssl_ocsp_cache_lookup(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_cache_store(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx);\n+\n static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);\n \n \n@@ -743,7 +767,7 @@ ngx_ssl_stapling_cleanup(void *data)\n \n ngx_int_t\n ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n-    ngx_uint_t depth)\n+    ngx_uint_t depth, ngx_shm_zone_t *shm_zone)\n {\n     ngx_url_t             u;\n     ngx_ssl_ocsp_conf_t  *ocf;\n@@ -754,6 +778,7 @@ ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n     }\n \n     ocf->depth = depth;\n+    ocf->shm_zone = shm_zone;\n \n     if (responder->len) {\n         ngx_memzero(&u, sizeof(ngx_url_t));\n@@ -923,7 +948,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                   \"ssl ocsp validate, certs:%i\", sk_X509_num(ocsp->certs));\n+                   \"ssl ocsp validate, certs:%d\", sk_X509_num(ocsp->certs));\n \n     ngx_ssl_ocsp_validate_next(c);\n \n@@ -939,6 +964,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n static void\n ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n {\n+    ngx_int_t             rc;\n     ngx_uint_t            n;\n     ngx_ssl_ocsp_t       *ocsp;\n     ngx_ssl_ocsp_ctx_t   *ctx;\n@@ -978,6 +1004,8 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         ctx->handler = ngx_ssl_ocsp_handler;\n         ctx->data = c;\n \n+        ctx->shm_zone = ocf->shm_zone;\n+\n         ctx->addrs = ocf->addrs;\n         ctx->naddrs = ocf->naddrs;\n         ctx->host = ocf->host;\n@@ -994,7 +1022,28 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n \n         ocsp->ncert++;\n \n-        break;\n+        rc = ngx_ssl_ocsp_cache_lookup(ctx);\n+\n+        if (rc == NGX_ERROR) {\n+            goto failed;\n+        }\n+\n+        if (rc == NGX_DECLINED) {\n+            break;\n+        }\n+\n+        /* rc == NGX_OK */\n+\n+        if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                           \"ssl ocsp cached status \\\"%s\\\"\",\n+                           OCSP_cert_status_str(ctx->status));\n+            ocsp->cert_status = ctx->status;\n+            goto done;\n+        }\n+\n+        ocsp->ctx = NULL;\n+        ngx_ssl_ocsp_done(ctx);\n     }\n \n     ngx_ssl_ocsp_request(ctx);\n@@ -1029,6 +1078,13 @@ ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n         goto done;\n     }\n \n+    rc = ngx_ssl_ocsp_cache_store(ctx);\n+    if (rc != NGX_OK) {\n+        ocsp->status = rc;\n+        ngx_ssl_ocsp_done(ctx);\n+        goto done;\n+    }\n+\n     if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n         ocsp->cert_status = ctx->status;\n         ocsp->status = NGX_OK;\n@@ -2374,6 +2430,245 @@ ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx)\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n+{\n+    size_t                 len;\n+    ngx_slab_pool_t       *shpool;\n+    ngx_ssl_ocsp_cache_t  *cache;\n+\n+    if (data) {\n+        shm_zone->data = data;\n+        return NGX_OK;\n+    }\n+\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+\n+    if (shm_zone->shm.exists) {\n+        shm_zone->data = shpool->data;\n+        return NGX_OK;\n+    }\n+\n+    cache = ngx_slab_alloc(shpool, sizeof(ngx_ssl_ocsp_cache_t));\n+    if (cache == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    shpool->data = cache;\n+    shm_zone->data = cache;\n+\n+    ngx_rbtree_init(&cache->rbtree, &cache->sentinel,\n+                    ngx_str_rbtree_insert_value);\n+\n+    ngx_queue_init(&cache->expire_queue);\n+\n+    len = sizeof(\" in OCSP cache \\\"\\\"\") + shm_zone->shm.name.len;\n+\n+    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n+    if (shpool->log_ctx == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_sprintf(shpool->log_ctx, \" in OCSP cache \\\"%V\\\"%Z\",\n+                &shm_zone->shm.name);\n+\n+    shpool->log_nomem = 0;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_cache_lookup(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    uint32_t                    hash;\n+    ngx_shm_zone_t             *shm_zone;\n+    ngx_slab_pool_t            *shpool;\n+    ngx_ssl_ocsp_cache_t       *cache;\n+    ngx_ssl_ocsp_cache_node_t  *node;\n+\n+    shm_zone = ctx->shm_zone;\n+\n+    if (shm_zone == NULL) {\n+        return NGX_DECLINED;\n+    }\n+\n+    if (ngx_ssl_ocsp_create_key(ctx) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp cache lookup\");\n+\n+    cache = shm_zone->data;\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    hash = ngx_hash_key(ctx->key.data, ctx->key.len);\n+\n+    ngx_shmtx_lock(&shpool->mutex);\n+\n+    node = (ngx_ssl_ocsp_cache_node_t *)\n+               ngx_str_rbtree_lookup(&cache->rbtree, &ctx->key, hash);\n+\n+    if (node) {\n+        if (node->valid > ngx_time()) {\n+            ctx->status = node->status;\n+            ngx_shmtx_unlock(&shpool->mutex);\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                           \"ssl ocsp cache hit, %s\",\n+                           OCSP_cert_status_str(ctx->status));\n+\n+            return NGX_OK;\n+        }\n+\n+        ngx_queue_remove(&node->queue);\n+        ngx_rbtree_delete(&cache->rbtree, &node->node.node);\n+        ngx_slab_free_locked(shpool, node);\n+\n+        ngx_shmtx_unlock(&shpool->mutex);\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                       \"ssl ocsp cache expired\");\n+\n+        return NGX_DECLINED;\n+    }\n+\n+    ngx_shmtx_unlock(&shpool->mutex);\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp cache miss\");\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_cache_store(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    time_t                      now, valid;\n+    uint32_t                    hash;\n+    ngx_queue_t                *q;\n+    ngx_shm_zone_t             *shm_zone;\n+    ngx_slab_pool_t            *shpool;\n+    ngx_ssl_ocsp_cache_t       *cache;\n+    ngx_ssl_ocsp_cache_node_t  *node;\n+\n+    shm_zone = ctx->shm_zone;\n+\n+    if (shm_zone == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    valid = ctx->valid;\n+\n+    now = ngx_time();\n+\n+    if (valid < now) {\n+        return NGX_OK;\n+    }\n+\n+    if (valid == NGX_MAX_TIME_T_VALUE) {\n+        valid = now + 3600;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp cache store, valid:%T\", valid - now);\n+\n+    cache = shm_zone->data;\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    hash = ngx_hash_key(ctx->key.data, ctx->key.len);\n+\n+    ngx_shmtx_lock(&shpool->mutex);\n+\n+    node = ngx_slab_calloc_locked(shpool,\n+                             sizeof(ngx_ssl_ocsp_cache_node_t) + ctx->key.len);\n+    if (node == NULL) {\n+\n+        if (!ngx_queue_empty(&cache->expire_queue)) {\n+            q = ngx_queue_last(&cache->expire_queue);\n+            node = ngx_queue_data(q, ngx_ssl_ocsp_cache_node_t, queue);\n+\n+            ngx_rbtree_delete(&cache->rbtree, &node->node.node);\n+            ngx_queue_remove(q);\n+            ngx_slab_free_locked(shpool, node);\n+\n+            node = ngx_slab_alloc_locked(shpool,\n+                             sizeof(ngx_ssl_ocsp_cache_node_t) + ctx->key.len);\n+        }\n+\n+        if (node == NULL) {\n+            ngx_shmtx_unlock(&shpool->mutex);\n+            ngx_log_error(NGX_LOG_ALERT, ctx->log, 0,\n+                          \"could not allocate new entry%s\", shpool->log_ctx);\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    node->node.str.len = ctx->key.len;\n+    node->node.str.data = (u_char *) node + sizeof(ngx_ssl_ocsp_cache_node_t);\n+    ngx_memcpy(node->node.str.data, ctx->key.data, ctx->key.len);\n+    node->node.node.key = hash;\n+    node->status = ctx->status;\n+    node->valid = valid;\n+\n+    ngx_rbtree_insert(&cache->rbtree, &node->node.node);\n+    ngx_queue_insert_head(&cache->expire_queue, &node->queue);\n+\n+    ngx_shmtx_unlock(&shpool->mutex);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    u_char        *p;\n+    X509_NAME     *name;\n+    ASN1_INTEGER  *serial;\n+\n+    p = ngx_pnalloc(ctx->pool, 60);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ctx->key.data = p;\n+    ctx->key.len = 60;\n+\n+    name = X509_get_subject_name(ctx->issuer);\n+    if (X509_NAME_digest(name, EVP_sha1(), p, NULL) == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    p += 20;\n+\n+    if (X509_pubkey_digest(ctx->issuer, EVP_sha1(), p, NULL) == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    p += 20;\n+\n+    serial = X509_get_serialNumber(ctx->cert);\n+    if (serial->length > 20) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(p, serial->data, serial->length);\n+    ngx_memzero(p, 20 - serial->length);\n+\n+#if (NGX_DEBUG)\n+    {\n+        u_char  buf[120];\n+\n+        ngx_hex_dump(buf, ctx->key.data, ctx->key.len);\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                       \"ssl ocsp key %*s\", sizeof(buf), buf);\n+    }\n+#endif\n+\n+    return NGX_OK;\n+}\n+\n+\n static u_char *\n ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len)\n {\n@@ -2436,7 +2731,7 @@ ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n \n ngx_int_t\n ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n-    ngx_uint_t depth)\n+    ngx_uint_t depth, ngx_shm_zone_t *shm_zone)\n {\n     ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,\n                   \"\\\"ssl_ocsp\\\" is not supported on this platform\");\n@@ -2473,4 +2768,11 @@ ngx_ssl_ocsp_cleanup(ngx_connection_t *c)\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n+{\n+    return NGX_OK;\n+}\n+\n+\n #endif\nDiff:\n@@ -50,6 +50,8 @@ static char *ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static char *ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n \n static ngx_int_t ngx_http_ssl_init(ngx_conf_t *cf);\n \n@@ -236,6 +238,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, ocsp_responder),\n       NULL },\n \n+    { ngx_string(\"ssl_ocsp_cache\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_http_ssl_ocsp_cache,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n     { ngx_string(\"ssl_stapling\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n       ngx_conf_set_flag_slot,\n@@ -602,6 +611,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->session_tickets = NGX_CONF_UNSET;\n     sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;\n     sscf->ocsp = NGX_CONF_UNSET_UINT;\n+    sscf->ocsp_cache_zone = NGX_CONF_UNSET_PTR;\n     sscf->stapling = NGX_CONF_UNSET;\n     sscf->stapling_verify = NGX_CONF_UNSET;\n \n@@ -667,6 +677,8 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_uint_value(conf->ocsp, prev->ocsp, 0);\n     ngx_conf_merge_str_value(conf->ocsp_responder, prev->ocsp_responder, \"\");\n+    ngx_conf_merge_ptr_value(conf->ocsp_cache_zone,\n+                         prev->ocsp_cache_zone, NULL);\n \n     ngx_conf_merge_value(conf->stapling, prev->stapling, 0);\n     ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);\n@@ -838,7 +850,8 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n             return NGX_CONF_ERROR;\n         }\n \n-        if (ngx_ssl_ocsp(cf, &conf->ssl, &conf->ocsp_responder, conf->ocsp)\n+        if (ngx_ssl_ocsp(cf, &conf->ssl, &conf->ocsp_responder, conf->ocsp,\n+                         conf->ocsp_cache_zone)\n             != NGX_OK)\n         {\n             return NGX_CONF_ERROR;\n@@ -1143,6 +1156,85 @@ ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_http_ssl_srv_conf_t *sscf = conf;\n+\n+    size_t       len;\n+    ngx_int_t    n;\n+    ngx_str_t   *value, name, size;\n+    ngx_uint_t   j;\n+\n+    if (sscf->ocsp_cache_zone != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+        sscf->ocsp_cache_zone = NULL;\n+        return NGX_CONF_OK;\n+    }\n+\n+    if (value[1].len <= sizeof(\"shared:\") - 1\n+        || ngx_strncmp(value[1].data, \"shared:\", sizeof(\"shared:\") - 1) != 0)\n+    {\n+        goto invalid;\n+    }\n+\n+    len = 0;\n+\n+    for (j = sizeof(\"shared:\") - 1; j < value[1].len; j++) {\n+        if (value[1].data[j] == ':') {\n+            break;\n+        }\n+\n+        len++;\n+    }\n+\n+    if (len == 0) {\n+        goto invalid;\n+    }\n+\n+    name.len = len;\n+    name.data = value[1].data + sizeof(\"shared:\") - 1;\n+\n+    size.len = value[1].len - j - 1;\n+    size.data = name.data + len + 1;\n+\n+    n = ngx_parse_size(&size);\n+\n+    if (n == NGX_ERROR) {\n+        goto invalid;\n+    }\n+\n+    if (n < (ngx_int_t) (8 * ngx_pagesize)) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"OCSP cache \\\"%V\\\" is too small\", &value[1]);\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    sscf->ocsp_cache_zone = ngx_shared_memory_add(cf, &name, n,\n+                                                  &ngx_http_ssl_module_ctx);\n+    if (sscf->ocsp_cache_zone == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    sscf->ocsp_cache_zone->init = ngx_ssl_ocsp_cache_init;\n+\n+    return NGX_CONF_OK;\n+\n+invalid:\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"invalid OCSP cache \\\"%V\\\"\", &value[1]);\n+\n+    return NGX_CONF_ERROR;\n+}\n+\n+\n static ngx_int_t\n ngx_http_ssl_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -56,6 +56,7 @@ typedef struct {\n \n     ngx_uint_t                      ocsp;\n     ngx_str_t                       ocsp_responder;\n+    ngx_shm_zone_t                 *ocsp_cache_zone;\n \n     ngx_flag_t                      stapling;\n     ngx_flag_t                      stapling_verify;\n"
    },
    {
        "commit_sha": "0bd3cef32811ce5ccaf3125842bd70bb534b6784",
        "commit_index": "Commit 23",
        "commit_diff": "Diff:\n@@ -130,6 +130,7 @@ int  ngx_ssl_connection_index;\n int  ngx_ssl_server_conf_index;\n int  ngx_ssl_session_cache_index;\n int  ngx_ssl_session_ticket_keys_index;\n+int  ngx_ssl_ocsp_index;\n int  ngx_ssl_certificate_index;\n int  ngx_ssl_next_certificate_index;\n int  ngx_ssl_certificate_name_index;\n@@ -213,6 +214,13 @@ ngx_ssl_init(ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n+    ngx_ssl_ocsp_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n+    if (ngx_ssl_ocsp_index == -1) {\n+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,\n+                      \"SSL_CTX_get_ex_new_index() failed\");\n+        return NGX_ERROR;\n+    }\n+\n     ngx_ssl_certificate_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,\n                                                          NULL);\n     if (ngx_ssl_certificate_index == -1) {\n@@ -1594,13 +1602,18 @@ ngx_ssl_handshake(ngx_connection_t *c)\n {\n     int        n, sslerr;\n     ngx_err_t  err;\n+    ngx_int_t  rc;\n \n #ifdef SSL_READ_EARLY_DATA_SUCCESS\n     if (c->ssl->try_early_data) {\n         return ngx_ssl_try_early_data(c);\n     }\n #endif\n \n+    if (c->ssl->in_ocsp) {\n+        return ngx_ssl_ocsp_validate(c);\n+    }\n+\n     ngx_ssl_clear_error(c->log);\n \n     n = SSL_do_handshake(c->ssl->connection);\n@@ -1621,8 +1634,6 @@ ngx_ssl_handshake(ngx_connection_t *c)\n         ngx_ssl_handshake_log(c);\n #endif\n \n-        c->ssl->handshaked = 1;\n-\n         c->recv = ngx_ssl_recv;\n         c->send = ngx_ssl_write;\n         c->recv_chain = ngx_ssl_recv_chain;\n@@ -1641,6 +1652,20 @@ ngx_ssl_handshake(ngx_connection_t *c)\n #endif\n #endif\n \n+        rc = ngx_ssl_ocsp_validate(c);\n+\n+        if (rc == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->read->handler = ngx_ssl_handshake_handler;\n+            c->write->handler = ngx_ssl_handshake_handler;\n+            return NGX_AGAIN;\n+        }\n+\n+        c->ssl->handshaked = 1;\n+\n         return NGX_OK;\n     }\n \n@@ -1710,6 +1735,7 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n     u_char     buf;\n     size_t     readbytes;\n     ngx_err_t  err;\n+    ngx_int_t  rc;\n \n     ngx_ssl_clear_error(c->log);\n \n@@ -1744,14 +1770,27 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->ssl->early_buf = buf;\n         c->ssl->early_preread = 1;\n \n-        c->ssl->handshaked = 1;\n         c->ssl->in_early = 1;\n \n         c->recv = ngx_ssl_recv;\n         c->send = ngx_ssl_write;\n         c->recv_chain = ngx_ssl_recv_chain;\n         c->send_chain = ngx_ssl_send_chain;\n \n+        rc = ngx_ssl_ocsp_validate(c);\n+\n+        if (rc == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->read->handler = ngx_ssl_handshake_handler;\n+            c->write->handler = ngx_ssl_handshake_handler;\n+            return NGX_AGAIN;\n+        }\n+\n+        c->ssl->handshaked = 1;\n+\n         return NGX_OK;\n     }\n \n@@ -2735,6 +2774,8 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n     int        n, sslerr, mode;\n     ngx_err_t  err;\n \n+    ngx_ssl_ocsp_cleanup(c);\n+\n     if (SSL_in_init(c->ssl->connection)) {\n         /*\n          * OpenSSL 1.0.2f complains if SSL_shutdown() is called during\n@@ -4894,11 +4935,14 @@ ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n     rc = SSL_get_verify_result(c->ssl->connection);\n \n     if (rc == X509_V_OK) {\n-        ngx_str_set(s, \"SUCCESS\");\n-        return NGX_OK;\n-    }\n+        if (ngx_ssl_ocsp_get_status(c, &str) == NGX_OK) {\n+            ngx_str_set(s, \"SUCCESS\");\n+            return NGX_OK;\n+        }\n \n-    str = X509_verify_cert_error_string(rc);\n+    } else {\n+        str = X509_verify_cert_error_string(rc);\n+    }\n \n     s->data = ngx_pnalloc(pool, sizeof(\"FAILED:\") - 1 + ngx_strlen(str));\n     if (s->data == NULL) {\nDiff:\n@@ -64,6 +64,9 @@\n #endif\n \n \n+typedef struct ngx_ssl_ocsp_s  ngx_ssl_ocsp_t;\n+\n+\n struct ngx_ssl_s {\n     SSL_CTX                    *ctx;\n     ngx_log_t                  *log;\n@@ -87,6 +90,8 @@ struct ngx_ssl_connection_s {\n     ngx_event_handler_pt        saved_read_handler;\n     ngx_event_handler_pt        saved_write_handler;\n \n+    ngx_ssl_ocsp_t             *ocsp;\n+\n     u_char                      early_buf;\n \n     unsigned                    handshaked:1;\n@@ -97,6 +102,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    handshake_buffer_set:1;\n     unsigned                    try_early_data:1;\n     unsigned                    in_early:1;\n+    unsigned                    in_ocsp:1;\n     unsigned                    early_preread:1;\n     unsigned                    write_blocked:1;\n };\n@@ -180,6 +186,13 @@ ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);\n ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n+ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n+    ngx_uint_t depth);\n+ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n+ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n+ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n+void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n     int key_length);\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\n@@ -281,6 +294,7 @@ extern int  ngx_ssl_connection_index;\n extern int  ngx_ssl_server_conf_index;\n extern int  ngx_ssl_session_cache_index;\n extern int  ngx_ssl_session_ticket_keys_index;\n+extern int  ngx_ssl_ocsp_index;\n extern int  ngx_ssl_certificate_index;\n extern int  ngx_ssl_next_certificate_index;\n extern int  ngx_ssl_certificate_name_index;\nDiff:\n@@ -43,8 +43,35 @@ typedef struct {\n } ngx_ssl_stapling_t;\n \n \n+typedef struct {\n+    ngx_addr_t                  *addrs;\n+    ngx_uint_t                   naddrs;\n+\n+    ngx_str_t                    host;\n+    ngx_str_t                    uri;\n+    in_port_t                    port;\n+    ngx_uint_t                   depth;\n+\n+    ngx_resolver_t              *resolver;\n+    ngx_msec_t                   resolver_timeout;\n+} ngx_ssl_ocsp_conf_t;\n+\n+\n typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;\n \n+\n+struct ngx_ssl_ocsp_s {\n+    STACK_OF(X509)              *certs;\n+    ngx_uint_t                   ncert;\n+\n+    int                          cert_status;\n+    ngx_int_t                    status;\n+\n+    ngx_ssl_ocsp_conf_t         *conf;\n+    ngx_ssl_ocsp_ctx_t          *ctx;\n+};\n+\n+\n struct ngx_ssl_ocsp_ctx_s {\n     SSL_CTX                     *ssl_ctx;\n \n@@ -114,7 +141,12 @@ static time_t ngx_ssl_stapling_time(ASN1_GENERALIZEDTIME *asn1time);\n \n static void ngx_ssl_stapling_cleanup(void *data);\n \n-static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);\n+static void ngx_ssl_ocsp_validate_next(ngx_connection_t *c);\n+static void ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_responder(ngx_connection_t *c,\n+    ngx_ssl_ocsp_ctx_t *ctx);\n+\n+static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(ngx_log_t *log);\n static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);\n@@ -570,7 +602,7 @@ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)\n \n     staple->loading = 1;\n \n-    ctx = ngx_ssl_ocsp_start();\n+    ctx = ngx_ssl_ocsp_start(ngx_cycle->log);\n     if (ctx == NULL) {\n         return;\n     }\n@@ -709,14 +741,467 @@ ngx_ssl_stapling_cleanup(void *data)\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n+    ngx_uint_t depth)\n+{\n+    ngx_url_t             u;\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    ocf = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_ocsp_conf_t));\n+    if (ocf == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ocf->depth = depth;\n+\n+    if (responder->len) {\n+        ngx_memzero(&u, sizeof(ngx_url_t));\n+\n+        u.url = *responder;\n+        u.default_port = 80;\n+        u.uri_part = 1;\n+\n+        if (u.url.len > 7\n+            && ngx_strncasecmp(u.url.data, (u_char *) \"http://\", 7) == 0)\n+        {\n+            u.url.len -= 7;\n+            u.url.data += 7;\n+\n+        } else {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                          \"invalid URL prefix in OCSP responder \\\"%V\\\" \"\n+                          \"in \\\"ssl_ocsp_responder\\\"\", &u.url);\n+            return NGX_ERROR;\n+        }\n+\n+        if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n+            if (u.err) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"%s in OCSP responder \\\"%V\\\" \"\n+                              \"in \\\"ssl_ocsp_responder\\\"\", u.err, &u.url);\n+            }\n+\n+            return NGX_ERROR;\n+        }\n+\n+        ocf->addrs = u.addrs;\n+        ocf->naddrs = u.naddrs;\n+        ocf->host = u.host;\n+        ocf->uri = u.uri;\n+        ocf->port = u.port;\n+    }\n+\n+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_ocsp_index, ocf) == 0) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set_ex_data() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)\n+{\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    ocf = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_ocsp_index);\n+    ocf->resolver = resolver;\n+    ocf->resolver_timeout = resolver_timeout;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_validate(ngx_connection_t *c)\n+{\n+    X509                 *cert;\n+    SSL_CTX              *ssl_ctx;\n+    ngx_int_t             rc;\n+    X509_STORE           *store;\n+    X509_STORE_CTX       *store_ctx;\n+    STACK_OF(X509)       *chain;\n+    ngx_ssl_ocsp_t       *ocsp;\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    if (c->ssl->in_ocsp) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    ssl_ctx = SSL_get_SSL_CTX(c->ssl->connection);\n+\n+    ocf = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_ocsp_index);\n+    if (ocf == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (SSL_get_verify_result(c->ssl->connection) != X509_V_OK) {\n+        return NGX_OK;\n+    }\n+\n+    cert = SSL_get_peer_certificate(c->ssl->connection);\n+    if (cert == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    ocsp = ngx_pcalloc(c->pool, sizeof(ngx_ssl_ocsp_t));\n+    if (ocsp == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    c->ssl->ocsp = ocsp;\n+\n+    ocsp->status = NGX_AGAIN;\n+    ocsp->cert_status = V_OCSP_CERTSTATUS_GOOD;\n+    ocsp->conf = ocf;\n+\n+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined LIBRESSL_VERSION_NUMBER)\n+\n+    ocsp->certs = SSL_get0_verified_chain(c->ssl->connection);\n+\n+    if (ocsp->certs) {\n+        ocsp->certs = X509_chain_up_ref(ocsp->certs);\n+        if (ocsp->certs == NULL) {\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+#endif\n+\n+    if (ocsp->certs == NULL) {\n+        store = SSL_CTX_get_cert_store(ssl_ctx);\n+        if (store == NULL) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"SSL_CTX_get_cert_store() failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        store_ctx = X509_STORE_CTX_new();\n+        if (store_ctx == NULL) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"X509_STORE_CTX_new() failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        chain = SSL_get_peer_cert_chain(c->ssl->connection);\n+\n+        if (X509_STORE_CTX_init(store_ctx, store, cert, chain) == 0) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"X509_STORE_CTX_init() failed\");\n+            X509_STORE_CTX_free(store_ctx);\n+            return NGX_ERROR;\n+        }\n+\n+        rc = X509_verify_cert(store_ctx);\n+        if (rc <= 0) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0, \"X509_verify_cert() failed\");\n+            X509_STORE_CTX_free(store_ctx);\n+            return NGX_ERROR;\n+        }\n+\n+        ocsp->certs = X509_STORE_CTX_get1_chain(store_ctx);\n+        if (ocsp->certs == NULL) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"X509_STORE_CTX_get1_chain() failed\");\n+            X509_STORE_CTX_free(store_ctx);\n+            return NGX_ERROR;\n+        }\n+\n+        X509_STORE_CTX_free(store_ctx);\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"ssl ocsp validate, certs:%i\", sk_X509_num(ocsp->certs));\n+\n+    ngx_ssl_ocsp_validate_next(c);\n+\n+    if (ocsp->status == NGX_AGAIN) {\n+        c->ssl->in_ocsp = 1;\n+        return NGX_AGAIN;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void\n+ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n+{\n+    ngx_uint_t            n;\n+    ngx_ssl_ocsp_t       *ocsp;\n+    ngx_ssl_ocsp_ctx_t   *ctx;\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    ocsp = c->ssl->ocsp;\n+    ocf = ocsp->conf;\n+\n+    n = sk_X509_num(ocsp->certs);\n+\n+    for ( ;; ) {\n+\n+        if (ocsp->ncert == n - 1 || (ocf->depth == 2 && ocsp->ncert == 1)) {\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"ssl ocsp validated, certs:%ui\", ocsp->ncert);\n+            goto done;\n+        }\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"ssl ocsp validate cert:%ui\", ocsp->ncert);\n+\n+        ctx = ngx_ssl_ocsp_start(c->log);\n+        if (ctx == NULL) {\n+            goto failed;\n+        }\n+\n+        ocsp->ctx = ctx;\n+\n+        ctx->ssl_ctx = SSL_get_SSL_CTX(c->ssl->connection);\n+        ctx->cert = sk_X509_value(ocsp->certs, ocsp->ncert);\n+        ctx->issuer = sk_X509_value(ocsp->certs, ocsp->ncert + 1);\n+        ctx->chain = ocsp->certs;\n+\n+        ctx->resolver = ocf->resolver;\n+        ctx->resolver_timeout = ocf->resolver_timeout;\n+\n+        ctx->handler = ngx_ssl_ocsp_handler;\n+        ctx->data = c;\n+\n+        ctx->addrs = ocf->addrs;\n+        ctx->naddrs = ocf->naddrs;\n+        ctx->host = ocf->host;\n+        ctx->uri = ocf->uri;\n+        ctx->port = ocf->port;\n+\n+        if (ngx_ssl_ocsp_responder(c, ctx) != NGX_OK) {\n+            goto failed;\n+        }\n+\n+        if (ctx->uri.len == 0) {\n+            ngx_str_set(&ctx->uri, \"/\");\n+        }\n+\n+        ocsp->ncert++;\n+\n+        break;\n+    }\n+\n+    ngx_ssl_ocsp_request(ctx);\n+    return;\n+\n+done:\n+\n+    ocsp->status = NGX_OK;\n+    return;\n+\n+failed:\n+\n+    ocsp->status = NGX_ERROR;\n+}\n+\n+\n+static void\n+ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    ngx_int_t          rc;\n+    ngx_ssl_ocsp_t    *ocsp;\n+    ngx_connection_t  *c;\n+\n+    c = ctx->data;\n+    ocsp = c->ssl->ocsp;\n+    ocsp->ctx = NULL;\n+\n+    rc = ngx_ssl_ocsp_verify(ctx);\n+    if (rc != NGX_OK) {\n+        ocsp->status = rc;\n+        ngx_ssl_ocsp_done(ctx);\n+        goto done;\n+    }\n+\n+    if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n+        ocsp->cert_status = ctx->status;\n+        ocsp->status = NGX_OK;\n+        ngx_ssl_ocsp_done(ctx);\n+        goto done;\n+    }\n+\n+    ngx_ssl_ocsp_done(ctx);\n+\n+    ngx_ssl_ocsp_validate_next(c);\n+\n+done:\n+\n+    if (ocsp->status == NGX_AGAIN || !c->ssl->in_ocsp) {\n+        return;\n+    }\n+\n+    c->ssl->handshaked = 1;\n+\n+    c->ssl->handler(c);\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_responder(ngx_connection_t *c, ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    char                      *s;\n+    ngx_str_t                  responder;\n+    ngx_url_t                  u;\n+    STACK_OF(OPENSSL_STRING)  *aia;\n+\n+    if (ctx->host.len) {\n+        return NGX_OK;\n+    }\n+\n+    /* extract OCSP responder URL from certificate */\n+\n+    aia = X509_get1_ocsp(ctx->cert);\n+    if (aia == NULL) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"no OCSP responder URL in certificate\");\n+        return NGX_ERROR;\n+    }\n+\n+#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n+    s = sk_OPENSSL_STRING_value(aia, 0);\n+#else\n+    s = sk_value(aia, 0);\n+#endif\n+    if (s == NULL) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"no OCSP responder URL in certificate\");\n+        X509_email_free(aia);\n+        return NGX_ERROR;\n+    }\n+\n+    responder.len = ngx_strlen(s);\n+    responder.data = ngx_palloc(ctx->pool, responder.len);\n+    if (responder.data == NULL) {\n+        X509_email_free(aia);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(responder.data, s, responder.len);\n+    X509_email_free(aia);\n+\n+    ngx_memzero(&u, sizeof(ngx_url_t));\n+\n+    u.url = responder;\n+    u.default_port = 80;\n+    u.uri_part = 1;\n+    u.no_resolve = 1;\n+\n+    if (u.url.len > 7\n+        && ngx_strncasecmp(u.url.data, (u_char *) \"http://\", 7) == 0)\n+    {\n+        u.url.len -= 7;\n+        u.url.data += 7;\n+\n+    } else {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"invalid URL prefix in OCSP responder \\\"%V\\\" \"\n+                      \"in certificate\", &u.url);\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_parse_url(ctx->pool, &u) != NGX_OK) {\n+        if (u.err) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                          \"%s in OCSP responder \\\"%V\\\" in certificate\",\n+                          u.err, &u.url);\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    if (u.host.len == 0) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"empty host in OCSP responder in certificate\");\n+        return NGX_ERROR;\n+    }\n+\n+    ctx->addrs = u.addrs;\n+    ctx->naddrs = u.naddrs;\n+    ctx->host = u.host;\n+    ctx->uri = u.uri;\n+    ctx->port = u.port;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)\n+{\n+    ngx_ssl_ocsp_t  *ocsp;\n+\n+    ocsp = c->ssl->ocsp;\n+    if (ocsp == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (ocsp->status == NGX_ERROR) {\n+        *s = \"certificate status request failed\";\n+        return NGX_DECLINED;\n+    }\n+\n+    switch (ocsp->cert_status) {\n+\n+    case V_OCSP_CERTSTATUS_GOOD:\n+        return NGX_OK;\n+\n+    case V_OCSP_CERTSTATUS_REVOKED:\n+        *s = \"certificate revoked\";\n+        break;\n+\n+    default: /* V_OCSP_CERTSTATUS_UNKNOWN */\n+        *s = \"certificate status unknown\";\n+    }\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+void\n+ngx_ssl_ocsp_cleanup(ngx_connection_t *c)\n+{\n+    ngx_ssl_ocsp_t  *ocsp;\n+\n+    ocsp = c->ssl->ocsp;\n+    if (ocsp == NULL) {\n+        return;\n+    }\n+\n+    if (ocsp->ctx) {\n+        ngx_ssl_ocsp_done(ocsp->ctx);\n+        ocsp->ctx = NULL;\n+    }\n+\n+    if (ocsp->certs) {\n+        sk_X509_pop_free(ocsp->certs, X509_free);\n+        ocsp->certs = NULL;\n+    }\n+}\n+\n+\n static ngx_ssl_ocsp_ctx_t *\n-ngx_ssl_ocsp_start(void)\n+ngx_ssl_ocsp_start(ngx_log_t *log)\n {\n-    ngx_log_t           *log;\n     ngx_pool_t          *pool;\n     ngx_ssl_ocsp_ctx_t  *ctx;\n \n-    pool = ngx_create_pool(2048, ngx_cycle->log);\n+    pool = ngx_create_pool(2048, log);\n     if (pool == NULL) {\n         return NULL;\n     }\n@@ -828,6 +1313,14 @@ ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx)\n         }\n \n         if (resolve == NGX_NO_RESOLVER) {\n+            if (ctx->naddrs == 0) {\n+                ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                              \"no resolver defined to resolve %V\", &ctx->host);\n+\n+                ngx_ssl_ocsp_error(ctx);\n+                return;\n+            }\n+\n             ngx_log_error(NGX_LOG_WARN, ctx->log, 0,\n                           \"no resolver defined to resolve %V\", &ctx->host);\n             goto connect;\n@@ -979,8 +1472,10 @@ ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)\n \n     ctx->process = ngx_ssl_ocsp_process_status_line;\n \n-    ngx_add_timer(ctx->peer.connection->read, ctx->timeout);\n-    ngx_add_timer(ctx->peer.connection->write, ctx->timeout);\n+    if (ctx->timeout) {\n+        ngx_add_timer(ctx->peer.connection->read, ctx->timeout);\n+        ngx_add_timer(ctx->peer.connection->write, ctx->timeout);\n+    }\n \n     if (rc == NGX_OK) {\n         ngx_ssl_ocsp_write_handler(ctx->peer.connection->write);\n@@ -1036,7 +1531,7 @@ ngx_ssl_ocsp_write_handler(ngx_event_t *wev)\n         }\n     }\n \n-    if (!wev->timer_set) {\n+    if (!wev->timer_set && ctx->timeout) {\n         ngx_add_timer(wev, ctx->timeout);\n     }\n }\n@@ -1939,4 +2434,43 @@ ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n+    ngx_uint_t depth)\n+{\n+    ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,\n+                  \"\\\"ssl_ocsp\\\" is not supported on this platform\");\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_validate(ngx_connection_t *c)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_ssl_ocsp_cleanup(ngx_connection_t *c)\n+{\n+}\n+\n+\n #endif\nDiff:\n@@ -74,6 +74,14 @@ static ngx_conf_enum_t  ngx_http_ssl_verify[] = {\n };\n \n \n+static ngx_conf_enum_t  ngx_http_ssl_ocsp[] = {\n+    { ngx_string(\"off\"), 0 },\n+    { ngx_string(\"on\"), 1 },\n+    { ngx_string(\"leaf\"), 2 },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n static ngx_conf_deprecated_t  ngx_http_ssl_deprecated = {\n     ngx_conf_deprecated, \"ssl\", \"listen ... ssl\"\n };\n@@ -214,6 +222,20 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, crl),\n       NULL },\n \n+    { ngx_string(\"ssl_ocsp\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_enum_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, ocsp),\n+      &ngx_http_ssl_ocsp },\n+\n+    { ngx_string(\"ssl_ocsp_responder\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, ocsp_responder),\n+      NULL },\n+\n     { ngx_string(\"ssl_stapling\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n       ngx_conf_set_flag_slot,\n@@ -561,6 +583,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n      *     sscf->crl = { 0, NULL };\n      *     sscf->ciphers = { 0, NULL };\n      *     sscf->shm_zone = NULL;\n+     *     sscf->ocsp_responder = { 0, NULL };\n      *     sscf->stapling_file = { 0, NULL };\n      *     sscf->stapling_responder = { 0, NULL };\n      */\n@@ -578,6 +601,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->session_timeout = NGX_CONF_UNSET;\n     sscf->session_tickets = NGX_CONF_UNSET;\n     sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;\n+    sscf->ocsp = NGX_CONF_UNSET_UINT;\n     sscf->stapling = NGX_CONF_UNSET;\n     sscf->stapling_verify = NGX_CONF_UNSET;\n \n@@ -641,6 +665,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_uint_value(conf->ocsp, prev->ocsp, 0);\n+    ngx_conf_merge_str_value(conf->ocsp_responder, prev->ocsp_responder, \"\");\n+\n     ngx_conf_merge_value(conf->stapling, prev->stapling, 0);\n     ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);\n     ngx_conf_merge_str_value(conf->stapling_file, prev->stapling_file, \"\");\n@@ -802,6 +829,22 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (conf->ocsp) {\n+\n+        if (conf->verify == 3) {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                          \"\\\"ssl_ocsp\\\" is incompatible with \"\n+                          \"\\\"ssl_verify_client optional_no_ca\\\"\");\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        if (ngx_ssl_ocsp(cf, &conf->ssl, &conf->ocsp_responder, conf->ocsp)\n+            != NGX_OK)\n+        {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n     if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -1118,17 +1161,28 @@ ngx_http_ssl_init(ngx_conf_t *cf)\n \n         sscf = cscfp[s]->ctx->srv_conf[ngx_http_ssl_module.ctx_index];\n \n-        if (sscf->ssl.ctx == NULL || !sscf->stapling) {\n+        if (sscf->ssl.ctx == NULL) {\n             continue;\n         }\n \n         clcf = cscfp[s]->ctx->loc_conf[ngx_http_core_module.ctx_index];\n \n-        if (ngx_ssl_stapling_resolver(cf, &sscf->ssl, clcf->resolver,\n+        if (sscf->stapling) {\n+            if (ngx_ssl_stapling_resolver(cf, &sscf->ssl, clcf->resolver,\n+                                          clcf->resolver_timeout)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        if (sscf->ocsp) {\n+            if (ngx_ssl_ocsp_resolver(cf, &sscf->ssl, clcf->resolver,\n                                       clcf->resolver_timeout)\n-            != NGX_OK)\n-        {\n-            return NGX_ERROR;\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -54,6 +54,9 @@ typedef struct {\n     ngx_flag_t                      session_tickets;\n     ngx_array_t                    *session_ticket_keys;\n \n+    ngx_uint_t                      ocsp;\n+    ngx_str_t                       ocsp_responder;\n+\n     ngx_flag_t                      stapling;\n     ngx_flag_t                      stapling_verify;\n     ngx_str_t                       stapling_file;\nDiff:\n@@ -1993,6 +1993,7 @@ ngx_http_process_request(ngx_http_request_t *r)\n     if (r->http_connection->ssl) {\n         long                      rc;\n         X509                     *cert;\n+        const char               *s;\n         ngx_http_ssl_srv_conf_t  *sscf;\n \n         if (c->ssl == NULL) {\n@@ -2037,6 +2038,17 @@ ngx_http_process_request(ngx_http_request_t *r)\n \n                 X509_free(cert);\n             }\n+\n+            if (ngx_ssl_ocsp_get_status(c, &s) != NGX_OK) {\n+                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                              \"client SSL certificate verify error: %s\", s);\n+\n+                ngx_ssl_remove_cached_session(c->ssl->session_ctx,\n+                                       (SSL_get0_session(c->ssl->connection)));\n+\n+                ngx_http_finalize_request(r, NGX_HTTPS_CERT_ERROR);\n+                return;\n+            }\n         }\n     }\n \n"
    },
    {
        "commit_sha": "ef970a54395324307fffd11ab37266479ac37d4c",
        "commit_index": "Commit 22",
        "commit_diff": "Diff:\n@@ -22,6 +22,7 @@ typedef struct {\n     ngx_msec_t                   resolver_timeout;\n \n     ngx_addr_t                  *addrs;\n+    ngx_uint_t                   naddrs;\n     ngx_str_t                    host;\n     ngx_str_t                    uri;\n     in_port_t                    port;\n@@ -30,6 +31,7 @@ typedef struct {\n \n     X509                        *cert;\n     X509                        *issuer;\n+    STACK_OF(X509)              *chain;\n \n     u_char                      *name;\n \n@@ -44,12 +46,19 @@ typedef struct {\n typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;\n \n struct ngx_ssl_ocsp_ctx_s {\n+    SSL_CTX                     *ssl_ctx;\n+\n     X509                        *cert;\n     X509                        *issuer;\n+    STACK_OF(X509)              *chain;\n+\n+    int                          status;\n+    time_t                       valid;\n \n     u_char                      *name;\n \n     ngx_uint_t                   naddrs;\n+    ngx_uint_t                   naddr;\n \n     ngx_addr_t                  *addrs;\n     ngx_str_t                    host;\n@@ -74,7 +83,7 @@ struct ngx_ssl_ocsp_ctx_s {\n \n     ngx_uint_t                   code;\n     ngx_uint_t                   count;\n-\n+    ngx_uint_t                   flags;\n     ngx_uint_t                   done;\n \n     u_char                      *header_name_start;\n@@ -107,6 +116,7 @@ static void ngx_ssl_stapling_cleanup(void *data);\n \n static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);\n static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);\n+static void ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve);\n static void ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx);\n@@ -120,6 +130,7 @@ static ngx_int_t ngx_ssl_ocsp_parse_status_line(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_process_headers(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx);\n \n static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);\n \n@@ -173,6 +184,18 @@ ngx_ssl_stapling_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, X509 *cert,\n         return NGX_ERROR;\n     }\n \n+#ifdef SSL_CTRL_SELECT_CURRENT_CERT\n+    /* OpenSSL 1.0.2+ */\n+    SSL_CTX_select_current_cert(ssl->ctx, cert);\n+#endif\n+\n+#ifdef SSL_CTRL_GET_EXTRA_CHAIN_CERTS\n+    /* OpenSSL 1.0.1+ */\n+    SSL_CTX_get_extra_chain_certs(ssl->ctx, &staple->chain);\n+#else\n+    staple->chain = ssl->ctx->extra_certs;\n+#endif\n+\n     staple->ssl_ctx = ssl->ctx;\n     staple->timeout = 60000;\n     staple->verify = verify;\n@@ -289,29 +312,16 @@ ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     X509            *cert, *issuer;\n     X509_STORE      *store;\n     X509_STORE_CTX  *store_ctx;\n-    STACK_OF(X509)  *chain;\n \n     cert = staple->cert;\n \n-#ifdef SSL_CTRL_SELECT_CURRENT_CERT\n-    /* OpenSSL 1.0.2+ */\n-    SSL_CTX_select_current_cert(ssl->ctx, cert);\n-#endif\n-\n-#ifdef SSL_CTRL_GET_EXTRA_CHAIN_CERTS\n-    /* OpenSSL 1.0.1+ */\n-    SSL_CTX_get_extra_chain_certs(ssl->ctx, &chain);\n-#else\n-    chain = ssl->ctx->extra_certs;\n-#endif\n-\n-    n = sk_X509_num(chain);\n+    n = sk_X509_num(staple->chain);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,\n                    \"SSL get issuer: %d extra certs\", n);\n \n     for (i = 0; i < n; i++) {\n-        issuer = sk_X509_value(chain, i);\n+        issuer = sk_X509_value(staple->chain, i);\n         if (X509_check_issued(issuer, cert) == X509_V_OK) {\n #if OPENSSL_VERSION_NUMBER >= 0x10100001L\n             X509_up_ref(issuer);\n@@ -462,6 +472,7 @@ ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     }\n \n     staple->addrs = u.addrs;\n+    staple->naddrs = u.naddrs;\n     staple->host = u.host;\n     staple->uri = u.uri;\n     staple->port = u.port;\n@@ -564,11 +575,15 @@ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)\n         return;\n     }\n \n+    ctx->ssl_ctx = staple->ssl_ctx;\n     ctx->cert = staple->cert;\n     ctx->issuer = staple->issuer;\n+    ctx->chain = staple->chain;\n     ctx->name = staple->name;\n+    ctx->flags = (staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY);\n \n     ctx->addrs = staple->addrs;\n+    ctx->naddrs = staple->naddrs;\n     ctx->host = staple->host;\n     ctx->uri = staple->uri;\n     ctx->port = staple->port;\n@@ -589,137 +604,27 @@ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)\n static void\n ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n {\n-    int                    n;\n-    size_t                 len;\n-    time_t                 now, valid;\n-    ngx_str_t              response;\n-    X509_STORE            *store;\n-    const u_char          *p;\n-    STACK_OF(X509)        *chain;\n-    OCSP_CERTID           *id;\n-    OCSP_RESPONSE         *ocsp;\n-    OCSP_BASICRESP        *basic;\n-    ngx_ssl_stapling_t    *staple;\n-    ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;\n+    time_t               now;\n+    ngx_str_t            response;\n+    ngx_ssl_stapling_t  *staple;\n \n     staple = ctx->data;\n     now = ngx_time();\n-    ocsp = NULL;\n-    basic = NULL;\n-    id = NULL;\n-\n-    if (ctx->code != 200) {\n-        goto error;\n-    }\n-\n-    /* check the response */\n-\n-    len = ctx->response->last - ctx->response->pos;\n-    p = ctx->response->pos;\n-\n-    ocsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n-    if (ocsp == NULL) {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"d2i_OCSP_RESPONSE() failed\");\n-        goto error;\n-    }\n-\n-    n = OCSP_response_status(ocsp);\n-\n-    if (n != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n-        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP response not successful (%d: %s)\",\n-                      n, OCSP_response_status_str(n));\n-        goto error;\n-    }\n-\n-    basic = OCSP_response_get1_basic(ocsp);\n-    if (basic == NULL) {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP_response_get1_basic() failed\");\n-        goto error;\n-    }\n-\n-    store = SSL_CTX_get_cert_store(staple->ssl_ctx);\n-    if (store == NULL) {\n-        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n-                      \"SSL_CTX_get_cert_store() failed\");\n-        goto error;\n-    }\n-\n-#ifdef SSL_CTRL_SELECT_CURRENT_CERT\n-    /* OpenSSL 1.0.2+ */\n-    SSL_CTX_select_current_cert(staple->ssl_ctx, ctx->cert);\n-#endif\n-\n-#ifdef SSL_CTRL_GET_EXTRA_CHAIN_CERTS\n-    /* OpenSSL 1.0.1+ */\n-    SSL_CTX_get_extra_chain_certs(staple->ssl_ctx, &chain);\n-#else\n-    chain = staple->ssl_ctx->extra_certs;\n-#endif\n-\n-    if (OCSP_basic_verify(basic, chain, store,\n-                          staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY)\n-        != 1)\n-    {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP_basic_verify() failed\");\n-        goto error;\n-    }\n-\n-    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);\n-    if (id == NULL) {\n-        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n-                      \"OCSP_cert_to_id() failed\");\n-        goto error;\n-    }\n \n-    if (OCSP_resp_find_status(basic, id, &n, NULL, NULL,\n-                              &thisupdate, &nextupdate)\n-        != 1)\n-    {\n-        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"certificate status not found in the OCSP response\");\n+    if (ngx_ssl_ocsp_verify(ctx) != NGX_OK) {\n         goto error;\n     }\n \n-    if (n != V_OCSP_CERTSTATUS_GOOD) {\n+    if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n         ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n                       \"certificate status \\\"%s\\\" in the OCSP response\",\n-                      OCSP_cert_status_str(n));\n-        goto error;\n-    }\n-\n-    if (OCSP_check_validity(thisupdate, nextupdate, 300, -1) != 1) {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP_check_validity() failed\");\n+                      OCSP_cert_status_str(ctx->status));\n         goto error;\n     }\n \n-    if (nextupdate) {\n-        valid = ngx_ssl_stapling_time(nextupdate);\n-        if (valid == (time_t) NGX_ERROR) {\n-            ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n-                          \"invalid nextUpdate time in certificate status\");\n-            goto error;\n-        }\n-\n-    } else {\n-        valid = NGX_MAX_TIME_T_VALUE;\n-    }\n-\n-    OCSP_CERTID_free(id);\n-    OCSP_BASICRESP_free(basic);\n-    OCSP_RESPONSE_free(ocsp);\n-\n-    id = NULL;\n-    basic = NULL;\n-    ocsp = NULL;\n-\n     /* copy the response to memory not in ctx->pool */\n \n-    response.len = len;\n+    response.len = ctx->response->last - ctx->response->pos;\n     response.data = ngx_alloc(response.len, ctx->log);\n \n     if (response.data == NULL) {\n@@ -728,24 +633,20 @@ ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n \n     ngx_memcpy(response.data, ctx->response->pos, response.len);\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n-                   \"ssl ocsp response, %s, %uz\",\n-                   OCSP_cert_status_str(n), response.len);\n-\n     if (staple->staple.data) {\n         ngx_free(staple->staple.data);\n     }\n \n     staple->staple = response;\n-    staple->valid = valid;\n+    staple->valid = ctx->valid;\n \n     /*\n      * refresh before the response expires,\n      * but not earlier than in 5 minutes, and at least in an hour\n      */\n \n     staple->loading = 0;\n-    staple->refresh = ngx_max(ngx_min(valid - 300, now + 3600), now + 300);\n+    staple->refresh = ngx_max(ngx_min(ctx->valid - 300, now + 3600), now + 300);\n \n     ngx_ssl_ocsp_done(ctx);\n     return;\n@@ -755,18 +656,6 @@ ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n     staple->loading = 0;\n     staple->refresh = now + 300;\n \n-    if (id) {\n-        OCSP_CERTID_free(id);\n-    }\n-\n-    if (basic) {\n-        OCSP_BASICRESP_free(basic);\n-    }\n-\n-    if (ocsp) {\n-        OCSP_RESPONSE_free(ocsp);\n-    }\n-\n     ngx_ssl_ocsp_done(ctx);\n }\n \n@@ -884,6 +773,36 @@ ngx_ssl_ocsp_error(ngx_ssl_ocsp_ctx_t *ctx)\n }\n \n \n+static void\n+ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp next\");\n+\n+    if (++ctx->naddr >= ctx->naddrs) {\n+        ngx_ssl_ocsp_error(ctx);\n+        return;\n+    }\n+\n+    ctx->request->pos = ctx->request->start;\n+\n+    if (ctx->response) {\n+        ctx->response->last = ctx->response->pos;\n+    }\n+\n+    if (ctx->peer.connection) {\n+        ngx_close_connection(ctx->peer.connection);\n+        ctx->peer.connection = NULL;\n+    }\n+\n+    ctx->state = 0;\n+    ctx->count = 0;\n+    ctx->done = 0;\n+\n+    ngx_ssl_ocsp_connect(ctx);\n+}\n+\n+\n static void\n ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx)\n {\n@@ -1022,16 +941,17 @@ ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve)\n static void\n ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)\n {\n-    ngx_int_t  rc;\n+    ngx_int_t    rc;\n+    ngx_addr_t  *addr;\n \n-    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n-                   \"ssl ocsp connect\");\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp connect %ui/%ui\", ctx->naddr, ctx->naddrs);\n \n-    /* TODO: use all ip addresses */\n+    addr = &ctx->addrs[ctx->naddr];\n \n-    ctx->peer.sockaddr = ctx->addrs[0].sockaddr;\n-    ctx->peer.socklen = ctx->addrs[0].socklen;\n-    ctx->peer.name = &ctx->addrs[0].name;\n+    ctx->peer.sockaddr = addr->sockaddr;\n+    ctx->peer.socklen = addr->socklen;\n+    ctx->peer.name = &addr->name;\n     ctx->peer.get = ngx_event_get_peer;\n     ctx->peer.log = ctx->log;\n     ctx->peer.log_error = NGX_ERROR_ERR;\n@@ -1041,11 +961,16 @@ ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)\n     ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n                    \"ssl ocsp connect peer done\");\n \n-    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {\n+    if (rc == NGX_ERROR) {\n         ngx_ssl_ocsp_error(ctx);\n         return;\n     }\n \n+    if (rc == NGX_BUSY || rc == NGX_DECLINED) {\n+        ngx_ssl_ocsp_next(ctx);\n+        return;\n+    }\n+\n     ctx->peer.connection->data = ctx;\n     ctx->peer.connection->pool = ctx->pool;\n \n@@ -1080,7 +1005,7 @@ ngx_ssl_ocsp_write_handler(ngx_event_t *wev)\n     if (wev->timedout) {\n         ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,\n                       \"OCSP responder timed out\");\n-        ngx_ssl_ocsp_error(ctx);\n+        ngx_ssl_ocsp_next(ctx);\n         return;\n     }\n \n@@ -1089,7 +1014,7 @@ ngx_ssl_ocsp_write_handler(ngx_event_t *wev)\n     n = ngx_send(c, ctx->request->pos, size);\n \n     if (n == NGX_ERROR) {\n-        ngx_ssl_ocsp_error(ctx);\n+        ngx_ssl_ocsp_next(ctx);\n         return;\n     }\n \n@@ -1134,7 +1059,7 @@ ngx_ssl_ocsp_read_handler(ngx_event_t *rev)\n     if (rev->timedout) {\n         ngx_log_error(NGX_LOG_ERR, rev->log, NGX_ETIMEDOUT,\n                       \"OCSP responder timed out\");\n-        ngx_ssl_ocsp_error(ctx);\n+        ngx_ssl_ocsp_next(ctx);\n         return;\n     }\n \n@@ -1158,7 +1083,7 @@ ngx_ssl_ocsp_read_handler(ngx_event_t *rev)\n             rc = ctx->process(ctx);\n \n             if (rc == NGX_ERROR) {\n-                ngx_ssl_ocsp_error(ctx);\n+                ngx_ssl_ocsp_next(ctx);\n                 return;\n             }\n \n@@ -1189,7 +1114,7 @@ ngx_ssl_ocsp_read_handler(ngx_event_t *rev)\n     ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n                   \"OCSP responder prematurely closed connection\");\n \n-    ngx_ssl_ocsp_error(ctx);\n+    ngx_ssl_ocsp_next(ctx);\n }\n \n \n@@ -1831,6 +1756,129 @@ ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx)\n }\n \n \n+static ngx_int_t\n+ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    int                    n;\n+    size_t                 len;\n+    X509_STORE            *store;\n+    const u_char          *p;\n+    OCSP_CERTID           *id;\n+    OCSP_RESPONSE         *ocsp;\n+    OCSP_BASICRESP        *basic;\n+    ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;\n+\n+    ocsp = NULL;\n+    basic = NULL;\n+    id = NULL;\n+\n+    if (ctx->code != 200) {\n+        goto error;\n+    }\n+\n+    /* check the response */\n+\n+    len = ctx->response->last - ctx->response->pos;\n+    p = ctx->response->pos;\n+\n+    ocsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n+    if (ocsp == NULL) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"d2i_OCSP_RESPONSE() failed\");\n+        goto error;\n+    }\n+\n+    n = OCSP_response_status(ocsp);\n+\n+    if (n != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP response not successful (%d: %s)\",\n+                      n, OCSP_response_status_str(n));\n+        goto error;\n+    }\n+\n+    basic = OCSP_response_get1_basic(ocsp);\n+    if (basic == NULL) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP_response_get1_basic() failed\");\n+        goto error;\n+    }\n+\n+    store = SSL_CTX_get_cert_store(ctx->ssl_ctx);\n+    if (store == NULL) {\n+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n+                      \"SSL_CTX_get_cert_store() failed\");\n+        goto error;\n+    }\n+\n+    if (OCSP_basic_verify(basic, ctx->chain, store, ctx->flags) != 1) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP_basic_verify() failed\");\n+        goto error;\n+    }\n+\n+    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);\n+    if (id == NULL) {\n+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n+                      \"OCSP_cert_to_id() failed\");\n+        goto error;\n+    }\n+\n+    if (OCSP_resp_find_status(basic, id, &ctx->status, NULL, NULL,\n+                              &thisupdate, &nextupdate)\n+        != 1)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"certificate status not found in the OCSP response\");\n+        goto error;\n+    }\n+\n+    if (OCSP_check_validity(thisupdate, nextupdate, 300, -1) != 1) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP_check_validity() failed\");\n+        goto error;\n+    }\n+\n+    if (nextupdate) {\n+        ctx->valid = ngx_ssl_stapling_time(nextupdate);\n+        if (ctx->valid == (time_t) NGX_ERROR) {\n+            ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                          \"invalid nextUpdate time in certificate status\");\n+            goto error;\n+        }\n+\n+    } else {\n+        ctx->valid = NGX_MAX_TIME_T_VALUE;\n+    }\n+\n+    OCSP_CERTID_free(id);\n+    OCSP_BASICRESP_free(basic);\n+    OCSP_RESPONSE_free(ocsp);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp response, %s, %uz\",\n+                   OCSP_cert_status_str(ctx->status), len);\n+\n+    return NGX_OK;\n+\n+error:\n+\n+    if (id) {\n+        OCSP_CERTID_free(id);\n+    }\n+\n+    if (basic) {\n+        OCSP_BASICRESP_free(basic);\n+    }\n+\n+    if (ocsp) {\n+        OCSP_RESPONSE_free(ocsp);\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n static u_char *\n ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len)\n {\nDiff:\n@@ -328,15 +328,6 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n \n     src = ctx->cookie;\n \n-    /*\n-     * we have to limit the encoded string to 22 characters because\n-     *  1) cookie may be marked by \"userid_mark\",\n-     *  2) and there are already the millions cookies with a garbage\n-     *     instead of the correct base64 trail \"==\"\n-     */\n-\n-    src.len = 22;\n-\n     dst.data = (u_char *) ctx->uid_got;\n \n     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\nDiff:\n@@ -2502,6 +2502,8 @@ ngx_http_upstream_test_next(ngx_http_request_t *r, ngx_http_upstream_t *u)\n         }\n \n #endif\n+\n+        break;\n     }\n \n #if (NGX_HTTP_CACHE)\n"
    },
    {
        "commit_sha": "2e54412b8e855e6465a3320e70512d1a021e2128",
        "commit_index": "Commit 21",
        "commit_diff": "Diff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017010\n-#define NGINX_VERSION      \"1.17.10\"\n+#define nginx_version      1019000\n+#define NGINX_VERSION      \"1.19.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -120,6 +120,7 @@ typedef struct {\n     unsigned                   end_stream:1;\n     unsigned                   done:1;\n     unsigned                   status:1;\n+    unsigned                   rst:1;\n \n     ngx_http_request_t        *request;\n \n@@ -1205,6 +1206,7 @@ ngx_http_grpc_reinit_request(ngx_http_request_t *r)\n     ctx->end_stream = 0;\n     ctx->done = 0;\n     ctx->status = 0;\n+    ctx->rst = 0;\n     ctx->connection = NULL;\n \n     return NGX_OK;\n@@ -2088,7 +2090,10 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                 return NGX_ERROR;\n             }\n \n-            if (ctx->stream_id && ctx->done) {\n+            if (ctx->stream_id && ctx->done\n+                && ctx->type != NGX_HTTP_V2_RST_STREAM_FRAME\n+                && ctx->type != NGX_HTTP_V2_WINDOW_UPDATE_FRAME)\n+            {\n                 ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                               \"upstream sent frame for closed stream %ui\",\n                               ctx->stream_id);\n@@ -2131,11 +2136,21 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                 return NGX_ERROR;\n             }\n \n-            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                          \"upstream rejected request with error %ui\",\n-                          ctx->error);\n+            if (ctx->error || !ctx->done) {\n+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                              \"upstream rejected request with error %ui\",\n+                              ctx->error);\n+                return NGX_ERROR;\n+            }\n \n-            return NGX_ERROR;\n+            if (ctx->rst) {\n+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                              \"upstream sent frame for closed stream %ui\",\n+                              ctx->stream_id);\n+                return NGX_ERROR;\n+            }\n+\n+            ctx->rst = 1;\n         }\n \n         if (ctx->type == NGX_HTTP_V2_GOAWAY_FRAME) {\nDiff:\n@@ -1085,7 +1085,7 @@ ngx_http_variable_argument(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     len = name->len - (sizeof(\"arg_\") - 1);\n     arg = name->data + sizeof(\"arg_\") - 1;\n \n-    if (ngx_http_arg(r, arg, len, &value) != NGX_OK) {\n+    if (len == 0 || ngx_http_arg(r, arg, len, &value) != NGX_OK) {\n         v->not_found = 1;\n         return NGX_OK;\n     }\n"
    },
    {
        "commit_sha": "106991de0a69fa519f4172ab6fdd672079062aa3",
        "commit_index": "Commit 20",
        "commit_diff": "Diff:\n@@ -448,3 +448,4 @@ de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n 5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\n+c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\nDiff:\n@@ -5,6 +5,20 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.10\" date=\"2020-04-14\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива auth_delay.\n+</para>\n+<para lang=\"en\">\n+the \"auth_delay\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.9\" date=\"2020-03-03\">\n \n <change type=\"change\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1d\n+OPENSSL =\topenssl-1.1.1f\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \n"
    },
    {
        "commit_sha": "1b0695bd9aa04df8031634ac8b80f4a7a2687bf7",
        "commit_index": "Commit 19",
        "commit_diff": "Diff:\n@@ -25,7 +25,6 @@ static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r,\n     ngx_str_t *passwd, ngx_str_t *realm);\n static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r,\n     ngx_str_t *realm);\n-static void ngx_http_auth_basic_close(ngx_file_t *file);\n static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf);\n static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf,\n     void *parent, void *child);\n@@ -177,8 +176,8 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n                           offset);\n \n         if (n == NGX_ERROR) {\n-            ngx_http_auth_basic_close(&file);\n-            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            goto cleanup;\n         }\n \n         if (n == 0) {\n@@ -219,12 +218,11 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n                 if (buf[i] == LF || buf[i] == CR || buf[i] == ':') {\n                     buf[i] = '\\0';\n \n-                    ngx_http_auth_basic_close(&file);\n-\n                     pwd.len = i - passwd;\n                     pwd.data = &buf[passwd];\n \n-                    return ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+                    rc = ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+                    goto cleanup;\n                 }\n \n                 break;\n@@ -251,8 +249,6 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n         offset += n;\n     }\n \n-    ngx_http_auth_basic_close(&file);\n-\n     if (state == sw_passwd) {\n         pwd.len = i - passwd;\n         pwd.data = ngx_pnalloc(r->pool, pwd.len + 1);\n@@ -262,14 +258,26 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n \n         ngx_cpystrn(pwd.data, &buf[passwd], pwd.len + 1);\n \n-        return ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+        rc = ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+        goto cleanup;\n     }\n \n     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                   \"user \\\"%V\\\" was not found in \\\"%s\\\"\",\n                   &r->headers_in.user, user_file.data);\n \n-    return ngx_http_auth_basic_set_realm(r, &realm);\n+    rc = ngx_http_auth_basic_set_realm(r, &realm);\n+\n+cleanup:\n+\n+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", user_file.data);\n+    }\n+\n+    ngx_explicit_memzero(buf, NGX_HTTP_AUTH_BUF_SIZE);\n+\n+    return rc;\n }\n \n \n@@ -338,15 +346,6 @@ ngx_http_auth_basic_set_realm(ngx_http_request_t *r, ngx_str_t *realm)\n     return NGX_HTTP_UNAUTHORIZED;\n }\n \n-static void\n-ngx_http_auth_basic_close(ngx_file_t *file)\n-{\n-    if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {\n-        ngx_log_error(NGX_LOG_ALERT, file->log, ngx_errno,\n-                      ngx_close_file_n \" \\\"%s\\\" failed\", file->name.data);\n-    }\n-}\n-\n \n static void *\n ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf)\nDiff:\n@@ -21,6 +21,9 @@ typedef struct {\n #define NGX_HTTP_REQUEST_BODY_FILE_CLEAN  2\n \n \n+static ngx_int_t ngx_http_core_auth_delay(ngx_http_request_t *r);\n+static void ngx_http_core_auth_delay_handler(ngx_http_request_t *r);\n+\n static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r);\n static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r,\n     ngx_http_location_tree_node_t *node);\n@@ -520,6 +523,13 @@ static ngx_command_t  ngx_http_core_commands[] = {\n       offsetof(ngx_http_core_loc_conf_t, satisfy),\n       &ngx_http_core_satisfy },\n \n+    { ngx_string(\"auth_delay\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_core_loc_conf_t, auth_delay),\n+      NULL },\n+\n     { ngx_string(\"internal\"),\n       NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,\n       ngx_http_core_internal,\n@@ -1124,6 +1134,10 @@ ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n \n     /* rc == NGX_ERROR || rc == NGX_HTTP_...  */\n \n+    if (rc == NGX_HTTP_UNAUTHORIZED) {\n+        return ngx_http_core_auth_delay(r);\n+    }\n+\n     ngx_http_finalize_request(r, rc);\n     return NGX_OK;\n }\n@@ -1141,12 +1155,17 @@ ngx_http_core_post_access_phase(ngx_http_request_t *r,\n     access_code = r->access_code;\n \n     if (access_code) {\n+        r->access_code = 0;\n+\n         if (access_code == NGX_HTTP_FORBIDDEN) {\n             ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                           \"access forbidden by rule\");\n         }\n \n-        r->access_code = 0;\n+        if (access_code == NGX_HTTP_UNAUTHORIZED) {\n+            return ngx_http_core_auth_delay(r);\n+        }\n+\n         ngx_http_finalize_request(r, access_code);\n         return NGX_OK;\n     }\n@@ -1156,6 +1175,65 @@ ngx_http_core_post_access_phase(ngx_http_request_t *r,\n }\n \n \n+static ngx_int_t\n+ngx_http_core_auth_delay(ngx_http_request_t *r)\n+{\n+    ngx_http_core_loc_conf_t  *clcf;\n+\n+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+\n+    if (clcf->auth_delay == 0) {\n+        ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                  \"delaying unauthorized request\");\n+\n+    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    r->read_event_handler = ngx_http_test_reading;\n+    r->write_event_handler = ngx_http_core_auth_delay_handler;\n+\n+    r->connection->write->delayed = 1;\n+    ngx_add_timer(r->connection->write, clcf->auth_delay);\n+\n+    /*\n+     * trigger an additional event loop iteration\n+     * to ensure constant-time processing\n+     */\n+\n+    ngx_post_event(r->connection->write, &ngx_posted_next_events);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void\n+ngx_http_core_auth_delay_handler(ngx_http_request_t *r)\n+{\n+    ngx_event_t  *wev;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"auth delay handler\");\n+\n+    wev = r->connection->write;\n+\n+    if (wev->delayed) {\n+\n+        if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+        }\n+\n+        return;\n+    }\n+\n+    ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);\n+}\n+\n+\n ngx_int_t\n ngx_http_core_content_phase(ngx_http_request_t *r,\n     ngx_http_phase_handler_t *ph)\n@@ -3394,6 +3472,7 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     clcf->client_body_buffer_size = NGX_CONF_UNSET_SIZE;\n     clcf->client_body_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->satisfy = NGX_CONF_UNSET_UINT;\n+    clcf->auth_delay = NGX_CONF_UNSET_MSEC;\n     clcf->if_modified_since = NGX_CONF_UNSET_UINT;\n     clcf->max_ranges = NGX_CONF_UNSET_UINT;\n     clcf->client_body_in_file_only = NGX_CONF_UNSET_UINT;\n@@ -3609,6 +3688,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                                |NGX_HTTP_KEEPALIVE_DISABLE_MSIE6));\n     ngx_conf_merge_uint_value(conf->satisfy, prev->satisfy,\n                               NGX_HTTP_SATISFY_ALL);\n+    ngx_conf_merge_msec_value(conf->auth_delay, prev->auth_delay, 0);\n     ngx_conf_merge_uint_value(conf->if_modified_since, prev->if_modified_since,\n                               NGX_HTTP_IMS_EXACT);\n     ngx_conf_merge_uint_value(conf->max_ranges, prev->max_ranges,\nDiff:\n@@ -366,6 +366,7 @@ struct ngx_http_core_loc_conf_s {\n     ngx_msec_t    lingering_time;          /* lingering_time */\n     ngx_msec_t    lingering_timeout;       /* lingering_timeout */\n     ngx_msec_t    resolver_timeout;        /* resolver_timeout */\n+    ngx_msec_t    auth_delay;              /* auth_delay */\n \n     ngx_resolver_t  *resolver;             /* resolver */\n \n"
    },
    {
        "commit_sha": "9faf31628c201a44f7ae9920da04623ef80ac535",
        "commit_index": "Commit 18",
        "commit_diff": "Diff:\n@@ -447,3 +447,4 @@ ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n+5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\nDiff:\n@@ -5,6 +5,82 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.9\" date=\"2020-03-03\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx не разрешает\n+несколько строк \"Host\" в заголовке запроса.\n+</para>\n+<para lang=\"en\">\n+now nginx does not allow\n+several \"Host\" request header lines.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx игнорировал дополнительные\n+строки \"Transfer-Encoding\" в заголовке запроса.\n+</para>\n+<para lang=\"en\">\n+nginx ignored additional\n+\"Transfer-Encoding\" request header lines.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+socket leak when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в рабочем процессе мог произойти segmentation fault,\n+если использовался OCSP stapling.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+if OCSP stapling was used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_mp4_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_mp4_module.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при перенаправлении ошибок с кодом 494 с помощью директивы error_page\n+nginx возвращал ответ с кодом 494 вместо 400.\n+</para>\n+<para lang=\"en\">\n+nginx used status code 494 instead of 400\n+if errors with code 494 were redirected with the \"error_page\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании подзапросов в модуле njs и директивы aio.\n+</para>\n+<para lang=\"en\">\n+socket leak when using subrequests in the njs module and the \"aio\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.8\" date=\"2020-01-21\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017009\n-#define NGINX_VERSION      \"1.17.9\"\n+#define nginx_version      1017010\n+#define NGINX_VERSION      \"1.17.10\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "4d6689d1df88bf7f092594db0e96f24d1da1c643",
        "commit_index": "Commit 17",
        "commit_diff": "Diff:\n@@ -8,7 +8,7 @@ CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n OPENSSL =\topenssl-1.1.1d\n ZLIB =\t\tzlib-1.2.11\n-PCRE =\t\tpcre-8.43\n+PCRE =\t\tpcre-8.44\n \n \n release: export\nDiff:\n@@ -4687,6 +4687,7 @@ ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 case NGX_HTTP_TO_HTTPS:\n                 case NGX_HTTPS_CERT_ERROR:\n                 case NGX_HTTPS_NO_CERT:\n+                case NGX_HTTP_REQUEST_HEADER_TOO_LARGE:\n                     err->overwrite = NGX_HTTP_BAD_REQUEST;\n             }\n         }\nDiff:\n@@ -2488,26 +2488,6 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n     }\n \n     if (r != r->main) {\n-        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-\n-        if (r->background) {\n-            if (!r->logged) {\n-                if (clcf->log_subrequest) {\n-                    ngx_http_log_request(r);\n-                }\n-\n-                r->logged = 1;\n-\n-            } else {\n-                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n-                              \"subrequest: \\\"%V?%V\\\" logged again\",\n-                              &r->uri, &r->args);\n-            }\n-\n-            r->done = 1;\n-            ngx_http_finalize_connection(r);\n-            return;\n-        }\n \n         if (r->buffered || r->postponed) {\n \n@@ -2520,11 +2500,12 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n \n         pr = r->parent;\n \n-        if (r == c->data) {\n-\n-            r->main->count--;\n+        if (r == c->data || r->background) {\n \n             if (!r->logged) {\n+\n+                clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+\n                 if (clcf->log_subrequest) {\n                     ngx_http_log_request(r);\n                 }\n@@ -2539,6 +2520,13 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n \n             r->done = 1;\n \n+            if (r->background) {\n+                ngx_http_finalize_connection(r);\n+                return;\n+            }\n+\n+            r->main->count--;\n+\n             if (pr->postponed && pr->postponed->request == r) {\n                 pr->postponed = pr->postponed->next;\n             }\n"
    },
    {
        "commit_sha": "39f66fa6c5f03b995a01f67087f1bf7def50decc",
        "commit_index": "Commit 16",
        "commit_diff": "Diff:\n@@ -3116,6 +3116,13 @@ ngx_http_mp4_update_stsz_atom(ngx_http_mp4_file_t *mp4,\n                        \"chunk samples sizes:%uL\",\n                        trak->start_chunk_samples_size);\n \n+        if (trak->start_chunk_samples_size > (uint64_t) mp4->end) {\n+            ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                          \"too large mp4 start samples size in \\\"%s\\\"\",\n+                          mp4->file.name.data);\n+            return NGX_ERROR;\n+        }\n+\n         if (mp4->length) {\n             if (trak->end_sample - trak->start_sample > entries) {\n                 ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n@@ -3135,6 +3142,13 @@ ngx_http_mp4_update_stsz_atom(ngx_http_mp4_file_t *mp4,\n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n                            \"mp4 stsz end_chunk_samples_size:%uL\",\n                            trak->end_chunk_samples_size);\n+\n+            if (trak->end_chunk_samples_size > (uint64_t) mp4->end) {\n+                ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                              \"too large mp4 end samples size in \\\"%s\\\"\",\n+                              mp4->file.name.data);\n+                return NGX_ERROR;\n+            }\n         }\n \n         atom_size = sizeof(ngx_mp4_stsz_atom_t) + (data->last - data->pos);\n@@ -3226,6 +3240,7 @@ ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,\n {\n     size_t                atom_size;\n     uint32_t              entries;\n+    uint64_t              chunk_offset, samples_size;\n     ngx_buf_t            *atom, *data;\n     ngx_mp4_stco_atom_t  *stco_atom;\n \n@@ -3256,8 +3271,19 @@ ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,\n \n     data->pos += trak->start_chunk * sizeof(uint32_t);\n \n-    trak->start_offset = ngx_mp4_get_32value(data->pos);\n-    trak->start_offset += trak->start_chunk_samples_size;\n+    chunk_offset = ngx_mp4_get_32value(data->pos);\n+    samples_size = trak->start_chunk_samples_size;\n+\n+    if (chunk_offset > (uint64_t) mp4->end - samples_size\n+        || chunk_offset + samples_size > NGX_MAX_UINT32_VALUE)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"too large chunk offset in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    trak->start_offset = chunk_offset + samples_size;\n     ngx_mp4_set_32value(data->pos, trak->start_offset);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n@@ -3276,9 +3302,19 @@ ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,\n         data->last = data->pos + entries * sizeof(uint32_t);\n \n         if (entries) {\n-            trak->end_offset =\n-                            ngx_mp4_get_32value(data->last - sizeof(uint32_t));\n-            trak->end_offset += trak->end_chunk_samples_size;\n+            chunk_offset = ngx_mp4_get_32value(data->last - sizeof(uint32_t));\n+            samples_size = trak->end_chunk_samples_size;\n+\n+            if (chunk_offset > (uint64_t) mp4->end - samples_size\n+                || chunk_offset + samples_size > NGX_MAX_UINT32_VALUE)\n+            {\n+                ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                              \"too large chunk offset in \\\"%s\\\"\",\n+                              mp4->file.name.data);\n+                return NGX_ERROR;\n+            }\n+\n+            trak->end_offset = chunk_offset + samples_size;\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n                            \"end chunk offset:%O\", trak->end_offset);\n@@ -3409,7 +3445,7 @@ ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak)\n {\n     size_t                atom_size;\n-    uint64_t              entries;\n+    uint64_t              entries, chunk_offset, samples_size;\n     ngx_buf_t            *atom, *data;\n     ngx_mp4_co64_atom_t  *co64_atom;\n \n@@ -3440,8 +3476,17 @@ ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,\n \n     data->pos += trak->start_chunk * sizeof(uint64_t);\n \n-    trak->start_offset = ngx_mp4_get_64value(data->pos);\n-    trak->start_offset += trak->start_chunk_samples_size;\n+    chunk_offset = ngx_mp4_get_64value(data->pos);\n+    samples_size = trak->start_chunk_samples_size;\n+\n+    if (chunk_offset > (uint64_t) mp4->end - samples_size) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"too large chunk offset in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    trak->start_offset = chunk_offset + samples_size;\n     ngx_mp4_set_64value(data->pos, trak->start_offset);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n@@ -3460,9 +3505,17 @@ ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,\n         data->last = data->pos + entries * sizeof(uint64_t);\n \n         if (entries) {\n-            trak->end_offset =\n-                            ngx_mp4_get_64value(data->last - sizeof(uint64_t));\n-            trak->end_offset += trak->end_chunk_samples_size;\n+            chunk_offset = ngx_mp4_get_64value(data->last - sizeof(uint64_t));\n+            samples_size = trak->end_chunk_samples_size;\n+\n+            if (chunk_offset > (uint64_t) mp4->end - samples_size) {\n+                ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                              \"too large chunk offset in \\\"%s\\\"\",\n+                              mp4->file.name.data);\n+                return NGX_ERROR;\n+            }\n+\n+            trak->end_offset = chunk_offset + samples_size;\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n                            \"end chunk offset:%O\", trak->end_offset);\nDiff:\n@@ -2667,43 +2667,41 @@ ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r, ngx_addr_t *addr,\n     u_char *xff, size_t xfflen, ngx_array_t *proxies, int recursive)\n {\n     u_char      *p;\n-    ngx_int_t    rc;\n     ngx_addr_t   paddr;\n+    ngx_uint_t   found;\n \n-    if (ngx_cidr_match(addr->sockaddr, proxies) != NGX_OK) {\n-        return NGX_DECLINED;\n-    }\n+    found = 0;\n \n-    for (p = xff + xfflen - 1; p > xff; p--, xfflen--) {\n-        if (*p != ' ' && *p != ',') {\n-            break;\n-        }\n-    }\n+    do {\n \n-    for ( /* void */ ; p > xff; p--) {\n-        if (*p == ' ' || *p == ',') {\n-            p++;\n-            break;\n+        if (ngx_cidr_match(addr->sockaddr, proxies) != NGX_OK) {\n+            return found ? NGX_DONE : NGX_DECLINED;\n         }\n-    }\n-\n-    if (ngx_parse_addr_port(r->pool, &paddr, p, xfflen - (p - xff)) != NGX_OK) {\n-        return NGX_DECLINED;\n-    }\n \n-    *addr = paddr;\n+        for (p = xff + xfflen - 1; p > xff; p--, xfflen--) {\n+            if (*p != ' ' && *p != ',') {\n+                break;\n+            }\n+        }\n \n-    if (recursive && p > xff) {\n-        rc = ngx_http_get_forwarded_addr_internal(r, addr, xff, p - 1 - xff,\n-                                                  proxies, 1);\n+        for ( /* void */ ; p > xff; p--) {\n+            if (*p == ' ' || *p == ',') {\n+                p++;\n+                break;\n+            }\n+        }\n \n-        if (rc == NGX_DECLINED) {\n-            return NGX_DONE;\n+        if (ngx_parse_addr_port(r->pool, &paddr, p, xfflen - (p - xff))\n+            != NGX_OK)\n+        {\n+            return found ? NGX_DONE : NGX_DECLINED;\n         }\n \n-        /* rc == NGX_OK || rc == NGX_DONE  */\n-        return rc;\n-    }\n+        *addr = paddr;\n+        found = 1;\n+        xfflen = p - 1 - xff;\n+\n+    } while (recursive && p > xff);\n \n     return NGX_OK;\n }\nDiff:\n@@ -131,7 +131,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n \n     { ngx_string(\"Transfer-Encoding\"),\n                  offsetof(ngx_http_headers_in_t, transfer_encoding),\n-                 ngx_http_process_header_line },\n+                 ngx_http_process_unique_header_line },\n \n     { ngx_string(\"TE\"),\n                  offsetof(ngx_http_headers_in_t, te),\n@@ -748,6 +748,8 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n                 return;\n             }\n \n+            ngx_reusable_connection(c, 0);\n+\n             rc = ngx_ssl_handshake(c);\n \n             if (rc == NGX_AGAIN) {\n@@ -756,8 +758,6 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n                     ngx_add_timer(rev, c->listening->post_accept_timeout);\n                 }\n \n-                ngx_reusable_connection(c, 0);\n-\n                 c->ssl->handler = ngx_http_ssl_handshake_handler;\n                 return;\n             }\n@@ -1755,10 +1755,18 @@ ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_int_t  rc;\n     ngx_str_t  host;\n \n-    if (r->headers_in.host == NULL) {\n-        r->headers_in.host = h;\n+    if (r->headers_in.host) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate host header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.host->key,\n+                      &r->headers_in.host->value);\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n     }\n \n+    r->headers_in.host = h;\n+\n     host = h->value;\n \n     rc = ngx_http_validate_host(&host, r->pool, 0);\n@@ -1952,10 +1960,7 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n             r->headers_in.content_length_n = -1;\n             r->headers_in.chunked = 1;\n \n-        } else if (r->headers_in.transfer_encoding->value.len != 8\n-            || ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n-                               (u_char *) \"identity\", 8) != 0)\n-        {\n+        } else {\n             ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                           \"client sent unknown \\\"Transfer-Encoding\\\": \\\"%V\\\"\",\n                           &r->headers_in.transfer_encoding->value);\n"
    },
    {
        "commit_sha": "935f9c03174211caa4615a288fb42a5b601176e0",
        "commit_index": "Commit 15",
        "commit_diff": "Diff:\n@@ -446,3 +446,4 @@ ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n 9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\n de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n+fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017008\n-#define NGINX_VERSION      \"1.17.8\"\n+#define nginx_version      1017009\n+#define NGINX_VERSION      \"1.17.9\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1719,8 +1719,13 @@ ngx_http_v2_state_header_complete(ngx_http_v2_connection_t *h2c, u_char *pos,\n     ngx_http_v2_stream_t  *stream;\n \n     if (h2c->state.length) {\n-        h2c->state.handler = ngx_http_v2_state_header_block;\n-        return pos;\n+        if (end - pos > 0) {\n+            h2c->state.handler = ngx_http_v2_state_header_block;\n+            return pos;\n+        }\n+\n+        return ngx_http_v2_state_headers_save(h2c, pos, end,\n+                                              ngx_http_v2_state_header_block);\n     }\n \n     if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)) {\n"
    },
    {
        "commit_sha": "a2875d22b649d7305ba90e18968ed8bb96c8c609",
        "commit_index": "Commit 14",
        "commit_diff": "Diff:\n@@ -5,6 +5,42 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.8\" date=\"2020-01-21\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива grpc_pass поддерживает переменные.\n+</para>\n+<para lang=\"en\">\n+variables support in the \"grpc_pass\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при обработке pipelined-запросов по SSL-соединению мог произойти таймаут;\n+ошибка появилась в 1.17.5.\n+</para>\n+<para lang=\"en\">\n+a timeout might occur while handling pipelined requests in an SSL connection;\n+the bug had appeared in 1.17.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве debug_points при использовании HTTP/2.<br/>\n+Спасибо Даниилу Бондареву.\n+</para>\n+<para lang=\"en\">\n+in the \"debug_points\" directive when using HTTP/2.<br/>\n+Thanks to Daniil Bondarev.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.7\" date=\"2019-12-24\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -27,6 +27,9 @@ typedef struct {\n     ngx_str_t                  host;\n     ngx_uint_t                 host_set;\n \n+    ngx_array_t               *grpc_lengths;\n+    ngx_array_t               *grpc_values;\n+\n #if (NGX_HTTP_SSL)\n     ngx_uint_t                 ssl;\n     ngx_uint_t                 ssl_protocols;\n@@ -119,6 +122,8 @@ typedef struct {\n     unsigned                   status:1;\n \n     ngx_http_request_t        *request;\n+\n+    ngx_str_t                  host;\n } ngx_http_grpc_ctx_t;\n \n \n@@ -135,6 +140,8 @@ typedef struct {\n } ngx_http_grpc_frame_t;\n \n \n+static ngx_int_t ngx_http_grpc_eval(ngx_http_request_t *r,\n+    ngx_http_grpc_ctx_t *ctx, ngx_http_grpc_loc_conf_t *glcf);\n static ngx_int_t ngx_http_grpc_create_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_grpc_reinit_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_grpc_body_output_filter(void *data, ngx_chain_t *in);\n@@ -524,23 +531,41 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n+    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_grpc_ctx_t));\n+    if (ctx == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    ctx->request = r;\n+\n+    ngx_http_set_ctx(r, ctx, ngx_http_grpc_module);\n+\n     glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);\n \n     u = r->upstream;\n \n+    if (glcf->grpc_lengths == NULL) {\n+        ctx->host = glcf->host;\n+\n #if (NGX_HTTP_SSL)\n-    u->ssl = (glcf->upstream.ssl != NULL);\n+        u->ssl = (glcf->upstream.ssl != NULL);\n \n-    if (u->ssl) {\n-        ngx_str_set(&u->schema, \"grpcs://\");\n+        if (u->ssl) {\n+            ngx_str_set(&u->schema, \"grpcs://\");\n \n-    } else {\n-        ngx_str_set(&u->schema, \"grpc://\");\n-    }\n+        } else {\n+            ngx_str_set(&u->schema, \"grpc://\");\n+        }\n #else\n-    ngx_str_set(&u->schema, \"grpc://\");\n+        ngx_str_set(&u->schema, \"grpc://\");\n #endif\n \n+    } else {\n+        if (ngx_http_grpc_eval(r, ctx, glcf) != NGX_OK) {\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+    }\n+\n     u->output.tag = (ngx_buf_tag_t) &ngx_http_grpc_module;\n \n     u->conf = &glcf->upstream;\n@@ -551,15 +576,6 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n     u->abort_request = ngx_http_grpc_abort_request;\n     u->finalize_request = ngx_http_grpc_finalize_request;\n \n-    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_grpc_ctx_t));\n-    if (ctx == NULL) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n-    }\n-\n-    ctx->request = r;\n-\n-    ngx_http_set_ctx(r, ctx, ngx_http_grpc_module);\n-\n     u->input_filter_init = ngx_http_grpc_filter_init;\n     u->input_filter = ngx_http_grpc_filter;\n     u->input_filter_ctx = ctx;\n@@ -576,6 +592,103 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_grpc_eval(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n+    ngx_http_grpc_loc_conf_t *glcf)\n+{\n+    size_t                add;\n+    ngx_url_t             url;\n+    ngx_http_upstream_t  *u;\n+\n+    ngx_memzero(&url, sizeof(ngx_url_t));\n+\n+    if (ngx_http_script_run(r, &url.url, glcf->grpc_lengths->elts, 0,\n+                            glcf->grpc_values->elts)\n+        == NULL)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    if (url.url.len > 7\n+        && ngx_strncasecmp(url.url.data, (u_char *) \"grpc://\", 7) == 0)\n+    {\n+        add = 7;\n+\n+    } else if (url.url.len > 8\n+               && ngx_strncasecmp(url.url.data, (u_char *) \"grpcs://\", 8) == 0)\n+    {\n+\n+#if (NGX_HTTP_SSL)\n+        add = 8;\n+        r->upstream->ssl = 1;\n+#else\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"grpcs protocol requires SSL support\");\n+        return NGX_ERROR;\n+#endif\n+\n+    } else {\n+        add = 0;\n+    }\n+\n+    u = r->upstream;\n+\n+    if (add) {\n+        u->schema.len = add;\n+        u->schema.data = url.url.data;\n+\n+        url.url.data += add;\n+        url.url.len -= add;\n+\n+    } else {\n+        ngx_str_set(&u->schema, \"grpc://\");\n+    }\n+\n+    url.no_resolve = 1;\n+\n+    if (ngx_parse_url(r->pool, &url) != NGX_OK) {\n+        if (url.err) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"%s in upstream \\\"%V\\\"\", url.err, &url.url);\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));\n+    if (u->resolved == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (url.addrs) {\n+        u->resolved->sockaddr = url.addrs[0].sockaddr;\n+        u->resolved->socklen = url.addrs[0].socklen;\n+        u->resolved->name = url.addrs[0].name;\n+        u->resolved->naddrs = 1;\n+    }\n+\n+    u->resolved->host = url.host;\n+    u->resolved->port = url.port;\n+    u->resolved->no_port = url.no_port;\n+\n+    if (url.family != AF_UNIX) {\n+\n+        if (url.no_port) {\n+            ctx->host = url.host;\n+\n+        } else {\n+            ctx->host.len = url.host.len + 1 + url.port_text.len;\n+            ctx->host.data = url.host.data;\n+        }\n+\n+    } else {\n+        ngx_str_set(&ctx->host, \"localhost\");\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_grpc_create_request(ngx_http_request_t *r)\n {\n@@ -587,6 +700,7 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n     ngx_table_elt_t              *header;\n+    ngx_http_grpc_ctx_t          *ctx;\n     ngx_http_upstream_t          *u;\n     ngx_http_grpc_frame_t        *f;\n     ngx_http_script_code_pt       code;\n@@ -598,6 +712,8 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n \n     glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);\n \n+    ctx = ngx_http_get_module_ctx(r, ngx_http_grpc_module);\n+\n     len = sizeof(ngx_http_grpc_connection_start) - 1\n           + sizeof(ngx_http_grpc_frame_t);             /* headers frame */\n \n@@ -637,10 +753,10 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n     /* :authority header */\n \n     if (!glcf->host_set) {\n-        len += 1 + NGX_HTTP_V2_INT_OCTETS + glcf->host.len;\n+        len += 1 + NGX_HTTP_V2_INT_OCTETS + ctx->host.len;\n \n-        if (tmp_len < glcf->host.len) {\n-            tmp_len = glcf->host.len;\n+        if (tmp_len < ctx->host.len) {\n+            tmp_len = ctx->host.len;\n         }\n     }\n \n@@ -785,7 +901,7 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n     }\n \n #if (NGX_HTTP_SSL)\n-    if (glcf->ssl) {\n+    if (u->ssl) {\n         *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_SCHEME_HTTPS_INDEX);\n \n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n@@ -846,11 +962,11 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n \n     if (!glcf->host_set) {\n         *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_AUTHORITY_INDEX);\n-        b->last = ngx_http_v2_write_value(b->last, glcf->host.data,\n-                                          glcf->host.len, tmp);\n+        b->last = ngx_http_v2_write_value(b->last, ctx->host.data,\n+                                          ctx->host.len, tmp);\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"grpc header: \\\":authority: %V\\\"\", &glcf->host);\n+                       \"grpc header: \\\":authority: %V\\\"\", &ctx->host);\n     }\n \n     ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n@@ -4319,15 +4435,23 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n \n-    if (clcf->noname && conf->upstream.upstream == NULL) {\n+    if (clcf->noname\n+        && conf->upstream.upstream == NULL && conf->grpc_lengths == NULL)\n+    {\n         conf->upstream.upstream = prev->upstream.upstream;\n         conf->host = prev->host;\n+\n+        conf->grpc_lengths = prev->grpc_lengths;\n+        conf->grpc_values = prev->grpc_values;\n+\n #if (NGX_HTTP_SSL)\n         conf->upstream.ssl = prev->upstream.ssl;\n #endif\n     }\n \n-    if (clcf->lmt_excpt && clcf->handler == NULL && conf->upstream.upstream) {\n+    if (clcf->lmt_excpt && clcf->handler == NULL\n+        && (conf->upstream.upstream || conf->grpc_lengths))\n+    {\n         clcf->handler = ngx_http_grpc_handler;\n     }\n \n@@ -4537,18 +4661,54 @@ ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n {\n     ngx_http_grpc_loc_conf_t *glcf = conf;\n \n-    size_t                     add;\n-    ngx_str_t                 *value, *url;\n-    ngx_url_t                  u;\n-    ngx_http_core_loc_conf_t  *clcf;\n+    size_t                      add;\n+    ngx_str_t                  *value, *url;\n+    ngx_url_t                   u;\n+    ngx_uint_t                  n;\n+    ngx_http_core_loc_conf_t   *clcf;\n+    ngx_http_script_compile_t   sc;\n \n-    if (glcf->upstream.upstream) {\n+    if (glcf->upstream.upstream || glcf->grpc_lengths) {\n         return \"is duplicate\";\n     }\n \n+    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n+\n+    clcf->handler = ngx_http_grpc_handler;\n+\n+    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {\n+        clcf->auto_redirect = 1;\n+    }\n+\n     value = cf->args->elts;\n+\n     url = &value[1];\n \n+    n = ngx_http_script_variables_count(url);\n+\n+    if (n) {\n+\n+        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));\n+\n+        sc.cf = cf;\n+        sc.source = url;\n+        sc.lengths = &glcf->grpc_lengths;\n+        sc.values = &glcf->grpc_values;\n+        sc.variables = n;\n+        sc.complete_lengths = 1;\n+        sc.complete_values = 1;\n+\n+        if (ngx_http_script_compile(&sc) != NGX_OK) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+#if (NGX_HTTP_SSL)\n+        glcf->ssl = 1;\n+#endif\n+\n+        return NGX_CONF_OK;\n+    }\n+\n     if (ngx_strncasecmp(url->data, (u_char *) \"grpc://\", 7) == 0) {\n         add = 7;\n \n@@ -4593,14 +4753,6 @@ ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         ngx_str_set(&glcf->host, \"localhost\");\n     }\n \n-    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n-\n-    clcf->handler = ngx_http_grpc_handler;\n-\n-    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {\n-        clcf->auto_redirect = 1;\n-    }\n-\n     return NGX_CONF_OK;\n }\n \nDiff:\n@@ -2466,10 +2466,6 @@ ngx_http_v2_connection_error(ngx_http_v2_connection_t *h2c,\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                    \"http2 state connection error\");\n \n-    if (err == NGX_HTTP_V2_INTERNAL_ERROR) {\n-        ngx_debug_point();\n-    }\n-\n     ngx_http_v2_finalize_connection(h2c, err);\n \n     return NULL;\n"
    },
    {
        "commit_sha": "b7c9c9537162c32541de403956577c99435e1098",
        "commit_index": "Commit 13",
        "commit_diff": "Diff:\n@@ -238,6 +238,7 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     if (!ngx_queue_empty(&ngx_posted_next_events)) {\n+        ngx_event_move_posted_next(cycle);\n         timer = 0;\n     }\n \n@@ -261,7 +262,6 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     ngx_event_process_posted(cycle, &ngx_posted_events);\n-    ngx_event_process_posted_next(cycle, &ngx_posted_next_events);\n }\n \n \nDiff:\n@@ -2017,6 +2017,10 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n                         c->read->available = 0;\n                         c->read->ready = 0;\n \n+                        if (c->read->posted) {\n+                            ngx_delete_posted_event(c->read);\n+                        }\n+\n                         ngx_post_event(c->read, &ngx_posted_next_events);\n                     }\n \nDiff:\n@@ -37,26 +37,24 @@ ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted)\n \n \n void\n-ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted)\n+ngx_event_move_posted_next(ngx_cycle_t *cycle)\n {\n     ngx_queue_t  *q;\n     ngx_event_t  *ev;\n \n-    while (!ngx_queue_empty(posted)) {\n-\n-        q = ngx_queue_head(posted);\n+    for (q = ngx_queue_head(&ngx_posted_next_events);\n+         q != ngx_queue_sentinel(&ngx_posted_next_events);\n+         q = ngx_queue_next(q))\n+    {\n         ev = ngx_queue_data(q, ngx_event_t, queue);\n \n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                       \"posted next event %p\", ev);\n \n-        ngx_delete_posted_event(ev);\n-\n-        if (!ev->ready) {\n-            ev->ready = 1;\n-            ev->available = -1;\n-        }\n-\n-        ev->handler(ev);\n+        ev->ready = 1;\n+        ev->available = -1;\n     }\n+\n+    ngx_queue_add(&ngx_posted_events, &ngx_posted_next_events);\n+    ngx_queue_init(&ngx_posted_next_events);\n }\nDiff:\n@@ -39,7 +39,7 @@\n \n \n void ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted);\n-void ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted);\n+void ngx_event_move_posted_next(ngx_cycle_t *cycle);\n \n \n extern ngx_queue_t  ngx_posted_accept_events;\n"
    },
    {
        "commit_sha": "0dbd46415432759475e6e4bb5adfaada6fb7d506",
        "commit_index": "Commit 12",
        "commit_diff": "Diff:\n@@ -27,7 +27,7 @@ was used in the configuration.\n или директивой proxy_pass с URI.\n </para>\n <para lang=\"en\">\n-a segmentation fault might occur in a worker process \n+a segmentation fault might occur in a worker process\n if the \"break\" directive was used with the \"alias\" directive\n or with the \"proxy_pass\" directive with a URI.\n </para>\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017007\n-#define NGINX_VERSION      \"1.17.7\"\n+#define nginx_version      1017008\n+#define NGINX_VERSION      \"1.17.8\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1889,7 +1889,7 @@ ngx_http_auth_basic_user(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    auth.len = ngx_base64_decoded_length(encoded.len);\n+    auth.len = NGX_HTTP_AUTH_MAX;\n     auth.data = ngx_pnalloc(r->pool, auth.len + 1);\n     if (auth.data == NULL) {\n         return NGX_ERROR;\nDiff:\n@@ -60,6 +60,9 @@ typedef struct ngx_thread_pool_s  ngx_thread_pool_t;\n #define NGX_HTTP_SERVER_TOKENS_BUILD    2\n \n \n+#define NGX_HTTP_AUTH_MAX               16\n+\n+\n typedef struct ngx_http_location_tree_node_s  ngx_http_location_tree_node_t;\n typedef struct ngx_http_core_loc_conf_s  ngx_http_core_loc_conf_t;\n \n"
    },
    {
        "commit_sha": "91b43af18a3efc103d34bf2595a3fb487984ab99",
        "commit_index": "Commit 11",
        "commit_diff": "Diff:\n@@ -445,3 +445,4 @@ ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n 9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\n de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n+e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\nDiff:\n@@ -5,6 +5,90 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.7\" date=\"2019-12-24\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+на старте или во время переконфигурации мог произойти segmentation fault,\n+если в конфигурации использовалась\n+директива rewrite с пустой строкой замены.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur on start or during reconfiguration\n+if the \"rewrite\" directive with an empty replacement string\n+was used in the configuration.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в рабочем процессе мог произойти segmentation fault,\n+если директива break использовалась совместно с директивой alias\n+или директивой proxy_pass с URI.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process \n+if the \"break\" directive was used with the \"alias\" directive\n+or with the \"proxy_pass\" directive with a URI.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+строка Location заголовка ответа могла содержать мусор,\n+если URI запроса был изменён на URI, содержащий нулевой символ.\n+</para>\n+<para lang=\"en\">\n+the \"Location\" response header line might contain garbage\n+if the request URI was rewritten to the one containing a null character.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при возврате перенаправлений с помощью директивы error_page\n+запросы с телом обрабатывались некорректно;\n+ошибка появилась в 0.7.12.\n+</para>\n+<para lang=\"en\">\n+requests with bodies were handled incorrectly\n+when returning redirections with the \"error_page\" directive;\n+the bug had appeared in 0.7.12.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+socket leak when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при обработке pipelined-запросов по SSL-соединению мог произойти таймаут;\n+ошибка появилась в 1.17.5.\n+</para>\n+<para lang=\"en\">\n+a timeout might occur while handling pipelined requests in an SSL connection;\n+the bug had appeared in 1.17.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_dav_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_dav_module.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.6\" date=\"2019-11-19\">\n \n <change type=\"feature\">\nDiff:\n@@ -238,8 +238,6 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     if (!ngx_queue_empty(&ngx_posted_next_events)) {\n-        ngx_queue_add(&ngx_posted_events, &ngx_posted_next_events);\n-        ngx_queue_init(&ngx_posted_next_events);\n         timer = 0;\n     }\n \n@@ -263,6 +261,7 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     ngx_event_process_posted(cycle, &ngx_posted_events);\n+    ngx_event_process_posted_next(cycle, &ngx_posted_next_events);\n }\n \n \nDiff:\n@@ -43,7 +43,6 @@ static ssize_t ngx_ssl_recv_early(ngx_connection_t *c, u_char *buf,\n #endif\n static ngx_int_t ngx_ssl_handle_recv(ngx_connection_t *c, int n);\n static void ngx_ssl_write_handler(ngx_event_t *wev);\n-static void ngx_ssl_next_read_handler(ngx_event_t *rev);\n #ifdef SSL_READ_EARLY_DATA_SUCCESS\n static ssize_t ngx_ssl_write_early(ngx_connection_t *c, u_char *data,\n     size_t size);\n@@ -2018,11 +2017,6 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n                         c->read->available = 0;\n                         c->read->ready = 0;\n \n-                        if (c->ssl->next_read_handler == NULL) {\n-                            c->ssl->next_read_handler = c->read->handler;\n-                            c->read->handler = ngx_ssl_next_read_handler;\n-                        }\n-\n                         ngx_post_event(c->read, &ngx_posted_next_events);\n                     }\n \n@@ -2328,31 +2322,6 @@ ngx_ssl_write_handler(ngx_event_t *wev)\n }\n \n \n-static void\n-ngx_ssl_next_read_handler(ngx_event_t *rev)\n-{\n-    ngx_connection_t  *c;\n-\n-    c = rev->data;\n-\n-    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL next read handler\");\n-\n-    rev->handler = c->ssl->next_read_handler;\n-    c->ssl->next_read_handler = NULL;\n-\n-    if (!rev->ready) {\n-        rev->ready = 1;\n-        rev->available = -1;\n-    }\n-\n-    if (rev->posted) {\n-        ngx_delete_posted_event(rev);\n-    }\n-\n-    rev->handler(rev);\n-}\n-\n-\n /*\n  * OpenSSL has no SSL_writev() so we copy several bufs into our 16K buffer\n  * before the SSL_write() call to decrease a SSL overhead.\nDiff:\n@@ -86,7 +86,6 @@ struct ngx_ssl_connection_s {\n \n     ngx_event_handler_pt        saved_read_handler;\n     ngx_event_handler_pt        saved_write_handler;\n-    ngx_event_handler_pt        next_read_handler;\n \n     u_char                      early_buf;\n \nDiff:\n@@ -34,3 +34,29 @@ ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted)\n         ev->handler(ev);\n     }\n }\n+\n+\n+void\n+ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted)\n+{\n+    ngx_queue_t  *q;\n+    ngx_event_t  *ev;\n+\n+    while (!ngx_queue_empty(posted)) {\n+\n+        q = ngx_queue_head(posted);\n+        ev = ngx_queue_data(q, ngx_event_t, queue);\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                      \"posted next event %p\", ev);\n+\n+        ngx_delete_posted_event(ev);\n+\n+        if (!ev->ready) {\n+            ev->ready = 1;\n+            ev->available = -1;\n+        }\n+\n+        ev->handler(ev);\n+    }\n+}\nDiff:\n@@ -39,6 +39,7 @@\n \n \n void ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted);\n+void ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted);\n \n \n extern ngx_queue_t  ngx_posted_accept_events;\n"
    },
    {
        "commit_sha": "da686e0cdd9a59e95d7d72a979880ddc94db9f3d",
        "commit_index": "Commit 10",
        "commit_diff": "Diff:\n@@ -1,5 +1,5 @@\n .\\\"\n-.\\\" Copyright (C) 2010 Sergey A. Osokin\n+.\\\" Copyright (C) 2010, 2019 Sergey A. Osokin\n .\\\" Copyright (C) Nginx, Inc.\n .\\\" All rights reserved.\n .\\\"\n@@ -25,7 +25,7 @@\n .\\\" SUCH DAMAGE.\n .\\\"\n .\\\"\n-.Dd June 16, 2015\n+.Dd December 5, 2019\n .Dt NGINX 8\n .Os\n .Sh NAME\n@@ -42,7 +42,8 @@\n .Nm\n (pronounced\n .Dq engine x )\n-is an HTTP and reverse proxy server, as well as a mail proxy server.\n+is an HTTP and reverse proxy server, a mail proxy server, and a generic\n+TCP/UDP proxy server.\n It is known for its high performance, stability, rich feature set, simple\n configuration, and low resource consumption.\n .Pp\n@@ -82,15 +83,15 @@ The following table shows the corresponding system signals:\n .It Cm reload\n .Dv SIGHUP\n .El\n+.It Fl T\n+Same as\n+.Fl t ,\n+but additionally dump configuration files to standard output.\n .It Fl t\n Do not run, just test the configuration file.\n .Nm\n checks the configuration file syntax and then tries to open files\n referenced in the configuration file.\n-.It Fl T\n-Same as\n-.Fl t ,\n-but additionally dump configuration files to standard output.\n .It Fl V\n Print the\n .Nm\nDiff:\n@@ -312,7 +312,7 @@ ngx_http_dav_delete_handler(ngx_http_request_t *r)\n     ngx_file_info_t           fi;\n     ngx_http_dav_loc_conf_t  *dlcf;\n \n-    if (r->headers_in.content_length_n > 0) {\n+    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"DELETE with body is unsupported\");\n         return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n@@ -495,7 +495,7 @@ ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)\n     size_t     root;\n     ngx_str_t  path;\n \n-    if (r->headers_in.content_length_n > 0) {\n+    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"MKCOL with body is unsupported\");\n         return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n@@ -549,7 +549,9 @@ ngx_http_dav_copy_move_handler(ngx_http_request_t *r)\n     ngx_http_dav_copy_ctx_t   copy;\n     ngx_http_dav_loc_conf_t  *dlcf;\n \n-    if (r->headers_in.content_length_n > 0) {\n+    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"COPY and MOVE with body are unsupported\");\n         return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n     }\n \nDiff:\n@@ -178,6 +178,7 @@ static void ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r);\n static ngx_int_t ngx_http_v2_terminate_stream(ngx_http_v2_connection_t *h2c,\n     ngx_http_v2_stream_t *stream, ngx_uint_t status);\n static void ngx_http_v2_close_stream_handler(ngx_event_t *ev);\n+static void ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev);\n static void ngx_http_v2_handle_connection_handler(ngx_event_t *rev);\n static void ngx_http_v2_idle_handler(ngx_event_t *rev);\n static void ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n@@ -4288,8 +4289,9 @@ ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc)\n     fc = stream->request->connection;\n \n     if (stream->queued) {\n-        fc->write->handler = ngx_http_v2_close_stream_handler;\n-        fc->read->handler = ngx_http_empty_handler;\n+        fc->error = 1;\n+        fc->write->handler = ngx_http_v2_retry_close_stream_handler;\n+        fc->read->handler = ngx_http_v2_retry_close_stream_handler;\n         return;\n     }\n \n@@ -4411,6 +4413,22 @@ ngx_http_v2_close_stream_handler(ngx_event_t *ev)\n }\n \n \n+static void\n+ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev)\n+{\n+    ngx_connection_t    *fc;\n+    ngx_http_request_t  *r;\n+\n+    fc = ev->data;\n+    r = fc->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 retry close stream handler\");\n+\n+    ngx_http_v2_close_stream(r->stream, 0);\n+}\n+\n+\n static void\n ngx_http_v2_handle_connection_handler(ngx_event_t *rev)\n {\n"
    },
    {
        "commit_sha": "6298ff853bbef97c76096878b057f7a28972b763",
        "commit_index": "Commit 9",
        "commit_diff": "Diff:\n@@ -318,6 +318,11 @@ ngx_http_rewrite(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     value = cf->args->elts;\n \n+    if (value[2].len == 0) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"empty replacement\");\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n \n     rc.pattern = value[1];\nDiff:\n@@ -1843,7 +1843,8 @@ ngx_http_map_uri_to_path(ngx_http_request_t *r, ngx_str_t *path,\n         }\n     }\n \n-    last = ngx_cpystrn(last, r->uri.data + alias, r->uri.len - alias + 1);\n+    last = ngx_copy(last, r->uri.data + alias, r->uri.len - alias);\n+    *last = '\\0';\n \n     return last;\n }\nDiff:\n@@ -623,6 +623,12 @@ ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n         return ngx_http_named_location(r, &uri);\n     }\n \n+    r->expect_tested = 1;\n+\n+    if (ngx_http_discard_request_body(r) != NGX_OK) {\n+        r->keepalive = 0;\n+    }\n+\n     location = ngx_list_push(&r->headers_out.headers);\n \n     if (location == NULL) {\n"
    },
    {
        "commit_sha": "9d099047e4aec3d8fa5a1b8c770eed5b4ac1b066",
        "commit_index": "Commit 8",
        "commit_diff": "Diff:\n@@ -56,7 +56,7 @@ static ngx_int_t ngx_http_dav_copy_tree_file(ngx_tree_ctx_t *ctx,\n static ngx_int_t ngx_http_dav_depth(ngx_http_request_t *r, ngx_int_t dflt);\n static ngx_int_t ngx_http_dav_error(ngx_log_t *log, ngx_err_t err,\n     ngx_int_t not_found, char *failed, u_char *path);\n-static ngx_int_t ngx_http_dav_location(ngx_http_request_t *r, u_char *path);\n+static ngx_int_t ngx_http_dav_location(ngx_http_request_t *r);\n static void *ngx_http_dav_create_loc_conf(ngx_conf_t *cf);\n static char *ngx_http_dav_merge_loc_conf(ngx_conf_t *cf,\n     void *parent, void *child);\n@@ -285,7 +285,7 @@ ngx_http_dav_put_handler(ngx_http_request_t *r)\n     }\n \n     if (status == NGX_HTTP_CREATED) {\n-        if (ngx_http_dav_location(r, path.data) != NGX_OK) {\n+        if (ngx_http_dav_location(r) != NGX_OK) {\n             ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n             return;\n         }\n@@ -520,9 +520,7 @@ ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)\n     if (ngx_create_dir(path.data, ngx_dir_access(dlcf->access))\n         != NGX_FILE_ERROR)\n     {\n-        *(p - 1) = '/';\n-\n-        if (ngx_http_dav_location(r, path.data) != NGX_OK) {\n+        if (ngx_http_dav_location(r) != NGX_OK) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n@@ -1070,35 +1068,16 @@ ngx_http_dav_error(ngx_log_t *log, ngx_err_t err, ngx_int_t not_found,\n \n \n static ngx_int_t\n-ngx_http_dav_location(ngx_http_request_t *r, u_char *path)\n+ngx_http_dav_location(ngx_http_request_t *r)\n {\n-    u_char                    *location;\n-    ngx_http_core_loc_conf_t  *clcf;\n-\n     r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n     if (r->headers_out.location == NULL) {\n         return NGX_ERROR;\n     }\n \n-    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-\n-    if (!clcf->alias && clcf->root_lengths == NULL) {\n-        location = path + clcf->root.len;\n-\n-    } else {\n-        location = ngx_pnalloc(r->pool, r->uri.len);\n-        if (location == NULL) {\n-            ngx_http_clear_location(r);\n-            return NGX_ERROR;\n-        }\n-\n-        ngx_memcpy(location, r->uri.data, r->uri.len);\n-    }\n-\n     r->headers_out.location->hash = 1;\n     ngx_str_set(&r->headers_out.location->key, \"Location\");\n-    r->headers_out.location->value.len = r->uri.len;\n-    r->headers_out.location->value.data = location;\n+    r->headers_out.location->value = r->uri;\n \n     return NGX_OK;\n }\nDiff:\n@@ -163,7 +163,7 @@ ngx_http_index_handler(ngx_http_request_t *r)\n \n             name = ngx_http_map_uri_to_path(r, &path, &root, reserve);\n             if (name == NULL) {\n-                return NGX_ERROR;\n+                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n             }\n \n             allocated = path.data + path.len - name;\nDiff:\n@@ -157,8 +157,8 @@ ngx_http_static_handler(ngx_http_request_t *r)\n \n         len = r->uri.len + 1;\n \n-        if (!clcf->alias && clcf->root_lengths == NULL && r->args.len == 0) {\n-            location = path.data + clcf->root.len;\n+        if (!clcf->alias && r->args.len == 0) {\n+            location = path.data + root;\n \n             *last = '/';\n \nDiff:\n@@ -1477,7 +1477,14 @@ ngx_http_script_return_code(ngx_http_script_engine_t *e)\n void\n ngx_http_script_break_code(ngx_http_script_engine_t *e)\n {\n-    e->request->uri_changed = 0;\n+    ngx_http_request_t  *r;\n+\n+    r = e->request;\n+\n+    if (r->uri_changed) {\n+        r->valid_location = 0;\n+        r->uri_changed = 0;\n+    }\n \n     e->ip = ngx_http_script_exit;\n }\n"
    },
    {
        "commit_sha": "46d6961ac7b4978793e4ba41dd47b074e0420084",
        "commit_index": "Commit 7",
        "commit_diff": "Diff:\n@@ -444,3 +444,4 @@ d2fd76709909767fc727a5b4affcf1dc9ca488a7 release-1.15.9\n ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n 9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\n+de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\nDiff:\n@@ -5,6 +5,38 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.6\" date=\"2019-11-19\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные $proxy_protocol_server_addr и $proxy_protocol_server_port.\n+</para>\n+<para lang=\"en\">\n+the $proxy_protocol_server_addr and $proxy_protocol_server_port variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива limit_conn_dry_run.\n+</para>\n+<para lang=\"en\">\n+the \"limit_conn_dry_run\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные $limit_req_status и $limit_conn_status.\n+</para>\n+<para lang=\"en\">\n+the $limit_req_status and $limit_conn_status variables.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.5\" date=\"2019-10-22\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017006\n-#define NGINX_VERSION      \"1.17.6\"\n+#define nginx_version      1017007\n+#define NGINX_VERSION      \"1.17.7\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -513,14 +513,15 @@ ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)\n     }\n \n     *(p - 1) = '\\0';\n-    r->uri.len--;\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http mkcol path: \\\"%s\\\"\", path.data);\n \n     if (ngx_create_dir(path.data, ngx_dir_access(dlcf->access))\n         != NGX_FILE_ERROR)\n     {\n+        *(p - 1) = '/';\n+\n         if (ngx_http_dav_location(r, path.data) != NGX_OK) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\nDiff:\n@@ -275,6 +275,7 @@ ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc, void *data)\n \n     c->idle = 0;\n     c->sent = 0;\n+    c->data = NULL;\n     c->log = pc->log;\n     c->read->log = pc->log;\n     c->write->log = pc->log;\n"
    },
    {
        "commit_sha": "be5832bc48509d451d4c280438ba913e43069449",
        "commit_index": "Commit 6",
        "commit_diff": "Diff:\n@@ -10,37 +10,49 @@\n #include <ngx_http.h>\n \n \n+#define NGX_HTTP_LIMIT_CONN_PASSED            1\n+#define NGX_HTTP_LIMIT_CONN_REJECTED          2\n+#define NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN  3\n+\n+\n typedef struct {\n-    u_char                     color;\n-    u_char                     len;\n-    u_short                    conn;\n-    u_char                     data[1];\n+    u_char                        color;\n+    u_char                        len;\n+    u_short                       conn;\n+    u_char                        data[1];\n } ngx_http_limit_conn_node_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t            *shm_zone;\n-    ngx_rbtree_node_t         *node;\n+    ngx_shm_zone_t               *shm_zone;\n+    ngx_rbtree_node_t            *node;\n } ngx_http_limit_conn_cleanup_t;\n \n \n typedef struct {\n-    ngx_rbtree_t              *rbtree;\n-    ngx_http_complex_value_t   key;\n+    ngx_rbtree_t                  rbtree;\n+    ngx_rbtree_node_t             sentinel;\n+} ngx_http_limit_conn_shctx_t;\n+\n+\n+typedef struct {\n+    ngx_http_limit_conn_shctx_t  *sh;\n+    ngx_slab_pool_t              *shpool;\n+    ngx_http_complex_value_t      key;\n } ngx_http_limit_conn_ctx_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t            *shm_zone;\n-    ngx_uint_t                 conn;\n+    ngx_shm_zone_t               *shm_zone;\n+    ngx_uint_t                    conn;\n } ngx_http_limit_conn_limit_t;\n \n \n typedef struct {\n-    ngx_array_t                limits;\n-    ngx_uint_t                 log_level;\n-    ngx_uint_t                 status_code;\n-    ngx_flag_t                 dry_run;\n+    ngx_array_t                   limits;\n+    ngx_uint_t                    log_level;\n+    ngx_uint_t                    status_code;\n+    ngx_flag_t                    dry_run;\n } ngx_http_limit_conn_conf_t;\n \n \n@@ -49,13 +61,16 @@ static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree,\n static void ngx_http_limit_conn_cleanup(void *data);\n static ngx_inline void ngx_http_limit_conn_cleanup_all(ngx_pool_t *pool);\n \n+static ngx_int_t ngx_http_limit_conn_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf);\n static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf, void *parent,\n     void *child);\n static char *ngx_http_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static ngx_int_t ngx_http_limit_conn_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf);\n \n \n@@ -115,7 +130,7 @@ static ngx_command_t  ngx_http_limit_conn_commands[] = {\n \n \n static ngx_http_module_t  ngx_http_limit_conn_module_ctx = {\n-    NULL,                                  /* preconfiguration */\n+    ngx_http_limit_conn_add_variables,     /* preconfiguration */\n     ngx_http_limit_conn_init,              /* postconfiguration */\n \n     NULL,                                  /* create main configuration */\n@@ -145,14 +160,29 @@ ngx_module_t  ngx_http_limit_conn_module = {\n };\n \n \n+static ngx_http_variable_t  ngx_http_limit_conn_vars[] = {\n+\n+    { ngx_string(\"limit_conn_status\"), NULL,\n+      ngx_http_limit_conn_status_variable, 0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n+\n+      ngx_http_null_variable\n+};\n+\n+\n+static ngx_str_t  ngx_http_limit_conn_status[] = {\n+    ngx_string(\"PASSED\"),\n+    ngx_string(\"REJECTED\"),\n+    ngx_string(\"REJECTED_DRY_RUN\")\n+};\n+\n+\n static ngx_int_t\n ngx_http_limit_conn_handler(ngx_http_request_t *r)\n {\n     size_t                          n;\n     uint32_t                        hash;\n     ngx_str_t                       key;\n     ngx_uint_t                      i;\n-    ngx_slab_pool_t                *shpool;\n     ngx_rbtree_node_t              *node;\n     ngx_pool_cleanup_t             *cln;\n     ngx_http_limit_conn_ctx_t      *ctx;\n@@ -161,7 +191,7 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n     ngx_http_limit_conn_limit_t    *limits;\n     ngx_http_limit_conn_cleanup_t  *lccln;\n \n-    if (r->main->limit_conn_set) {\n+    if (r->main->limit_conn_status) {\n         return NGX_DECLINED;\n     }\n \n@@ -187,32 +217,34 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n             continue;\n         }\n \n-        r->main->limit_conn_set = 1;\n+        r->main->limit_conn_status = NGX_HTTP_LIMIT_CONN_PASSED;\n \n         hash = ngx_crc32_short(key.data, key.len);\n \n-        shpool = (ngx_slab_pool_t *) limits[i].shm_zone->shm.addr;\n-\n-        ngx_shmtx_lock(&shpool->mutex);\n+        ngx_shmtx_lock(&ctx->shpool->mutex);\n \n-        node = ngx_http_limit_conn_lookup(ctx->rbtree, &key, hash);\n+        node = ngx_http_limit_conn_lookup(&ctx->sh->rbtree, &key, hash);\n \n         if (node == NULL) {\n \n             n = offsetof(ngx_rbtree_node_t, color)\n                 + offsetof(ngx_http_limit_conn_node_t, data)\n                 + key.len;\n \n-            node = ngx_slab_alloc_locked(shpool, n);\n+            node = ngx_slab_alloc_locked(ctx->shpool, n);\n \n             if (node == NULL) {\n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n                 ngx_http_limit_conn_cleanup_all(r->pool);\n \n                 if (lccf->dry_run) {\n+                    r->main->limit_conn_status =\n+                                          NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                r->main->limit_conn_status = NGX_HTTP_LIMIT_CONN_REJECTED;\n+\n                 return lccf->status_code;\n             }\n \n@@ -223,15 +255,15 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n             lc->conn = 1;\n             ngx_memcpy(lc->data, key.data, key.len);\n \n-            ngx_rbtree_insert(ctx->rbtree, node);\n+            ngx_rbtree_insert(&ctx->sh->rbtree, node);\n \n         } else {\n \n             lc = (ngx_http_limit_conn_node_t *) &node->color;\n \n             if ((ngx_uint_t) lc->conn >= limits[i].conn) {\n \n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, r->connection->log, 0,\n                               \"limiting connections%s by zone \\\"%V\\\"\",\n@@ -241,9 +273,13 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n                 ngx_http_limit_conn_cleanup_all(r->pool);\n \n                 if (lccf->dry_run) {\n+                    r->main->limit_conn_status =\n+                                          NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                r->main->limit_conn_status = NGX_HTTP_LIMIT_CONN_REJECTED;\n+\n                 return lccf->status_code;\n             }\n \n@@ -253,7 +289,7 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"limit conn: %08Xi %d\", node->key, lc->conn);\n \n-        ngx_shmtx_unlock(&shpool->mutex);\n+        ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n         cln = ngx_pool_cleanup_add(r->pool,\n                                    sizeof(ngx_http_limit_conn_cleanup_t));\n@@ -357,29 +393,27 @@ ngx_http_limit_conn_cleanup(void *data)\n {\n     ngx_http_limit_conn_cleanup_t  *lccln = data;\n \n-    ngx_slab_pool_t             *shpool;\n     ngx_rbtree_node_t           *node;\n     ngx_http_limit_conn_ctx_t   *ctx;\n     ngx_http_limit_conn_node_t  *lc;\n \n     ctx = lccln->shm_zone->data;\n-    shpool = (ngx_slab_pool_t *) lccln->shm_zone->shm.addr;\n     node = lccln->node;\n     lc = (ngx_http_limit_conn_node_t *) &node->color;\n \n-    ngx_shmtx_lock(&shpool->mutex);\n+    ngx_shmtx_lock(&ctx->shpool->mutex);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, lccln->shm_zone->shm.log, 0,\n                    \"limit conn cleanup: %08Xi %d\", node->key, lc->conn);\n \n     lc->conn--;\n \n     if (lc->conn == 0) {\n-        ngx_rbtree_delete(ctx->rbtree, node);\n-        ngx_slab_free_locked(shpool, node);\n+        ngx_rbtree_delete(&ctx->sh->rbtree, node);\n+        ngx_slab_free_locked(ctx->shpool, node);\n     }\n \n-    ngx_shmtx_unlock(&shpool->mutex);\n+    ngx_shmtx_unlock(&ctx->shpool->mutex);\n }\n \n \n@@ -405,8 +439,6 @@ ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n     ngx_http_limit_conn_ctx_t  *octx = data;\n \n     size_t                      len;\n-    ngx_slab_pool_t            *shpool;\n-    ngx_rbtree_node_t          *sentinel;\n     ngx_http_limit_conn_ctx_t  *ctx;\n \n     ctx = shm_zone->data;\n@@ -425,48 +457,63 @@ ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n             return NGX_ERROR;\n         }\n \n-        ctx->rbtree = octx->rbtree;\n+        ctx->sh = octx->sh;\n+        ctx->shpool = octx->shpool;\n \n         return NGX_OK;\n     }\n \n-    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n \n     if (shm_zone->shm.exists) {\n-        ctx->rbtree = shpool->data;\n+        ctx->sh = ctx->shpool->data;\n \n         return NGX_OK;\n     }\n \n-    ctx->rbtree = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_t));\n-    if (ctx->rbtree == NULL) {\n+    ctx->sh = ngx_slab_alloc(ctx->shpool, sizeof(ngx_http_limit_conn_shctx_t));\n+    if (ctx->sh == NULL) {\n         return NGX_ERROR;\n     }\n \n-    shpool->data = ctx->rbtree;\n+    ctx->shpool->data = ctx->sh;\n \n-    sentinel = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_node_t));\n-    if (sentinel == NULL) {\n-        return NGX_ERROR;\n-    }\n-\n-    ngx_rbtree_init(ctx->rbtree, sentinel,\n+    ngx_rbtree_init(&ctx->sh->rbtree, &ctx->sh->sentinel,\n                     ngx_http_limit_conn_rbtree_insert_value);\n \n     len = sizeof(\" in limit_conn_zone \\\"\\\"\") + shm_zone->shm.name.len;\n \n-    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n-    if (shpool->log_ctx == NULL) {\n+    ctx->shpool->log_ctx = ngx_slab_alloc(ctx->shpool, len);\n+    if (ctx->shpool->log_ctx == NULL) {\n         return NGX_ERROR;\n     }\n \n-    ngx_sprintf(shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n+    ngx_sprintf(ctx->shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n                 &shm_zone->shm.name);\n \n     return NGX_OK;\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_conn_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    if (r->main->limit_conn_status == 0) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->len = ngx_http_limit_conn_status[r->main->limit_conn_status - 1].len;\n+    v->data = ngx_http_limit_conn_status[r->main->limit_conn_status - 1].data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static void *\n ngx_http_limit_conn_create_conf(ngx_conf_t *cf)\n {\n@@ -673,6 +720,25 @@ ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_conn_add_variables(ngx_conf_t *cf)\n+{\n+    ngx_http_variable_t  *var, *v;\n+\n+    for (v = ngx_http_limit_conn_vars; v->name.len; v++) {\n+        var = ngx_http_add_variable(cf, &v->name, v->flags);\n+        if (var == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        var->get_handler = v->get_handler;\n+        var->data = v->data;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_limit_conn_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -512,7 +512,7 @@ struct ngx_http_request_s {\n      * ngx_http_limit_conn_module and ngx_http_limit_req_module\n      * we use the bit fields in the request structure\n      */\n-    unsigned                          limit_conn_set:1;\n+    unsigned                          limit_conn_status:2;\n     unsigned                          limit_req_status:3;\n \n     unsigned                          limit_rate_set:1;\nDiff:\n@@ -226,6 +226,8 @@ struct ngx_stream_session_s {\n     unsigned                       stat_processing:1;\n \n     unsigned                       health_check:1;\n+\n+    unsigned                       limit_conn_status:2;\n };\n \n \nDiff:\n@@ -10,36 +10,48 @@\n #include <ngx_stream.h>\n \n \n+#define NGX_STREAM_LIMIT_CONN_PASSED            1\n+#define NGX_STREAM_LIMIT_CONN_REJECTED          2\n+#define NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN  3\n+\n+\n typedef struct {\n-    u_char                       color;\n-    u_char                       len;\n-    u_short                      conn;\n-    u_char                       data[1];\n+    u_char                          color;\n+    u_char                          len;\n+    u_short                         conn;\n+    u_char                          data[1];\n } ngx_stream_limit_conn_node_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t              *shm_zone;\n-    ngx_rbtree_node_t           *node;\n+    ngx_shm_zone_t                 *shm_zone;\n+    ngx_rbtree_node_t              *node;\n } ngx_stream_limit_conn_cleanup_t;\n \n \n typedef struct {\n-    ngx_rbtree_t                *rbtree;\n-    ngx_stream_complex_value_t   key;\n+    ngx_rbtree_t                    rbtree;\n+    ngx_rbtree_node_t               sentinel;\n+} ngx_stream_limit_conn_shctx_t;\n+\n+\n+typedef struct {\n+    ngx_stream_limit_conn_shctx_t  *sh;\n+    ngx_slab_pool_t                *shpool;\n+    ngx_stream_complex_value_t      key;\n } ngx_stream_limit_conn_ctx_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t              *shm_zone;\n-    ngx_uint_t                   conn;\n+    ngx_shm_zone_t                 *shm_zone;\n+    ngx_uint_t                      conn;\n } ngx_stream_limit_conn_limit_t;\n \n \n typedef struct {\n-    ngx_array_t                  limits;\n-    ngx_uint_t                   log_level;\n-    ngx_flag_t                   dry_run;\n+    ngx_array_t                     limits;\n+    ngx_uint_t                      log_level;\n+    ngx_flag_t                      dry_run;\n } ngx_stream_limit_conn_conf_t;\n \n \n@@ -48,13 +60,16 @@ static ngx_rbtree_node_t *ngx_stream_limit_conn_lookup(ngx_rbtree_t *rbtree,\n static void ngx_stream_limit_conn_cleanup(void *data);\n static ngx_inline void ngx_stream_limit_conn_cleanup_all(ngx_pool_t *pool);\n \n+static ngx_int_t ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data);\n static void *ngx_stream_limit_conn_create_conf(ngx_conf_t *cf);\n static char *ngx_stream_limit_conn_merge_conf(ngx_conf_t *cf, void *parent,\n     void *child);\n static char *ngx_stream_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_stream_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static ngx_int_t ngx_stream_limit_conn_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_stream_limit_conn_init(ngx_conf_t *cf);\n \n \n@@ -102,7 +117,7 @@ static ngx_command_t  ngx_stream_limit_conn_commands[] = {\n \n \n static ngx_stream_module_t  ngx_stream_limit_conn_module_ctx = {\n-    NULL,                                  /* preconfiguration */\n+    ngx_stream_limit_conn_add_variables,   /* preconfiguration */\n     ngx_stream_limit_conn_init,            /* postconfiguration */\n \n     NULL,                                  /* create main configuration */\n@@ -129,14 +144,29 @@ ngx_module_t  ngx_stream_limit_conn_module = {\n };\n \n \n+static ngx_stream_variable_t  ngx_stream_limit_conn_vars[] = {\n+\n+    { ngx_string(\"limit_conn_status\"), NULL,\n+      ngx_stream_limit_conn_status_variable, 0, NGX_STREAM_VAR_NOCACHEABLE, 0 },\n+\n+      ngx_stream_null_variable\n+};\n+\n+\n+static ngx_str_t  ngx_stream_limit_conn_status[] = {\n+    ngx_string(\"PASSED\"),\n+    ngx_string(\"REJECTED\"),\n+    ngx_string(\"REJECTED_DRY_RUN\")\n+};\n+\n+\n static ngx_int_t\n ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n {\n     size_t                            n;\n     uint32_t                          hash;\n     ngx_str_t                         key;\n     ngx_uint_t                        i;\n-    ngx_slab_pool_t                  *shpool;\n     ngx_rbtree_node_t                *node;\n     ngx_pool_cleanup_t               *cln;\n     ngx_stream_limit_conn_ctx_t      *ctx;\n@@ -167,30 +197,34 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n             continue;\n         }\n \n-        hash = ngx_crc32_short(key.data, key.len);\n+        s->limit_conn_status = NGX_STREAM_LIMIT_CONN_PASSED;\n \n-        shpool = (ngx_slab_pool_t *) limits[i].shm_zone->shm.addr;\n+        hash = ngx_crc32_short(key.data, key.len);\n \n-        ngx_shmtx_lock(&shpool->mutex);\n+        ngx_shmtx_lock(&ctx->shpool->mutex);\n \n-        node = ngx_stream_limit_conn_lookup(ctx->rbtree, &key, hash);\n+        node = ngx_stream_limit_conn_lookup(&ctx->sh->rbtree, &key, hash);\n \n         if (node == NULL) {\n \n             n = offsetof(ngx_rbtree_node_t, color)\n                 + offsetof(ngx_stream_limit_conn_node_t, data)\n                 + key.len;\n \n-            node = ngx_slab_alloc_locked(shpool, n);\n+            node = ngx_slab_alloc_locked(ctx->shpool, n);\n \n             if (node == NULL) {\n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n \n                 if (lccf->dry_run) {\n+                    s->limit_conn_status =\n+                                        NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                s->limit_conn_status = NGX_STREAM_LIMIT_CONN_REJECTED;\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -201,15 +235,15 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n             lc->conn = 1;\n             ngx_memcpy(lc->data, key.data, key.len);\n \n-            ngx_rbtree_insert(ctx->rbtree, node);\n+            ngx_rbtree_insert(&ctx->sh->rbtree, node);\n \n         } else {\n \n             lc = (ngx_stream_limit_conn_node_t *) &node->color;\n \n             if ((ngx_uint_t) lc->conn >= limits[i].conn) {\n \n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, s->connection->log, 0,\n                               \"limiting connections%s by zone \\\"%V\\\"\",\n@@ -219,9 +253,13 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n \n                 if (lccf->dry_run) {\n+                    s->limit_conn_status =\n+                                        NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                s->limit_conn_status = NGX_STREAM_LIMIT_CONN_REJECTED;\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -231,7 +269,7 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n         ngx_log_debug2(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,\n                        \"limit conn: %08Xi %d\", node->key, lc->conn);\n \n-        ngx_shmtx_unlock(&shpool->mutex);\n+        ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n         cln = ngx_pool_cleanup_add(s->connection->pool,\n                                    sizeof(ngx_stream_limit_conn_cleanup_t));\n@@ -336,29 +374,27 @@ ngx_stream_limit_conn_cleanup(void *data)\n {\n     ngx_stream_limit_conn_cleanup_t  *lccln = data;\n \n-    ngx_slab_pool_t               *shpool;\n     ngx_rbtree_node_t             *node;\n     ngx_stream_limit_conn_ctx_t   *ctx;\n     ngx_stream_limit_conn_node_t  *lc;\n \n     ctx = lccln->shm_zone->data;\n-    shpool = (ngx_slab_pool_t *) lccln->shm_zone->shm.addr;\n     node = lccln->node;\n     lc = (ngx_stream_limit_conn_node_t *) &node->color;\n \n-    ngx_shmtx_lock(&shpool->mutex);\n+    ngx_shmtx_lock(&ctx->shpool->mutex);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_STREAM, lccln->shm_zone->shm.log, 0,\n                    \"limit conn cleanup: %08Xi %d\", node->key, lc->conn);\n \n     lc->conn--;\n \n     if (lc->conn == 0) {\n-        ngx_rbtree_delete(ctx->rbtree, node);\n-        ngx_slab_free_locked(shpool, node);\n+        ngx_rbtree_delete(&ctx->sh->rbtree, node);\n+        ngx_slab_free_locked(ctx->shpool, node);\n     }\n \n-    ngx_shmtx_unlock(&shpool->mutex);\n+    ngx_shmtx_unlock(&ctx->shpool->mutex);\n }\n \n \n@@ -384,8 +420,6 @@ ngx_stream_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n     ngx_stream_limit_conn_ctx_t  *octx = data;\n \n     size_t                        len;\n-    ngx_slab_pool_t              *shpool;\n-    ngx_rbtree_node_t            *sentinel;\n     ngx_stream_limit_conn_ctx_t  *ctx;\n \n     ctx = shm_zone->data;\n@@ -404,48 +438,64 @@ ngx_stream_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n             return NGX_ERROR;\n         }\n \n-        ctx->rbtree = octx->rbtree;\n+        ctx->sh = octx->sh;\n+        ctx->shpool = octx->shpool;\n \n         return NGX_OK;\n     }\n \n-    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n \n     if (shm_zone->shm.exists) {\n-        ctx->rbtree = shpool->data;\n+        ctx->sh = ctx->shpool->data;\n \n         return NGX_OK;\n     }\n \n-    ctx->rbtree = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_t));\n-    if (ctx->rbtree == NULL) {\n+    ctx->sh = ngx_slab_alloc(ctx->shpool,\n+                             sizeof(ngx_stream_limit_conn_shctx_t));\n+    if (ctx->sh == NULL) {\n         return NGX_ERROR;\n     }\n \n-    shpool->data = ctx->rbtree;\n-\n-    sentinel = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_node_t));\n-    if (sentinel == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ctx->shpool->data = ctx->sh;\n \n-    ngx_rbtree_init(ctx->rbtree, sentinel,\n+    ngx_rbtree_init(&ctx->sh->rbtree, &ctx->sh->sentinel,\n                     ngx_stream_limit_conn_rbtree_insert_value);\n \n     len = sizeof(\" in limit_conn_zone \\\"\\\"\") + shm_zone->shm.name.len;\n \n-    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n-    if (shpool->log_ctx == NULL) {\n+    ctx->shpool->log_ctx = ngx_slab_alloc(ctx->shpool, len);\n+    if (ctx->shpool->log_ctx == NULL) {\n         return NGX_ERROR;\n     }\n \n-    ngx_sprintf(shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n+    ngx_sprintf(ctx->shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n                 &shm_zone->shm.name);\n \n     return NGX_OK;\n }\n \n \n+static ngx_int_t\n+ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data)\n+{\n+    if (s->limit_conn_status == 0) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->len = ngx_stream_limit_conn_status[s->limit_conn_status - 1].len;\n+    v->data = ngx_stream_limit_conn_status[s->limit_conn_status - 1].data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static void *\n ngx_stream_limit_conn_create_conf(ngx_conf_t *cf)\n {\n@@ -649,6 +699,25 @@ ngx_stream_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static ngx_int_t\n+ngx_stream_limit_conn_add_variables(ngx_conf_t *cf)\n+{\n+    ngx_stream_variable_t  *var, *v;\n+\n+    for (v = ngx_stream_limit_conn_vars; v->name.len; v++) {\n+        var = ngx_stream_add_variable(cf, &v->name, v->flags);\n+        if (var == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        var->get_handler = v->get_handler;\n+        var->data = v->data;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_stream_limit_conn_init(ngx_conf_t *cf)\n {\n"
    },
    {
        "commit_sha": "35039194b376ab675eb72ef07710c5545bc1448e",
        "commit_index": "Commit 5",
        "commit_diff": "Diff:\n@@ -40,6 +40,7 @@ typedef struct {\n     ngx_array_t                limits;\n     ngx_uint_t                 log_level;\n     ngx_uint_t                 status_code;\n+    ngx_flag_t                 dry_run;\n } ngx_http_limit_conn_conf_t;\n \n \n@@ -102,6 +103,13 @@ static ngx_command_t  ngx_http_limit_conn_commands[] = {\n       offsetof(ngx_http_limit_conn_conf_t, status_code),\n       &ngx_http_limit_conn_status_bounds },\n \n+    { ngx_string(\"limit_conn_dry_run\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_limit_conn_conf_t, dry_run),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -200,6 +208,11 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n             if (node == NULL) {\n                 ngx_shmtx_unlock(&shpool->mutex);\n                 ngx_http_limit_conn_cleanup_all(r->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return lccf->status_code;\n             }\n \n@@ -221,10 +234,16 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n                 ngx_shmtx_unlock(&shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, r->connection->log, 0,\n-                              \"limiting connections by zone \\\"%V\\\"\",\n+                              \"limiting connections%s by zone \\\"%V\\\"\",\n+                              lccf->dry_run ? \", dry run,\" : \"\",\n                               &limits[i].shm_zone->shm.name);\n \n                 ngx_http_limit_conn_cleanup_all(r->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return lccf->status_code;\n             }\n \n@@ -466,6 +485,7 @@ ngx_http_limit_conn_create_conf(ngx_conf_t *cf)\n \n     conf->log_level = NGX_CONF_UNSET_UINT;\n     conf->status_code = NGX_CONF_UNSET_UINT;\n+    conf->dry_run = NGX_CONF_UNSET;\n \n     return conf;\n }\n@@ -485,6 +505,8 @@ ngx_http_limit_conn_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->status_code, prev->status_code,\n                               NGX_HTTP_SERVICE_UNAVAILABLE);\n \n+    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);\n+\n     return NGX_CONF_OK;\n }\n \nDiff:\n@@ -510,7 +510,7 @@ struct ngx_http_request_s {\n     /*\n      * instead of using the request context data in\n      * ngx_http_limit_conn_module and ngx_http_limit_req_module\n-     * we use the single bits in the request structure\n+     * we use the bit fields in the request structure\n      */\n     unsigned                          limit_conn_set:1;\n     unsigned                          limit_req_status:3;\nDiff:\n@@ -39,6 +39,7 @@ typedef struct {\n typedef struct {\n     ngx_array_t                  limits;\n     ngx_uint_t                   log_level;\n+    ngx_flag_t                   dry_run;\n } ngx_stream_limit_conn_conf_t;\n \n \n@@ -89,6 +90,13 @@ static ngx_command_t  ngx_stream_limit_conn_commands[] = {\n       offsetof(ngx_stream_limit_conn_conf_t, log_level),\n       &ngx_stream_limit_conn_log_levels },\n \n+    { ngx_string(\"limit_conn_dry_run\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_limit_conn_conf_t, dry_run),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -178,6 +186,11 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n             if (node == NULL) {\n                 ngx_shmtx_unlock(&shpool->mutex);\n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -199,10 +212,16 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n                 ngx_shmtx_unlock(&shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, s->connection->log, 0,\n-                              \"limiting connections by zone \\\"%V\\\"\",\n+                              \"limiting connections%s by zone \\\"%V\\\"\",\n+                              lccf->dry_run ? \", dry run,\" : \"\",\n                               &limits[i].shm_zone->shm.name);\n \n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -444,6 +463,7 @@ ngx_stream_limit_conn_create_conf(ngx_conf_t *cf)\n      */\n \n     conf->log_level = NGX_CONF_UNSET_UINT;\n+    conf->dry_run = NGX_CONF_UNSET;\n \n     return conf;\n }\n@@ -461,6 +481,8 @@ ngx_stream_limit_conn_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_uint_value(conf->log_level, prev->log_level, NGX_LOG_ERR);\n \n+    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);\n+\n     return NGX_CONF_OK;\n }\n \n"
    },
    {
        "commit_sha": "475e33bb70ab29a35ac96aad47b33806449b4ac0",
        "commit_index": "Commit 4",
        "commit_diff": "Diff:\n@@ -40,6 +40,10 @@ typedef struct {\n } ngx_proxy_protocol_inet6_addrs_t;\n \n \n+static u_char *ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p,\n+    u_char *last, ngx_str_t *addr);\n+static u_char *ngx_proxy_protocol_read_port(u_char *p, u_char *last,\n+    in_port_t *port, u_char sep);\n static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n \n@@ -48,8 +52,7 @@ u_char *\n ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n {\n     size_t                 len;\n-    u_char                 ch, *p, *addr, *port;\n-    ngx_int_t              n;\n+    u_char                *p;\n     ngx_proxy_protocol_t  *pp;\n \n     static const u_char signature[] = \"\\r\\n\\r\\n\\0\\r\\nQUIT\\n\";\n@@ -84,11 +87,77 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     }\n \n     p += 5;\n-    addr = p;\n+\n+    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n+    if (pp == NULL) {\n+        return NULL;\n+    }\n+\n+    p = ngx_proxy_protocol_read_addr(c, p, last, &pp->src_addr);\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    p = ngx_proxy_protocol_read_addr(c, p, last, &pp->dst_addr);\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    p = ngx_proxy_protocol_read_port(p, last, &pp->src_port, ' ');\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    p = ngx_proxy_protocol_read_port(p, last, &pp->dst_port, CR);\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    if (p == last) {\n+        goto invalid;\n+    }\n+\n+    if (*p++ != LF) {\n+        goto invalid;\n+    }\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol src: %V %d, dst: %V %d\",\n+                   &pp->src_addr, pp->src_port, &pp->dst_addr, pp->dst_port);\n+\n+    c->proxy_protocol = pp;\n+\n+    return p;\n+\n+skip:\n+\n+    for ( /* void */ ; p < last - 1; p++) {\n+        if (p[0] == CR && p[1] == LF) {\n+            return p + 2;\n+        }\n+    }\n+\n+invalid:\n+\n+    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                  \"broken header: \\\"%*s\\\"\", (size_t) (last - buf), buf);\n+\n+    return NULL;\n+}\n+\n+\n+static u_char *\n+ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p, u_char *last,\n+    ngx_str_t *addr)\n+{\n+    size_t  len;\n+    u_char  ch, *pos;\n+\n+    pos = p;\n \n     for ( ;; ) {\n         if (p == last) {\n-            goto invalid;\n+            return NULL;\n         }\n \n         ch = *p++;\n@@ -102,77 +171,54 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n             && (ch < 'A' || ch > 'F')\n             && (ch < '0' || ch > '9'))\n         {\n-            goto invalid;\n+            return NULL;\n         }\n     }\n \n-    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n-    if (pp == NULL) {\n-        return NULL;\n-    }\n-\n-    len = p - addr - 1;\n+    len = p - pos - 1;\n \n-    pp->src_addr.data = ngx_pnalloc(c->pool, len);\n-    if (pp->src_addr.data == NULL) {\n+    addr->data = ngx_pnalloc(c->pool, len);\n+    if (addr->data == NULL) {\n         return NULL;\n     }\n \n-    ngx_memcpy(pp->src_addr.data, addr, len);\n-    pp->src_addr.len = len;\n+    ngx_memcpy(addr->data, pos, len);\n+    addr->len = len;\n \n-    for ( ;; ) {\n-        if (p == last) {\n-            goto invalid;\n-        }\n+    return p;\n+}\n \n-        if (*p++ == ' ') {\n-            break;\n-        }\n-    }\n \n-    port = p;\n+static u_char *\n+ngx_proxy_protocol_read_port(u_char *p, u_char *last, in_port_t *port,\n+    u_char sep)\n+{\n+    size_t      len;\n+    u_char     *pos;\n+    ngx_int_t   n;\n+\n+    pos = p;\n \n     for ( ;; ) {\n         if (p == last) {\n-            goto invalid;\n+            return NULL;\n         }\n \n-        if (*p++ == ' ') {\n+        if (*p++ == sep) {\n             break;\n         }\n     }\n \n-    len = p - port - 1;\n-\n-    n = ngx_atoi(port, len);\n+    len = p - pos - 1;\n \n+    n = ngx_atoi(pos, len);\n     if (n < 0 || n > 65535) {\n-        goto invalid;\n-    }\n-\n-    pp->src_port = (in_port_t) n;\n-\n-    ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol address: %V %d\", &pp->src_addr,\n-                   pp->src_port);\n-\n-    c->proxy_protocol = pp;\n-\n-skip:\n-\n-    for ( /* void */ ; p < last - 1; p++) {\n-        if (p[0] == CR && p[1] == LF) {\n-            return p + 2;\n-        }\n+        return NULL;\n     }\n \n-invalid:\n-\n-    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n-                  \"broken header: \\\"%*s\\\"\", (size_t) (last - buf), buf);\n+    *port = (in_port_t) n;\n \n-    return NULL;\n+    return p;\n }\n \n \n@@ -227,7 +273,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     size_t                              len;\n     socklen_t                           socklen;\n     ngx_uint_t                          version, command, family, transport;\n-    ngx_sockaddr_t                      sockaddr;\n+    ngx_sockaddr_t                      src_sockaddr, dst_sockaddr;\n     ngx_proxy_protocol_t               *pp;\n     ngx_proxy_protocol_header_t        *header;\n     ngx_proxy_protocol_inet_addrs_t    *in;\n@@ -292,11 +338,16 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         in = (ngx_proxy_protocol_inet_addrs_t *) buf;\n \n-        sockaddr.sockaddr_in.sin_family = AF_INET;\n-        sockaddr.sockaddr_in.sin_port = 0;\n-        memcpy(&sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n+        src_sockaddr.sockaddr_in.sin_family = AF_INET;\n+        src_sockaddr.sockaddr_in.sin_port = 0;\n+        memcpy(&src_sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n+\n+        dst_sockaddr.sockaddr_in.sin_family = AF_INET;\n+        dst_sockaddr.sockaddr_in.sin_port = 0;\n+        memcpy(&dst_sockaddr.sockaddr_in.sin_addr, in->dst_addr, 4);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n+        pp->dst_port = ngx_proxy_protocol_parse_uint16(in->dst_port);\n \n         socklen = sizeof(struct sockaddr_in);\n \n@@ -314,11 +365,16 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         in6 = (ngx_proxy_protocol_inet6_addrs_t *) buf;\n \n-        sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n-        sockaddr.sockaddr_in6.sin6_port = 0;\n-        memcpy(&sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n+        src_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n+        src_sockaddr.sockaddr_in6.sin6_port = 0;\n+        memcpy(&src_sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n+\n+        dst_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n+        dst_sockaddr.sockaddr_in6.sin6_port = 0;\n+        memcpy(&dst_sockaddr.sockaddr_in6.sin6_addr, in6->dst_addr, 16);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n+        pp->dst_port = ngx_proxy_protocol_parse_uint16(in6->dst_port);\n \n         socklen = sizeof(struct sockaddr_in6);\n \n@@ -340,12 +396,20 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         return NULL;\n     }\n \n-    pp->src_addr.len = ngx_sock_ntop(&sockaddr.sockaddr, socklen,\n+    pp->src_addr.len = ngx_sock_ntop(&src_sockaddr.sockaddr, socklen,\n                                      pp->src_addr.data, NGX_SOCKADDR_STRLEN, 0);\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol v2 address: %V %d\", &pp->src_addr,\n-                   pp->src_port);\n+    pp->dst_addr.data = ngx_pnalloc(c->pool, NGX_SOCKADDR_STRLEN);\n+    if (pp->dst_addr.data == NULL) {\n+        return NULL;\n+    }\n+\n+    pp->dst_addr.len = ngx_sock_ntop(&dst_sockaddr.sockaddr, socklen,\n+                                     pp->dst_addr.data, NGX_SOCKADDR_STRLEN, 0);\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol v2 src: %V %d, dst: %V %d\",\n+                   &pp->src_addr, pp->src_port, &pp->dst_addr, pp->dst_port);\n \n     if (buf < end) {\n         ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\nDiff:\n@@ -18,7 +18,9 @@\n \n struct ngx_proxy_protocol_s {\n     ngx_str_t           src_addr;\n+    ngx_str_t           dst_addr;\n     in_port_t           src_port;\n+    in_port_t           dst_port;\n };\n \n \nDiff:\n@@ -10,6 +10,13 @@\n #include <ngx_http.h>\n \n \n+#define NGX_HTTP_LIMIT_REQ_PASSED            1\n+#define NGX_HTTP_LIMIT_REQ_DELAYED           2\n+#define NGX_HTTP_LIMIT_REQ_REJECTED          3\n+#define NGX_HTTP_LIMIT_REQ_DELAYED_DRY_RUN   4\n+#define NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN  5\n+\n+\n typedef struct {\n     u_char                       color;\n     u_char                       dummy;\n@@ -65,13 +72,16 @@ static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits,\n static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx,\n     ngx_uint_t n);\n \n+static ngx_int_t ngx_http_limit_req_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf);\n static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf, void *parent,\n     void *child);\n static char *ngx_http_limit_req_zone(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static ngx_int_t ngx_http_limit_req_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf);\n \n \n@@ -131,7 +141,7 @@ static ngx_command_t  ngx_http_limit_req_commands[] = {\n \n \n static ngx_http_module_t  ngx_http_limit_req_module_ctx = {\n-    NULL,                                  /* preconfiguration */\n+    ngx_http_limit_req_add_variables,      /* preconfiguration */\n     ngx_http_limit_req_init,               /* postconfiguration */\n \n     NULL,                                  /* create main configuration */\n@@ -161,6 +171,24 @@ ngx_module_t  ngx_http_limit_req_module = {\n };\n \n \n+static ngx_http_variable_t  ngx_http_limit_req_vars[] = {\n+\n+    { ngx_string(\"limit_req_status\"), NULL,\n+      ngx_http_limit_req_status_variable, 0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n+\n+      ngx_http_null_variable\n+};\n+\n+\n+static ngx_str_t  ngx_http_limit_req_status[] = {\n+    ngx_string(\"PASSED\"),\n+    ngx_string(\"DELAYED\"),\n+    ngx_string(\"REJECTED\"),\n+    ngx_string(\"DELAYED_DRY_RUN\"),\n+    ngx_string(\"REJECTED_DRY_RUN\")\n+};\n+\n+\n static ngx_int_t\n ngx_http_limit_req_handler(ngx_http_request_t *r)\n {\n@@ -173,7 +201,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n     ngx_http_limit_req_conf_t   *lrcf;\n     ngx_http_limit_req_limit_t  *limit, *limits;\n \n-    if (r->main->limit_req_set) {\n+    if (r->main->limit_req_status) {\n         return NGX_DECLINED;\n     }\n \n@@ -232,8 +260,6 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    r->main->limit_req_set = 1;\n-\n     if (rc == NGX_BUSY || rc == NGX_ERROR) {\n \n         if (rc == NGX_BUSY) {\n@@ -261,9 +287,12 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n         }\n \n         if (lrcf->dry_run) {\n+            r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN;\n             return NGX_DECLINED;\n         }\n \n+        r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_REJECTED;\n+\n         return lrcf->status_code;\n     }\n \n@@ -276,6 +305,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n     delay = ngx_http_limit_req_account(limits, n, &excess, &limit);\n \n     if (!delay) {\n+        r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_PASSED;\n         return NGX_DECLINED;\n     }\n \n@@ -285,9 +315,12 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n                   excess / 1000, excess % 1000, &limit->shm_zone->shm.name);\n \n     if (lrcf->dry_run) {\n+        r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_DELAYED_DRY_RUN;\n         return NGX_DECLINED;\n     }\n \n+    r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_DELAYED;\n+\n     if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n@@ -711,6 +744,25 @@ ngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_req_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    if (r->main->limit_req_status == 0) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->len = ngx_http_limit_req_status[r->main->limit_req_status - 1].len;\n+    v->data = ngx_http_limit_req_status[r->main->limit_req_status - 1].data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static void *\n ngx_http_limit_req_create_conf(ngx_conf_t *cf)\n {\n@@ -995,6 +1047,25 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_req_add_variables(ngx_conf_t *cf)\n+{\n+    ngx_http_variable_t  *var, *v;\n+\n+    for (v = ngx_http_limit_req_vars; v->name.len; v++) {\n+        var = ngx_http_add_variable(cf, &v->name, v->flags);\n+        if (var == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        var->get_handler = v->get_handler;\n+        var->data = v->data;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_limit_req_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -513,7 +513,7 @@ struct ngx_http_request_s {\n      * we use the single bits in the request structure\n      */\n     unsigned                          limit_conn_set:1;\n-    unsigned                          limit_req_set:1;\n+    unsigned                          limit_req_status:3;\n \n     unsigned                          limit_rate_set:1;\n     unsigned                          limit_rate_after_set:1;\nDiff:\n@@ -203,10 +203,20 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n     { ngx_string(\"remote_port\"), NULL, ngx_http_variable_remote_port, 0, 0, 0 },\n \n     { ngx_string(\"proxy_protocol_addr\"), NULL,\n-      ngx_http_variable_proxy_protocol_addr, 0, 0, 0 },\n+      ngx_http_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, src_addr), 0, 0 },\n \n     { ngx_string(\"proxy_protocol_port\"), NULL,\n-      ngx_http_variable_proxy_protocol_port, 0, 0, 0 },\n+      ngx_http_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, src_port), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_addr\"), NULL,\n+      ngx_http_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, dst_addr), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_port\"), NULL,\n+      ngx_http_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n     { ngx_string(\"server_addr\"), NULL, ngx_http_variable_server_addr, 0, 0, 0 },\n \n@@ -1303,6 +1313,7 @@ static ngx_int_t\n ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    ngx_str_t             *addr;\n     ngx_proxy_protocol_t  *pp;\n \n     pp = r->connection->proxy_protocol;\n@@ -1311,11 +1322,13 @@ ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    v->len = pp->src_addr.len;\n+    addr = (ngx_str_t *) ((char *) pp + data);\n+\n+    v->len = addr->len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = pp->src_addr.data;\n+    v->data = addr->data;\n \n     return NGX_OK;\n }\n@@ -1344,7 +1357,7 @@ ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    port = pp->src_port;\n+    port = *(in_port_t *) ((char *) pp + data);\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\nDiff:\n@@ -64,10 +64,20 @@ static ngx_stream_variable_t  ngx_stream_core_variables[] = {\n       ngx_stream_variable_remote_port, 0, 0, 0 },\n \n     { ngx_string(\"proxy_protocol_addr\"), NULL,\n-      ngx_stream_variable_proxy_protocol_addr, 0, 0, 0 },\n+      ngx_stream_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, src_addr), 0, 0 },\n \n     { ngx_string(\"proxy_protocol_port\"), NULL,\n-      ngx_stream_variable_proxy_protocol_port, 0, 0, 0 },\n+      ngx_stream_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, src_port), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_addr\"), NULL,\n+      ngx_stream_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, dst_addr), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_port\"), NULL,\n+      ngx_stream_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n     { ngx_string(\"server_addr\"), NULL,\n       ngx_stream_variable_server_addr, 0, 0, 0 },\n@@ -557,6 +567,7 @@ static ngx_int_t\n ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n {\n+    ngx_str_t             *addr;\n     ngx_proxy_protocol_t  *pp;\n \n     pp = s->connection->proxy_protocol;\n@@ -565,11 +576,13 @@ ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,\n         return NGX_OK;\n     }\n \n-    v->len = pp->src_addr.len;\n+    addr = (ngx_str_t *) ((char *) pp + data);\n+\n+    v->len = addr->len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = pp->src_addr.data;\n+    v->data = addr->data;\n \n     return NGX_OK;\n }\n@@ -598,7 +611,7 @@ ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n         return NGX_ERROR;\n     }\n \n-    port = pp->src_port;\n+    port = *(in_port_t *) ((char *) pp + data);\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\n"
    },
    {
        "commit_sha": "35e78dc9230f5636deda2776800dbbde8c4ac490",
        "commit_index": "Commit 3",
        "commit_diff": "Diff:\n@@ -147,8 +147,7 @@ struct ngx_connection_s {\n     socklen_t           socklen;\n     ngx_str_t           addr_text;\n \n-    ngx_str_t           proxy_protocol_addr;\n-    in_port_t           proxy_protocol_port;\n+    ngx_proxy_protocol_t  *proxy_protocol;\n \n #if (NGX_SSL || NGX_COMPAT)\n     ngx_ssl_connection_t  *ssl;\nDiff:\n@@ -26,6 +26,7 @@ typedef struct ngx_event_aio_s       ngx_event_aio_t;\n typedef struct ngx_connection_s      ngx_connection_t;\n typedef struct ngx_thread_task_s     ngx_thread_task_t;\n typedef struct ngx_ssl_s             ngx_ssl_t;\n+typedef struct ngx_proxy_protocol_s  ngx_proxy_protocol_t;\n typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t;\n typedef struct ngx_udp_connection_s  ngx_udp_connection_t;\n \nDiff:\n@@ -47,9 +47,10 @@ static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,\n u_char *\n ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n {\n-    size_t     len;\n-    u_char     ch, *p, *addr, *port;\n-    ngx_int_t  n;\n+    size_t                 len;\n+    u_char                 ch, *p, *addr, *port;\n+    ngx_int_t              n;\n+    ngx_proxy_protocol_t  *pp;\n \n     static const u_char signature[] = \"\\r\\n\\r\\n\\0\\r\\nQUIT\\n\";\n \n@@ -105,15 +106,20 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         }\n     }\n \n+    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n+    if (pp == NULL) {\n+        return NULL;\n+    }\n+\n     len = p - addr - 1;\n-    c->proxy_protocol_addr.data = ngx_pnalloc(c->pool, len);\n \n-    if (c->proxy_protocol_addr.data == NULL) {\n+    pp->src_addr.data = ngx_pnalloc(c->pool, len);\n+    if (pp->src_addr.data == NULL) {\n         return NULL;\n     }\n \n-    ngx_memcpy(c->proxy_protocol_addr.data, addr, len);\n-    c->proxy_protocol_addr.len = len;\n+    ngx_memcpy(pp->src_addr.data, addr, len);\n+    pp->src_addr.len = len;\n \n     for ( ;; ) {\n         if (p == last) {\n@@ -145,11 +151,13 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         goto invalid;\n     }\n \n-    c->proxy_protocol_port = (in_port_t) n;\n+    pp->src_port = (in_port_t) n;\n \n     ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol address: %V %d\", &c->proxy_protocol_addr,\n-                   c->proxy_protocol_port);\n+                   \"PROXY protocol address: %V %d\", &pp->src_addr,\n+                   pp->src_port);\n+\n+    c->proxy_protocol = pp;\n \n skip:\n \n@@ -220,6 +228,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     socklen_t                           socklen;\n     ngx_uint_t                          version, command, family, transport;\n     ngx_sockaddr_t                      sockaddr;\n+    ngx_proxy_protocol_t               *pp;\n     ngx_proxy_protocol_header_t        *header;\n     ngx_proxy_protocol_inet_addrs_t    *in;\n #if (NGX_HAVE_INET6)\n@@ -266,6 +275,11 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         return end;\n     }\n \n+    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n+    if (pp == NULL) {\n+        return NULL;\n+    }\n+\n     family = header->family_transport >> 4;\n \n     switch (family) {\n@@ -282,7 +296,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         sockaddr.sockaddr_in.sin_port = 0;\n         memcpy(&sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n \n-        c->proxy_protocol_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n+        pp->src_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n \n         socklen = sizeof(struct sockaddr_in);\n \n@@ -304,7 +318,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         sockaddr.sockaddr_in6.sin6_port = 0;\n         memcpy(&sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n \n-        c->proxy_protocol_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n+        pp->src_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n \n         socklen = sizeof(struct sockaddr_in6);\n \n@@ -321,23 +335,24 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         return end;\n     }\n \n-    c->proxy_protocol_addr.data = ngx_pnalloc(c->pool, NGX_SOCKADDR_STRLEN);\n-    if (c->proxy_protocol_addr.data == NULL) {\n+    pp->src_addr.data = ngx_pnalloc(c->pool, NGX_SOCKADDR_STRLEN);\n+    if (pp->src_addr.data == NULL) {\n         return NULL;\n     }\n \n-    c->proxy_protocol_addr.len = ngx_sock_ntop(&sockaddr.sockaddr, socklen,\n-                                               c->proxy_protocol_addr.data,\n-                                               NGX_SOCKADDR_STRLEN, 0);\n+    pp->src_addr.len = ngx_sock_ntop(&sockaddr.sockaddr, socklen,\n+                                     pp->src_addr.data, NGX_SOCKADDR_STRLEN, 0);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol v2 address: %V %d\", &c->proxy_protocol_addr,\n-                   c->proxy_protocol_port);\n+                   \"PROXY protocol v2 address: %V %d\", &pp->src_addr,\n+                   pp->src_port);\n \n     if (buf < end) {\n         ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n                        \"PROXY protocol v2 %z bytes of tlv ignored\", end - buf);\n     }\n \n+    c->proxy_protocol = pp;\n+\n     return end;\n }\nDiff:\n@@ -16,6 +16,12 @@\n #define NGX_PROXY_PROTOCOL_MAX_HEADER  107\n \n \n+struct ngx_proxy_protocol_s {\n+    ngx_str_t           src_addr;\n+    in_port_t           src_port;\n+};\n+\n+\n u_char *ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n u_char *ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf,\nDiff:\n@@ -180,12 +180,11 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n \n     case NGX_HTTP_REALIP_PROXY:\n \n-        value = &r->connection->proxy_protocol_addr;\n-\n-        if (value->len == 0) {\n+        if (r->connection->proxy_protocol == NULL) {\n             return NGX_DECLINED;\n         }\n \n+        value = &r->connection->proxy_protocol->src_addr;\n         xfwd = NULL;\n \n         break;\n@@ -238,7 +237,7 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n         != NGX_DECLINED)\n     {\n         if (rlcf->type == NGX_HTTP_REALIP_PROXY) {\n-            ngx_inet_set_port(addr.sockaddr, c->proxy_protocol_port);\n+            ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n         }\n \n         return ngx_http_realip_set_addr(r, &addr);\nDiff:\n@@ -1303,11 +1303,19 @@ static ngx_int_t\n ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    v->len = r->connection->proxy_protocol_addr.len;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = r->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = pp->src_addr.len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = r->connection->proxy_protocol_addr.data;\n+    v->data = pp->src_addr.data;\n \n     return NGX_OK;\n }\n@@ -1317,7 +1325,14 @@ static ngx_int_t\n ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    ngx_uint_t  port;\n+    ngx_uint_t             port;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = r->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n \n     v->len = 0;\n     v->valid = 1;\n@@ -1329,7 +1344,7 @@ ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    port = r->connection->proxy_protocol_port;\n+    port = pp->src_port;\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\nDiff:\n@@ -108,22 +108,22 @@ ngx_stream_realip_handler(ngx_stream_session_t *s)\n \n     c = s->connection;\n \n-    if (c->proxy_protocol_addr.len == 0) {\n+    if (c->proxy_protocol == NULL) {\n         return NGX_DECLINED;\n     }\n \n     if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) {\n         return NGX_DECLINED;\n     }\n \n-    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol_addr.data,\n-                       c->proxy_protocol_addr.len)\n+    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data,\n+                       c->proxy_protocol->src_addr.len)\n         != NGX_OK)\n     {\n         return NGX_DECLINED;\n     }\n \n-    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol_port);\n+    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n \n     return ngx_stream_realip_set_addr(s, &addr);\n }\nDiff:\n@@ -557,11 +557,19 @@ static ngx_int_t\n ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n {\n-    v->len = s->connection->proxy_protocol_addr.len;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = s->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = pp->src_addr.len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = s->connection->proxy_protocol_addr.data;\n+    v->data = pp->src_addr.data;\n \n     return NGX_OK;\n }\n@@ -571,7 +579,14 @@ static ngx_int_t\n ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n {\n-    ngx_uint_t  port;\n+    ngx_uint_t             port;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = s->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n \n     v->len = 0;\n     v->valid = 1;\n@@ -583,7 +598,7 @@ ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n         return NGX_ERROR;\n     }\n \n-    port = s->connection->proxy_protocol_port;\n+    port = pp->src_port;\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\n"
    },
    {
        "commit_sha": "f22cdc4466bb54c2160d62f0256463c4f848df84",
        "commit_index": "Commit 2",
        "commit_diff": "Diff:\n@@ -443,3 +443,4 @@ d2fd76709909767fc727a5b4affcf1dc9ca488a7 release-1.15.9\n 2fc9f853a6b7cd29dc84e0af2ed3cf78e0da6ca8 release-1.17.2\n ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n+9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\nDiff:\n@@ -5,6 +5,69 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.5\" date=\"2019-10-22\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь nginx использует вызов ioctl(FIONREAD), если он доступен,\n+чтобы избежать чтения из быстрого соединения в течение долгого времени.\n+</para>\n+<para lang=\"en\">\n+now nginx uses ioctl(FIONREAD), if available,\n+to avoid reading from a fast connection for a long time.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+неполные закодированные символы в конце URI запроса игнорировались.\n+</para>\n+<para lang=\"en\">\n+incomplete escaped characters at the end of the request URI were ignored.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+\"/.\" и \"/..\" в конце URI запроса не нормализовывались.\n+</para>\n+<para lang=\"en\">\n+\"/.\" and \"/..\" at the end of the request URI were not normalized.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве merge_slashes.\n+</para>\n+<para lang=\"en\">\n+in the \"merge_slashes\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве ignore_invalid_headers.<br/>\n+Спасибо Alan Kemp.\n+</para>\n+<para lang=\"en\">\n+in the \"ignore_invalid_headers\" directive.<br/>\n+Thanks to Alan Kemp.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не собирался с MinGW-w64 gcc 8.1 и новее.\n+</para>\n+<para lang=\"en\">\n+nginx could not be built with MinGW-w64 gcc 8.1 or newer.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.4\" date=\"2019-09-24\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017005\n-#define NGINX_VERSION      \"1.17.5\"\n+#define nginx_version      1017006\n+#define NGINX_VERSION      \"1.17.6\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n"
    },
    {
        "commit_sha": "9c5e32dcd9779c4cfe48c5377d0af8adc52a2be9",
        "commit_index": "Commit 1",
        "commit_diff": "Diff:\n@@ -1228,6 +1228,13 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\n     } else {\n         e->buf.len = e->pos - e->buf.data;\n \n+        if (e->buf.len > 2000) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"the rewritten URI is too long\");\n+            e->ip = ngx_http_script_exit;\n+            e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n         if (!code->add_args) {\n             r->args.len = 0;\n         }\nDiff:\n@@ -22,7 +22,7 @@ ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n     len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                         NULL, err, lang, (char *) errstr, size, NULL);\n \n-    if (len == 0 && lang && GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND) {\n+    if (len == 0 && lang) {\n \n         /*\n          * Try to use English messages first and fallback to a language,\nDiff:\n@@ -240,7 +240,7 @@ ngx_os_init(ngx_log_t *log)\n         goto nopoll;\n     }\n \n-    WSAPoll = (ngx_wsapoll_pt) GetProcAddress(hmod, \"WSAPoll\");\n+    WSAPoll = (ngx_wsapoll_pt) (void *) GetProcAddress(hmod, \"WSAPoll\");\n     if (WSAPoll == NULL) {\n         ngx_log_error(NGX_LOG_NOTICE, log, ngx_errno,\n                       \"GetProcAddress(\\\"WSAPoll\\\") failed\");\n"
    },
    {
        "commit_sha": "c498a935699a24720cc8857a48d0ce999e1aa6bb",
        "commit_index": "Initial Commit",
        "commit_diff": "Diff:\n@@ -0,0 +1,445 @@\n+551102312e19b704cd22bd7254a9444b9ea14e96 release-0.1.0\n+23fb87bddda14ce9faec90f774085634106aded4 release-0.1.1\n+295d97d70c698585705345f1a8f92b02e63d6d0d release-0.1.2\n+ded1284520cc939ad5ae6ddab39925375e64237d release-0.1.3\n+0491b909ef7612d8411f1f59054186c1f3471b52 release-0.1.4\n+a88a3e4e158fade0aaa6f3eb25597d5ced2c1075 release-0.1.5\n+1f31dc6d33a3a4e65240b08066bf186df9e33b79 release-0.1.6\n+5aecc125bc33d81d6214c91d73eb44230a903dde release-0.1.7\n+bbd6b0b4a2b15ef8c8f1aaf7b027b6da47303524 release-0.1.8\n+2ff194b74f1e60cd04670986973e3b1a6aa3bece release-0.1.9\n+31ee1b50354fb829564b81a6f34e8d6ceb2d3f48 release-0.1.10\n+8e8f3af115b5b903b2b8f3335de971f18891246f release-0.1.11\n+c3c2848fc081e19aec5ffa97e468ad20ddb81df0 release-0.1.12\n+ad1e9ebf93bb5ae4c748d471fad2de8a0afc4d2a release-0.1.13\n+c5240858380136a67bec261c59b1532560b57885 release-0.1.14\n+fd661d14a7fad212e326a7dad6234ea0de992fbf release-0.1.15\n+621229427cba1b0af417ff2a101fc4f17a7d93c8 release-0.1.16\n+4ebe09b07e3021f1a63b459903ec58f162183b26 release-0.1.17\n+31ff3e943e1675a2caf745ba7a981244445d4c98 release-0.1.18\n+45a460f82aec80b0f61136aa09f412436d42203a release-0.1.19\n+0f836f0288eee4980f57736d50a7a60fa082d8e9 release-0.1.20\n+975f62e77f0244f1b631f740be77c72c8f2da1de release-0.1.21\n+fc9909c369b2b4716304ac8e38da57b8fb781211 release-0.1.22\n+d7c90bb5ce83dab08715e98f9c7b81c7df4b37be release-0.1.23\n+64d9afb209da0cd4a917202b7b77e51cc23e2229 release-0.1.24\n+d4ea69372b946dc4ec37fc3f5ddd93ff7c3da675 release-0.1.25\n+b1648294f6935e993e436fd8a68bca75c74c826d release-0.1.26\n+ee66921ecd47a7fa459f70f4a9d660f91f6a1b94 release-0.1.27\n+cd3117ad9aab9c58c6f7e677e551e1adbdeaba54 release-0.1.28\n+9b8c906f6e63ec2c71cecebfff35819a7d32227d release-0.1.29\n+c12967aadd8726daf2d85e3f3e622d89c42db176 release-0.1.30\n+fbbf16224844e7d560c00043e8ade8a560415bba release-0.1.31\n+417a087c9c4d9abb9b0b9b3f787aff515c43c035 release-0.1.32\n+dadfa78d227027348d7f9d1e7b7093d06ba545a0 release-0.1.33\n+12234c998d83bfbbaa305273b3dd1b855ca325dc release-0.1.34\n+6f00349b98e5f706b82115c6e4dc84456fc0d770 release-0.1.35\n+2019117e6b38cc3e89fe4f56a23b271479c627a6 release-0.1.36\n+09b42134ac0c42625340f16628e29690a04f8db5 release-0.1.37\n+7fa11e5c6e9612ecff5eb58274cc846ae742d1d2 release-0.1.38\n+e5d7d0334fdb946133c17523c198800142ac9fe9 release-0.1.39\n+c3bd8cdabb8f73e5600a91f198eb7df6fac65e92 release-0.1.40\n+d6e48c08d718bf5a9e58c20a37e8ae172bff1139 release-0.1.41\n+563ad09abf5042eb41e8ecaf5b4e6c9deaa42731 release-0.1.42\n+c9ad0d9c7d59b2fa2a5fe669f1e88debd03e6c04 release-0.1.43\n+371c1cee100d7a1b0e6cad4d188e05c98a641ee7 release-0.1.44\n+b09ee85d0ac823e36861491eedfc4dfafe282997 release-0.1.45\n+511a89da35ada16ae806667d699f9610b4f8499a release-0.2.0\n+0148586012ab3dde69b394ec5a389d44bb11c869 release-0.2.1\n+818fbd4750b99d14d2736212c939855a11b1f1ef release-0.2.2\n+e16a8d574da511622b97d6237d005f40f2cddb30 release-0.2.3\n+483cca23060331f2078b1c2984870d80f288ad41 release-0.2.4\n+45033d85b30e3f12c407b7cfc518d76e0eda0263 release-0.2.5\n+7bd37aef1e7e87858c12b124e253e98558889b50 release-0.2.6\n+ecd9c160f25b7a7075dd93383d98a0fc8d8c0a41 release-0.3.0\n+c1f965ef97188fd7ef81342dcf8719da18c554d2 release-0.3.1\n+e48ebafc69393fc94fecfdf9997c4179fd1ce473 release-0.3.2\n+9c2f3ed7a24711d3b42b124d5f831155c8beff95 release-0.3.3\n+7c1369d37c7eb0017c28ebcaa0778046f5aafdcc release-0.3.4\n+1af2fcb3be8a63796b6b23a488049c92a6bc12f4 release-0.3.5\n+174f1e853e1e831b01000aeccfd06a9c8d4d95a2 release-0.3.6\n+458b6c3fea65a894c99dd429334a77bb164c7e83 release-0.3.7\n+58475592100cb792c125101b6d2d898f5adada30 release-0.3.8\n+fcd6fc7ff7f9b132c35193d834e6e7d05026c716 release-0.3.9\n+4d9ea73a627a914d364e83e20c58eb1283f4031d release-0.3.10\n+4c5c2c55975c1152b5ca5d5d55b32d4dd7945f7a release-0.3.11\n+326634fb9d47912ad94221dc2f8fa4bec424d40c release-0.3.12\n+4e296b7d25bf62390ca2afb599e395426b94f785 release-0.3.13\n+401de5a43ba5a8acdb9c52465193c0ea7354afe7 release-0.3.14\n+284cc140593bb16ac71094acd509ab415ff4837d release-0.3.15\n+d4e858a5751a7fd08e64586795ed7d336011fbc0 release-0.3.16\n+8c0cdd81580eb76d774cfc5724de68e7e5cbbdc2 release-0.3.17\n+425af804d968f30eeff01e33b808bc2e8c467f2c release-0.3.18\n+ebc68d8ca4962fe3531b7e13444f7ac4395d9c6e release-0.3.19\n+9262f520ce214d3d5fd7c842891519336ef85ca6 release-0.3.20\n+869b6444d2341a587183859d4df736c7f3381169 release-0.3.21\n+77f77f53214a0e3a68fef8226c15532b54f2c365 release-0.3.22\n+858700ae46b453ea111b966b6d03f2c21ddcb94e release-0.3.23\n+5dac8c7fb71b86aafed8ea352305e7f85759f72e release-0.3.24\n+77cdfe394a94a625955e7585e09983b3af9b889b release-0.3.25\n+608cf78b24ef7baaf9705e4715a361f26bb16ba9 release-0.3.26\n+3f8a2132b93d66ac19bec006205a304a68524a0b release-0.3.27\n+c73c5c58c619c22dd3a5a26c91bb0567a62c6930 release-0.3.28\n+5ef026a2ac7481f04154f29ab49377bf99aaf96f release-0.3.29\n+51b27717f140b71a2e9158807d79da17c888ce4c release-0.3.30\n+7a16e281c01f1c7ab3b79c64b43ddb754ea7935e release-0.3.31\n+93e85a79757c49d502e42a1cb8264a0f133b0b00 release-0.3.32\n+0216fd1471f386168545f772836156761eddec08 release-0.3.33\n+fbed40ce7cb4fd7203fecc22a617b9ce5b950fb3 release-0.3.34\n+387450de0b4d21652f0b6242a5e26a31e3be8d8c release-0.3.35\n+65bf042c0b4f39f18a235464c52f980e9fa24f6b release-0.3.36\n+5d2b8078c1c2593b95ec50acfeeafbefa65be344 release-0.3.37\n+f971949ffb585d400e0f15508a56232a0f897c80 release-0.3.38\n+18268abd340cb351e0c01b9c44e9f8cc05492364 release-0.3.39\n+e60fe4cf1d4ea3c34be8c49047c712c6d46c1727 release-0.3.40\n+715d243270806d38be776fc3ed826d97514a73d6 release-0.3.41\n+5e8fb59c18c19347a5607fb5af075fe1e2925b9a release-0.3.42\n+947c6fd27699e0199249ad592151f844c8a900b0 release-0.3.43\n+4946078f0a79e6cc952d3e410813aac9b8bda650 release-0.3.44\n+95d7da23ea5315a6e9255ce036ed2c51f091f180 release-0.3.45\n+1e720b0be7ecd92358da8a60944669fa493e78cd release-0.3.46\n+39b7d7b33c918d8f4abc86c4075052d8c19da3c7 release-0.3.47\n+7cbef16c71a1f43a07f8141f02e0135c775f0f5b release-0.3.48\n+4c8cd5ae5cc100add5c08c252d991b82b1838c6b release-0.3.49\n+400711951595aef7cd2ef865b84b31df52b15782 release-0.3.50\n+649c9063d0fda23620eaeaf0f6393be0a672ebe7 release-0.3.51\n+9079ee4735aefa98165bb2cb26dee4f58d58c1d7 release-0.3.52\n+6d5c1535bb9dcd891c5963971f767421a334a728 release-0.3.53\n+5fd7a5e990477189c40718c8c3e01002a2c20b81 release-0.3.54\n+63a820b0bc6ca629c8e45a069b52d622ddc27a2d release-0.3.55\n+562806624c4afb1687cba83bc1852f5d0fecbac3 release-0.3.56\n+cec32b3753acf610ac1a6227d14032c1a89d6319 release-0.3.57\n+b80f94fa2197b99db5e033fec92e0426d1fe5026 release-0.3.58\n+e924670896abe2769ea0fcfd2058b405bed8e8ec release-0.3.59\n+921a7ce4baf42fd1091b7e40f89c858c6b23053e release-0.3.60\n+df95dcff753a6dc5e94257302aea02c18c7a7c87 release-0.3.61\n+7e24168b0853ee7e46c9c7b943ef077dc64f17f5 release-0.4.0\n+8183d4ba50f8500465efb27e66dd23f98775dd21 release-0.4.1\n+610267a772c7bf911b499d37f66c21ce8f2ebaf7 release-0.4.2\n+39dd0b045441e21512e0a6061a03d0df63414d8b release-0.4.3\n+5e42c1615f4de0079bd4d8913886d588ce6a295d release-0.4.4\n+40266f92b829a870808b3d4ee54c8fccdecbd2d6 release-0.4.5\n+56e33c6efee7ff63cdc52bd1cf172bde195079df release-0.4.6\n+119bad43bfd493400c57a05848eada2c35a46810 release-0.4.7\n+0f404f82a1343cb4e4b277a44e3417385798e5e5 release-0.4.8\n+d24a717314365c857b9f283d6072c2a427d5e342 release-0.4.9\n+d6f0a00015fdef861fd67fb583b9690638650656 release-0.4.10\n+e372368dadd7b2ecd0182b2f1b11db86fc27b2c3 release-0.4.11\n+fd57967d850d2361072c72562d1ed03598473478 release-0.4.12\n+979045fdcbd20cf7188545c1c589ff240251f890 release-0.4.13\n+93c94cfa9f78f0a5740595dde4466ec4fba664f8 release-0.4.14\n+589ee12e8d7c2ae5e4f4676bcc7a1279a76f9e8e release-0.5.0\n+13416db8a807e5acb4021bc3c581203de57e2f50 release-0.5.1\n+06c58edc88831fb31c492a8eddcf2c6056567f18 release-0.5.2\n+e2ac5fa41bcba14adbbb722d45c083c30c07bb5c release-0.5.3\n+393dbc659df15ccd411680b5c1ce87ed86d4c144 release-0.5.4\n+38cc7bd8e04f2c519fd4526c12841a876be353cb release-0.5.5\n+6d1fcec2ea79101c756316c015f72e75f601a5ab release-0.5.6\n+aed8a9de62456c4b360358bc112ccca32ce02e8d release-0.5.7\n+7642f45af67d805452df2667486201c36efaff85 release-0.5.8\n+779216610662c3a459935d506f66a9b16b9c9576 release-0.5.9\n+9eeb585454f3daa30cf768e95c088a092fe229b9 release-0.5.10\n+bb491c8197e38ca10ae63b1f1ecb36bf6fdaf950 release-0.5.11\n+613369e08810f36bbcc9734ef1059a03ccbf5e16 release-0.5.12\n+bd796ef5c9c9dd34bfac20261b98685e0410122a release-0.5.13\n+8a730c49f906d783b47e4b44d735efd083936c64 release-0.5.14\n+cb447039152d85e9145139ff2575a6199b9af9d4 release-0.5.15\n+64854c7c95d04f838585ca08492823000503fa61 release-0.5.16\n+d1ffcf84ea1244f659145c36ff28de6fcdf528b2 release-0.5.17\n+796a6e30ca9d29504195c10210dbc8deced0ae83 release-0.5.18\n+1f81c711d2a039e1f93b9b515065a2235372d455 release-0.5.19\n+8e8f6082654aedb4438c8fca408cfc316c7c5a2a release-0.5.20\n+e9551132f7dd40da5719dd5bcf924c86f1436f85 release-0.5.21\n+533a252896c4d1cff1586ae42129d610f7497811 release-0.5.22\n+f461a49b6c747e0b67f721f2be172902afea5528 release-0.5.23\n+2d5ef73671f690b65bf6d9e22e7155f68f484d5a release-0.5.24\n+77bf42576050862c268e267ef3e508b145845a25 release-0.5.25\n+2aefee4d4ed69eb7567680bf27a2efd212232488 release-0.6.0\n+7ac0fe9bec9a2b5f8e191f6fdd6922bfd916a6cb release-0.6.1\n+4882735ebc71eeec0fbfe645bdfdb31306872d82 release-0.6.2\n+b94731c73d0922f472ff938b9d252ba29020f20c release-0.6.3\n+13e649b813d6ccba5db33a61e08ebe09d683cd5b release-0.6.4\n+80de622646b0059fd4c553eff47c391bf7503b89 release-0.6.5\n+3b05edb2619d5935023b979ee7a9611b61b6c9e5 release-0.6.6\n+1dcfd375100c4479611f71efb99271d0a3059215 release-0.6.7\n+0228185d4c5772947b842e856ad74cf7f7fd52f3 release-0.6.8\n+d1879c52326ecac45c713203670f54220879911e release-0.6.9\n+5a80c6ccbe2ad24fa3d4ff6f9fe4a2b07408d19d release-0.6.10\n+f88a8b0b39601b19cd740e4db614ab0b5b874686 release-0.6.11\n+5557460a7247a1602ae96efd1d0ccf781344cb58 release-0.6.12\n+451b02cc770a794cd41363461b446948ae1d8bc8 release-0.6.13\n+537b6ef014c4a133e0ab0b7dc817508e0647e315 release-0.6.14\n+5e68764f0d6e91a983170fa806e7450a9e9b33fe release-0.6.15\n+158aa4e8cc46fcf9504a61469d22daf3476b17bf release-0.6.16\n+d8fcca555542619228d9fab89e1665b993f8c3ee release-0.6.17\n+60707ebc037086cf004736a0d4979e2a608da033 release-0.6.18\n+3c2a99d3a71af846855be35e62edb9a12f363f44 release-0.6.19\n+3e0a27f9358ffc1b5249e0ea2311ce7da5c8967e release-0.6.20\n+143f4d65b1c875d6563ccb7f653d9157afc72194 release-0.6.21\n+95e6160d2b7d0af8ffd1b95a23cadadf8f0b3f6d release-0.6.22\n+69a03d5e3b6e6660079ef1ef172db7ac08d8370e release-0.6.23\n+3e2a58fb48f1e1a99ebf851e0d47a7034c52ae22 release-0.6.24\n+3b8607c05a8bebcfa59235c2126a70d737f0ccf5 release-0.6.25\n+07ad5b2606614c4be4ee720c46cf4af126059d31 release-0.6.26\n+be531addfabe5214f409d457140c1038af10d199 release-0.6.27\n+58f05255d3a345d04baef5cff0ca1ae0ac7ecebb release-0.6.28\n+eb2bd21dc8d03f6c94016f04ffb9adaf83a2b606 release-0.6.29\n+55408deb3cd171efa9b81d23d7a1dd1ccde0b839 release-0.6.30\n+d4288915bba73c4c3c9cf5d39d34e86879eb2b45 release-0.6.31\n+0a189588830b8629c4dfea68feb49af36b59e4a9 release-0.7.0\n+6ab27a06f3346cf9ec8737f5dbcc82dd4031e30f release-0.7.1\n+a07e258cef3b0a0b6e76a6ff4ba4651c5facc85a release-0.7.2\n+9992c4583513d2804fc2e7fec860fbc7ab043009 release-0.7.3\n+4dc24d50230fbadfc037a414a86390db2de69dd2 release-0.7.4\n+9527137b4354a648a229c7169850c7c65272c00d release-0.7.5\n+c2f0f7cf306f302254beae512bda18713922375c release-0.7.6\n+bbcf6d75556fdcee8bd4aba8f6c27014be9920ee release-0.7.7\n+43bde71f0bbe5a33b161760d7f9f980d50386597 release-0.7.8\n+769f0dd7081e9011394f264aa22aa66fd79730d8 release-0.7.9\n+511edfa732da637f5f0c9476335df7dca994706d release-0.7.10\n+0e7023bf6b2461309c29885935443449a41be807 release-0.7.11\n+9ad1bd2b21d93902863807528e426862aedee737 release-0.7.12\n+d90ea21e24ea35379aef50c5d70564158e110a15 release-0.7.13\n+c07d2d20d95c83d804079bbdcecbce4a0c8282f0 release-0.7.14\n+0cd7bb051f67eac2b179fb9f9cc988b9ba18ed76 release-0.7.15\n+eab2e87deba73ae6abd9cc740e8d4365bed96322 release-0.7.16\n+91d7a9eb8ade90e9421d7b1e3c2e47a6bc427876 release-0.7.17\n+fc10f7b5cb1305fb930f8ac40b46882d0828d61e release-0.7.18\n+9dba9779e37e5969a2d408c792084fd7acfec062 release-0.7.19\n+61838d1bcbddc7bc4dd9f30d535573a6fddca8f9 release-0.7.20\n+5f665d0fa6a5f6e748157f2ccbc445b2db8125d0 release-0.7.21\n+24763afa5efe91e54f00b2ae5b87666eb6c08c3b release-0.7.22\n+0562fb355a25266150cbe8c8d4e00f55e3654df3 release-0.7.23\n+19c452ecd083550816873a8a31eb3ed9879085e6 release-0.7.24\n+46b68faf271d6fdcaaf3ad2c69f6167ea9e9fa28 release-0.7.25\n+d04bfca0c7e3ae2e4422bc1d383553139d6f0a19 release-0.7.26\n+9425d9c7f8ead95b00a3929a9a5e487e0e3c8499 release-0.7.27\n+fbc3e7e8b3ee756568a875f87d8a954a2f9d3bf6 release-0.7.28\n+5176dfdf153fc785b18604197d58806f919829ad release-0.7.29\n+87e07ccdf0a4ec53458d9d7a4ea66e1239910968 release-0.7.30\n+9fddd7e1a7a27f8463867f41a461aad57df461b2 release-0.7.31\n+780b2ba1ec6daf6e3773774e26b05b9ff0d5483e release-0.7.32\n+83027471a25385b1c671968be761e9aa7a8591a7 release-0.7.33\n+1e9a362c3dcee221ca6e34308c483ed93867aca2 release-0.7.34\n+c7ee9e15717b54ead5f4a554686e74abe66c6b07 release-0.7.35\n+b84548abe9b9d4f4e203f848696e52c8c82c308f release-0.7.36\n+3286f0bab8e77dbc7ebb370b1dc379592ccff123 release-0.7.37\n+11a4e2ed5b166b9c9f119171aa399a9e3aa4684a release-0.7.38\n+f822655d4120629977794c32d3b969343b6c30db release-0.7.39\n+8a350e49d2b6751296db6d8e27277ccf63ed412a release-0.7.40\n+c4a56c197eeafd71fc1caef7a9d890a330e3c23d release-0.7.41\n+a9575a57a5443df39611774cf3840e9088132b0e release-0.7.42\n+7503d95d6eadad14c28b2db183ba09848265274b release-0.7.43\n+9be652e9114435fc6f1fdec84c0458d56702db91 release-0.7.44\n+797e070d480a34b31ddac0d364784773f1bbbcf9 release-0.7.45\n+9b5037e7ec7db25875c40f9d1cf20a853388b124 release-0.7.46\n+d1d0e6d7ff0ca3c0dd1be1ef1cfff2e3fd0b4e1c release-0.7.47\n+9816fb28eda599bfd53940e6d3b6617d1ecb6323 release-0.7.48\n+452b9d09df8e3f2fb04b2a33d04d2f3a6436eb34 release-0.7.49\n+e4350efa7cf7a0e868c2236a1137de8a33bd8ec6 release-0.7.50\n+f51f2bec766c8b6d7e1799d904f18f8ea631bd44 release-0.7.51\n+18e39e566781c9c187e2eb62bebd9d669d68f08c release-0.7.52\n+b073eaa1dcea296a3488b83d455fab6621a73932 release-0.7.53\n+01c6fe6c2a55998434cd3b05dd10ca487ac3fb6c release-0.7.54\n+3ed9377e686f2521e6ec15873084381033fb490d release-0.7.55\n+a1e44954549c35023b409f728c678be8bf898148 release-0.7.56\n+fbb1918a85e38a7becdb1a001dbaf5933f23a919 release-0.7.57\n+87f4a49a9cc34a5b11c8784cc5ea89e97b4b2bd8 release-0.7.58\n+0c22cb4862c8beb4ee1b9e4627125162a29a5304 release-0.7.59\n+82d56c2425ef857cd430b8530a3f9e1127145a67 release-0.8.0\n+f4acb784b53cd952559567971b97dde1e818a2b6 release-0.8.1\n+b3503597c1a0f0f378afdc5e5e5b85e2c095a4be release-0.8.2\n+c98da980514a02ba81c421b25bf91803ffffddf3 release-0.8.3\n+db34ec0c53c4b9dec12ffdf70caf89a325ab9577 release-0.8.4\n+0914802433b8678ba2cdf91280766f00f4b9b76e release-0.8.5\n+ff52ee9e6422f3759f43a442b7ba615595b3a3d4 release-0.8.6\n+7607237b4829fff1f60999f4663c50ed9d5182f7 release-0.8.7\n+1cef1807bc12cb05ac52fb0e7a0f111d3760b569 release-0.8.8\n+a40f8475511d74a468ade29c1505e8986600d7a3 release-0.8.9\n+2d9faf2260df6c3e5d4aa1781493c31f27a557d0 release-0.8.10\n+d0d61c32331a6505381b5218318f7b69db167ca8 release-0.8.11\n+ca7a1c6c798a7eb5b294d4ac3179ec87ecf297d3 release-0.8.12\n+81c8277cd8ed55febcb2dd9d9213076f6c0ccb09 release-0.8.13\n+3089486a8dc5844b5b6e9f78d536b4b26f7ffa16 release-0.8.14\n+d364c2c12dd9723a2dfac3f096f5e55d4cfe6838 release-0.8.15\n+52163a1027c3efd6b4c461b60a2ca6266c23e193 release-0.8.16\n+06564e9a2d9ec5852132c212e85eda0bf1300307 release-0.8.17\n+7aaa959da85e09e29bcac3b1cadec35b0a25b64d release-0.8.18\n+4bc73c644329a510da4e96b7241b80ead7772f83 release-0.8.19\n+ea3d168fb99c32a5c3545717ecc61e85a375e5dd release-0.8.20\n+27951ca037e63dae45ff5b6279124c224ae1255a release-0.8.21\n+d56c8b5df517c2bf6e7bc2827b8bf3e08cda90e1 release-0.8.22\n+3c6ac062b379b126212cbb27e98a3c8275ef381a release-0.8.23\n+89b9173476de14688b1418fbf7df10f91d1719ef release-0.8.24\n+aa550cb4159ae0d566006e091fb1c7a888771050 release-0.8.25\n+06ce92293f6a65651b08c466f90f55bd69984b98 release-0.8.26\n+ea50b0d79ef1d7d901cd0e4dcd7373447849d719 release-0.8.27\n+e68b1c35cad86105ff1c5b240f53442f4c36356e release-0.8.28\n+78d3582a30afe63fc0adb17c3ac8891a64e47146 release-0.8.29\n+9852c5965a3292a1b6127dbb4da9fce4912d898a release-0.8.30\n+4f84115914490e572bcbee5069157b7334df2744 release-0.8.31\n+59dee6f7f3afeb1fad6ed5983756e48c81ad2a5c release-0.8.32\n+a4456378d234c07038456cf32bfe3c651f1d5e82 release-0.8.33\n+21cb50799a20575a42f9733342d37a426f79db4d release-0.8.34\n+7cb3cb8d78ef7ae63561733ed91fd07933896bc8 release-0.8.35\n+aed68639d4eb6afe944b7fb50499c16f7f3f503c release-0.8.36\n+265b7fd2ae21c75bbffa5115b83a0123d6c4acb4 release-0.8.37\n+fa5f1ca353c0c5aa5415f51d72fd7bbcc02d1ed7 release-0.8.38\n+af10bf9d4c6532850aa1f70cdf7504bd109b284c release-0.8.39\n+4846ec9f83cb5bc4c8519d5641b35fb9b190430c release-0.8.40\n+718b4cb3faf7efe4e0648140f064bf7a92c3f7e8 release-0.8.41\n+b5a3065749093282ddd19845e0b77ffc2e54333e release-0.8.42\n+34df9fb22fed415cdad52def04095dc6d4b48222 release-0.8.43\n+00ec8cd76fb89af27363b76c40d9f88bf4679c3b release-0.8.44\n+e16dd52a0d226c23dcae9a11252564a04753bbed release-0.8.45\n+f034d9173df0a433e0bbcf5974f12ea9eb9076c0 release-0.8.46\n+4434dc967087315efcd0658206a67fe6c85528f3 release-0.8.47\n+0b65c962e0cd6783a854877b52c903cb058eec8c release-0.8.48\n+a2b7e94b9807e981866bf07e37b715847d1b7120 release-0.8.49\n+e7bdb8edc1bab2bc352a9fb6ce765c46575c35bf release-0.8.50\n+21dacebd12f65cb57ceb8d2688db5b07fad6e06d release-0.8.51\n+67dd7533b99c8945b5b8b5b393504d4e003a1c50 release-0.8.52\n+010468d890dbac33a4cae6dfb2017db70721b2fe release-0.8.53\n+62b599022a2fa625b526c2ad1711dc6db7d66786 release-0.9.0\n+71281dd73b17a0ead5535d531afaee098da723cb release-0.9.1\n+16cff36b0e49fc9fdeee13b2e92690286bcc1b3d release-0.9.2\n+b7b306325972661117694879d3e22faf4cf0df32 release-0.9.3\n+fe671505a8ea86a76f0358b3ec4de84a9037ac2b release-0.9.4\n+70542931bc5436d1bbd38f152245d93ac063968d release-0.9.5\n+27e2f3b7a3db1819c5d0ba28327ceaba84a13c4e release-0.9.6\n+657d05d63915ce2f6c4d763091059f5f85bb10e5 release-0.9.7\n+e0fd9f36005923b8f98d1ba1ea583cb7625f318f release-1.0.0\n+f8f89eb4e0c27e857ec517d893d4f9a454985084 release-1.0.1\n+c50df367648e53d55e80b60a447c9c66caa0d326 release-1.0.2\n+80d586db316512b5a9d39f00fe185f7f91523f52 release-1.0.3\n+c9c2805ac9245cc48ce6efeba2b4a444f859d6aa release-1.0.4\n+fa2c37b1122c2c983b6e91d1188e387d72dde4d6 release-1.0.5\n+f31aea5b06654c9163be5acd6d9b7aaf0fdf6b33 release-1.1.0\n+44bf95f670656fae01ccb266b3863843ea13d324 release-1.1.1\n+da1289482a143dfa016769649bdff636c26f53c8 release-1.1.2\n+bac8ba08a6570bac2ecd3bf2ad64b0ac3030c903 release-1.1.3\n+911060bc8221d4113a693ae97952a1fa88663ca8 release-1.1.4\n+e47531dfabbf8e5f8b8aff9ff353642ea4aa7abb release-1.1.5\n+f9ddecfe331462f870a95e4c1c3ba1bb8f19f2d3 release-1.1.6\n+378c297bb7459fb99aa9c77decac0d35391a3932 release-1.1.7\n+71600ce67510af093d4bc0117a78b3b4678c6b3a release-1.1.8\n+482d7d907f1ab92b78084d8b8631ed0eb7dd08f7 release-1.1.9\n+c7e65deabf0db5109e8d8f6cf64cd3fb7633a3d1 release-1.1.10\n+9590f0cf5aab8e6e0b0c8ae59c70187b2b97d886 release-1.1.11\n+ade8fc136430cfc04a8d0885c757968b0987d56c release-1.1.12\n+6a6836e65827fd3cb10a406e7bbbe36e0dad8736 release-1.1.13\n+6845f4ac909233f5a08ed8a51de137713a888328 release-1.1.14\n+2397e9c72f1bc5eac67006e12ad3e33e0ea9ba74 release-1.1.15\n+7b7c49639a7bceecabf4963c60b26b65a77d6ce0 release-1.1.16\n+f7e1113a9a1648cad122543e7080e895cf2d88f4 release-1.1.17\n+2b22743c3079b41233ded0fc35af8aa89bcfab91 release-1.1.18\n+0f0b425659e0b26f5bc8ea14a42dbf34de2eaba6 release-1.1.19\n+f582d662cc408eb7a132c21f4b298b71d0701abb release-1.2.0\n+9ee68d629722f583d43d92271f2eb84281afc630 release-1.3.0\n+61b6a3438afef630774e568eefd89c53e3b93287 release-1.3.1\n+7ccd50a0a455f2f2d3b241f376e1193ad956196d release-1.2.1\n+0000000000000000000000000000000000000000 release-1.2.1\n+50107e2d96bbfc2c59e46f889b1a5f68dd10cf19 release-1.3.2\n+2c5e1e88c8cf710caf551c5c67eba00443601efe release-1.3.3\n+a43447fb82aa03eabcd85352758ae14606a84d35 release-1.3.4\n+90f3b4ea7992a7bf9385851a3e77173363091eea release-1.3.5\n+3aeb14f88daeb973e4708310daa3dc68ac1200f7 release-1.3.6\n+dafd375f1c882b15fa4a9b7aa7c801c55082395e release-1.3.7\n+ab7ce0eb4cf78a656750ab1d8e55ef61f7e535ec release-1.3.8\n+1b1a9337a7399ad3cdc5e3a2f9fbaaec990271d5 release-1.3.9\n+2c053b2572694eb9cd4aed26a498b6cb1f51bbcc release-1.3.10\n+36409ac209872ce53019f084e4e07467c5d9d25e release-1.3.11\n+560dc55e90c13860a79d8f3e0d67a81c7b0257bb release-1.3.12\n+dc195ffe0965b2b9072f8e213fe74ecce38f6773 release-1.3.13\n+e04428778567dd4de329bbbe97ad653e22801612 release-1.3.14\n+cd84e467c72967b9f5fb4d96bfc708c93edeb634 release-1.3.15\n+23159600bdea695db8f9d2890aaf73424303e49c release-1.3.16\n+7809529022b83157067e7d1e2fb65d57db5f4d99 release-1.4.0\n+48a84bc3ff074a65a63e353b9796ff2b14239699 release-1.5.0\n+99eed1a88fc33f32d66e2ec913874dfef3e12fcc release-1.5.1\n+5bdca4812974011731e5719a6c398b54f14a6d61 release-1.5.2\n+644a079526295aca11c52c46cb81e3754e6ad4ad release-1.5.3\n+376a5e7694004048a9d073e4feb81bb54ee3ba91 release-1.5.4\n+60e0409b9ec7ee194c6d8102f0656598cc4a6cfe release-1.5.5\n+70c5cd3a61cb476c2afb3a61826e59c7cda0b7a7 release-1.5.6\n+9ba2542d75bf62a3972278c63561fc2ef5ec573a release-1.5.7\n+eaa76f24975948b0ce8be01838d949122d44ed67 release-1.5.8\n+5a1759f33b7fa6270e1617c08d7e655b7b127f26 release-1.5.9\n+b798fc020e3a84ef68e6c9f47865a319c826d33c release-1.5.10\n+f995a10d4c7e9a817157a6ce7b753297ad32897e release-1.5.11\n+97b47d95e4449cbde976657cf8cbbc118351ffe0 release-1.5.12\n+fd722b890eabc600394349730a093f50dac31639 release-1.5.13\n+d161d68df8be32e5cbf72b07db1a707714827803 release-1.7.0\n+0351a6d89c3dbcc7a76295024ba6b70e27b9a497 release-1.7.1\n+0bd223a546192fdf2e862f33938f4ec2a3b5b283 release-1.7.2\n+fe7cd01828d5ca7491059f0690bb4453645eb28b release-1.7.3\n+cbb146b120296852e781079d5138b04495bab6df release-1.7.4\n+fe129aa02db9001d220f1db7c3c056f79482c111 release-1.7.5\n+a8d111bb68847f61d682a3c8792fecb2e52efa2c release-1.7.6\n+6d2fbc30f8a7f70136cf08f32d5ff3179d524873 release-1.7.7\n+d5ea659b8bab2d6402a2266efa691f705e84001e release-1.7.8\n+34b201c1abd1e2d4faeae4650a21574771a03c0e release-1.7.9\n+860cfbcc4606ee36d898a9cd0c5ae8858db984d6 release-1.7.10\n+2b3b737b5456c05cd63d3d834f4fb4d3776953d0 release-1.7.11\n+3ef00a71f56420a9c3e9cec311c9a2109a015d67 release-1.7.12\n+53d850fe292f157d2fb999c52788ec1dc53c91ed release-1.9.0\n+884a967c369f73ab16ea859670d690fb094d3850 release-1.9.1\n+3a32d6e7404a79a0973bcd8d0b83181c5bf66074 release-1.9.2\n+e27a215601292872f545a733859e06d01af1017d release-1.9.3\n+5cb7e2eed2031e32d2e5422caf9402758c38a6ad release-1.9.4\n+942475e10cb47654205ede7ccbe7d568698e665b release-1.9.5\n+b78018cfaa2f0ec20494fccb16252daa87c48a31 release-1.9.6\n+54117529e40b988590ea2d38aae909b0b191663f release-1.9.7\n+1bdc497c81607d854e3edf8b9a3be324c3d136b6 release-1.9.8\n+ef107f3ddc237a3007e2769ec04adde0dcf627fa release-1.9.9\n+be00ca08e41a69e585b6aff70a725ed6c9e1a876 release-1.9.10\n+fe66cff450a95beed36a2515210eb2d7ef62c9d3 release-1.9.11\n+ead3907d74f90a14d1646f1b2b56ba01d3d11702 release-1.9.12\n+5936b7ed929237f1a73b467f662611cdc0309e51 release-1.9.13\n+4106db71cbcb9c8274700199ac17e520902c6c0f release-1.9.14\n+13070ecfda67397985f0e986eb9c42ecb46d05b5 release-1.9.15\n+271ee30c6791847980cd139d31807541f5e569bf release-1.11.0\n+cb783d9cc19761e14e1285d91c38f4b84d0b8756 release-1.11.1\n+4d3b3a13a8cf5fc3351a7f167d1c13325e00f21c release-1.11.2\n+b83a067949a3384a49fd3d943eb8d0997b31f87b release-1.11.3\n+953512ca02c6f63b4fcbbc3e10d0d9835896bf99 release-1.11.4\n+5253015a339aaca0a3111473d3e931b6d4752393 release-1.11.5\n+5e371426b3bcba4312ce08606194b89b758927d1 release-1.11.6\n+5c8f60faf33ca8926473d2da27b4c3c417bd4630 release-1.11.7\n+4591da489a30f790def29bc5987f43409b503cae release-1.11.8\n+20a45c768e5ed26b740679d0e22045c98727c3cc release-1.11.9\n+1ad0999a7ded3d4fb01c7acf8ff57c80b643da7e release-1.11.10\n+d8b321a876d6254e9e98795e3b194ef053290354 release-1.11.11\n+7f394e433f0003222aa6531931ecc0b24740d5e4 release-1.11.12\n+3d0e8655f897959e48cc74e87670bb5492a58871 release-1.11.13\n+3671096a45bce570a2afa20b9faf42c7fb0f7e66 release-1.13.0\n+539f7893ecb96bee60965528c8958d7eb2f1ce6b release-1.13.1\n+5be2b25bdc65775a85f18f68a4be4f58c7384415 release-1.13.2\n+8457ce87640f9bfe6221c4ac4466ced20e03bebe release-1.13.3\n+bbc642c813c829963ce8197c0ca237ab7601f3d4 release-1.13.4\n+0d45b4cf7c2e4e626a5a16e1fe604402ace1cea5 release-1.13.5\n+f87da7d9ca02b8ced4caa6c5eb9013ccd47b0117 release-1.13.6\n+47cca243d0ed39bf5dcb9859184affc958b79b6f release-1.13.7\n+20ca4bcff108d3e66977f4d97508637093492287 release-1.13.8\n+fb1212c7eca4c5328fe17d6cd95b010c67336aac release-1.13.9\n+31c929e16910c38492581ef474e72fa67c28f124 release-1.13.10\n+64179f242cb55fc206bca59de9bfdc4cf5ebcec7 release-1.13.11\n+051e5fa03b92b8a564f6b12debd483d267391e82 release-1.13.12\n+990b3e885636d763b97ed02d0d2cfc161a4e0c09 release-1.15.0\n+4189160cb946bb38d0bc0a452b5eb4cdd8979fb5 release-1.15.1\n+b234199c7ed8a156a6bb98f7ff58302c857c954f release-1.15.2\n+28b3e17ca7eba1e6a0891afde0e4bc5bcc99c861 release-1.15.3\n+49d49835653857daa418e68d6cbfed4958c78fca release-1.15.4\n+f062e43d74fc2578bb100a9e82a953efa1eb9e4e release-1.15.5\n+2351853ce6867b6166823bdf94333c0a76633c0a release-1.15.6\n+051a039ce1c7e09144de4a4846669ec7116cecea release-1.15.7\n+ee551e3f6dba336c0d875e266d7d55385f379b42 release-1.15.8\n+d2fd76709909767fc727a5b4affcf1dc9ca488a7 release-1.15.9\n+75f5c7f628411c79c7044102049f7ab4f7a246e7 release-1.15.10\n+5155d0296a5ef9841f035920527ffdb771076b44 release-1.15.11\n+0130ca3d58437b3c7c707cdddd813d530c68da9a release-1.15.12\n+054c1c46395caff79bb4caf16f40b331f71bb6dd release-1.17.0\n+7816bd7dabf6ee86c53c073b90a7143161546e06 release-1.17.1\n+2fc9f853a6b7cd29dc84e0af2ed3cf78e0da6ca8 release-1.17.2\n+ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n+ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\nDiff:\n@@ -0,0 +1,14 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# aCC: HP ANSI C++ B3910B A.03.55.02\n+\n+# C89 mode\n+\n+CFLAGS=\"$CFLAGS -Ae\"\n+CC_TEST_FLAGS=\"-Ae\"\n+\n+PCRE_OPT=\"$PCRE_OPT -Ae\"\n+ZLIB_OPT=\"$ZLIB_OPT -Ae\"\nDiff:\n@@ -0,0 +1,71 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# Borland C++ 5.5\n+\n+# optimizations\n+\n+# maximize speed\n+CFLAGS=\"$CFLAGS -O2\"\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium and Athlon\n+        CPU_OPT=\"-5\"\n+    ;;\n+\n+    pentiumpro)\n+        # optimize for Pentium Pro, Pentium II and Pentium III\n+        CPU_OPT=\"-6\"\n+    ;;\n+esac\n+\n+# __stdcall\n+#CPU_OPT=\"$CPU_OPT -ps\"\n+# __fastcall\n+#CPU_OPT=\"$CPU_OPT -pr\"\n+\n+CFLAGS=\"$CFLAGS $CPU_OPT\"\n+\n+# multithreaded\n+CFLAGS=\"$CFLAGS -tWM\"\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -w!\"\n+\n+# disable logo\n+CFLAGS=\"$CFLAGS -q\"\n+\n+\n+# precompiled headers\n+CORE_DEPS=\"$CORE_DEPS $NGX_OBJS/ngx_config.csm\"\n+NGX_PCH=\"$NGX_OBJS/ngx_config.csm\"\n+NGX_BUILD_PCH=\"-H=$NGX_OBJS/ngx_config.csm\"\n+NGX_USE_PCH=\"-Hu -H=$NGX_OBJS/ngx_config.csm\"\n+\n+\n+# Win32 GUI mode application\n+#LINK=\"\\$(CC) -laa\"\n+\n+\n+# the resource file\n+NGX_RES=\"$NGX_OBJS/nginx.res\"\n+NGX_RCC=\"brcc32 -fo$NGX_OBJS/nginx.res \\$(CORE_INCS) $NGX_WIN32_RC\"\n+# the pragma allows to link the resource file using bcc32 and\n+# to avoid the direct ilink32 calling and the c0w32.obj's WinMain/main problem\n+NGX_PRAGMA=\"#pragma resource \\\"$NGX_OBJS/nginx.res\\\"\"\n+\n+\n+ngx_include_opt=\"-I\"\n+ngx_objout=\"-o\"\n+ngx_binout=\"-e\"\n+ngx_objext=\"obj\"\n+\n+ngx_long_start='@&&|\n+\t'\n+ngx_long_end='|'\n+\n+ngx_regex_dirsep='\\\\'\n+ngx_dirsep=\"\\\\\"\nDiff:\n@@ -0,0 +1,46 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# Compaq C V6.5-207\n+\n+ngx_include_opt=\"-I\"\n+\n+# warnings\n+\n+CFLAGS=\"$CFLAGS -msg_enable level6 -msg_fatal level6\"\n+\n+CFLAGS=\"$CFLAGS -msg_disable unknownmacro\"\n+CFLAGS=\"$CFLAGS -msg_disable unusedincl\"\n+CFLAGS=\"$CFLAGS -msg_disable unnecincl\"\n+CFLAGS=\"$CFLAGS -msg_disable nestincl\"\n+CFLAGS=\"$CFLAGS -msg_disable strctpadding\"\n+CFLAGS=\"$CFLAGS -msg_disable ansialiascast\"\n+CFLAGS=\"$CFLAGS -msg_disable inlinestoclsmod\"\n+CFLAGS=\"$CFLAGS -msg_disable cxxkeyword\"\n+CFLAGS=\"$CFLAGS -msg_disable longlongsufx\"\n+CFLAGS=\"$CFLAGS -msg_disable valuepres\"\n+\n+# STUB\n+CFLAGS=\"$CFLAGS -msg_disable truncintcast\"\n+CFLAGS=\"$CFLAGS -msg_disable trunclongcast\"\n+\n+CFLAGS=\"$CFLAGS -msg_disable truncintasn\"\n+CFLAGS=\"$CFLAGS -msg_disable trunclongint\"\n+CFLAGS=\"$CFLAGS -msg_disable intconcastsgn\"\n+CFLAGS=\"$CFLAGS -msg_disable intconstsign\"\n+CFLAGS=\"$CFLAGS -msg_disable switchlong\"\n+CFLAGS=\"$CFLAGS -msg_disable subscrbounds2\"\n+\n+CFLAGS=\"$CFLAGS -msg_disable hexoctunsign\"\n+\n+CFLAGS=\"$CFLAGS -msg_disable ignorecallval\"\n+CFLAGS=\"$CFLAGS -msg_disable nonstandcast\"\n+CFLAGS=\"$CFLAGS -msg_disable embedcomment\"\n+CFLAGS=\"$CFLAGS -msg_disable unreachcode\"\n+CFLAGS=\"$CFLAGS -msg_disable questcompare2\"\n+CFLAGS=\"$CFLAGS -msg_disable unusedtop\"\n+CFLAGS=\"$CFLAGS -msg_disable unrefdecl\"\n+\n+CFLAGS=\"$CFLAGS -msg_disable bitnotint\"\nDiff:\n@@ -0,0 +1,99 @@\n+\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# clang\n+\n+\n+NGX_CLANG_VER=`$CC -v 2>&1 | grep 'version' 2>&1 \\\n+                           | sed -n -e 's/^.*clang version \\(.*\\)/\\1/p' \\\n+                                    -e 's/^.*LLVM version \\(.*\\)/\\1/p'`\n+\n+echo \" + clang version: $NGX_CLANG_VER\"\n+\n+have=NGX_COMPILER value=\"\\\"clang $NGX_CLANG_VER\\\"\" . auto/define\n+\n+\n+CC_TEST_FLAGS=\"-pipe\"\n+\n+\n+# optimizations\n+\n+#NGX_CLANG_OPT=\"-O2\"\n+#NGX_CLANG_OPT=\"-Oz\"\n+NGX_CLANG_OPT=\"-O\"\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium\n+        CPU_OPT=\"-march=pentium\"\n+        NGX_CPU_CACHE_LINE=32\n+    ;;\n+\n+    pentiumpro | pentium3)\n+        # optimize for Pentium Pro, Pentium II and Pentium III\n+        CPU_OPT=\"-march=pentiumpro\"\n+        NGX_CPU_CACHE_LINE=32\n+    ;;\n+\n+    pentium4)\n+        # optimize for Pentium 4\n+        CPU_OPT=\"-march=pentium4\"\n+        NGX_CPU_CACHE_LINE=128\n+    ;;\n+\n+    athlon)\n+        # optimize for Athlon\n+        CPU_OPT=\"-march=athlon\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    opteron)\n+        # optimize for Opteron\n+        CPU_OPT=\"-march=opteron\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+esac\n+\n+CC_AUX_FLAGS=\"$CC_AUX_FLAGS $CPU_OPT\"\n+\n+\n+CFLAGS=\"$CFLAGS -pipe $CPU_OPT\"\n+\n+if [ \".$PCRE_OPT\" = \".\" ]; then\n+    PCRE_OPT=\"-O2 -pipe $CPU_OPT\"\n+else\n+    PCRE_OPT=\"$PCRE_OPT -pipe\"\n+fi\n+\n+if [ \".$ZLIB_OPT\" = \".\" ]; then\n+    ZLIB_OPT=\"-O2 -pipe $CPU_OPT\"\n+else\n+    ZLIB_OPT=\"$ZLIB_OPT -pipe\"\n+fi\n+\n+\n+# warnings\n+\n+CFLAGS=\"$CFLAGS $NGX_CLANG_OPT -Wall -Wextra -Wpointer-arith\"\n+CFLAGS=\"$CFLAGS -Wconditional-uninitialized\"\n+#CFLAGS=\"$CFLAGS -Wmissing-prototypes\"\n+\n+# we have a lot of unused function arguments\n+CFLAGS=\"$CFLAGS -Wno-unused-parameter\"\n+\n+# deprecated system OpenSSL library on OS X\n+if [ \"$NGX_SYSTEM\" = \"Darwin\" ]; then\n+    CFLAGS=\"$CFLAGS -Wno-deprecated-declarations\"\n+fi\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -Werror\"\n+\n+# debug\n+CFLAGS=\"$CFLAGS -g\"\n+\n+if [ \".$CPP\" = \".\" ]; then\n+    CPP=\"$CC -E\"\n+fi\nDiff:\n@@ -0,0 +1,254 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+LINK=\"\\$(CC)\"\n+\n+MAIN_LINK=\n+MODULE_LINK=\"-shared\"\n+\n+ngx_include_opt=\"-I \"\n+ngx_compile_opt=\"-c\"\n+ngx_pic_opt=\"-fPIC\"\n+ngx_objout=\"-o \"\n+ngx_binout=\"-o \"\n+ngx_objext=\"o\"\n+ngx_binext=\n+ngx_modext=\".so\"\n+\n+ngx_long_start=\n+ngx_long_end=\n+\n+ngx_regex_dirsep=\"\\/\"\n+ngx_dirsep='/'\n+\n+ngx_regex_cont=' \\\\\\\n+\t'\n+ngx_cont=' \\\n+\t'\n+ngx_tab=' \\\n+\t\t'\n+ngx_spacer=\n+\n+ngx_long_regex_cont=$ngx_regex_cont\n+ngx_long_cont=$ngx_cont\n+\n+. auto/cc/name\n+\n+if test -n \"$CFLAGS\"; then\n+\n+    CC_TEST_FLAGS=\"$CFLAGS $NGX_CC_OPT\"\n+\n+    case $NGX_CC_NAME in\n+\n+        ccc)\n+            # Compaq C V6.5-207\n+\n+            ngx_include_opt=\"-I\"\n+        ;;\n+\n+        sunc)\n+\n+            MAIN_LINK=\n+            MODULE_LINK=\"-G\"\n+\n+            case \"$NGX_MACHINE\" in\n+\n+                i86pc)\n+                    NGX_AUX=\" src/os/unix/ngx_sunpro_x86.il\"\n+                ;;\n+\n+                sun4u | sun4v)\n+                    NGX_AUX=\" src/os/unix/ngx_sunpro_sparc64.il\"\n+                ;;\n+\n+            esac\n+\n+            case $CPU in\n+\n+                amd64)\n+                    NGX_AUX=\" src/os/unix/ngx_sunpro_amd64.il\"\n+                ;;\n+\n+            esac\n+        ;;\n+\n+    esac\n+\n+else\n+\n+    case $NGX_CC_NAME in\n+        gcc)\n+            # gcc 2.7.2.3, 2.8.1, 2.95.4, egcs-1.1.2\n+            #     3.0.4, 3.1.1, 3.2.3, 3.3.2, 3.3.3, 3.3.4, 3.4.0, 3.4.2\n+            #     4.0.0, 4.0.1, 4.1.0\n+\n+            . auto/cc/gcc\n+        ;;\n+\n+        clang)\n+            # Clang C compiler\n+\n+            . auto/cc/clang\n+        ;;\n+\n+        icc)\n+            # Intel C++ compiler 7.1, 8.0, 8.1\n+\n+            . auto/cc/icc\n+        ;;\n+\n+        sunc)\n+            # Sun C 5.7 Patch 117837-04 2005/05/11\n+\n+            . auto/cc/sunc\n+        ;;\n+\n+        ccc)\n+            # Compaq C V6.5-207\n+\n+            . auto/cc/ccc\n+        ;;\n+\n+        acc)\n+            # aCC: HP ANSI C++ B3910B A.03.55.02\n+\n+            . auto/cc/acc\n+        ;;\n+\n+        msvc*)\n+            # MSVC++ 6.0 SP2, MSVC++ Toolkit 2003\n+\n+            . auto/cc/msvc\n+        ;;\n+\n+        owc)\n+            # Open Watcom C 1.0, 1.2\n+\n+            . auto/cc/owc\n+        ;;\n+\n+        bcc)\n+            # Borland C++ 5.5\n+\n+            . auto/cc/bcc\n+        ;;\n+\n+    esac\n+\n+    CC_TEST_FLAGS=\"$CC_TEST_FLAGS $NGX_CC_OPT\"\n+\n+fi\n+\n+CFLAGS=\"$CFLAGS $NGX_CC_OPT\"\n+NGX_TEST_LD_OPT=\"$NGX_LD_OPT\"\n+\n+if [ \"$NGX_PLATFORM\" != win32 ]; then\n+\n+    if test -n \"$NGX_LD_OPT\"; then\n+        ngx_feature=--with-ld-opt=\\\"$NGX_LD_OPT\\\"\n+        ngx_feature_name=\n+        ngx_feature_run=no\n+        ngx_feature_incs=\n+        ngx_feature_path=\n+        ngx_feature_libs=\n+        ngx_feature_test=\n+        . auto/feature\n+\n+        if [ $ngx_found = no ]; then\n+            echo $0: error: the invalid value in --with-ld-opt=\\\"$NGX_LD_OPT\\\"\n+            echo\n+            exit 1\n+        fi\n+    fi\n+\n+\n+    ngx_feature=\"-Wl,-E switch\"\n+    ngx_feature_name=\n+    ngx_feature_run=no\n+    ngx_feature_incs=\n+    ngx_feature_path=\n+    ngx_feature_libs=-Wl,-E\n+    ngx_feature_test=\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        MAIN_LINK=\"-Wl,-E\"\n+    fi\n+\n+\n+    if [ \"$NGX_CC_NAME\" = \"sunc\" ]; then\n+        echo \"checking for gcc builtin atomic operations ... disabled\"\n+    else\n+        ngx_feature=\"gcc builtin atomic operations\"\n+        ngx_feature_name=NGX_HAVE_GCC_ATOMIC\n+        ngx_feature_run=yes\n+        ngx_feature_incs=\n+        ngx_feature_path=\n+        ngx_feature_libs=\n+        ngx_feature_test=\"long  n = 0;\n+                          if (!__sync_bool_compare_and_swap(&n, 0, 1))\n+                              return 1;\n+                          if (__sync_fetch_and_add(&n, 1) != 1)\n+                              return 1;\n+                          if (n != 2)\n+                              return 1;\n+                          __sync_synchronize();\"\n+        . auto/feature\n+    fi\n+\n+\n+    if [ \"$NGX_CC_NAME\" = \"ccc\" ]; then\n+        echo \"checking for C99 variadic macros ... disabled\"\n+    else\n+        ngx_feature=\"C99 variadic macros\"\n+        ngx_feature_name=\"NGX_HAVE_C99_VARIADIC_MACROS\"\n+        ngx_feature_run=yes\n+        ngx_feature_incs=\"#include <stdio.h>\n+#define var(dummy, ...)  sprintf(__VA_ARGS__)\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\n+        ngx_feature_test=\"char  buf[30]; buf[0] = '0';\n+                          var(0, buf, \\\"%d\\\", 1);\n+                          if (buf[0] != '1') return 1\"\n+        . auto/feature\n+    fi\n+\n+\n+    ngx_feature=\"gcc variadic macros\"\n+    ngx_feature_name=\"NGX_HAVE_GCC_VARIADIC_MACROS\"\n+    ngx_feature_run=yes\n+    ngx_feature_incs=\"#include <stdio.h>\n+#define var(dummy, args...)  sprintf(args)\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"char  buf[30]; buf[0] = '0';\n+                      var(0, buf, \\\"%d\\\", 1);\n+                      if (buf[0] != '1') return 1\"\n+    . auto/feature\n+\n+\n+    ngx_feature=\"gcc builtin 64 bit byteswap\"\n+    ngx_feature_name=\"NGX_HAVE_GCC_BSWAP64\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"if (__builtin_bswap64(0)) return 1\"\n+    . auto/feature\n+\n+\n+#    ngx_feature=\"inline\"\n+#    ngx_feature_name=\n+#    ngx_feature_run=no\n+#    ngx_feature_incs=\"int inline f(void) { return 1 }\"\n+#    ngx_feature_path=\n+#    ngx_feature_libs=\n+#    ngx_feature_test=\n+#    . auto/feature\n+#\n+#    if [ $ngx_found = yes ]; then\n+#    fi\n+\n+fi\nDiff:\n@@ -0,0 +1,179 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# gcc 2.7.2.3, 2.8.1, 2.95.4, egcs-1.1.2\n+#     3.0.4, 3.1.1, 3.2.3, 3.3.2, 3.3.3, 3.3.4, 3.4.0, 3.4.2\n+#     4.0.0, 4.0.1, 4.1.0\n+\n+\n+NGX_GCC_VER=`$CC -v 2>&1 | grep 'gcc version' 2>&1 \\\n+                         | sed -e 's/^.* version \\(.*\\)/\\1/'`\n+\n+echo \" + gcc version: $NGX_GCC_VER\"\n+\n+have=NGX_COMPILER value=\"\\\"gcc $NGX_GCC_VER\\\"\" . auto/define\n+\n+\n+# Solaris 7's /usr/ccs/bin/as does not support \"-pipe\"\n+\n+CC_TEST_FLAGS=\"-pipe\"\n+\n+ngx_feature=\"gcc -pipe switch\"\n+ngx_feature_name=\n+ngx_feature_run=no\n+ngx_feature_incs=\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\n+. auto/feature\n+\n+CC_TEST_FLAGS=\n+\n+if [ $ngx_found = yes ]; then\n+    PIPE=\"-pipe\"\n+fi\n+\n+\n+case \"$NGX_MACHINE\" in\n+\n+    sun4u | sun4v | sparc | sparc64 )\n+        # \"-mcpu=v9\" enables the \"casa\" assembler instruction\n+        CFLAGS=\"$CFLAGS -mcpu=v9\"\n+    ;;\n+\n+esac\n+\n+\n+# optimizations\n+\n+#NGX_GCC_OPT=\"-O2\"\n+#NGX_GCC_OPT=\"-Os\"\n+NGX_GCC_OPT=\"-O\"\n+\n+#CFLAGS=\"$CFLAGS -fomit-frame-pointer\"\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium and Athlon\n+        CPU_OPT=\"-march=pentium\"\n+        NGX_CPU_CACHE_LINE=32\n+    ;;\n+\n+    pentiumpro | pentium3)\n+        # optimize for Pentium Pro, Pentium II and Pentium III\n+        CPU_OPT=\"-march=pentiumpro\"\n+        NGX_CPU_CACHE_LINE=32\n+    ;;\n+\n+    pentium4)\n+        # optimize for Pentium 4, gcc 3.x\n+        CPU_OPT=\"-march=pentium4\"\n+        NGX_CPU_CACHE_LINE=128\n+    ;;\n+\n+    athlon)\n+        # optimize for Athlon, gcc 3.x\n+        CPU_OPT=\"-march=athlon\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    opteron)\n+        # optimize for Opteron, gcc 3.x\n+        CPU_OPT=\"-march=opteron\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    sparc32)\n+        # build 32-bit UltraSparc binary\n+        CPU_OPT=\"-m32\"\n+        CORE_LINK=\"$CORE_LINK -m32\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    sparc64)\n+        # build 64-bit UltraSparc binary\n+        CPU_OPT=\"-m64\"\n+        CORE_LINK=\"$CORE_LINK -m64\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    ppc64)\n+        # build 64-bit PowerPC binary\n+        CPU_OPT=\"-m64\"\n+        CPU_OPT=\"$CPU_OPT -falign-functions=32 -falign-labels=32\"\n+        CPU_OPT=\"$CPU_OPT -falign-loops=32 -falign-jumps=32\"\n+        CORE_LINK=\"$CORE_LINK -m64\"\n+        NGX_CPU_CACHE_LINE=128\n+    ;;\n+\n+esac\n+\n+CC_AUX_FLAGS=\"$CC_AUX_FLAGS $CPU_OPT\"\n+\n+case \"$NGX_GCC_VER\" in\n+    2.7*)\n+        # batch build\n+        CPU_OPT=\n+    ;;\n+esac\n+\n+\n+CFLAGS=\"$CFLAGS $PIPE $CPU_OPT\"\n+\n+if [ \".$PCRE_OPT\" = \".\" ]; then\n+    PCRE_OPT=\"-O2 -fomit-frame-pointer $PIPE $CPU_OPT\"\n+else\n+    PCRE_OPT=\"$PCRE_OPT $PIPE\"\n+fi\n+\n+if [ \".$ZLIB_OPT\" = \".\" ]; then\n+    ZLIB_OPT=\"-O2 -fomit-frame-pointer $PIPE $CPU_OPT\"\n+else\n+    ZLIB_OPT=\"$ZLIB_OPT $PIPE\"\n+fi\n+\n+\n+# warnings\n+\n+# -W requires at least -O\n+CFLAGS=\"$CFLAGS ${NGX_GCC_OPT:--O} -W\"\n+\n+CFLAGS=\"$CFLAGS -Wall -Wpointer-arith\"\n+#CFLAGS=\"$CFLAGS -Wconversion\"\n+#CFLAGS=\"$CFLAGS -Winline\"\n+#CFLAGS=\"$CFLAGS -Wmissing-prototypes\"\n+\n+case \"$NGX_GCC_VER\" in\n+    2.*)\n+        # we have a lot of the unused function arguments\n+        CFLAGS=\"$CFLAGS -Wno-unused\"\n+    ;;\n+\n+    *)\n+        # we have a lot of the unused function arguments\n+        CFLAGS=\"$CFLAGS -Wno-unused-parameter\"\n+        # 4.2.1 shows the warning in wrong places\n+        #CFLAGS=\"$CFLAGS -Wunreachable-code\"\n+\n+        # deprecated system OpenSSL library on OS X\n+        if [ \"$NGX_SYSTEM\" = \"Darwin\" ]; then\n+            CFLAGS=\"$CFLAGS -Wno-deprecated-declarations\"\n+        fi\n+    ;;\n+esac\n+\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -Werror\"\n+\n+# debug\n+CFLAGS=\"$CFLAGS -g\"\n+\n+# DragonFly's gcc3 generates DWARF\n+#CFLAGS=\"$CFLAGS -g -gstabs\"\n+\n+if [ \".$CPP\" = \".\" ]; then\n+    CPP=\"$CC -E\"\n+fi\nDiff:\n@@ -0,0 +1,117 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# Intel C++ compiler 7.1, 8.0, 8.1, 9.0, 11.1\n+\n+NGX_ICC_VER=`$CC -V 2>&1 | grep 'Version' 2>&1 \\\n+                         | sed -e 's/^.* Version \\([^ ]*\\) *Build.*$/\\1/'`\n+\n+echo \" + icc version: $NGX_ICC_VER\"\n+\n+have=NGX_COMPILER value=\"\\\"Intel C Compiler $NGX_ICC_VER\\\"\" . auto/define\n+\n+\n+# optimizations\n+\n+CFLAGS=\"$CFLAGS -O\"\n+\n+CORE_LINK=\"$CORE_LINK -opt_report_file=$NGX_OBJS/opt_report_file\"\n+\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium and Athlon\n+        CPU_OPT=\"-march=pentium\"\n+    ;;\n+\n+    pentiumpro)\n+        # optimize for Pentium Pro, Pentium II and Pentium III\n+        CPU_OPT=\"-mcpu=pentiumpro -march=pentiumpro\"\n+    ;;\n+\n+    pentium4)\n+        # optimize for Pentium 4, default\n+        CPU_OPT=\"-march=pentium4\"\n+    ;;\n+esac\n+\n+CFLAGS=\"$CFLAGS $CPU_OPT\"\n+\n+if [ \".$PCRE_OPT\" = \".\" ]; then\n+    PCRE_OPT=\"-O $CPU_OPT\"\n+fi\n+\n+if [ \".$ZLIB_OPT\" = \".\" ]; then\n+    ZLIB_OPT=\"-O $CPU_OPT\"\n+fi\n+\n+\n+# warnings\n+\n+CFLAGS=\"$CFLAGS -w2\"\n+\n+# disable some warnings\n+\n+# invalid type conversion: \"int\" to \"char *\"\n+CFLAGS=\"$CFLAGS -wd171\"\n+# argument is incompatible with corresponding format string conversion\n+CFLAGS=\"$CFLAGS -wd181\"\n+# zero used for undefined preprocessing identifier\n+CFLAGS=\"$CFLAGS -wd193\"\n+# the format string ends before this argument\n+CFLAGS=\"$CFLAGS -wd268\"\n+# invalid format string conversion\n+CFLAGS=\"$CFLAGS -wd269\"\n+# conversion from \"long long\" to \"size_t\" may lose significant bits\n+CFLAGS=\"$CFLAGS -wd810\"\n+# parameter was never referenced\n+CFLAGS=\"$CFLAGS -wd869\"\n+# attribute \"unused\" is only allowed in a function definition, warning on pTHX_\n+CFLAGS=\"$CFLAGS -wd1301\"\n+\n+# STUB\n+# enumerated type mixed with another type\n+CFLAGS=\"$CFLAGS -wd188\"\n+# controlling expression is constant\n+CFLAGS=\"$CFLAGS -wd279\"\n+# operands are evaluated in unspecified order\n+CFLAGS=\"$CFLAGS -wd981\"\n+# external definition with no prior declaration\n+CFLAGS=\"$CFLAGS -wd1418\"\n+# external declaration in primary source file\n+CFLAGS=\"$CFLAGS -wd1419\"\n+\n+case \"$NGX_ICC_VER\" in\n+    9.*)\n+        # \"cc\" clobber ignored, warnings for Linux's htonl()/htons()\n+        CFLAGS=\"$CFLAGS -wd1469\"\n+        # explicit conversion of a 64-bit integral type to a smaller\n+        # integral type\n+        CFLAGS=\"$CFLAGS -wd1683\"\n+        # conversion from pointer to same-sized integral type,\n+        # warning on offsetof()\n+        CFLAGS=\"$CFLAGS -wd1684\"\n+        # floating-point equality and inequality comparisons are unreliable,\n+        # warning on SvTRUE()\n+        CFLAGS=\"$CFLAGS -wd1572\"\n+    ;;\n+\n+    8.*)\n+        # \"cc\" clobber ignored, warnings for Linux's htonl()/htons()\n+        CFLAGS=\"$CFLAGS -wd1469\"\n+        # floating-point equality and inequality comparisons are unreliable,\n+        # warning on SvTRUE()\n+        CFLAGS=\"$CFLAGS -wd1572\"\n+    ;;\n+\n+    *)\n+    ;;\n+esac\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -Werror\"\n+\n+# debug\n+CFLAGS=\"$CFLAGS -g\"\nDiff:\n@@ -0,0 +1,156 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# MSVC 6.0 SP2                            cl 12.00\n+# MSVC Toolkit 2003 (7.1)                 cl 13.10\n+# MSVC 2005 Express Edition SP1 (8.0)     cl 14.00\n+# MSVC 2008 Express Edition (9.0)         cl 15.00\n+# MSVC 2010 (10.0)                        cl 16.00\n+# MSVC 2015 (14.0)                        cl 19.00\n+\n+\n+NGX_MSVC_VER=`$NGX_WINE $CC 2>&1 | grep 'Compiler Version' 2>&1 \\\n+                                 | sed -e 's/^.* Version \\(.*\\)/\\1/'`\n+\n+echo \" + cl version: $NGX_MSVC_VER\"\n+\n+have=NGX_COMPILER value=\"\\\"cl $NGX_MSVC_VER\\\"\" . auto/define\n+\n+\n+ngx_msvc_ver=`echo $NGX_MSVC_VER | sed -e 's/^\\([0-9]*\\).*/\\1/'`\n+\n+\n+# optimizations\n+\n+# maximize speed, equivalent to -Og -Oi -Ot -Oy -Ob2 -Gs -GF -Gy\n+CFLAGS=\"$CFLAGS -O2\"\n+\n+# enable global optimization\n+#CFLAGS=\"$CFLAGS -Og\"\n+# enable intrinsic functions\n+#CFLAGS=\"$CFLAGS -Oi\"\n+\n+# disable inline expansion\n+#CFLAGS=\"$CFLAGS -Ob0\"\n+# explicit inline expansion\n+#CFLAGS=\"$CFLAGS -Ob1\"\n+# explicit and implicit inline expansion\n+#CFLAGS=\"$CFLAGS -Ob2\"\n+\n+# enable frame pointer omission\n+#CFLAGS=\"$CFLAGS -Oy\"\n+# disable stack checking calls\n+#CFLAGS=\"$CFLAGS -Gs\"\n+\n+# pools strings as read/write\n+#CFLAGS=\"$CFLAGS -Gf\"\n+# pools strings as read-only\n+#CFLAGS=\"$CFLAGS -GF\"\n+\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium and Athlon\n+        CPU_OPT=\"-G5\"\n+    ;;\n+\n+    pentiumpro)\n+        # optimize for Pentium Pro, Pentium II and Pentium III\n+        CPU_OPT=\"-G6\"\n+    ;;\n+\n+    pentium4)\n+        # optimize for Pentium 4, MSVC 7\n+        CPU_OPT=\"-G7\"\n+    ;;\n+esac\n+\n+# __cdecl, default, must be used with OpenSSL, md5 asm, and sha1 asm\n+#CPU_OPT=\"$CPU_OPT -Gd\"\n+# __stdcall\n+#CPU_OPT=\"$CPU_OPT -Gz\"\n+# __fastcall\n+#CPU_OPT=\"$CPU_OPT -Gr\"\n+\n+\n+CFLAGS=\"$CFLAGS $CPU_OPT\"\n+\n+\n+# warnings\n+\n+CFLAGS=\"$CFLAGS -W4\"\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -WX\"\n+\n+# disable logo\n+CFLAGS=\"$CFLAGS -nologo\"\n+\n+# the link flags\n+CORE_LINK=\"$CORE_LINK -link -verbose:lib\"\n+\n+# link with libcmt.lib, multithreaded\n+LIBC=\"-MT\"\n+# link with msvcrt.dll\n+# however, MSVC Toolkit 2003 has no MSVCRT.LIB\n+#LIBC=\"-MD\"\n+\n+CFLAGS=\"$CFLAGS $LIBC\"\n+\n+CORE_LIBS=\"$CORE_LIBS kernel32.lib user32.lib\"\n+\n+# Win32 GUI mode application\n+#CORE_LINK=\"$CORE_LINK -subsystem:windows -entry:mainCRTStartup\"\n+\n+# debug\n+# msvc under Wine issues\n+# C1902: Program database manager mismatch; please check your installation\n+if [ -z \"$NGX_WINE\" ]; then\n+   CFLAGS=\"$CFLAGS -Zi -Fd$NGX_OBJS/nginx.pdb\"\n+   CORE_LINK=\"$CORE_LINK -debug\"\n+fi\n+\n+\n+# MSVC 2005 supports C99 variadic macros\n+if [ \"$ngx_msvc_ver\" -ge 14 ]; then\n+    have=NGX_HAVE_C99_VARIADIC_MACROS . auto/have\n+fi\n+\n+\n+# precompiled headers\n+CORE_DEPS=\"$CORE_DEPS $NGX_OBJS/ngx_config.pch\"\n+CORE_LINK=\"$CORE_LINK $NGX_OBJS/ngx_pch.obj\"\n+NGX_PCH=\"$NGX_OBJS/ngx_config.pch\"\n+NGX_BUILD_PCH=\"-Ycngx_config.h -Fp$NGX_OBJS/ngx_config.pch\"\n+NGX_USE_PCH=\"-Yungx_config.h -Fp$NGX_OBJS/ngx_config.pch\"\n+\n+\n+# the resource file\n+NGX_RES=\"$NGX_OBJS/nginx.res\"\n+NGX_RCC=\"rc -fo$NGX_RES \\$(CORE_INCS) $NGX_WIN32_RC\"\n+CORE_LINK=\"$NGX_RES $CORE_LINK\"\n+\n+\n+# dynamic modules\n+#MAIN_LINK=\"-link -def:$NGX_OBJS/nginx.def\"\n+#MODULE_LINK=\"-LD $NGX_OBJS/nginx.lib\"\n+\n+\n+ngx_pic_opt=\n+ngx_objout=\"-Fo\"\n+ngx_binout=\"-Fe\"\n+ngx_objext=\"obj\"\n+\n+ngx_long_start='@<<\n+\t'\n+ngx_long_end='<<'\n+ngx_long_regex_cont=' \\\n+\t'\n+ngx_long_cont='\n+\t'\n+\n+# MSVC understand / in path\n+#ngx_regex_dirsep='\\\\'\n+#ngx_dirsep=\"\\\\\"\nDiff:\n@@ -0,0 +1,70 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ \"$NGX_PLATFORM\" != win32 ]; then\n+\n+    ngx_feature=\"C compiler\"\n+    ngx_feature_name=\n+    ngx_feature_run=yes\n+    ngx_feature_incs=\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\n+    . auto/feature\n+\n+    if [ $ngx_found = no ]; then\n+        echo\n+        echo $0: error: C compiler $CC is not found\n+        echo\n+        exit 1\n+    fi\n+\n+fi\n+\n+\n+if [ \"$CC\" = cl ]; then\n+    NGX_CC_NAME=msvc\n+    echo \" + using Microsoft Visual C++ compiler\"\n+\n+elif [ \"$CC\" = wcl386 ]; then\n+    NGX_CC_NAME=owc\n+    echo \" + using Open Watcom C compiler\"\n+\n+elif [ \"$CC\" = bcc32 ]; then\n+    NGX_CC_NAME=bcc\n+    echo \" + using Borland C++ compiler\"\n+\n+elif `$CC -V 2>&1 | grep '^Intel(R) C' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=icc\n+    echo \" + using Intel C++ compiler\"\n+\n+elif `$CC -v 2>&1 | grep 'gcc version' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=gcc\n+    echo \" + using GNU C compiler\"\n+\n+elif `$CC -v 2>&1 | grep 'clang version' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=clang\n+    echo \" + using Clang C compiler\"\n+\n+elif `$CC -v 2>&1 | grep 'LLVM version' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=clang\n+    echo \" + using Clang C compiler\"\n+\n+elif `$CC -V 2>&1 | grep 'Sun C' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=sunc\n+    echo \" + using Sun C compiler\"\n+\n+elif `$CC -V 2>&1 | grep '^Compaq C' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=ccc\n+    echo \" + using Compaq C compiler\"\n+\n+elif `$CC -V 2>&1 | grep '^aCC: ' >/dev/null 2>&1`; then\n+    NGX_CC_NAME=acc\n+    echo \" + using HP aC++ compiler\"\n+\n+else\n+    NGX_CC_NAME=unknown\n+\n+fi\nDiff:\n@@ -0,0 +1,103 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# Open Watcom C 1.0, 1.2, 1.3\n+\n+# optimizations\n+\n+# maximize speed\n+CFLAGS=\"$CFLAGS -ot\"\n+# reorder instructions for best pipeline usage\n+CFLAGS=\"$CFLAGS -op\"\n+# inline intrinsic functions\n+CFLAGS=\"$CFLAGS -oi\"\n+# inline expansion\n+CFLAGS=\"$CFLAGS -oe\"\n+# disable stack checking calls\n+CFLAGS=\"$CFLAGS -s\"\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium and Athlon\n+        # register-based arguments passing conventions\n+        CPU_OPT=\"-5r\"\n+        # stack-based arguments passing conventions\n+        #CPU_OPT=\"-5s\"\n+    ;;\n+\n+    pentiumpro)\n+        # optimize for Pentium Pro, Pentium II and Pentium III\n+        # register-based arguments passing conventions\n+        CPU_OPT=\"-6r\"\n+        # stack-based arguments passing conventions\n+        #CPU_OPT=\"-6s\"\n+    ;;\n+esac\n+\n+CFLAGS=\"$CFLAGS $CPU_OPT\"\n+\n+\n+# warnings\n+\n+# maximum level\n+CFLAGS=\"$CFLAGS -wx\"\n+#CFLAGS=\"$CFLAGS -w3\"\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -we\"\n+\n+# built target is NT\n+CFLAGS=\"$CFLAGS -bt=nt\"\n+\n+# multithreaded\n+CFLAGS=\"$CFLAGS -bm\"\n+\n+# debug\n+CFLAGS=\"$CFLAGS -d2\"\n+\n+# quiet\n+CFLAGS=\"$CFLAGS -zq\"\n+\n+# Open Watcom C 1.2\n+have=NGX_HAVE_C99_VARIADIC_MACROS . auto/have\n+\n+\n+# the precompiled headers\n+#CORE_DEPS=\"$CORE_DEPS $NGX_OBJS/ngx_config.pch\"\n+#NGX_PCH=\"$NGX_OBJS/ngx_config.pch\"\n+#NGX_BUILD_PCH=\"-fhq=$NGX_OBJS/ngx_config.pch\"\n+#NGX_USE_PCH=\"-fh=$NGX_OBJS/ngx_config.pch\"\n+\n+\n+# the link flags, built target is NT GUI mode application\n+#CORE_LINK=\"$CORE_LINK -l=nt_win\"\n+\n+\n+# the resource file\n+NGX_RCC=\"wrc \\$(CORE_INCS) -fo=$NGX_OBJS/nginx.res \"\n+NGX_RCC=\"$NGX_RCC $NGX_WIN32_RC $NGX_OBJS/nginx.exe\"\n+\n+\n+ngx_include_opt=\"-i=\"\n+ngx_objout=\"-fo\"\n+ngx_binout=\"-fe=\"\n+ngx_objext=\"obj\"\n+\n+ngx_regex_dirsep='\\\\'\n+ngx_dirsep=\"\\\\\"\n+\n+ngx_long_start=' '\n+ngx_long_end=' '\n+ngx_long_regex_cont=' \\&\\\n+\t'\n+ngx_long_cont=' &\n+\t'\n+\n+ngx_regex_cont=' \\&\\\n+\t'\n+ngx_cont=' &\n+\t'\n+ngx_tab=' &\n+\t\t'\nDiff:\n@@ -0,0 +1,163 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+# Sun C 5.7 Patch 117837-04 2005/05/11    Sun Studio 10\n+# Sun C 5.8 2005/10/13                    Sun Studio 11\n+# Sun C 5.9 SunOS_i386 2007/05/03         Sun Studio 12\n+# Sun C 5.9 SunOS_sparc 2007/05/03\n+# Sun C 5.10 SunOS_i386 2009/06/03        Sun Studio 12.1\n+# Sun C 5.11 SunOS_i386 2010/08/13        Oracle Solaris Studio 12.2\n+# Sun C 5.12 SunOS_i386 2011/11/16        Oracle Solaris Studio 12.3\n+# Sun C 5.13 SunOS_i386 2014/10/20        Oracle Solaris Studio 12.4\n+# Sun C 5.14 SunOS_i386 2016/05/31        Oracle Developer Studio 12.5\n+\n+NGX_SUNC_VER=`$CC -V 2>&1 | grep 'Sun C' 2>&1 \\\n+                          | sed -e 's/^.* Sun C \\(.*\\)/\\1/'`\n+\n+echo \" + Sun C version: $NGX_SUNC_VER\"\n+\n+have=NGX_COMPILER value=\"\\\"Sun C $NGX_SUNC_VER\\\"\" . auto/define\n+\n+\n+cat << END > $NGX_AUTOTEST.c\n+\n+int main(void) {\n+    printf(\"%d\", __SUNPRO_C);\n+    return 0;\n+}\n+\n+END\n+\n+eval \"$CC -o $NGX_AUTOTEST $NGX_AUTOTEST.c >> $NGX_ERR 2>&1\"\n+\n+if [ -x $NGX_AUTOTEST ]; then\n+    ngx_sunc_ver=`$NGX_AUTOTEST`\n+fi\n+\n+rm -rf $NGX_AUTOTEST*\n+\n+# 1424 == 0x590, Sun Studio 12\n+\n+if [ \"$ngx_sunc_ver\" -ge 1424 ]; then\n+    ngx_sparc32=\"-m32\"\n+    ngx_sparc64=\"-m64\"\n+    ngx_amd64=\"-m64\"\n+\n+else\n+    ngx_sparc32=\"-xarch=v8plus\"\n+    ngx_sparc64=\"-xarch=v9\"\n+    ngx_amd64=\"-xarch=amd64\"\n+fi\n+\n+case \"$NGX_MACHINE\" in\n+\n+    i86pc)\n+        NGX_AUX=\" src/os/unix/ngx_sunpro_x86.il\"\n+    ;;\n+\n+    sun4u | sun4v)\n+        NGX_AUX=\" src/os/unix/ngx_sunpro_sparc64.il\"\n+    ;;\n+\n+esac\n+\n+MAIN_LINK=\n+MODULE_LINK=\"-G\"\n+\n+\n+# optimizations\n+\n+# 20736 == 0x5100, Sun Studio 12.1\n+\n+if [ \"$ngx_sunc_ver\" -ge 20736 ]; then\n+    ngx_fast=\"-fast\"\n+\n+else\n+    # older versions had problems with bit-fields\n+    ngx_fast=\"-fast -xalias_level=any\"\n+fi\n+\n+IPO=-xipo\n+CFLAGS=\"$CFLAGS $ngx_fast $IPO\"\n+CORE_LINK=\"$CORE_LINK $ngx_fast $IPO\"\n+\n+\n+case $CPU in\n+    pentium)\n+        # optimize for Pentium and Athlon\n+        CPU_OPT=\"-xchip=pentium\"\n+    ;;\n+\n+    pentiumpro)\n+        # optimize for Pentium Pro, Pentium II\n+        CPU_OPT=\"-xchip=pentium_pro\"\n+    ;;\n+\n+    pentium3)\n+        # optimize for Pentium III\n+        CPU_OPT=\"-xchip=pentium3\"\n+        #CPU_OPT=\"$CPU_OPT -xarch=sse\"\n+        CPU_OPT=\"$CPU_OPT -xcache=16/32/4:256/32/4\"\n+    ;;\n+\n+    pentium4)\n+        # optimize for Pentium 4\n+        CPU_OPT=\"-xchip=pentium4\"\n+        #CPU_OPT=\"$CPU_OPT -xarch=sse2\"\n+        CPU_OPT=\"$CPU_OPT -xcache=8/64/4:256/128/8\"\n+    ;;\n+\n+    opteron)\n+        # optimize for Opteron\n+        CPU_OPT=\"-xchip=opteron\"\n+        #CPU_OPT=\"$CPU_OPT -xarch=sse2\"\n+        CPU_OPT=\"$CPU_OPT -xcache=64/64/2:1024/64/16\"\n+    ;;\n+\n+    sparc32)\n+        # build 32-bit UltraSparc binary\n+        CPU_OPT=\"$ngx_sparc32\"\n+        CORE_LINK=\"$CORE_LINK $ngx_sparc32\"\n+        CC_AUX_FLAGS=\"$CC_AUX_FLAGS $ngx_sparc32\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    sparc64)\n+        # build 64-bit UltraSparc binary\n+        CPU_OPT=\"$ngx_sparc64\"\n+        CORE_LINK=\"$CORE_LINK $ngx_sparc64\"\n+        CC_AUX_FLAGS=\"$CC_AUX_FLAGS $ngx_sparc64\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+    amd64)\n+        # build 64-bit amd64 binary\n+        CPU_OPT=\"$ngx_amd64\"\n+        CORE_LINK=\"$CORE_LINK $ngx_amd64\"\n+        CC_AUX_FLAGS=\"$CC_AUX_FLAGS $ngx_amd64\"\n+        NGX_AUX=\" src/os/unix/ngx_sunpro_amd64.il\"\n+        NGX_CPU_CACHE_LINE=64\n+    ;;\n+\n+esac\n+\n+\n+CFLAGS=\"$CFLAGS $CPU_OPT\"\n+\n+\n+if [ \".$PCRE_OPT\" = \".\" ]; then\n+    PCRE_OPT=\"$ngx_fast $IPO $CPU_OPT\"\n+fi\n+\n+if [ \".$ZLIB_OPT\" = \".\" ]; then\n+    ZLIB_OPT=\"$ngx_fast $IPO $CPU_OPT\"\n+fi\n+\n+\n+# stop on warning\n+CFLAGS=\"$CFLAGS -errwarn=%all\"\n+\n+# debug\n+CFLAGS=\"$CFLAGS -g\"\nDiff:\n@@ -0,0 +1,116 @@\n+#!/bin/sh\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+LC_ALL=C\n+export LC_ALL\n+\n+. auto/options\n+. auto/init\n+. auto/sources\n+\n+test -d $NGX_OBJS || mkdir -p $NGX_OBJS\n+\n+echo > $NGX_AUTO_HEADERS_H\n+echo > $NGX_AUTOCONF_ERR\n+\n+echo \"#define NGX_CONFIGURE \\\"$NGX_CONFIGURE\\\"\" > $NGX_AUTO_CONFIG_H\n+\n+\n+if [ $NGX_DEBUG = YES ]; then\n+    have=NGX_DEBUG . auto/have\n+fi\n+\n+\n+if test -z \"$NGX_PLATFORM\"; then\n+    echo \"checking for OS\"\n+\n+    NGX_SYSTEM=`uname -s 2>/dev/null`\n+    NGX_RELEASE=`uname -r 2>/dev/null`\n+    NGX_MACHINE=`uname -m 2>/dev/null`\n+\n+    echo \" + $NGX_SYSTEM $NGX_RELEASE $NGX_MACHINE\"\n+\n+    NGX_PLATFORM=\"$NGX_SYSTEM:$NGX_RELEASE:$NGX_MACHINE\";\n+\n+    case \"$NGX_SYSTEM\" in\n+        MINGW32_* | MINGW64_* | MSYS_*)\n+            NGX_PLATFORM=win32\n+        ;;\n+    esac\n+\n+else\n+    echo \"building for $NGX_PLATFORM\"\n+    NGX_SYSTEM=$NGX_PLATFORM\n+fi\n+\n+. auto/cc/conf\n+\n+if [ \"$NGX_PLATFORM\" != win32 ]; then\n+    . auto/headers\n+fi\n+\n+. auto/os/conf\n+\n+if [ \"$NGX_PLATFORM\" != win32 ]; then\n+    . auto/unix\n+fi\n+\n+. auto/threads\n+. auto/modules\n+. auto/lib/conf\n+\n+case \".$NGX_PREFIX\" in\n+    .)\n+        NGX_PREFIX=${NGX_PREFIX:-/usr/local/nginx}\n+        have=NGX_PREFIX value=\"\\\"$NGX_PREFIX/\\\"\" . auto/define\n+    ;;\n+\n+    .!)\n+        NGX_PREFIX=\n+    ;;\n+\n+    *)\n+        have=NGX_PREFIX value=\"\\\"$NGX_PREFIX/\\\"\" . auto/define\n+    ;;\n+esac\n+\n+if [ \".$NGX_CONF_PREFIX\" != \".\" ]; then\n+    have=NGX_CONF_PREFIX value=\"\\\"$NGX_CONF_PREFIX/\\\"\" . auto/define\n+fi\n+\n+have=NGX_SBIN_PATH value=\"\\\"$NGX_SBIN_PATH\\\"\" . auto/define\n+have=NGX_CONF_PATH value=\"\\\"$NGX_CONF_PATH\\\"\" . auto/define\n+have=NGX_PID_PATH value=\"\\\"$NGX_PID_PATH\\\"\" . auto/define\n+have=NGX_LOCK_PATH value=\"\\\"$NGX_LOCK_PATH\\\"\" . auto/define\n+have=NGX_ERROR_LOG_PATH value=\"\\\"$NGX_ERROR_LOG_PATH\\\"\" . auto/define\n+\n+have=NGX_HTTP_LOG_PATH value=\"\\\"$NGX_HTTP_LOG_PATH\\\"\" . auto/define\n+have=NGX_HTTP_CLIENT_TEMP_PATH value=\"\\\"$NGX_HTTP_CLIENT_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_PROXY_TEMP_PATH value=\"\\\"$NGX_HTTP_PROXY_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_FASTCGI_TEMP_PATH value=\"\\\"$NGX_HTTP_FASTCGI_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_UWSGI_TEMP_PATH value=\"\\\"$NGX_HTTP_UWSGI_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_SCGI_TEMP_PATH value=\"\\\"$NGX_HTTP_SCGI_TEMP_PATH\\\"\"\n+. auto/define\n+\n+. auto/make\n+. auto/lib/make\n+. auto/install\n+\n+# STUB\n+. auto/stubs\n+\n+have=NGX_USER value=\"\\\"$NGX_USER\\\"\" . auto/define\n+have=NGX_GROUP value=\"\\\"$NGX_GROUP\\\"\" . auto/define\n+\n+if [ \".$NGX_BUILD\" != \".\" ]; then\n+    have=NGX_BUILD value=\"\\\"$NGX_BUILD\\\"\" . auto/define\n+fi\n+\n+. auto/summary\nDiff:\n@@ -0,0 +1,12 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#ifndef $have\n+#define $have  $value\n+#endif\n+\n+END\nDiff:\n@@ -0,0 +1,50 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo $ngx_n \"checking for system byte ordering ...$ngx_c\"\n+\n+cat << END >> $NGX_AUTOCONF_ERR\n+\n+----------------------------------------\n+checking for system byte ordering\n+\n+END\n+\n+\n+cat << END > $NGX_AUTOTEST.c\n+\n+int main(void) {\n+    int i = 0x11223344;\n+    char *p;\n+\n+    p = (char *) &i;\n+    if (*p == 0x44) return 0;\n+    return 1;\n+}\n+\n+END\n+\n+ngx_test=\"$CC $CC_TEST_FLAGS $CC_AUX_FLAGS \\\n+          -o $NGX_AUTOTEST $NGX_AUTOTEST.c $NGX_LD_OPT $ngx_feature_libs\"\n+\n+eval \"$ngx_test >> $NGX_AUTOCONF_ERR 2>&1\"\n+\n+if [ -x $NGX_AUTOTEST ]; then\n+    if $NGX_AUTOTEST >/dev/null 2>&1; then\n+        echo \" little endian\"\n+        have=NGX_HAVE_LITTLE_ENDIAN . auto/have\n+    else\n+        echo \" big endian\"\n+    fi\n+\n+    rm -rf $NGX_AUTOTEST*\n+\n+else\n+    rm -rf $NGX_AUTOTEST*\n+\n+    echo\n+    echo \"$0: error: cannot detect system byte ordering\"\n+    exit 1\n+fi\nDiff:\n@@ -0,0 +1,123 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo $ngx_n \"checking for $ngx_feature ...$ngx_c\"\n+\n+cat << END >> $NGX_AUTOCONF_ERR\n+\n+----------------------------------------\n+checking for $ngx_feature\n+\n+END\n+\n+ngx_found=no\n+\n+if test -n \"$ngx_feature_name\"; then\n+    ngx_have_feature=`echo $ngx_feature_name \\\n+                   | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ`\n+fi\n+\n+if test -n \"$ngx_feature_path\"; then\n+    for ngx_temp in $ngx_feature_path; do\n+        ngx_feature_inc_path=\"$ngx_feature_inc_path -I $ngx_temp\"\n+    done\n+fi\n+\n+cat << END > $NGX_AUTOTEST.c\n+\n+#include <sys/types.h>\n+$NGX_INCLUDE_UNISTD_H\n+$ngx_feature_incs\n+\n+int main(void) {\n+    $ngx_feature_test;\n+    return 0;\n+}\n+\n+END\n+\n+\n+ngx_test=\"$CC $CC_TEST_FLAGS $CC_AUX_FLAGS $ngx_feature_inc_path \\\n+          -o $NGX_AUTOTEST $NGX_AUTOTEST.c $NGX_TEST_LD_OPT $ngx_feature_libs\"\n+\n+ngx_feature_inc_path=\n+\n+eval \"/bin/sh -c \\\"$ngx_test\\\" >> $NGX_AUTOCONF_ERR 2>&1\"\n+\n+\n+if [ -x $NGX_AUTOTEST ]; then\n+\n+    case \"$ngx_feature_run\" in\n+\n+        yes)\n+            # /bin/sh is used to intercept \"Killed\" or \"Abort trap\" messages\n+            if /bin/sh -c $NGX_AUTOTEST >> $NGX_AUTOCONF_ERR 2>&1; then\n+                echo \" found\"\n+                ngx_found=yes\n+\n+                if test -n \"$ngx_feature_name\"; then\n+                    have=$ngx_have_feature . auto/have\n+                fi\n+\n+            else\n+                echo \" found but is not working\"\n+            fi\n+        ;;\n+\n+        value)\n+            # /bin/sh is used to intercept \"Killed\" or \"Abort trap\" messages\n+            if /bin/sh -c $NGX_AUTOTEST >> $NGX_AUTOCONF_ERR 2>&1; then\n+                echo \" found\"\n+                ngx_found=yes\n+\n+                cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#ifndef $ngx_feature_name\n+#define $ngx_feature_name  `$NGX_AUTOTEST`\n+#endif\n+\n+END\n+            else\n+                echo \" found but is not working\"\n+            fi\n+        ;;\n+\n+        bug)\n+            # /bin/sh is used to intercept \"Killed\" or \"Abort trap\" messages\n+            if /bin/sh -c $NGX_AUTOTEST >> $NGX_AUTOCONF_ERR 2>&1; then\n+                echo \" not found\"\n+\n+            else\n+                echo \" found\"\n+                ngx_found=yes\n+\n+                if test -n \"$ngx_feature_name\"; then\n+                    have=$ngx_have_feature . auto/have\n+                fi\n+            fi\n+        ;;\n+\n+        *)\n+            echo \" found\"\n+            ngx_found=yes\n+\n+            if test -n \"$ngx_feature_name\"; then\n+                have=$ngx_have_feature . auto/have\n+            fi\n+        ;;\n+\n+    esac\n+\n+else\n+    echo \" not found\"\n+\n+    echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+    cat $NGX_AUTOTEST.c  >> $NGX_AUTOCONF_ERR\n+    echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+    echo $ngx_test       >> $NGX_AUTOCONF_ERR\n+    echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+fi\n+\n+rm -rf $NGX_AUTOTEST*\nDiff:\n@@ -0,0 +1,12 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#ifndef $have\n+#define $have  1\n+#endif\n+\n+END\nDiff:\n@@ -0,0 +1,12 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+cat << END >> $NGX_AUTO_HEADERS_H\n+\n+#ifndef $have\n+#define $have  1\n+#endif\n+\n+END\nDiff:\n@@ -0,0 +1,13 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+ngx_include=\"unistd.h\";      . auto/include\n+ngx_include=\"inttypes.h\";    . auto/include\n+ngx_include=\"limits.h\";      . auto/include\n+ngx_include=\"sys/filio.h\";   . auto/include\n+ngx_include=\"sys/param.h\";   . auto/include\n+ngx_include=\"sys/mount.h\";   . auto/include\n+ngx_include=\"sys/statvfs.h\"; . auto/include\n+ngx_include=\"crypt.h\";       . auto/include\nDiff:\n@@ -0,0 +1,58 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo $ngx_n \"checking for $ngx_include ...$ngx_c\"\n+\n+cat << END >> $NGX_AUTOCONF_ERR\n+\n+----------------------------------------\n+checking for $ngx_include\n+\n+END\n+\n+\n+ngx_found=no\n+\n+cat << END > $NGX_AUTOTEST.c\n+\n+$NGX_INCLUDE_SYS_PARAM_H\n+#include <$ngx_include>\n+\n+int main(void) {\n+    return 0;\n+}\n+\n+END\n+\n+\n+ngx_test=\"$CC -o $NGX_AUTOTEST $NGX_AUTOTEST.c\"\n+\n+eval \"$ngx_test >> $NGX_AUTOCONF_ERR 2>&1\"\n+\n+if [ -x $NGX_AUTOTEST ]; then\n+\n+    ngx_found=yes\n+\n+    echo \" found\"\n+\n+    ngx_name=`echo $ngx_include \\\n+              | tr abcdefghijklmnopqrstuvwxyz/. ABCDEFGHIJKLMNOPQRSTUVWXYZ__`\n+\n+\n+    have=NGX_HAVE_$ngx_name . auto/have_headers\n+\n+    eval \"NGX_INCLUDE_$ngx_name='#include <$ngx_include>'\"\n+\n+else\n+    echo \" not found\"\n+\n+    echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+    cat $NGX_AUTOTEST.c  >> $NGX_AUTOCONF_ERR\n+    echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+    echo $ngx_test       >> $NGX_AUTOCONF_ERR\n+    echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+fi\n+\n+rm -rf $NGX_AUTOTEST*\nDiff:\n@@ -0,0 +1,51 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+NGX_MAKEFILE=$NGX_OBJS/Makefile\n+NGX_MODULES_C=$NGX_OBJS/ngx_modules.c\n+\n+NGX_AUTO_HEADERS_H=$NGX_OBJS/ngx_auto_headers.h\n+NGX_AUTO_CONFIG_H=$NGX_OBJS/ngx_auto_config.h\n+\n+NGX_AUTOTEST=$NGX_OBJS/autotest\n+NGX_AUTOCONF_ERR=$NGX_OBJS/autoconf.err\n+\n+# STUBs\n+NGX_ERR=$NGX_OBJS/autoconf.err\n+MAKEFILE=$NGX_OBJS/Makefile\n+\n+\n+NGX_PCH=\n+NGX_USE_PCH=\n+\n+\n+# check the echo's \"-n\" option and \"\\c\" capability\n+\n+if echo \"test\\c\" | grep c >/dev/null; then\n+\n+    if echo -n test | grep n >/dev/null; then\n+        ngx_n=\n+        ngx_c=\n+\n+    else\n+        ngx_n=-n\n+        ngx_c=\n+    fi\n+\n+else\n+    ngx_n=\n+    ngx_c='\\c'\n+fi\n+\n+\n+# create Makefile\n+\n+cat << END > Makefile\n+\n+default:\tbuild\n+\n+clean:\n+\trm -rf Makefile $NGX_OBJS\n+END\nDiff:\n@@ -0,0 +1,218 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $USE_PERL != NO ]; then\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+install_perl_modules:\n+\tcd $NGX_OBJS/src/http/modules/perl && \\$(MAKE) install\n+END\n+\n+    NGX_INSTALL_PERL_MODULES=install_perl_modules\n+\n+fi\n+\n+\n+case \".$NGX_SBIN_PATH\" in\n+    ./*)\n+    ;;\n+\n+    *)\n+        NGX_SBIN_PATH=$NGX_PREFIX/$NGX_SBIN_PATH\n+    ;;\n+esac\n+\n+\n+case \".$NGX_MODULES_PATH\" in\n+    ./*)\n+    ;;\n+\n+    *)\n+        NGX_MODULES_PATH=$NGX_PREFIX/$NGX_MODULES_PATH\n+    ;;\n+esac\n+\n+NGX_MODULES_PATH=`dirname $NGX_MODULES_PATH/.`\n+\n+\n+case \".$NGX_CONF_PATH\" in\n+    ./*)\n+    ;;\n+\n+    *)\n+        NGX_CONF_PATH=$NGX_PREFIX/$NGX_CONF_PATH\n+    ;;\n+esac\n+\n+\n+NGX_CONF_PREFIX=`dirname $NGX_CONF_PATH`\n+\n+\n+case \".$NGX_PID_PATH\" in\n+    ./*)\n+    ;;\n+\n+    *)\n+        NGX_PID_PATH=$NGX_PREFIX/$NGX_PID_PATH\n+    ;;\n+esac\n+\n+\n+case \".$NGX_ERROR_LOG_PATH\" in\n+    ./* | .)\n+    ;;\n+\n+    *)\n+        NGX_ERROR_LOG_PATH=$NGX_PREFIX/$NGX_ERROR_LOG_PATH\n+    ;;\n+esac\n+\n+\n+case \".$NGX_HTTP_LOG_PATH\" in\n+    ./*)\n+    ;;\n+\n+    *)\n+        NGX_HTTP_LOG_PATH=$NGX_PREFIX/$NGX_HTTP_LOG_PATH\n+    ;;\n+esac\n+\n+\n+if test -f man/nginx.8 ; then\n+    NGX_MAN=man/nginx.8\n+else\n+    NGX_MAN=docs/man/nginx.8\n+fi\n+\n+if test -d html ; then\n+    NGX_HTML=html\n+else\n+    NGX_HTML=docs/html\n+fi\n+\n+cat << END                                                    >> $NGX_MAKEFILE\n+\n+manpage:\t$NGX_OBJS/nginx.8\n+\n+$NGX_OBJS/nginx.8:\t$NGX_MAN $NGX_AUTO_CONFIG_H\n+\tsed -e \"s|%%PREFIX%%|$NGX_PREFIX|\" \\\\\n+\t\t-e \"s|%%PID_PATH%%|$NGX_PID_PATH|\" \\\\\n+\t\t-e \"s|%%CONF_PATH%%|$NGX_CONF_PATH|\" \\\\\n+\t\t-e \"s|%%ERROR_LOG_PATH%%|${NGX_ERROR_LOG_PATH:-stderr}|\" \\\\\n+\t\t< $NGX_MAN > \\$@\n+\n+install:\tbuild $NGX_INSTALL_PERL_MODULES\n+\ttest -d '\\$(DESTDIR)$NGX_PREFIX' || mkdir -p '\\$(DESTDIR)$NGX_PREFIX'\n+\n+\ttest -d '\\$(DESTDIR)`dirname \"$NGX_SBIN_PATH\"`' \\\\\n+\t\t|| mkdir -p '\\$(DESTDIR)`dirname \"$NGX_SBIN_PATH\"`'\n+\ttest ! -f '\\$(DESTDIR)$NGX_SBIN_PATH' \\\\\n+\t\t|| mv '\\$(DESTDIR)$NGX_SBIN_PATH' \\\\\n+\t\t\t'\\$(DESTDIR)$NGX_SBIN_PATH.old'\n+\tcp $NGX_OBJS/nginx '\\$(DESTDIR)$NGX_SBIN_PATH'\n+\n+\ttest -d '\\$(DESTDIR)$NGX_CONF_PREFIX' \\\\\n+\t\t|| mkdir -p '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\n+\tcp conf/koi-win '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/koi-utf '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/win-utf '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\n+\ttest -f '\\$(DESTDIR)$NGX_CONF_PREFIX/mime.types' \\\\\n+\t\t|| cp conf/mime.types '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/mime.types '\\$(DESTDIR)$NGX_CONF_PREFIX/mime.types.default'\n+\n+\ttest -f '\\$(DESTDIR)$NGX_CONF_PREFIX/fastcgi_params' \\\\\n+\t\t|| cp conf/fastcgi_params '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/fastcgi_params \\\\\n+\t\t'\\$(DESTDIR)$NGX_CONF_PREFIX/fastcgi_params.default'\n+\n+\ttest -f '\\$(DESTDIR)$NGX_CONF_PREFIX/fastcgi.conf' \\\\\n+\t\t|| cp conf/fastcgi.conf '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/fastcgi.conf '\\$(DESTDIR)$NGX_CONF_PREFIX/fastcgi.conf.default'\n+\n+\ttest -f '\\$(DESTDIR)$NGX_CONF_PREFIX/uwsgi_params' \\\\\n+\t\t|| cp conf/uwsgi_params '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/uwsgi_params \\\\\n+\t\t'\\$(DESTDIR)$NGX_CONF_PREFIX/uwsgi_params.default'\n+\n+\ttest -f '\\$(DESTDIR)$NGX_CONF_PREFIX/scgi_params' \\\\\n+\t\t|| cp conf/scgi_params '\\$(DESTDIR)$NGX_CONF_PREFIX'\n+\tcp conf/scgi_params \\\\\n+\t\t'\\$(DESTDIR)$NGX_CONF_PREFIX/scgi_params.default'\n+\n+\ttest -f '\\$(DESTDIR)$NGX_CONF_PATH' \\\\\n+\t\t|| cp conf/nginx.conf '\\$(DESTDIR)$NGX_CONF_PATH'\n+\tcp conf/nginx.conf '\\$(DESTDIR)$NGX_CONF_PREFIX/nginx.conf.default'\n+\n+\ttest -d '\\$(DESTDIR)`dirname \"$NGX_PID_PATH\"`' \\\\\n+\t\t|| mkdir -p '\\$(DESTDIR)`dirname \"$NGX_PID_PATH\"`'\n+\n+\ttest -d '\\$(DESTDIR)`dirname \"$NGX_HTTP_LOG_PATH\"`' \\\\\n+\t\t|| mkdir -p '\\$(DESTDIR)`dirname \"$NGX_HTTP_LOG_PATH\"`'\n+\n+\ttest -d '\\$(DESTDIR)$NGX_PREFIX/html' \\\\\n+\t\t|| cp -R $NGX_HTML '\\$(DESTDIR)$NGX_PREFIX'\n+END\n+\n+\n+if test -n \"$NGX_ERROR_LOG_PATH\"; then\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+\ttest -d '\\$(DESTDIR)`dirname \"$NGX_ERROR_LOG_PATH\"`' \\\\\n+\t\t|| mkdir -p '\\$(DESTDIR)`dirname \"$NGX_ERROR_LOG_PATH\"`'\n+END\n+\n+fi\n+\n+\n+if test -n \"$DYNAMIC_MODULES\"; then\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+\ttest -d '\\$(DESTDIR)$NGX_MODULES_PATH' \\\\\n+\t\t|| mkdir -p '\\$(DESTDIR)$NGX_MODULES_PATH'\n+END\n+\n+fi\n+\n+\n+for ngx_module in $DYNAMIC_MODULES\n+do\n+    ngx_module=$ngx_module$ngx_modext\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+\ttest ! -f '\\$(DESTDIR)$NGX_MODULES_PATH/$ngx_module' \\\\\n+\t\t|| mv '\\$(DESTDIR)$NGX_MODULES_PATH/$ngx_module' \\\\\n+\t\t\t'\\$(DESTDIR)$NGX_MODULES_PATH/$ngx_module.old'\n+\tcp $NGX_OBJS/$ngx_module '\\$(DESTDIR)$NGX_MODULES_PATH/$ngx_module'\n+END\n+\n+done\n+\n+\n+# create Makefile\n+\n+cat << END >> Makefile\n+\n+build:\n+\t\\$(MAKE) -f $NGX_MAKEFILE\n+\n+install:\n+\t\\$(MAKE) -f $NGX_MAKEFILE install\n+\n+modules:\n+\t\\$(MAKE) -f $NGX_MAKEFILE modules\n+\n+upgrade:\n+\t$NGX_SBIN_PATH -t\n+\n+\tkill -USR2 \\`cat $NGX_PID_PATH\\`\n+\tsleep 1\n+\ttest -f $NGX_PID_PATH.oldbin\n+\n+\tkill -QUIT \\`cat $NGX_PID_PATH.oldbin\\`\n+END\nDiff:\n@@ -0,0 +1,54 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $USE_PCRE = YES -o $PCRE != NONE ]; then\n+    . auto/lib/pcre/conf\n+\n+else\n+    if [ $USE_PCRE = DISABLED -a $HTTP = YES -a $HTTP_REWRITE = YES ]; then\n+\n+cat << END\n+\n+$0: error: the HTTP rewrite module requires the PCRE library.\n+You can either disable the module by using --without-http_rewrite_module\n+option or you have to enable the PCRE support.\n+\n+END\n+        exit 1\n+    fi\n+fi\n+\n+\n+if [ $USE_OPENSSL = YES ]; then\n+    . auto/lib/openssl/conf\n+fi\n+\n+if [ $USE_ZLIB = YES ]; then\n+    . auto/lib/zlib/conf\n+fi\n+\n+if [ $USE_LIBXSLT != NO ]; then\n+    . auto/lib/libxslt/conf\n+fi\n+\n+if [ $USE_LIBGD != NO ]; then\n+    . auto/lib/libgd/conf\n+fi\n+\n+if [ $USE_PERL != NO ]; then\n+    . auto/lib/perl/conf\n+fi\n+\n+if [ $USE_GEOIP != NO ]; then\n+    . auto/lib/geoip/conf\n+fi\n+\n+if [ $NGX_GOOGLE_PERFTOOLS = YES ]; then\n+    . auto/lib/google-perftools/conf\n+fi\n+\n+if [ $NGX_LIBATOMIC != NO ]; then\n+    . auto/lib/libatomic/conf\n+fi\nDiff:\n@@ -0,0 +1,97 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+    ngx_feature=\"GeoIP library\"\n+    ngx_feature_name=\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <GeoIP.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\"-lGeoIP\"\n+    ngx_feature_test=\"GeoIP_open(NULL, 0)\"\n+    . auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # FreeBSD port\n+\n+    ngx_feature=\"GeoIP library in /usr/local/\"\n+    ngx_feature_path=\"/usr/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lGeoIP\"\n+    else\n+        ngx_feature_libs=\"-L/usr/local/lib -lGeoIP\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # NetBSD port\n+\n+    ngx_feature=\"GeoIP library in /usr/pkg/\"\n+    ngx_feature_path=\"/usr/pkg/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/pkg/lib -L/usr/pkg/lib -lGeoIP\"\n+    else\n+        ngx_feature_libs=\"-L/usr/pkg/lib -lGeoIP\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # MacPorts\n+\n+    ngx_feature=\"GeoIP library in /opt/local/\"\n+    ngx_feature_path=\"/opt/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lGeoIP\"\n+    else\n+        ngx_feature_libs=\"-L/opt/local/lib -lGeoIP\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = yes ]; then\n+\n+    CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+\n+    if [ $USE_GEOIP = YES ]; then\n+        CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+    fi\n+\n+    NGX_LIB_GEOIP=$ngx_feature_libs\n+\n+    ngx_feature=\"GeoIP IPv6 support\"\n+    ngx_feature_name=\"NGX_HAVE_GEOIP_V6\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <stdio.h>\n+                      #include <GeoIP.h>\"\n+    #ngx_feature_path=\n+    #ngx_feature_libs=\n+    ngx_feature_test=\"printf(\\\"%d\\\", GEOIP_CITY_EDITION_REV0_V6);\"\n+    . auto/feature\n+\n+else\n+\n+cat << END\n+\n+$0: error: the GeoIP module requires the GeoIP library.\n+You can either do not enable the module or install the library.\n+\n+END\n+\n+    exit 1\n+fi\nDiff:\n@@ -0,0 +1,62 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+    ngx_feature=\"Google perftools\"\n+    ngx_feature_name=\n+    ngx_feature_run=no\n+    ngx_feature_incs=\n+    ngx_feature_path=\n+    ngx_feature_libs=\"-lprofiler\"\n+    ngx_feature_test=\"void ProfilerStop(void);\n+                      ProfilerStop()\"\n+    . auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # FreeBSD port\n+\n+    ngx_feature=\"Google perftools in /usr/local/\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lprofiler\"\n+    else\n+        ngx_feature_libs=\"-L/usr/local/lib -lprofiler\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # MacPorts\n+\n+    ngx_feature=\"Google perftools in /opt/local/\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lprofiler\"\n+    else\n+        ngx_feature_libs=\"-L/opt/local/lib -lprofiler\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = yes ]; then\n+    CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+\n+else\n+\n+cat << END\n+\n+$0: error: the Google perftools module requires the Google perftools\n+library. You can either do not enable the module or install the library.\n+\n+END\n+\n+    exit 1\n+fi\nDiff:\n@@ -0,0 +1,43 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $NGX_LIBATOMIC != YES ]; then\n+\n+    have=NGX_HAVE_LIBATOMIC . auto/have\n+    CORE_INCS=\"$CORE_INCS $NGX_LIBATOMIC/src\"\n+    LINK_DEPS=\"$LINK_DEPS $NGX_LIBATOMIC/src/libatomic_ops.a\"\n+    CORE_LIBS=\"$CORE_LIBS $NGX_LIBATOMIC/src/libatomic_ops.a\"\n+\n+else\n+\n+    ngx_feature=\"atomic_ops library\"\n+    ngx_feature_name=NGX_HAVE_LIBATOMIC\n+    ngx_feature_run=yes\n+    ngx_feature_incs=\"#define AO_REQUIRE_CAS\n+                      #include <atomic_ops.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\"-latomic_ops\"\n+    ngx_feature_test=\"long  n = 0;\n+                      if (!AO_compare_and_swap(&n, 0, 1))\n+                          return 1;\n+                      if (AO_fetch_and_add(&n, 1) != 1)\n+                          return 1;\n+                      if (n != 2)\n+                          return 1;\n+                      AO_nop();\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+    else\n+\n+cat << END\n+\n+$0: error: libatomic_ops library was not found.\n+\n+END\n+        exit 1\n+    fi\n+fi\nDiff:\n@@ -0,0 +1,16 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+    cat << END                                            >> $NGX_MAKEFILE\n+\n+$NGX_LIBATOMIC/src/libatomic_ops.a:\t$NGX_LIBATOMIC/Makefile\n+\tcd $NGX_LIBATOMIC && \\$(MAKE)\n+\n+$NGX_LIBATOMIC/Makefile:\t$NGX_MAKEFILE\n+\tcd $NGX_LIBATOMIC \\\\\n+\t&& if [ -f Makefile ]; then \\$(MAKE) distclean; fi \\\\\n+\t&& ./configure\n+\n+END\nDiff:\n@@ -0,0 +1,95 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+    ngx_feature=\"GD library\"\n+    ngx_feature_name=\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <gd.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\"-lgd\"\n+    ngx_feature_test=\"gdImagePtr img = gdImageCreateFromGifPtr(1, NULL);\n+                      (void) img\"\n+    . auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # FreeBSD port\n+\n+    ngx_feature=\"GD library in /usr/local/\"\n+    ngx_feature_path=\"/usr/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lgd\"\n+    else\n+        ngx_feature_libs=\"-L/usr/local/lib -lgd\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # NetBSD port\n+\n+    ngx_feature=\"GD library in /usr/pkg/\"\n+    ngx_feature_path=\"/usr/pkg/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/pkg/lib -L/usr/pkg/lib -lgd\"\n+    else\n+        ngx_feature_libs=\"-L/usr/pkg/lib -lgd\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # MacPorts\n+\n+    ngx_feature=\"GD library in /opt/local/\"\n+    ngx_feature_path=\"/opt/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lgd\"\n+    else\n+        ngx_feature_libs=\"-L/opt/local/lib -lgd\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = yes ]; then\n+\n+    CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+\n+    if [ $USE_LIBGD = YES ]; then\n+        CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+    fi\n+\n+    NGX_LIB_LIBGD=$ngx_feature_libs\n+\n+    ngx_feature=\"GD WebP support\"\n+    ngx_feature_name=\"NGX_HAVE_GD_WEBP\"\n+    ngx_feature_test=\"gdImagePtr img = gdImageCreateFromWebpPtr(1, NULL);\n+                      (void) img\"\n+    . auto/feature\n+\n+else\n+\n+cat << END\n+\n+$0: error: the HTTP image filter module requires the GD library.\n+You can either do not enable the module or install the libraries.\n+\n+END\n+\n+    exit 1\n+\n+fi\nDiff:\n@@ -0,0 +1,165 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+    ngx_feature=\"libxslt\"\n+    ngx_feature_name=\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <libxml/parser.h>\n+                      #include <libxml/tree.h>\n+                      #include <libxslt/xslt.h>\n+                      #include <libxslt/xsltInternals.h>\n+                      #include <libxslt/transform.h>\n+                      #include <libxslt/xsltutils.h>\"\n+    ngx_feature_path=\"/usr/include/libxml2\"\n+    ngx_feature_libs=\"-lxml2 -lxslt\"\n+    ngx_feature_test=\"xmlParserCtxtPtr    ctxt = NULL;\n+                      xsltStylesheetPtr   sheet = NULL;\n+                      xmlDocPtr           doc = NULL;\n+                      xmlParseChunk(ctxt, NULL, 0, 0);\n+                      xsltApplyStylesheet(sheet, doc, NULL);\"\n+    . auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # FreeBSD port\n+\n+    ngx_feature=\"libxslt in /usr/local/\"\n+    ngx_feature_path=\"/usr/local/include/libxml2 /usr/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lxml2 -lxslt\"\n+    else\n+        ngx_feature_libs=\"-L/usr/local/lib -lxml2 -lxslt\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # NetBSD port\n+\n+    ngx_feature=\"libxslt in /usr/pkg/\"\n+    ngx_feature_path=\"/usr/pkg/include/libxml2 /usr/pkg/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/pkg/lib -L/usr/pkg/lib -lxml2 -lxslt\"\n+    else\n+        ngx_feature_libs=\"-L/usr/pkg/lib -lxml2 -lxslt\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # MacPorts\n+\n+    ngx_feature=\"libxslt in /opt/local/\"\n+    ngx_feature_path=\"/opt/local/include/libxml2 /opt/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lxml2 -lxslt\"\n+    else\n+        ngx_feature_libs=\"-L/opt/local/lib -lxml2 -lxslt\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = yes ]; then\n+\n+    CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+\n+    if [ $USE_LIBXSLT = YES ]; then\n+        CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+    fi\n+\n+    NGX_LIB_LIBXSLT=$ngx_feature_libs\n+\n+else\n+\n+cat << END\n+\n+$0: error: the HTTP XSLT module requires the libxml2/libxslt\n+libraries. You can either do not enable the module or install the libraries.\n+\n+END\n+\n+    exit 1\n+fi\n+\n+\n+    ngx_feature=\"libexslt\"\n+    ngx_feature_name=NGX_HAVE_EXSLT\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <libexslt/exslt.h>\"\n+    ngx_feature_path=\"/usr/include/libxml2\"\n+    ngx_feature_libs=\"-lexslt\"\n+    ngx_feature_test=\"exsltRegisterAll();\"\n+    . auto/feature\n+\n+if [ $ngx_found = no ]; then\n+\n+    # FreeBSD port\n+\n+    ngx_feature=\"libexslt in /usr/local/\"\n+    ngx_feature_path=\"/usr/local/include/libxml2 /usr/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lexslt\"\n+    else\n+        ngx_feature_libs=\"-L/usr/local/lib -lexslt\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # NetBSD port\n+\n+    ngx_feature=\"libexslt in /usr/pkg/\"\n+    ngx_feature_path=\"/usr/pkg/include/libxml2 /usr/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/usr/pkg/lib -L/usr/pkg/lib -lexslt\"\n+    else\n+        ngx_feature_libs=\"-L/usr/pkg/lib -lexslt\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # MacPorts\n+\n+    ngx_feature=\"libexslt in /opt/local/\"\n+    ngx_feature_path=\"/opt/local/include/libxml2 /opt/local/include\"\n+\n+    if [ $NGX_RPATH = YES ]; then\n+        ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lexslt\"\n+    else\n+        ngx_feature_libs=\"-L/opt/local/lib -lexslt\"\n+    fi\n+\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = yes ]; then\n+    if [ $USE_LIBXSLT = YES ]; then\n+        CORE_LIBS=\"$CORE_LIBS -lexslt\"\n+    fi\n+\n+    NGX_LIB_LIBXSLT=\"$NGX_LIB_LIBXSLT -lexslt\"\n+fi\nDiff:\n@@ -0,0 +1,24 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $PCRE != NONE -a $PCRE != NO -a $PCRE != YES ]; then\n+    . auto/lib/pcre/make\n+fi\n+\n+if [ $OPENSSL != NONE -a $OPENSSL != NO -a $OPENSSL != YES ]; then\n+    . auto/lib/openssl/make\n+fi\n+\n+if [ $ZLIB != NONE -a $ZLIB != NO -a $ZLIB != YES ]; then\n+    . auto/lib/zlib/make\n+fi\n+\n+if [ $NGX_LIBATOMIC != NO -a $NGX_LIBATOMIC != YES ]; then\n+    . auto/lib/libatomic/make\n+fi\n+\n+if [ $USE_PERL != NO ]; then\n+    . auto/lib/perl/make\n+fi\nDiff:\n@@ -0,0 +1,142 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $OPENSSL != NONE ]; then\n+\n+    case \"$CC\" in\n+\n+        cl | bcc32)\n+            have=NGX_OPENSSL . auto/have\n+            have=NGX_SSL . auto/have\n+\n+            CFLAGS=\"$CFLAGS -DNO_SYS_TYPES_H\"\n+\n+            CORE_INCS=\"$CORE_INCS $OPENSSL/openssl/include\"\n+            CORE_DEPS=\"$CORE_DEPS $OPENSSL/openssl/include/openssl/ssl.h\"\n+\n+            if [ -f $OPENSSL/ms/do_ms.bat ]; then\n+                # before OpenSSL 1.1.0\n+                CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/ssleay32.lib\"\n+                CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libeay32.lib\"\n+            else\n+                # OpenSSL 1.1.0+\n+                CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libssl.lib\"\n+                CORE_LIBS=\"$CORE_LIBS $OPENSSL/openssl/lib/libcrypto.lib\"\n+            fi\n+\n+            # libeay32.lib requires gdi32.lib\n+            CORE_LIBS=\"$CORE_LIBS gdi32.lib\"\n+            # OpenSSL 1.0.0 requires crypt32.lib\n+            CORE_LIBS=\"$CORE_LIBS crypt32.lib\"\n+        ;;\n+\n+        *)\n+            have=NGX_OPENSSL . auto/have\n+            have=NGX_SSL . auto/have\n+\n+            CORE_INCS=\"$CORE_INCS $OPENSSL/.openssl/include\"\n+            CORE_DEPS=\"$CORE_DEPS $OPENSSL/.openssl/include/openssl/ssl.h\"\n+            CORE_LIBS=\"$CORE_LIBS $OPENSSL/.openssl/lib/libssl.a\"\n+            CORE_LIBS=\"$CORE_LIBS $OPENSSL/.openssl/lib/libcrypto.a\"\n+            CORE_LIBS=\"$CORE_LIBS $NGX_LIBDL\"\n+            CORE_LIBS=\"$CORE_LIBS $NGX_LIBPTHREAD\"\n+\n+            if [ \"$NGX_PLATFORM\" = win32 ]; then\n+                CORE_LIBS=\"$CORE_LIBS -lgdi32 -lcrypt32 -lws2_32\"\n+            fi\n+        ;;\n+    esac\n+\n+else\n+\n+    if [ \"$NGX_PLATFORM\" != win32 ]; then\n+\n+        OPENSSL=NO\n+\n+        ngx_feature=\"OpenSSL library\"\n+        ngx_feature_name=\"NGX_OPENSSL\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#include <openssl/ssl.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\"-lssl -lcrypto $NGX_LIBDL $NGX_LIBPTHREAD\"\n+        ngx_feature_test=\"SSL_CTX_set_options(NULL, 0)\"\n+        . auto/feature\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # FreeBSD port\n+\n+            ngx_feature=\"OpenSSL library in /usr/local/\"\n+            ngx_feature_path=\"/usr/local/include\"\n+\n+            if [ $NGX_RPATH = YES ]; then\n+                ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lssl -lcrypto\"\n+            else\n+                ngx_feature_libs=\"-L/usr/local/lib -lssl -lcrypto\"\n+            fi\n+\n+            ngx_feature_libs=\"$ngx_feature_libs $NGX_LIBDL $NGX_LIBPTHREAD\"\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # NetBSD port\n+\n+            ngx_feature=\"OpenSSL library in /usr/pkg/\"\n+            ngx_feature_path=\"/usr/pkg/include\"\n+\n+            if [ $NGX_RPATH = YES ]; then\n+                ngx_feature_libs=\"-R/usr/pkg/lib -L/usr/pkg/lib -lssl -lcrypto\"\n+            else\n+                ngx_feature_libs=\"-L/usr/pkg/lib -lssl -lcrypto\"\n+            fi\n+\n+            ngx_feature_libs=\"$ngx_feature_libs $NGX_LIBDL $NGX_LIBPTHREAD\"\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # MacPorts\n+\n+            ngx_feature=\"OpenSSL library in /opt/local/\"\n+            ngx_feature_path=\"/opt/local/include\"\n+\n+            if [ $NGX_RPATH = YES ]; then\n+                ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lssl -lcrypto\"\n+            else\n+                ngx_feature_libs=\"-L/opt/local/lib -lssl -lcrypto\"\n+            fi\n+\n+            ngx_feature_libs=\"$ngx_feature_libs $NGX_LIBDL $NGX_LIBPTHREAD\"\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = yes ]; then\n+            have=NGX_SSL . auto/have\n+            CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+            CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+            OPENSSL=YES\n+        fi\n+    fi\n+\n+    if [ $OPENSSL != YES ]; then\n+\n+cat << END\n+\n+$0: error: SSL modules require the OpenSSL library.\n+You can either do not enable the modules, or install the OpenSSL library\n+into the system, or build the OpenSSL library statically from the source\n+with nginx by using --with-openssl=<path> option.\n+\n+END\n+        exit 1\n+    fi\n+\n+fi\nDiff:\n@@ -0,0 +1,62 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+case \"$CC\" in\n+\n+    cl)\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+$OPENSSL/openssl/include/openssl/ssl.h:\t$NGX_MAKEFILE\n+\t\\$(MAKE) -f auto/lib/openssl/makefile.msvc\t\t\t\\\n+\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\n+\n+END\n+\n+    ;;\n+\n+    bcc32)\n+\n+        ngx_opt=`echo \"-DOPENSSL=\\\"$OPENSSL\\\" -DOPENSSL_OPT=\\\"$OPENSSL_OPT\\\"\" \\\n+            | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+`echo \"$OPENSSL\\\\openssl\\\\lib\\\\libeay32.lib:\t\t\t\t\\\n+\t$OPENSSL\\\\openssl\\\\include\\\\openssl\\\\ssl.h\"\t\t\t\\\n+\t| sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+`echo \"$OPENSSL\\\\openssl\\\\lib\\\\ssleay32.lib:\t\t\t\t\\\n+\t$OPENSSL\\\\openssl\\\\include\\\\openssl\\\\ssl.h\"\t\t\t\\\n+\t| sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+`echo \"$OPENSSL\\\\openssl\\\\include\\\\openssl\\\\ssl.h:\t$NGX_MAKEFILE\"\t\\\n+\t| sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\t\\$(MAKE) -f auto/lib/openssl/makefile.bcc $ngx_opt\n+\n+END\n+\n+    ;;\n+\n+    *)\n+        case $OPENSSL in\n+            /*) ngx_prefix=\"$OPENSSL/.openssl\" ;;\n+            *)  ngx_prefix=\"$PWD/$OPENSSL/.openssl\" ;;\n+        esac\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+$OPENSSL/.openssl/include/openssl/ssl.h:\t$NGX_MAKEFILE\n+\tcd $OPENSSL \\\\\n+\t&& if [ -f Makefile ]; then \\$(MAKE) clean; fi \\\\\n+\t&& ./config --prefix=$ngx_prefix no-shared no-threads $OPENSSL_OPT \\\\\n+\t&& \\$(MAKE) \\\\\n+\t&& \\$(MAKE) install_sw LIBDIR=lib\n+\n+END\n+\n+    ;;\n+\n+esac\nDiff:\n@@ -0,0 +1,18 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+all:\n+\tcd $(OPENSSL)\n+\n+\tperl Configure BC-32 no-shared --prefix=openssl $(OPENSSL_OPT)\n+\n+\tms\\do_nasm\n+\n+\t$(MAKE) -f ms\\bcb.mak\n+\t$(MAKE) -f ms\\bcb.mak install\n+\n+\t# Borland's make does not expand \"[ch]\" in\n+\t#    copy \"inc32\\openssl\\*.[ch]\" \"openssl\\include\\openssl\"\n+\tcopy inc32\\openssl\\*.h openssl\\include\\openssl\nDiff:\n@@ -0,0 +1,21 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+all:\n+\tcd $(OPENSSL)\n+\n+\tperl Configure VC-WIN32 no-shared\t\t\t\t\\\n+\t\t--prefix=\"%cd%/openssl\" \t\t\t\t\\\n+\t\t--openssldir=\"%cd%/openssl/ssl\" \t\t\t\\\n+\t\t$(OPENSSL_OPT)\n+\n+\tif exist ms\\do_ms.bat (\t\t\t\t\t\t\\\n+\t\tms\\do_ms\t\t\t\t\t\t\\\n+\t\t&& $(MAKE) -f ms\\nt.mak\t\t\t\t\t\\\n+\t\t&& $(MAKE) -f ms\\nt.mak install\t\t\t\t\\\n+\t) else (\t\t\t\t\t\t\t\\\n+\t\t$(MAKE)\t\t\t\t\t\t\t\\\n+\t\t&& $(MAKE) install_sw\t\t\t\t\t\\\n+\t)\nDiff:\n@@ -0,0 +1,203 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $PCRE != NONE ]; then\n+    CORE_INCS=\"$CORE_INCS $PCRE\"\n+\n+    case \"$NGX_CC_NAME\" in\n+\n+        msvc | owc | bcc)\n+            have=NGX_PCRE . auto/have\n+            have=PCRE_STATIC . auto/have\n+            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n+            LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n+            CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n+        ;;\n+\n+        icc)\n+            have=NGX_PCRE . auto/have\n+            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n+\n+            LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n+\n+            echo $ngx_n \"checking for PCRE library ...$ngx_c\"\n+\n+            if [ -f $PCRE/pcre.h ]; then\n+                ngx_pcre_ver=`grep PCRE_MAJOR $PCRE/pcre.h \\\n+                              | sed -e 's/^.*PCRE_MAJOR.* \\(.*\\)$/\\1/'`\n+\n+            else if [ -f $PCRE/configure.in ]; then\n+                ngx_pcre_ver=`grep PCRE_MAJOR= $PCRE/configure.in \\\n+                              | sed -e 's/^.*=\\(.*\\)$/\\1/'`\n+\n+            else\n+                ngx_pcre_ver=`grep pcre_major, $PCRE/configure.ac \\\n+                              | sed -e 's/^.*pcre_major,.*\\[\\(.*\\)\\].*$/\\1/'`\n+            fi\n+            fi\n+\n+            echo \" $ngx_pcre_ver major version found\"\n+\n+            # to allow -ipo optimization we link with the *.o but not library\n+\n+            case \"$ngx_pcre_ver\" in\n+                4|5)\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.o\"\n+                ;;\n+\n+                6)\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_chartables.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_compile.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_exec.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_fullinfo.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_globals.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_tables.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_try_flipped.o\"\n+                ;;\n+\n+                *)\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_chartables.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_compile.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_exec.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_fullinfo.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_globals.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_tables.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_try_flipped.o\"\n+                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_newline.o\"\n+                ;;\n+\n+            esac\n+        ;;\n+\n+        *)\n+            have=NGX_PCRE . auto/have\n+\n+            if [ \"$NGX_PLATFORM\" = win32 ]; then\n+                have=PCRE_STATIC . auto/have\n+            fi\n+\n+            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n+            LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n+            CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n+        ;;\n+\n+    esac\n+\n+\n+    if [ $PCRE_JIT = YES ]; then\n+        have=NGX_HAVE_PCRE_JIT . auto/have\n+        PCRE_CONF_OPT=\"$PCRE_CONF_OPT --enable-jit\"\n+    fi\n+\n+else\n+\n+    if [ \"$NGX_PLATFORM\" != win32 ]; then\n+\n+        PCRE=NO\n+\n+        ngx_feature=\"PCRE library\"\n+        ngx_feature_name=\"NGX_PCRE\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#include <pcre.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\"-lpcre\"\n+        ngx_feature_test=\"pcre *re;\n+                          re = pcre_compile(NULL, 0, NULL, 0, NULL);\n+                          if (re == NULL) return 1\"\n+        . auto/feature\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # FreeBSD port\n+\n+            ngx_feature=\"PCRE library in /usr/local/\"\n+            ngx_feature_path=\"/usr/local/include\"\n+\n+            if [ $NGX_RPATH = YES ]; then\n+                ngx_feature_libs=\"-R/usr/local/lib -L/usr/local/lib -lpcre\"\n+            else\n+                ngx_feature_libs=\"-L/usr/local/lib -lpcre\"\n+            fi\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # RedHat RPM, Solaris package\n+\n+            ngx_feature=\"PCRE library in /usr/include/pcre/\"\n+            ngx_feature_path=\"/usr/include/pcre\"\n+            ngx_feature_libs=\"-lpcre\"\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # NetBSD port\n+\n+            ngx_feature=\"PCRE library in /usr/pkg/\"\n+            ngx_feature_path=\"/usr/pkg/include\"\n+\n+            if [ $NGX_RPATH = YES ]; then\n+                ngx_feature_libs=\"-R/usr/pkg/lib -L/usr/pkg/lib -lpcre\"\n+            else\n+                ngx_feature_libs=\"-L/usr/pkg/lib -lpcre\"\n+            fi\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # MacPorts\n+\n+            ngx_feature=\"PCRE library in /opt/local/\"\n+            ngx_feature_path=\"/opt/local/include\"\n+\n+            if [ $NGX_RPATH = YES ]; then\n+                ngx_feature_libs=\"-R/opt/local/lib -L/opt/local/lib -lpcre\"\n+            else\n+                ngx_feature_libs=\"-L/opt/local/lib -lpcre\"\n+            fi\n+\n+            . auto/feature\n+        fi\n+\n+        if [ $ngx_found = yes ]; then\n+            CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+            CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+            PCRE=YES\n+        fi\n+\n+        if [ $PCRE = YES ]; then\n+            ngx_feature=\"PCRE JIT support\"\n+            ngx_feature_name=\"NGX_HAVE_PCRE_JIT\"\n+            ngx_feature_test=\"int jit = 0;\n+                              pcre_free_study(NULL);\n+                              pcre_config(PCRE_CONFIG_JIT, &jit);\n+                              if (jit != 1) return 1;\"\n+            . auto/feature\n+\n+            if [ $ngx_found = yes ]; then\n+                PCRE_JIT=YES\n+            fi\n+        fi\n+    fi\n+\n+    if [ $PCRE != YES ]; then\n+cat << END\n+\n+$0: error: the HTTP rewrite module requires the PCRE library.\n+You can either disable the module by using --without-http_rewrite_module\n+option, or install the PCRE library into the system, or build the PCRE library\n+statically from the source with nginx by using --with-pcre=<path> option.\n+\n+END\n+        exit 1\n+    fi\n+\n+fi\nDiff:\n@@ -0,0 +1,64 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+case \"$NGX_CC_NAME\" in\n+\n+    msvc)\n+        ngx_makefile=makefile.msvc\n+        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\" LIBC=$LIBC\"\n+        ngx_pcre=\"PCRE=\\\"$PCRE\\\"\"\n+    ;;\n+\n+    owc)\n+        ngx_makefile=makefile.owc\n+        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\"\"\n+        ngx_pcre=`echo PCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+    ;;\n+\n+    bcc)\n+        ngx_makefile=makefile.bcc\n+        ngx_opt=\"-DCPU_OPT=\\\"$CPU_OPT\\\"\"\n+        ngx_pcre=`echo \\-DPCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+    ;;\n+\n+    *)\n+        ngx_makefile=\n+    ;;\n+\n+esac\n+\n+\n+if [ -n \"$ngx_makefile\" ]; then\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+`echo \"$PCRE/pcre.lib:\t$PCRE/pcre.h $NGX_MAKEFILE\"\t\t\t\\\n+\t| sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\t\\$(MAKE) -f auto/lib/pcre/$ngx_makefile $ngx_pcre $ngx_opt\n+\n+`echo \"$PCRE/pcre.h:\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\t\\$(MAKE) -f auto/lib/pcre/$ngx_makefile $ngx_pcre pcre.h\n+\n+END\n+\n+else\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+$PCRE/pcre.h:\t$PCRE/Makefile\n+\n+$PCRE/Makefile:\t$NGX_MAKEFILE\n+\tcd $PCRE \\\\\n+\t&& if [ -f Makefile ]; then \\$(MAKE) distclean; fi \\\\\n+\t&& CC=\"\\$(CC)\" CFLAGS=\"$PCRE_OPT\" \\\\\n+\t./configure --disable-shared $PCRE_CONF_OPT\n+\n+$PCRE/.libs/libpcre.a:\t$PCRE/Makefile\n+\tcd $PCRE \\\\\n+\t&& \\$(MAKE) libpcre.la\n+\n+END\n+\n+fi\nDiff:\n@@ -0,0 +1,27 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CFLAGS =\t-q -O2 -tWM -w-8004 $(CPU_OPT)\n+PCREFLAGS =\t-DHAVE_CONFIG_H -DPCRE_STATIC -DPOSIX_MALLOC_THRESHOLD=10 \\\n+\t\t-DSUPPORT_PCRE8 -DHAVE_MEMMOVE\n+\n+\n+pcre.lib:\n+\tcd $(PCRE)\n+\n+\tbcc32 -c $(CFLAGS) -I. $(PCREFLAGS) pcre_*.c\n+\n+\tcopy /y nul pcre.lst\n+\tfor %n in (*.obj) do @echo +%n ^^& >> pcre.lst\n+\techo + >> pcre.lst\n+\n+\ttlib pcre.lib @pcre.lst\n+\n+pcre.h:\n+\tcd $(PCRE)\n+\n+\tcopy /y pcre.h.generic pcre.h\n+\tcopy /y config.h.generic config.h\n+\tcopy /y pcre_chartables.c.dist pcre_chartables.c\nDiff:\n@@ -0,0 +1,23 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CFLAGS =\t-O2 -Ob1 -Oi -Gs $(LIBC) $(CPU_OPT)\n+PCREFLAGS =\t-DHAVE_CONFIG_H -DPCRE_STATIC -DPOSIX_MALLOC_THRESHOLD=10 \\\n+\t\t-DSUPPORT_PCRE8 -DHAVE_MEMMOVE\n+\n+\n+pcre.lib:\n+\tcd $(PCRE)\n+\n+\tcl -nologo -c $(CFLAGS) -I . $(PCREFLAGS) pcre_*.c\n+\n+\tlink -lib -out:pcre.lib -verbose:lib pcre_*.obj\n+\n+pcre.h:\n+\tcd $(PCRE)\n+\n+\tcopy /y pcre.h.generic pcre.h\n+\tcopy /y config.h.generic config.h\n+\tcopy /y pcre_chartables.c.dist pcre_chartables.c\nDiff:\n@@ -0,0 +1,25 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CFLAGS =\t-c -zq -bt=nt -ot -op -oi -oe -s -bm $(CPU_OPT)\n+PCREFLAGS =\t-DHAVE_CONFIG_H -DPCRE_STATIC -DPOSIX_MALLOC_THRESHOLD=10 &\n+\t\t-DSUPPORT_PCRE8 -DHAVE_MEMMOVE\n+\n+\n+pcre.lib:\n+\tcd $(PCRE)\n+\n+\twcl386 $(CFLAGS) -i=. $(PCREFLAGS) pcre_*.c\n+\n+\tdir /b *.obj > pcre.lst\n+\n+\twlib -n pcre.lib @pcre.lst\n+\n+pcre.h:\n+\tcd $(PCRE)\n+\n+\tcopy /y pcre.h.generic pcre.h\n+\tcopy /y config.h.generic config.h\n+\tcopy /y pcre_chartables.c.dist pcre_chartables.c\nDiff:\n@@ -0,0 +1,83 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo \"checking for perl\"\n+\n+\n+NGX_PERL_VER=`$NGX_PERL -v 2>&1 | grep '^This is perl' 2>&1 \\\n+                                | sed -e 's/^This is perl, \\(.*\\)/\\1/'`\n+\n+if test -n \"$NGX_PERL_VER\"; then\n+    echo \" + perl version: $NGX_PERL_VER\"\n+\n+    if [ \"`$NGX_PERL -e 'use 5.008006; print \"OK\"'`\" != \"OK\" ]; then\n+        echo\n+        echo \"$0: error: perl 5.8.6 or higher is required\"\n+        echo\n+\n+        exit 1;\n+    fi\n+\n+    if [ \"`$NGX_PERL -MExtUtils::Embed -e 'print \"OK\"'`\" != \"OK\" ]; then\n+        echo\n+        echo \"$0: error: perl module ExtUtils::Embed is required\"\n+        echo\n+\n+        exit 1;\n+    fi\n+\n+    NGX_PM_CFLAGS=`$NGX_PERL -MExtUtils::Embed -e ccopts`\n+    NGX_PM_LDFLAGS=`$NGX_PERL -MConfig -e 'print $Config{lddlflags}'`\n+\n+    NGX_PERL_CFLAGS=\"$CFLAGS `$NGX_PERL -MExtUtils::Embed -e ccopts`\"\n+\n+    # gcc 4.1/4.2 warn about unused values in pTHX_\n+    NGX_PERL_CFLAGS=`echo $NGX_PERL_CFLAGS \\\n+                     | sed -e 's/-Wunused-value/-Wno-unused-value/'`\n+    # icc8 warns 'declaration hides parameter \"my_perl\"' in ENTER and LEAVE\n+    NGX_PERL_CFLAGS=`echo $NGX_PERL_CFLAGS \\\n+                     | sed -e 's/-wd171/-wd171 -wd1599/'`\n+\n+    ngx_perl_ldopts=`$NGX_PERL -MExtUtils::Embed -e ldopts`\n+\n+    ngx_perl_dlext=`$NGX_PERL -MConfig -e 'print $Config{dlext}'`\n+    ngx_perl_libdir=\"src/http/modules/perl/blib/arch/auto\"\n+    ngx_perl_module=\"$ngx_perl_libdir/nginx/nginx.$ngx_perl_dlext\"\n+\n+    if $NGX_PERL -V:usemultiplicity | grep define > /dev/null; then\n+        have=NGX_HAVE_PERL_MULTIPLICITY . auto/have\n+        echo \" + perl interpreter multiplicity found\"\n+    fi\n+\n+    if $NGX_PERL -V:useithreads | grep undef > /dev/null; then\n+        # FreeBSD port wants to link with -pthread non-threaded perl\n+        ngx_perl_ldopts=`echo $ngx_perl_ldopts | sed 's/ -pthread//'`\n+    fi\n+\n+    if [ \"$NGX_SYSTEM\" = \"Darwin\" ]; then\n+        # OS X system perl wants to link universal binaries\n+        ngx_perl_ldopts=`echo $ngx_perl_ldopts \\\n+                         | sed -e 's/-arch i386//' -e 's/-arch x86_64//'`\n+    fi\n+\n+    if [ $USE_PERL = YES ]; then\n+        CORE_LINK=\"$CORE_LINK $ngx_perl_ldopts\"\n+    fi\n+\n+    NGX_LIB_PERL=\"$ngx_perl_ldopts\"\n+\n+    if test -n \"$NGX_PERL_MODULES\"; then\n+        have=NGX_PERL_MODULES value=\"(u_char *) \\\"$NGX_PERL_MODULES\\\"\"\n+        . auto/define\n+        NGX_PERL_MODULES_MAN=$NGX_PERL_MODULES/man3\n+    fi\n+\n+else\n+    echo\n+    echo \"$0: error: perl 5.8.6 or higher is required\"\n+    echo\n+\n+    exit 1;\n+fi\nDiff:\n@@ -0,0 +1,46 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+cat << END                                                    >> $NGX_MAKEFILE\n+\n+$NGX_OBJS/src/http/modules/perl/ngx_http_perl_module.o: \\\\\n+\t\t$NGX_OBJS/$ngx_perl_module\n+\n+$NGX_OBJS/$ngx_perl_module: \\\\\n+\t\t\\$(CORE_DEPS) \\$(HTTP_DEPS) \\\\\n+\t\tsrc/http/modules/perl/ngx_http_perl_module.h \\\\\n+\t\t$NGX_OBJS/src/http/modules/perl/Makefile\n+\tcd $NGX_OBJS/src/http/modules/perl && \\$(MAKE)\n+\n+\trm -rf $NGX_OBJS/install_perl\n+\n+\n+$NGX_OBJS/src/http/modules/perl/Makefile: \\\\\n+\t\t$NGX_AUTO_CONFIG_H \\\\\n+\t\tsrc/core/nginx.h \\\\\n+\t\tsrc/http/modules/perl/Makefile.PL \\\\\n+\t\tsrc/http/modules/perl/nginx.pm \\\\\n+\t\tsrc/http/modules/perl/nginx.xs \\\\\n+\t\tsrc/http/modules/perl/typemap\n+\tgrep 'define NGINX_VERSION' src/core/nginx.h \\\\\n+\t\t| sed -e 's/^.*\"\\(.*\\)\".*/\\1/' > \\\\\n+\t\t$NGX_OBJS/src/http/modules/perl/version\n+\tsed \"s/%%VERSION%%/\\`cat $NGX_OBJS/src/http/modules/perl/version\\`/\" \\\\\n+\t\tsrc/http/modules/perl/nginx.pm > \\\\\n+\t\t$NGX_OBJS/src/http/modules/perl/nginx.pm\n+\tcp -p src/http/modules/perl/nginx.xs $NGX_OBJS/src/http/modules/perl/\n+\tcp -p src/http/modules/perl/typemap $NGX_OBJS/src/http/modules/perl/\n+\tcp -p src/http/modules/perl/Makefile.PL $NGX_OBJS/src/http/modules/perl/\n+\n+\tcd $NGX_OBJS/src/http/modules/perl \\\\\n+\t\t&& NGX_PM_CFLAGS=\"\\$(NGX_PM_CFLAGS) -g $NGX_CC_OPT\" \\\\\n+\t\t\tNGX_PM_LDFLAGS=\"$NGX_LD_OPT \\$(NGX_PM_LDFLAGS)\" \\\\\n+\t\t\tNGX_INCS=\"$CORE_INCS $NGX_OBJS $HTTP_INCS\" \\\\\n+\t\t\tNGX_DEPS=\"\\$(CORE_DEPS) \\$(HTTP_DEPS)\" \\\\\n+\t\t$NGX_PERL Makefile.PL \\\\\n+\t\t\tLIB=$NGX_PERL_MODULES \\\\\n+\t\t\tINSTALLSITEMAN3DIR=$NGX_PERL_MODULES_MAN\n+\n+END\nDiff:\n@@ -0,0 +1,79 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $ZLIB != NONE ]; then\n+    CORE_INCS=\"$CORE_INCS $ZLIB\"\n+\n+    case \"$NGX_CC_NAME\" in\n+\n+        msvc | owc | bcc)\n+            have=NGX_ZLIB . auto/have\n+            LINK_DEPS=\"$LINK_DEPS $ZLIB/zlib.lib\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/zlib.lib\"\n+        ;;\n+\n+        icc)\n+            have=NGX_ZLIB . auto/have\n+            LINK_DEPS=\"$LINK_DEPS $ZLIB/libz.a\"\n+\n+            # to allow -ipo optimization we link with the *.o but not library\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/adler32.o\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/crc32.o\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/deflate.o\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/trees.o\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/zutil.o\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/compress.o\"\n+\n+            if [ $ZLIB_ASM != NO ]; then\n+                CORE_LIBS=\"$CORE_LIBS $ZLIB/match.o\"\n+            fi\n+        ;;\n+\n+        *)\n+            have=NGX_ZLIB . auto/have\n+            LINK_DEPS=\"$LINK_DEPS $ZLIB/libz.a\"\n+            CORE_LIBS=\"$CORE_LIBS $ZLIB/libz.a\"\n+            #CORE_LIBS=\"$CORE_LIBS -L $ZLIB -lz\"\n+        ;;\n+\n+    esac\n+\n+else\n+\n+    if [ \"$NGX_PLATFORM\" != win32 ]; then\n+        ZLIB=NO\n+\n+        # FreeBSD, Solaris, Linux\n+\n+        ngx_feature=\"zlib library\"\n+        ngx_feature_name=\"NGX_ZLIB\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#include <zlib.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\"-lz\"\n+        ngx_feature_test=\"z_stream z; deflate(&z, Z_NO_FLUSH)\"\n+        . auto/feature\n+\n+\n+        if [ $ngx_found = yes ]; then\n+            CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+            ZLIB=YES\n+            ngx_found=no\n+        fi\n+    fi\n+\n+    if [ $ZLIB != YES ]; then\n+cat << END\n+\n+$0: error: the HTTP gzip module requires the zlib library.\n+You can either disable the module by using --without-http_gzip_module\n+option, or install the zlib library into the system, or build the zlib library\n+statically from the source with nginx by using --with-zlib=<path> option.\n+\n+END\n+        exit 1\n+    fi\n+\n+fi\nDiff:\n@@ -0,0 +1,135 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+case \"$NGX_CC_NAME\" in\n+\n+    msvc)\n+        ngx_makefile=makefile.msvc\n+        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\" LIBC=$LIBC\"\n+        ngx_zlib=\"ZLIB=\\\"$ZLIB\\\"\"\n+\n+    ;;\n+\n+    owc)\n+        ngx_makefile=makefile.owc\n+        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\"\"\n+        ngx_zlib=`echo ZLIB=\\\"$ZLIB\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+    ;;\n+\n+    bcc)\n+        ngx_makefile=makefile.bcc\n+        ngx_opt=\"-DCPU_OPT=\\\"$CPU_OPT\\\"\"\n+        ngx_zlib=`echo \\-DZLIB=\\\"$ZLIB\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+    ;;\n+\n+    *)\n+        ngx_makefile=\n+    ;;\n+\n+esac\n+\n+\n+done=NO\n+\n+\n+case \"$NGX_PLATFORM\" in\n+\n+    win32)\n+\n+        if [ -n \"$ngx_makefile\" ]; then\n+            cat << END                                        >> $NGX_MAKEFILE\n+\n+`echo \"$ZLIB/zlib.lib:\t$NGX_MAKEFILE\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\t\\$(MAKE) -f auto/lib/zlib/$ngx_makefile $ngx_opt $ngx_zlib\n+\n+END\n+\n+        else\n+\n+            cat << END                                        >> $NGX_MAKEFILE\n+\n+$ZLIB/libz.a:\t$NGX_MAKEFILE\n+\tcd $ZLIB \\\\\n+\t&& \\$(MAKE) distclean \\\\\n+\t&& \\$(MAKE) -f win32/Makefile.gcc \\\\\n+\t\tCFLAGS=\"$ZLIB_OPT\" CC=\"\\$(CC)\" \\\\\n+\t\tlibz.a\n+\n+END\n+\n+        fi\n+\n+        done=YES\n+    ;;\n+\n+    # FreeBSD: i386\n+    # Linux: i686\n+\n+    *:i386 | *:i686)\n+        case $ZLIB_ASM in\n+            pentium)\n+\n+                cat << END                                    >> $NGX_MAKEFILE\n+\n+$ZLIB/libz.a:\t$NGX_MAKEFILE\n+\tcd $ZLIB \\\\\n+\t&& \\$(MAKE) distclean \\\\\n+\t&& cp contrib/asm586/match.S . \\\\\n+\t&& CFLAGS=\"$ZLIB_OPT -DASMV\" CC=\"\\$(CC)\" \\\\\n+\t\t./configure \\\\\n+\t&& \\$(MAKE) OBJA=match.o libz.a\n+\n+END\n+\n+                done=YES\n+            ;;\n+\n+            pentiumpro)\n+\n+                cat << END                                    >> $NGX_MAKEFILE\n+\n+$ZLIB/libz.a:\t$NGX_MAKEFILE\n+\tcd $ZLIB \\\\\n+\t&& \\$(MAKE) distclean \\\\\n+\t&& cp contrib/asm686/match.S . \\\\\n+\t&& CFLAGS=\"$ZLIB_OPT -DASMV\" CC=\"\\$(CC)\" \\\\\n+\t\t./configure \\\\\n+\t&& \\$(MAKE) OBJA=match.o libz.a\n+\n+END\n+\n+                done=YES\n+            ;;\n+\n+            NO)\n+            ;;\n+\n+            *)\n+                echo \"$0: error: invalid --with-zlib-asm=$ZLIB_ASM option.\"\n+                echo \"The valid values are \\\"pentium\\\" and \\\"pentiumpro\\\" only\".\n+                echo\n+\n+                exit 1;\n+            ;;\n+        esac\n+    ;;\n+\n+esac\n+\n+\n+if [ $done = NO ]; then\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+$ZLIB/libz.a:\t$NGX_MAKEFILE\n+\tcd $ZLIB \\\\\n+\t&& \\$(MAKE) distclean \\\\\n+\t&& CFLAGS=\"$ZLIB_OPT\" CC=\"\\$(CC)\" \\\\\n+\t\t./configure \\\\\n+\t&& \\$(MAKE) libz.a\n+\n+END\n+\n+fi\nDiff:\n@@ -0,0 +1,17 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CFLAGS = -q -O2 -tWM -w-8004 -w-8012 $(CPU_OPT)\n+\n+zlib.lib:\n+\tcd $(ZLIB)\n+\n+\tbcc32 -c $(CFLAGS) adler32.c crc32.c deflate.c \\\n+\t\ttrees.c zutil.c compress.c \\\n+\t\tinflate.c inffast.c inftrees.c\n+\n+\ttlib zlib.lib +adler32.obj +crc32.obj +deflate.obj \\\n+\t\t+trees.obj +zutil.obj +compress.obj \\\n+\t\t+inflate.obj +inffast.obj +inftrees.obj\nDiff:\n@@ -0,0 +1,17 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CFLAGS = -nologo -O2 -Ob1 -Oi -Gs $(LIBC) $(CPU_OPT)\n+\n+zlib.lib:\n+\tcd $(ZLIB)\n+\n+\tcl -c $(CFLAGS) adler32.c crc32.c deflate.c \\\n+\t\ttrees.c zutil.c compress.c \\\n+\t\tinflate.c inffast.c inftrees.c\n+\n+\tlink -lib -out:zlib.lib adler32.obj crc32.obj deflate.obj \\\n+\t\ttrees.obj zutil.obj compress.obj \\\n+\t\tinflate.obj inffast.obj inftrees.obj\nDiff:\n@@ -0,0 +1,14 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CFLAGS = -zq -bt=nt -ot -op -oi -oe -s -bm $(CPU_OPT)\n+\n+zlib.lib:\n+\tcd $(ZLIB)\n+\n+\twcl386 -c $(CFLAGS) adler32.c crc32.c deflate.c trees.c zutil.c &\n+\t\tcompress.c inflate.c inffast.c inftrees.c\n+\twlib -n zlib.lib adler32.obj crc32.obj deflate.obj trees.obj &\n+\t\tzutil.obj compress.obj inflate.obj inffast.obj inftrees.obj\nDiff:\n@@ -0,0 +1,672 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo \"creating $NGX_MAKEFILE\"\n+\n+mkdir -p $NGX_OBJS/src/core $NGX_OBJS/src/event $NGX_OBJS/src/event/modules \\\n+         $NGX_OBJS/src/os/unix $NGX_OBJS/src/os/win32 \\\n+         $NGX_OBJS/src/http $NGX_OBJS/src/http/v2 $NGX_OBJS/src/http/modules \\\n+         $NGX_OBJS/src/http/modules/perl \\\n+         $NGX_OBJS/src/mail \\\n+         $NGX_OBJS/src/stream \\\n+         $NGX_OBJS/src/misc\n+\n+\n+ngx_objs_dir=$NGX_OBJS$ngx_regex_dirsep\n+ngx_use_pch=`echo $NGX_USE_PCH | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+\n+cat << END                                                     > $NGX_MAKEFILE\n+\n+CC =\t$CC\n+CFLAGS = $CFLAGS\n+CPP =\t$CPP\n+LINK =\t$LINK\n+\n+END\n+\n+\n+if test -n \"$NGX_PERL_CFLAGS\"; then\n+    echo NGX_PERL_CFLAGS = $NGX_PERL_CFLAGS                   >> $NGX_MAKEFILE\n+    echo NGX_PM_CFLAGS = $NGX_PM_CFLAGS                       >> $NGX_MAKEFILE\n+    echo NGX_PM_LDFLAGS = $NGX_PM_LDFLAGS                     >> $NGX_MAKEFILE\n+fi\n+\n+\n+# ALL_INCS, required by the addons and by OpenWatcom C precompiled headers\n+\n+ngx_incs=`echo $CORE_INCS $NGX_OBJS $HTTP_INCS $MAIL_INCS $STREAM_INCS\\\n+    | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont$ngx_include_opt\\1/g\" \\\n+          -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+cat << END                                                    >> $NGX_MAKEFILE\n+\n+ALL_INCS = $ngx_include_opt$ngx_incs\n+\n+END\n+\n+\n+ngx_all_srcs=\"$CORE_SRCS\"\n+\n+\n+# the core dependencies and include paths\n+\n+ngx_deps=`echo $CORE_DEPS $NGX_AUTO_CONFIG_H $NGX_PCH \\\n+    | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\" \\\n+          -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+ngx_incs=`echo $CORE_INCS $NGX_OBJS \\\n+    | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont$ngx_include_opt\\1/g\" \\\n+          -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+cat << END                                                    >> $NGX_MAKEFILE\n+\n+CORE_DEPS = $ngx_deps\n+\n+\n+CORE_INCS = $ngx_include_opt$ngx_incs\n+\n+END\n+\n+\n+# the http dependencies and include paths\n+\n+if [ $HTTP = YES ]; then\n+\n+    ngx_all_srcs=\"$ngx_all_srcs $HTTP_SRCS\"\n+\n+    ngx_deps=`echo $HTTP_DEPS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_incs=`echo $HTTP_INCS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont$ngx_include_opt\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+HTTP_DEPS = $ngx_deps\n+\n+\n+HTTP_INCS = $ngx_include_opt$ngx_incs\n+\n+END\n+\n+fi\n+\n+\n+# the mail dependencies and include paths\n+\n+if [ $MAIL != NO ]; then\n+\n+    if [ $MAIL = YES ]; then\n+        ngx_all_srcs=\"$ngx_all_srcs $MAIL_SRCS\"\n+    fi\n+\n+    ngx_deps=`echo $MAIL_DEPS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_incs=`echo $MAIL_INCS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont$ngx_include_opt\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+MAIL_DEPS = $ngx_deps\n+\n+\n+MAIL_INCS = $ngx_include_opt$ngx_incs\n+\n+END\n+\n+fi\n+\n+\n+# the stream dependencies and include paths\n+\n+if [ $STREAM != NO ]; then\n+\n+    if [ $STREAM = YES ]; then\n+        ngx_all_srcs=\"$ngx_all_srcs $STREAM_SRCS\"\n+    fi\n+\n+    ngx_deps=`echo $STREAM_DEPS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_incs=`echo $STREAM_INCS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont$ngx_include_opt\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+STREAM_DEPS = $ngx_deps\n+\n+\n+STREAM_INCS = $ngx_include_opt$ngx_incs\n+\n+END\n+\n+fi\n+\n+\n+ngx_all_srcs=\"$ngx_all_srcs $MISC_SRCS\"\n+\n+\n+if test -n \"$NGX_ADDON_SRCS$DYNAMIC_MODULES\"; then\n+\n+cat << END                                                >> $NGX_MAKEFILE\n+\n+ADDON_DEPS = \\$(CORE_DEPS) $NGX_ADDON_DEPS\n+\n+END\n+\n+fi\n+\n+\n+# nginx\n+\n+ngx_all_srcs=`echo $ngx_all_srcs | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+for ngx_src in $NGX_ADDON_SRCS\n+do\n+    ngx_obj=\"addon/`basename \\`dirname $ngx_src\\``\"\n+\n+    test -d $NGX_OBJS/$ngx_obj || mkdir -p $NGX_OBJS/$ngx_obj\n+\n+    ngx_obj=`echo $ngx_obj/\\`basename $ngx_src\\` \\\n+        | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_all_srcs=\"$ngx_all_srcs $ngx_obj\"\n+done\n+\n+ngx_all_objs=`echo $ngx_all_srcs \\\n+    | sed -e \"s#\\([^ ]*\\.\\)cpp#$NGX_OBJS\\/\\1$ngx_objext#g\" \\\n+          -e \"s#\\([^ ]*\\.\\)cc#$NGX_OBJS\\/\\1$ngx_objext#g\" \\\n+          -e \"s#\\([^ ]*\\.\\)c#$NGX_OBJS\\/\\1$ngx_objext#g\" \\\n+          -e \"s#\\([^ ]*\\.\\)S#$NGX_OBJS\\/\\1$ngx_objext#g\"`\n+\n+ngx_modules_c=`echo $NGX_MODULES_C | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+ngx_modules_obj=`echo $ngx_modules_c | sed -e \"s/\\(.*\\.\\)c/\\1$ngx_objext/\"`\n+\n+\n+if test -n \"$NGX_RES\"; then\n+   ngx_res=$NGX_RES\n+else\n+   ngx_res=\"$NGX_RC $NGX_ICONS\"\n+   ngx_rcc=`echo $NGX_RCC | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+fi\n+\n+ngx_deps=`echo $ngx_all_objs $ngx_modules_obj $ngx_res $LINK_DEPS \\\n+    | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\" \\\n+          -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+ngx_objs=`echo $ngx_all_objs $ngx_modules_obj \\\n+    | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_long_regex_cont\\1/g\" \\\n+          -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+ngx_libs=\n+if test -n \"$NGX_LD_OPT$CORE_LIBS\"; then\n+    ngx_libs=`echo $NGX_LD_OPT $CORE_LIBS \\\n+        | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"`\n+fi\n+\n+ngx_link=${CORE_LINK:+`echo $CORE_LINK \\\n+    | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"`}\n+\n+ngx_main_link=${MAIN_LINK:+`echo $MAIN_LINK \\\n+    | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"`}\n+\n+\n+cat << END                                                    >> $NGX_MAKEFILE\n+\n+build:\tbinary modules manpage\n+\n+binary:\t$NGX_OBJS${ngx_dirsep}nginx$ngx_binext\n+\n+$NGX_OBJS${ngx_dirsep}nginx$ngx_binext:\t$ngx_deps$ngx_spacer\n+\t\\$(LINK) $ngx_long_start$ngx_binout$NGX_OBJS${ngx_dirsep}nginx$ngx_binext$ngx_long_cont$ngx_objs$ngx_libs$ngx_link$ngx_main_link\n+\t$ngx_rcc\n+$ngx_long_end\n+\n+modules:\n+END\n+\n+\n+# ngx_modules.c\n+\n+if test -n \"$NGX_PCH\"; then\n+    ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+else\n+    ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) \\$(CORE_INCS)\"\n+fi\n+\n+cat << END                                                    >> $NGX_MAKEFILE\n+\n+$ngx_modules_obj:\t\\$(CORE_DEPS)$ngx_cont$ngx_modules_c\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_modules_obj$ngx_tab$ngx_modules_c$NGX_AUX\n+\n+END\n+\n+\n+# the core sources\n+\n+for ngx_src in $CORE_SRCS\n+do\n+    ngx_src=`echo $ngx_src | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+    ngx_obj=`echo $ngx_src \\\n+        | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+              -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+              -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+              -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(CORE_DEPS)$ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+\n+done\n+\n+\n+# the http sources\n+\n+if [ $HTTP = YES ]; then\n+\n+    if test -n \"$NGX_PCH\"; then\n+        ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+    else\n+        ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) \\$(CORE_INCS) \\$(HTTP_INCS)\"\n+        ngx_perl_cc=\"\\$(CC) $ngx_compile_opt \\$(NGX_PERL_CFLAGS)\"\n+        ngx_perl_cc=\"$ngx_perl_cc \\$(CORE_INCS) \\$(HTTP_INCS)\"\n+    fi\n+\n+    for ngx_source in $HTTP_SRCS\n+    do\n+        ngx_src=`echo $ngx_source | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ngx_obj=`echo $ngx_src \\\n+            | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+        if [ $ngx_source = src/http/modules/perl/ngx_http_perl_module.c ]; then\n+\n+            cat << END                                        >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(CORE_DEPS) \\$(HTTP_DEPS)$ngx_cont$ngx_src\n+\t$ngx_perl_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+        else\n+\n+            cat << END                                        >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(CORE_DEPS) \\$(HTTP_DEPS)$ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+\n+        fi\n+     done\n+\n+fi\n+\n+\n+# the mail sources\n+\n+if [ $MAIL = YES ]; then\n+\n+    if test -n \"$NGX_PCH\"; then\n+        ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+    else\n+        ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) \\$(CORE_INCS) \\$(MAIL_INCS)\"\n+    fi\n+\n+    for ngx_src in $MAIL_SRCS\n+    do\n+        ngx_src=`echo $ngx_src | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ngx_obj=`echo $ngx_src \\\n+            | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(CORE_DEPS) \\$(MAIL_DEPS)$ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+     done\n+\n+fi\n+\n+\n+# the stream sources\n+\n+if [ $STREAM = YES ]; then\n+\n+    if test -n \"$NGX_PCH\"; then\n+        ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+    else\n+        ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) \\$(CORE_INCS) \\$(STREAM_INCS)\"\n+    fi\n+\n+    for ngx_src in $STREAM_SRCS\n+    do\n+        ngx_src=`echo $ngx_src | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ngx_obj=`echo $ngx_src \\\n+            | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(CORE_DEPS) \\$(STREAM_DEPS)$ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+     done\n+\n+fi\n+\n+\n+# the misc sources\n+\n+if test -n \"$MISC_SRCS\"; then\n+\n+    ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+\n+    for ngx_src in $MISC_SRCS\n+    do\n+        ngx_src=`echo $ngx_src | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ngx_obj=`echo $ngx_src \\\n+            | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(CORE_DEPS) $ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+     done\n+\n+fi\n+\n+\n+# the addons sources\n+\n+if test -n \"$NGX_ADDON_SRCS\"; then\n+\n+    ngx_cc=\"\\$(CC) $ngx_compile_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+\n+    for ngx_src in $NGX_ADDON_SRCS\n+    do\n+        ngx_obj=\"addon/`basename \\`dirname $ngx_src\\``\"\n+\n+        ngx_obj=`echo $ngx_obj/\\`basename $ngx_src\\` \\\n+            | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+        ngx_obj=`echo $ngx_obj \\\n+            | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+        ngx_src=`echo $ngx_src | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(ADDON_DEPS)$ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+     done\n+\n+fi\n+\n+\n+# the addons config.make\n+\n+if test -n \"$NGX_ADDONS$DYNAMIC_ADDONS\"; then\n+\n+    for ngx_addon_dir in $NGX_ADDONS $DYNAMIC_ADDONS\n+    do\n+        if test -f $ngx_addon_dir/config.make; then\n+            . $ngx_addon_dir/config.make\n+        fi\n+    done\n+fi\n+\n+\n+# Win32 resource file\n+\n+if test -n \"$NGX_RES\"; then\n+\n+    ngx_res=`echo \"$NGX_RES:\t$NGX_RC $NGX_ICONS\" \\\n+                 | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+    ngx_rcc=`echo $NGX_RCC | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+$ngx_res\n+\t$ngx_rcc\n+\n+END\n+\n+fi\n+\n+\n+# the precompiled headers\n+\n+if test -n \"$NGX_PCH\"; then\n+    echo \"#include <ngx_config.h>\" > $NGX_OBJS/ngx_pch.c\n+\n+    ngx_pch=\"src/core/ngx_config.h $OS_CONFIG $NGX_OBJS/ngx_auto_config.h\"\n+    ngx_pch=`echo \"$NGX_PCH:\t$ngx_pch\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_src=\"\\$(CC) \\$(CFLAGS) $NGX_BUILD_PCH $ngx_compile_opt \\$(ALL_INCS)\"\n+    ngx_src=\"$ngx_src $ngx_objout$NGX_OBJS/ngx_pch.obj $NGX_OBJS/ngx_pch.c\"\n+    ngx_src=`echo $ngx_src | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    cat << END                                                >> $NGX_MAKEFILE\n+\n+$ngx_pch\n+\t$ngx_src\n+\n+END\n+\n+fi\n+\n+\n+# dynamic modules\n+\n+if test -n \"$NGX_PCH\"; then\n+    ngx_cc=\"\\$(CC) $ngx_compile_opt $ngx_pic_opt \\$(CFLAGS) $ngx_use_pch \\$(ALL_INCS)\"\n+else\n+    ngx_cc=\"\\$(CC) $ngx_compile_opt $ngx_pic_opt \\$(CFLAGS) \\$(ALL_INCS)\"\n+    ngx_perl_cc=\"\\$(CC) $ngx_compile_opt $ngx_pic_opt \\$(NGX_PERL_CFLAGS)\"\n+    ngx_perl_cc=\"$ngx_perl_cc \\$(ALL_INCS)\"\n+fi\n+\n+for ngx_module in $DYNAMIC_MODULES\n+do\n+    eval ngx_module_srcs=\"\\$${ngx_module}_SRCS\"\n+    eval eval ngx_module_libs=\"\\\\\\\"\\$${ngx_module}_LIBS\\\\\\\"\"\n+\n+    eval ngx_module_modules=\"\\$${ngx_module}_MODULES\"\n+    eval ngx_module_order=\"\\$${ngx_module}_ORDER\"\n+\n+    ngx_modules_c=$NGX_OBJS/${ngx_module}_modules.c\n+\n+    cat << END                                    > $ngx_modules_c\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+END\n+\n+    for mod in $ngx_module_modules\n+    do\n+        echo \"extern ngx_module_t  $mod;\"         >> $ngx_modules_c\n+    done\n+\n+    echo                                          >> $ngx_modules_c\n+    echo 'ngx_module_t *ngx_modules[] = {'        >> $ngx_modules_c\n+\n+    for mod in $ngx_module_modules\n+    do\n+        echo \"    &$mod,\"                         >> $ngx_modules_c\n+    done\n+\n+    cat << END                                    >> $ngx_modules_c\n+    NULL\n+};\n+\n+END\n+\n+    echo 'char *ngx_module_names[] = {'           >> $ngx_modules_c\n+\n+    for mod in $ngx_module_modules\n+    do\n+        echo \"    \\\"$mod\\\",\"                      >> $ngx_modules_c\n+    done\n+\n+    cat << END                                    >> $ngx_modules_c\n+    NULL\n+};\n+\n+END\n+\n+    echo 'char *ngx_module_order[] = {'           >> $ngx_modules_c\n+\n+    for mod in $ngx_module_order\n+    do\n+        echo \"    \\\"$mod\\\",\"                      >> $ngx_modules_c\n+    done\n+\n+    cat << END                                    >> $ngx_modules_c\n+    NULL\n+};\n+\n+END\n+\n+    ngx_modules_c=`echo $ngx_modules_c | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_modules_obj=`echo $ngx_modules_c \\\n+        | sed -e \"s/\\(.*\\.\\)c/\\1$ngx_objext/\"`\n+\n+    ngx_module_objs=\n+    for ngx_src in $ngx_module_srcs\n+    do\n+        case \"$ngx_src\" in\n+            src/*)\n+                ngx_obj=$ngx_src\n+                ;;\n+            *)\n+                ngx_obj=\"addon/`basename \\`dirname $ngx_src\\``\"\n+                mkdir -p $NGX_OBJS/$ngx_obj\n+                ngx_obj=\"$ngx_obj/`basename $ngx_src`\"\n+                ;;\n+        esac\n+\n+        ngx_module_objs=\"$ngx_module_objs $ngx_obj\"\n+    done\n+\n+    ngx_module_objs=`echo $ngx_module_objs \\\n+        | sed -e \"s#\\([^ ]*\\.\\)cpp#$NGX_OBJS\\/\\1$ngx_objext#g\" \\\n+              -e \"s#\\([^ ]*\\.\\)cc#$NGX_OBJS\\/\\1$ngx_objext#g\" \\\n+              -e \"s#\\([^ ]*\\.\\)c#$NGX_OBJS\\/\\1$ngx_objext#g\" \\\n+              -e \"s#\\([^ ]*\\.\\)S#$NGX_OBJS\\/\\1$ngx_objext#g\"`\n+\n+    ngx_deps=`echo $ngx_module_objs $ngx_modules_obj $LINK_DEPS \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_objs=`echo $ngx_module_objs $ngx_modules_obj \\\n+        | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_long_regex_cont\\1/g\" \\\n+              -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+    ngx_obj=$NGX_OBJS$ngx_dirsep$ngx_module$ngx_modext\n+\n+    if [ \"$NGX_PLATFORM\" = win32 ]; then\n+        ngx_module_libs=\"$CORE_LIBS $ngx_module_libs\"\n+    fi\n+\n+    ngx_libs=\n+    if test -n \"$NGX_LD_OPT$ngx_module_libs\"; then\n+        ngx_libs=`echo $NGX_LD_OPT $ngx_module_libs \\\n+            | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"`\n+    fi\n+\n+    ngx_link=${CORE_LINK:+`echo $CORE_LINK \\\n+        | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"`}\n+\n+    ngx_module_link=${MODULE_LINK:+`echo $MODULE_LINK \\\n+        | sed -e \"s/\\//$ngx_regex_dirsep/g\" -e \"s/^/$ngx_long_regex_cont/\"`}\n+\n+\n+    cat << END                                            >> $NGX_MAKEFILE\n+\n+modules:\t$ngx_obj\n+\n+$ngx_obj:\t$ngx_deps$ngx_spacer\n+\t\\$(LINK) $ngx_long_start$ngx_binout$ngx_obj$ngx_long_cont$ngx_objs$ngx_libs$ngx_link$ngx_module_link\n+$ngx_long_end\n+\n+$ngx_modules_obj:\t\\$(CORE_DEPS)$ngx_cont$ngx_modules_c\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_modules_obj$ngx_tab$ngx_modules_c$NGX_AUX\n+\n+END\n+\n+    for ngx_source in $ngx_module_srcs\n+    do\n+        case \"$ngx_source\" in\n+            src/*)\n+                ngx_obj=`echo $ngx_source | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+                ;;\n+            *)\n+                ngx_obj=\"addon/`basename \\`dirname $ngx_source\\``\"\n+                ngx_obj=`echo $ngx_obj/\\`basename $ngx_source\\` \\\n+                    | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+                ;;\n+        esac\n+\n+        ngx_obj=`echo $ngx_obj \\\n+            | sed -e \"s#^\\(.*\\.\\)cpp\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)cc\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)c\\\\$#$ngx_objs_dir\\1$ngx_objext#g\" \\\n+                  -e \"s#^\\(.*\\.\\)S\\\\$#$ngx_objs_dir\\1$ngx_objext#g\"`\n+\n+        ngx_src=`echo $ngx_source | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+\n+        if [ $ngx_source = src/http/modules/perl/ngx_http_perl_module.c ]; then\n+\n+            cat << END                                        >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(ADDON_DEPS)$ngx_cont$ngx_src\n+\t$ngx_perl_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+        else\n+\n+            cat << END                                        >> $NGX_MAKEFILE\n+\n+$ngx_obj:\t\\$(ADDON_DEPS)$ngx_cont$ngx_src\n+\t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n+\n+END\n+\n+        fi\n+    done\n+done\nDiff:\n@@ -0,0 +1,138 @@\n+\n+# Copyright (C) Ruslan Ermilov\n+# Copyright (C) Nginx, Inc.\n+\n+\n+case $ngx_module_type in\n+    HTTP_*) ngx_var=HTTP ;;\n+    *)      ngx_var=$ngx_module_type ;;\n+esac\n+\n+\n+if [ \"$ngx_module_link\" = DYNAMIC ]; then\n+\n+    for ngx_module in $ngx_module_name; do\n+        # extract the first name\n+        break\n+    done\n+\n+    DYNAMIC_MODULES=\"$DYNAMIC_MODULES $ngx_module\"\n+    eval ${ngx_module}_SRCS=\\\"$ngx_module_srcs\\\"\n+\n+    eval ${ngx_module}_MODULES=\\\"$ngx_module_name\\\"\n+\n+    if [ -z \"$ngx_module_order\" -a \\\n+         \\( \"$ngx_module_type\" = \"HTTP_FILTER\" \\\n+         -o \"$ngx_module_type\" = \"HTTP_AUX_FILTER\" \\) ]\n+    then\n+        eval ${ngx_module}_ORDER=\\\"$ngx_module_name \\\n+                                   ngx_http_copy_filter_module\\\"\n+    else\n+        eval ${ngx_module}_ORDER=\\\"$ngx_module_order\\\"\n+    fi\n+\n+    if test -n \"$ngx_module_incs\"; then\n+        CORE_INCS=\"$CORE_INCS $ngx_module_incs\"\n+    fi\n+\n+    if test -n \"$ngx_module_deps\"; then\n+        NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_module_deps\"\n+    fi\n+\n+    libs=\n+    for lib in $ngx_module_libs\n+    do\n+        case $lib in\n+\n+            LIBXSLT | LIBGD | GEOIP | PERL)\n+                libs=\"$libs \\$NGX_LIB_$lib\"\n+\n+                if eval [ \"\\$USE_${lib}\" = NO ] ; then\n+                    eval USE_${lib}=DYNAMIC\n+                fi\n+            ;;\n+\n+            PCRE | OPENSSL | ZLIB)\n+                eval USE_${lib}=YES\n+            ;;\n+\n+            MD5 | SHA1)\n+                # obsolete\n+            ;;\n+\n+            *)\n+                libs=\"$libs $lib\"\n+            ;;\n+\n+        esac\n+    done\n+    eval ${ngx_module}_LIBS=\\'$libs\\'\n+\n+elif [ \"$ngx_module_link\" = YES ]; then\n+\n+    eval ${ngx_module_type}_MODULES=\\\"\\$${ngx_module_type}_MODULES \\\n+                                      $ngx_module_name\\\"\n+\n+    eval ${ngx_var}_SRCS=\\\"\\$${ngx_var}_SRCS $ngx_module_srcs\\\"\n+\n+    if test -n \"$ngx_module_incs\"; then\n+        eval ${ngx_var}_INCS=\\\"\\$${ngx_var}_INCS $ngx_module_incs\\\"\n+    fi\n+\n+    if test -n \"$ngx_module_deps\"; then\n+        eval ${ngx_var}_DEPS=\\\"\\$${ngx_var}_DEPS $ngx_module_deps\\\"\n+    fi\n+\n+    for lib in $ngx_module_libs\n+    do\n+        case $lib in\n+\n+            PCRE | OPENSSL | ZLIB | LIBXSLT | LIBGD | PERL | GEOIP)\n+                eval USE_${lib}=YES\n+            ;;\n+\n+            MD5 | SHA1)\n+                # obsolete\n+            ;;\n+\n+            *)\n+                CORE_LIBS=\"$CORE_LIBS $lib\"\n+            ;;\n+\n+        esac\n+    done\n+\n+elif [ \"$ngx_module_link\" = ADDON ]; then\n+\n+    eval ${ngx_module_type}_MODULES=\\\"\\$${ngx_module_type}_MODULES \\\n+                                      $ngx_module_name\\\"\n+\n+    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_module_srcs\"\n+\n+    if test -n \"$ngx_module_incs\"; then\n+        eval ${ngx_var}_INCS=\\\"\\$${ngx_var}_INCS $ngx_module_incs\\\"\n+    fi\n+\n+    if test -n \"$ngx_module_deps\"; then\n+        NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_module_deps\"\n+    fi\n+\n+    for lib in $ngx_module_libs\n+    do\n+        case $lib in\n+\n+            PCRE | OPENSSL | ZLIB | LIBXSLT | LIBGD | PERL | GEOIP)\n+                eval USE_${lib}=YES\n+            ;;\n+\n+            MD5 | SHA1)\n+                # obsolete\n+            ;;\n+\n+            *)\n+                CORE_LIBS=\"$CORE_LIBS $lib\"\n+            ;;\n+\n+        esac\n+    done\n+fi\nDiff:\n@@ -0,0 +1,1406 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $EVENT_SELECT = NO -a $EVENT_FOUND = NO ]; then\n+    EVENT_SELECT=YES\n+fi\n+\n+if [ $EVENT_SELECT = YES ]; then\n+    have=NGX_HAVE_SELECT . auto/have\n+    CORE_SRCS=\"$CORE_SRCS $SELECT_SRCS\"\n+    EVENT_MODULES=\"$EVENT_MODULES $SELECT_MODULE\"\n+fi\n+\n+\n+if [ $EVENT_POLL = NO -a $EVENT_FOUND = NO ]; then\n+    EVENT_POLL=YES\n+fi\n+\n+if [ $EVENT_POLL = YES ]; then\n+    have=NGX_HAVE_POLL . auto/have\n+    CORE_SRCS=\"$CORE_SRCS $POLL_SRCS\"\n+    EVENT_MODULES=\"$EVENT_MODULES $POLL_MODULE\"\n+fi\n+\n+\n+if [ $NGX_TEST_BUILD_DEVPOLL = YES ]; then\n+    have=NGX_HAVE_DEVPOLL . auto/have\n+    have=NGX_TEST_BUILD_DEVPOLL . auto/have\n+    EVENT_MODULES=\"$EVENT_MODULES $DEVPOLL_MODULE\"\n+    CORE_SRCS=\"$CORE_SRCS $DEVPOLL_SRCS\"\n+fi\n+\n+\n+if [ $NGX_TEST_BUILD_EVENTPORT = YES ]; then\n+    have=NGX_HAVE_EVENTPORT . auto/have\n+    have=NGX_TEST_BUILD_EVENTPORT . auto/have\n+    EVENT_MODULES=\"$EVENT_MODULES $EVENTPORT_MODULE\"\n+    CORE_SRCS=\"$CORE_SRCS $EVENTPORT_SRCS\"\n+fi\n+\n+if [ $NGX_TEST_BUILD_EPOLL = YES ]; then\n+    have=NGX_HAVE_EPOLL . auto/have\n+    have=NGX_HAVE_EPOLLRDHUP . auto/have\n+    have=NGX_HAVE_EPOLLEXCLUSIVE . auto/have\n+    have=NGX_HAVE_EVENTFD . auto/have\n+    have=NGX_TEST_BUILD_EPOLL . auto/have\n+    EVENT_MODULES=\"$EVENT_MODULES $EPOLL_MODULE\"\n+    CORE_SRCS=\"$CORE_SRCS $EPOLL_SRCS\"\n+fi\n+\n+if [ $NGX_TEST_BUILD_SOLARIS_SENDFILEV = YES ]; then\n+    have=NGX_TEST_BUILD_SOLARIS_SENDFILEV . auto/have\n+    CORE_SRCS=\"$CORE_SRCS $SOLARIS_SENDFILEV_SRCS\"\n+fi\n+\n+\n+if [ $HTTP = YES ]; then\n+    HTTP_MODULES=\n+    HTTP_DEPS=\n+    HTTP_INCS=\n+\n+    ngx_module_type=HTTP\n+\n+    if :; then\n+        ngx_module_name=\"ngx_http_module \\\n+                         ngx_http_core_module \\\n+                         ngx_http_log_module \\\n+                         ngx_http_upstream_module\"\n+        ngx_module_incs=\"src/http src/http/modules\"\n+        ngx_module_deps=\"src/http/ngx_http.h \\\n+                         src/http/ngx_http_request.h \\\n+                         src/http/ngx_http_config.h \\\n+                         src/http/ngx_http_core_module.h \\\n+                         src/http/ngx_http_cache.h \\\n+                         src/http/ngx_http_variables.h \\\n+                         src/http/ngx_http_script.h \\\n+                         src/http/ngx_http_upstream.h \\\n+                         src/http/ngx_http_upstream_round_robin.h\"\n+        ngx_module_srcs=\"src/http/ngx_http.c \\\n+                         src/http/ngx_http_core_module.c \\\n+                         src/http/ngx_http_special_response.c \\\n+                         src/http/ngx_http_request.c \\\n+                         src/http/ngx_http_parse.c \\\n+                         src/http/modules/ngx_http_log_module.c \\\n+                         src/http/ngx_http_request_body.c \\\n+                         src/http/ngx_http_variables.c \\\n+                         src/http/ngx_http_script.c \\\n+                         src/http/ngx_http_upstream.c \\\n+                         src/http/ngx_http_upstream_round_robin.c\"\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+\n+    if [ $HTTP_CACHE = YES ]; then\n+        have=NGX_HTTP_CACHE . auto/have\n+        HTTP_SRCS=\"$HTTP_SRCS $HTTP_FILE_CACHE_SRCS\"\n+    fi\n+\n+\n+    # the module order is important\n+    #     ngx_http_static_module\n+    #     ngx_http_gzip_static_module\n+    #     ngx_http_dav_module\n+    #     ngx_http_autoindex_module\n+    #     ngx_http_index_module\n+    #     ngx_http_random_index_module\n+    #\n+    #     ngx_http_access_module\n+    #     ngx_http_realip_module\n+    #\n+    #\n+    # the filter order is important\n+    #     ngx_http_write_filter\n+    #     ngx_http_header_filter\n+    #     ngx_http_chunked_filter\n+    #     ngx_http_v2_filter\n+    #     ngx_http_range_header_filter\n+    #     ngx_http_gzip_filter\n+    #     ngx_http_postpone_filter\n+    #     ngx_http_ssi_filter\n+    #     ngx_http_charset_filter\n+    #         ngx_http_xslt_filter\n+    #         ngx_http_image_filter\n+    #         ngx_http_sub_filter\n+    #         ngx_http_addition_filter\n+    #         ngx_http_gunzip_filter\n+    #         ngx_http_userid_filter\n+    #         ngx_http_headers_filter\n+    #     ngx_http_copy_filter\n+    #     ngx_http_range_body_filter\n+    #     ngx_http_not_modified_filter\n+    #     ngx_http_slice_filter\n+\n+    ngx_module_type=HTTP_FILTER\n+    HTTP_FILTER_MODULES=\n+\n+    ngx_module_order=\"ngx_http_static_module \\\n+                      ngx_http_gzip_static_module \\\n+                      ngx_http_dav_module \\\n+                      ngx_http_autoindex_module \\\n+                      ngx_http_index_module \\\n+                      ngx_http_random_index_module \\\n+                      ngx_http_access_module \\\n+                      ngx_http_realip_module \\\n+                      ngx_http_write_filter_module \\\n+                      ngx_http_header_filter_module \\\n+                      ngx_http_chunked_filter_module \\\n+                      ngx_http_v2_filter_module \\\n+                      ngx_http_range_header_filter_module \\\n+                      ngx_http_gzip_filter_module \\\n+                      ngx_http_postpone_filter_module \\\n+                      ngx_http_ssi_filter_module \\\n+                      ngx_http_charset_filter_module \\\n+                      ngx_http_xslt_filter_module \\\n+                      ngx_http_image_filter_module \\\n+                      ngx_http_sub_filter_module \\\n+                      ngx_http_addition_filter_module \\\n+                      ngx_http_gunzip_filter_module \\\n+                      ngx_http_userid_filter_module \\\n+                      ngx_http_headers_filter_module \\\n+                      ngx_http_copy_filter_module \\\n+                      ngx_http_range_body_filter_module \\\n+                      ngx_http_not_modified_filter_module \\\n+                      ngx_http_slice_filter_module\"\n+\n+    if :; then\n+        ngx_module_name=ngx_http_write_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/ngx_http_write_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_header_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/ngx_http_header_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_chunked_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_chunked_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_V2 = YES ]; then\n+        ngx_module_name=ngx_http_v2_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/v2/ngx_http_v2_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_V2\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_range_header_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_range_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_GZIP = YES ]; then\n+        have=NGX_HTTP_GZIP . auto/have\n+        USE_ZLIB=YES\n+\n+        ngx_module_name=ngx_http_gzip_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_gzip_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_GZIP\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_postpone_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/ngx_http_postpone_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SSI = YES ]; then\n+        have=NGX_HTTP_SSI . auto/have\n+\n+        ngx_module_name=ngx_http_ssi_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=src/http/modules/ngx_http_ssi_filter_module.h\n+        ngx_module_srcs=src/http/modules/ngx_http_ssi_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SSI\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_CHARSET = YES ]; then\n+        ngx_module_name=ngx_http_charset_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_charset_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_CHARSET\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_XSLT != NO ]; then\n+        ngx_module_name=ngx_http_xslt_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_xslt_filter_module.c\n+        ngx_module_libs=LIBXSLT\n+        ngx_module_link=$HTTP_XSLT\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_IMAGE_FILTER != NO ]; then\n+        ngx_module_name=ngx_http_image_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_image_filter_module.c\n+        ngx_module_libs=LIBGD\n+        ngx_module_link=$HTTP_IMAGE_FILTER\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SUB = YES ]; then\n+        ngx_module_name=ngx_http_sub_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_sub_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SUB\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_ADDITION = YES ]; then\n+        ngx_module_name=ngx_http_addition_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_addition_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_ADDITION\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_GUNZIP = YES ]; then\n+        have=NGX_HTTP_GZIP . auto/have\n+        USE_ZLIB=YES\n+\n+        ngx_module_name=ngx_http_gunzip_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_gunzip_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_GUNZIP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_USERID = YES ]; then\n+        ngx_module_name=ngx_http_userid_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_userid_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_USERID\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_headers_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_headers_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+\n+    ngx_module_type=HTTP_INIT_FILTER\n+    HTTP_INIT_FILTER_MODULES=\n+\n+    if :; then\n+        ngx_module_name=ngx_http_copy_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/ngx_http_copy_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_range_body_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_not_modified_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_not_modified_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SLICE = YES ]; then\n+        ngx_module_name=ngx_http_slice_filter_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_slice_filter_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SLICE\n+\n+        . auto/module\n+    fi\n+\n+\n+    ngx_module_type=HTTP\n+\n+    if [ $HTTP_V2 = YES ]; then\n+        have=NGX_HTTP_V2 . auto/have\n+        have=NGX_HTTP_HEADERS . auto/have\n+\n+        ngx_module_name=ngx_http_v2_module\n+        ngx_module_incs=src/http/v2\n+        ngx_module_deps=\"src/http/v2/ngx_http_v2.h \\\n+                         src/http/v2/ngx_http_v2_module.h\"\n+        ngx_module_srcs=\"src/http/v2/ngx_http_v2.c \\\n+                         src/http/v2/ngx_http_v2_table.c \\\n+                         src/http/v2/ngx_http_v2_encode.c \\\n+                         src/http/v2/ngx_http_v2_huff_decode.c \\\n+                         src/http/v2/ngx_http_v2_huff_encode.c \\\n+                         src/http/v2/ngx_http_v2_module.c\"\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_V2\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_static_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_static_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_GZIP_STATIC = YES ]; then\n+        have=NGX_HTTP_GZIP . auto/have\n+\n+        ngx_module_name=ngx_http_gzip_static_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_gzip_static_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_GZIP_STATIC\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_DAV = YES ]; then\n+        have=NGX_HTTP_DAV . auto/have\n+\n+        ngx_module_name=ngx_http_dav_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_dav_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_DAV\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_AUTOINDEX = YES ]; then\n+        ngx_module_name=ngx_http_autoindex_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_autoindex_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_AUTOINDEX\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_index_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_index_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_RANDOM_INDEX = YES ]; then\n+        ngx_module_name=ngx_http_random_index_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_random_index_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_RANDOM_INDEX\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_MIRROR = YES ]; then\n+        ngx_module_name=ngx_http_mirror_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_mirror_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_MIRROR\n+\n+        . auto/module\n+    fi\n+\n+    if :; then\n+        ngx_module_name=ngx_http_try_files_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_try_files_module.c\n+        ngx_module_libs=\n+        ngx_module_link=YES\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_AUTH_REQUEST = YES ]; then\n+        ngx_module_name=ngx_http_auth_request_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_auth_request_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_AUTH_REQUEST\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_AUTH_BASIC = YES ]; then\n+        have=NGX_CRYPT . auto/have\n+\n+        ngx_module_name=ngx_http_auth_basic_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_auth_basic_module.c\n+        ngx_module_libs=$CRYPT_LIB\n+        ngx_module_link=$HTTP_AUTH_BASIC\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_ACCESS = YES ]; then\n+        ngx_module_name=ngx_http_access_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_access_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_ACCESS\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_LIMIT_CONN = YES ]; then\n+        ngx_module_name=ngx_http_limit_conn_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_limit_conn_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_LIMIT_CONN\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_LIMIT_REQ = YES ]; then\n+        ngx_module_name=ngx_http_limit_req_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_limit_req_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_LIMIT_REQ\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_REALIP = YES ]; then\n+        have=NGX_HTTP_REALIP . auto/have\n+        have=NGX_HTTP_X_FORWARDED_FOR . auto/have\n+\n+        ngx_module_name=ngx_http_realip_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_realip_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_REALIP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_STATUS = YES ]; then\n+        ngx_module_name=ngx_http_status_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_status_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_STATUS\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_GEO = YES ]; then\n+        have=NGX_HTTP_X_FORWARDED_FOR . auto/have\n+\n+        ngx_module_name=ngx_http_geo_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_geo_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_GEO\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_GEOIP != NO ]; then\n+        have=NGX_HTTP_X_FORWARDED_FOR . auto/have\n+\n+        ngx_module_name=ngx_http_geoip_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_geoip_module.c\n+        ngx_module_libs=GEOIP\n+        ngx_module_link=$HTTP_GEOIP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_MAP = YES ]; then\n+        ngx_module_name=ngx_http_map_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_map_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_MAP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SPLIT_CLIENTS = YES ]; then\n+        ngx_module_name=ngx_http_split_clients_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_split_clients_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SPLIT_CLIENTS\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_REFERER = YES ]; then\n+        ngx_module_name=ngx_http_referer_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_referer_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_REFERER\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_REWRITE = YES -a $USE_PCRE != DISABLED ]; then\n+        USE_PCRE=YES\n+\n+        ngx_module_name=ngx_http_rewrite_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_rewrite_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_REWRITE\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SSL = YES ]; then\n+        USE_OPENSSL=YES\n+        have=NGX_HTTP_SSL . auto/have\n+\n+        ngx_module_name=ngx_http_ssl_module\n+        ngx_module_incs=\n+        ngx_module_deps=src/http/modules/ngx_http_ssl_module.h\n+        ngx_module_srcs=src/http/modules/ngx_http_ssl_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SSL\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_PROXY = YES ]; then\n+        have=NGX_HTTP_X_FORWARDED_FOR . auto/have\n+\n+        ngx_module_name=ngx_http_proxy_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_proxy_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_PROXY\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_FASTCGI = YES ]; then\n+        ngx_module_name=ngx_http_fastcgi_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_fastcgi_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_FASTCGI\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UWSGI = YES ]; then\n+        ngx_module_name=ngx_http_uwsgi_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_uwsgi_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UWSGI\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SCGI = YES ]; then\n+        ngx_module_name=ngx_http_scgi_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_scgi_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SCGI\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_GRPC = YES -a $HTTP_V2 = YES ]; then\n+        ngx_module_name=ngx_http_grpc_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_grpc_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_GRPC\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_PERL != NO ]; then\n+        ngx_module_name=ngx_http_perl_module\n+        ngx_module_incs=src/http/modules/perl\n+        ngx_module_deps=src/http/modules/perl/ngx_http_perl_module.h\n+        ngx_module_srcs=src/http/modules/perl/ngx_http_perl_module.c\n+        ngx_module_libs=PERL\n+        ngx_module_link=$HTTP_PERL\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_MEMCACHED = YES ]; then\n+        ngx_module_name=ngx_http_memcached_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_memcached_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_MEMCACHED\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_EMPTY_GIF = YES ]; then\n+        ngx_module_name=ngx_http_empty_gif_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_empty_gif_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_EMPTY_GIF\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_BROWSER = YES ]; then\n+        ngx_module_name=ngx_http_browser_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_browser_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_BROWSER\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_SECURE_LINK = YES ]; then\n+        ngx_module_name=ngx_http_secure_link_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_secure_link_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_SECURE_LINK\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_DEGRADATION = YES ]; then\n+        have=NGX_HTTP_DEGRADATION . auto/have\n+\n+        ngx_module_name=ngx_http_degradation_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_degradation_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_DEGRADATION\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_FLV = YES ]; then\n+        ngx_module_name=ngx_http_flv_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_flv_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_FLV\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_MP4 = YES ]; then\n+        ngx_module_name=ngx_http_mp4_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_mp4_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_MP4\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UPSTREAM_HASH = YES ]; then\n+        ngx_module_name=ngx_http_upstream_hash_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_upstream_hash_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UPSTREAM_HASH\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UPSTREAM_IP_HASH = YES ]; then\n+        ngx_module_name=ngx_http_upstream_ip_hash_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_upstream_ip_hash_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UPSTREAM_IP_HASH\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UPSTREAM_LEAST_CONN = YES ]; then\n+        ngx_module_name=ngx_http_upstream_least_conn_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_upstream_least_conn_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UPSTREAM_LEAST_CONN\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UPSTREAM_RANDOM = YES ]; then\n+        ngx_module_name=ngx_http_upstream_random_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_upstream_random_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UPSTREAM_RANDOM\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UPSTREAM_KEEPALIVE = YES ]; then\n+        ngx_module_name=ngx_http_upstream_keepalive_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_upstream_keepalive_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UPSTREAM_KEEPALIVE\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_UPSTREAM_ZONE = YES ]; then\n+        have=NGX_HTTP_UPSTREAM_ZONE . auto/have\n+\n+        ngx_module_name=ngx_http_upstream_zone_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_upstream_zone_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_UPSTREAM_ZONE\n+\n+        . auto/module\n+    fi\n+\n+    if [ $HTTP_STUB_STATUS = YES ]; then\n+        have=NGX_STAT_STUB . auto/have\n+\n+        ngx_module_name=ngx_http_stub_status_module\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=src/http/modules/ngx_http_stub_status_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$HTTP_STUB_STATUS\n+\n+        . auto/module\n+    fi\n+fi\n+\n+\n+if [ $MAIL != NO ]; then\n+    MAIL_MODULES=\n+    MAIL_DEPS=\n+    MAIL_INCS=\n+\n+    ngx_module_type=MAIL\n+    ngx_module_libs=\n+    ngx_module_link=YES\n+\n+    ngx_module_order=\n+\n+    ngx_module_name=\"ngx_mail_module ngx_mail_core_module\"\n+    ngx_module_incs=\"src/mail\"\n+    ngx_module_deps=\"src/mail/ngx_mail.h\"\n+    ngx_module_srcs=\"src/mail/ngx_mail.c \\\n+                     src/mail/ngx_mail_core_module.c \\\n+                     src/mail/ngx_mail_handler.c \\\n+                     src/mail/ngx_mail_parse.c\"\n+\n+    . auto/module\n+\n+    ngx_module_incs=\n+\n+    if [ $MAIL_SSL = YES ]; then\n+        USE_OPENSSL=YES\n+        have=NGX_MAIL_SSL . auto/have\n+\n+        ngx_module_name=ngx_mail_ssl_module\n+        ngx_module_deps=src/mail/ngx_mail_ssl_module.h\n+        ngx_module_srcs=src/mail/ngx_mail_ssl_module.c\n+\n+        . auto/module\n+    fi\n+\n+    if [ $MAIL_POP3 = YES ]; then\n+        ngx_module_name=ngx_mail_pop3_module\n+        ngx_module_deps=src/mail/ngx_mail_pop3_module.h\n+        ngx_module_srcs=\"src/mail/ngx_mail_pop3_module.c \\\n+                         src/mail/ngx_mail_pop3_handler.c\"\n+\n+        . auto/module\n+    fi\n+\n+    if [ $MAIL_IMAP = YES ]; then\n+        ngx_module_name=ngx_mail_imap_module\n+        ngx_module_deps=src/mail/ngx_mail_imap_module.h\n+        ngx_module_srcs=\"src/mail/ngx_mail_imap_module.c \\\n+                         src/mail/ngx_mail_imap_handler.c\"\n+\n+        . auto/module\n+    fi\n+\n+    if [ $MAIL_SMTP = YES ]; then\n+        ngx_module_name=ngx_mail_smtp_module\n+        ngx_module_deps=src/mail/ngx_mail_smtp_module.h\n+        ngx_module_srcs=\"src/mail/ngx_mail_smtp_module.c \\\n+                         src/mail/ngx_mail_smtp_handler.c\"\n+\n+        . auto/module\n+    fi\n+\n+    ngx_module_name=ngx_mail_auth_http_module\n+    ngx_module_deps=\n+    ngx_module_srcs=src/mail/ngx_mail_auth_http_module.c\n+\n+    . auto/module\n+\n+    ngx_module_name=ngx_mail_proxy_module\n+    ngx_module_deps=\n+    ngx_module_srcs=src/mail/ngx_mail_proxy_module.c\n+\n+    . auto/module\n+fi\n+\n+\n+if [ $STREAM != NO ]; then\n+    STREAM_MODULES=\n+    STREAM_DEPS=\n+    STREAM_INCS=\n+\n+    ngx_module_type=STREAM\n+    ngx_module_libs=\n+    ngx_module_link=YES\n+\n+    ngx_module_order=\n+\n+    ngx_module_name=\"ngx_stream_module \\\n+                     ngx_stream_core_module \\\n+                     ngx_stream_log_module \\\n+                     ngx_stream_proxy_module \\\n+                     ngx_stream_upstream_module \\\n+                     ngx_stream_write_filter_module\"\n+    ngx_module_incs=\"src/stream\"\n+    ngx_module_deps=\"src/stream/ngx_stream.h \\\n+                     src/stream/ngx_stream_variables.h \\\n+                     src/stream/ngx_stream_script.h \\\n+                     src/stream/ngx_stream_upstream.h \\\n+                     src/stream/ngx_stream_upstream_round_robin.h\"\n+    ngx_module_srcs=\"src/stream/ngx_stream.c \\\n+                     src/stream/ngx_stream_variables.c \\\n+                     src/stream/ngx_stream_script.c \\\n+                     src/stream/ngx_stream_handler.c \\\n+                     src/stream/ngx_stream_core_module.c \\\n+                     src/stream/ngx_stream_log_module.c \\\n+                     src/stream/ngx_stream_proxy_module.c \\\n+                     src/stream/ngx_stream_upstream.c \\\n+                     src/stream/ngx_stream_upstream_round_robin.c \\\n+                     src/stream/ngx_stream_write_filter_module.c\"\n+\n+    . auto/module\n+\n+    ngx_module_incs=\n+\n+    if [ $STREAM_SSL = YES ]; then\n+        USE_OPENSSL=YES\n+        have=NGX_STREAM_SSL . auto/have\n+\n+        ngx_module_name=ngx_stream_ssl_module\n+        ngx_module_deps=src/stream/ngx_stream_ssl_module.h\n+        ngx_module_srcs=src/stream/ngx_stream_ssl_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_SSL\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_REALIP = YES ]; then\n+        ngx_module_name=ngx_stream_realip_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_realip_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_REALIP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_LIMIT_CONN = YES ]; then\n+        ngx_module_name=ngx_stream_limit_conn_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_limit_conn_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_LIMIT_CONN\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_ACCESS = YES ]; then\n+        ngx_module_name=ngx_stream_access_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_access_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_ACCESS\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_GEO = YES ]; then\n+        ngx_module_name=ngx_stream_geo_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_geo_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_GEO\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_GEOIP != NO ]; then\n+        ngx_module_name=ngx_stream_geoip_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_geoip_module.c\n+        ngx_module_libs=GEOIP\n+        ngx_module_link=$STREAM_GEOIP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_MAP = YES ]; then\n+        ngx_module_name=ngx_stream_map_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_map_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_MAP\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_SPLIT_CLIENTS = YES ]; then\n+        ngx_module_name=ngx_stream_split_clients_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_split_clients_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_SPLIT_CLIENTS\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_RETURN = YES ]; then\n+        ngx_module_name=ngx_stream_return_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_return_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_RETURN\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_UPSTREAM_HASH = YES ]; then\n+        ngx_module_name=ngx_stream_upstream_hash_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_upstream_hash_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_UPSTREAM_HASH\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_UPSTREAM_LEAST_CONN = YES ]; then\n+        ngx_module_name=ngx_stream_upstream_least_conn_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_upstream_least_conn_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_UPSTREAM_LEAST_CONN\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_UPSTREAM_RANDOM = YES ]; then\n+        ngx_module_name=ngx_stream_upstream_random_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_upstream_random_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_UPSTREAM_RANDOM\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_UPSTREAM_ZONE = YES ]; then\n+        have=NGX_STREAM_UPSTREAM_ZONE . auto/have\n+\n+        ngx_module_name=ngx_stream_upstream_zone_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_upstream_zone_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_UPSTREAM_ZONE\n+\n+        . auto/module\n+    fi\n+\n+    if [ $STREAM_SSL_PREREAD = YES ]; then\n+        ngx_module_name=ngx_stream_ssl_preread_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_ssl_preread_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_SSL_PREREAD\n+\n+        . auto/module\n+    fi\n+fi\n+\n+\n+#if [ -r $NGX_OBJS/auto ]; then\n+#    . $NGX_OBJS/auto\n+#fi\n+\n+\n+if test -n \"$NGX_ADDONS\"; then\n+\n+    echo configuring additional modules\n+\n+    for ngx_addon_dir in $NGX_ADDONS\n+    do\n+        echo \"adding module in $ngx_addon_dir\"\n+\n+        ngx_module_type=\n+        ngx_module_name=\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=\n+        ngx_module_libs=\n+        ngx_module_order=\n+        ngx_module_link=ADDON\n+\n+        if test -f $ngx_addon_dir/config; then\n+            . $ngx_addon_dir/config\n+\n+            echo \" + $ngx_addon_name was configured\"\n+\n+        else\n+            echo \"$0: error: no $ngx_addon_dir/config was found\"\n+            exit 1\n+        fi\n+    done\n+fi\n+\n+\n+if test -n \"$DYNAMIC_ADDONS\"; then\n+\n+    echo configuring additional dynamic modules\n+\n+    for ngx_addon_dir in $DYNAMIC_ADDONS\n+    do\n+        echo \"adding module in $ngx_addon_dir\"\n+\n+        ngx_module_type=\n+        ngx_module_name=\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=\n+        ngx_module_libs=\n+        ngx_module_order=\n+        ngx_module_link=DYNAMIC\n+\n+        if test -f $ngx_addon_dir/config; then\n+            . $ngx_addon_dir/config\n+\n+            echo \" + $ngx_addon_name was configured\"\n+\n+        else\n+            echo \"$0: error: no $ngx_addon_dir/config was found\"\n+            exit 1\n+        fi\n+    done\n+fi\n+\n+\n+if [ $USE_OPENSSL = YES ]; then\n+    ngx_module_type=CORE\n+    ngx_module_name=ngx_openssl_module\n+    ngx_module_incs=\n+    ngx_module_deps=src/event/ngx_event_openssl.h\n+    ngx_module_srcs=\"src/event/ngx_event_openssl.c\n+                     src/event/ngx_event_openssl_stapling.c\"\n+    ngx_module_libs=\n+    ngx_module_link=YES\n+    ngx_module_order=\n+\n+    . auto/module\n+fi\n+\n+\n+if [ $USE_PCRE = YES ]; then\n+    ngx_module_type=CORE\n+    ngx_module_name=ngx_regex_module\n+    ngx_module_incs=\n+    ngx_module_deps=src/core/ngx_regex.h\n+    ngx_module_srcs=src/core/ngx_regex.c\n+    ngx_module_libs=\n+    ngx_module_link=YES\n+    ngx_module_order=\n+\n+    . auto/module\n+fi\n+\n+\n+modules=\"$CORE_MODULES $EVENT_MODULES\"\n+\n+\n+# thread pool module should be initialized after events\n+if [ $USE_THREADS = YES ]; then\n+    modules=\"$modules $THREAD_POOL_MODULE\"\n+fi\n+\n+\n+if [ $HTTP = YES ]; then\n+    modules=\"$modules $HTTP_MODULES $HTTP_FILTER_MODULES \\\n+             $HTTP_AUX_FILTER_MODULES $HTTP_INIT_FILTER_MODULES\"\n+\n+    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS \\$(HTTP_DEPS)\"\n+fi\n+\n+\n+if [ $MAIL != NO ]; then\n+\n+    if [ $MAIL = YES ]; then\n+        modules=\"$modules $MAIL_MODULES\"\n+\n+    elif [ $MAIL = DYNAMIC ]; then\n+        ngx_module_name=$MAIL_MODULES\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=$MAIL_SRCS\n+        ngx_module_libs=\n+        ngx_module_link=DYNAMIC\n+\n+        . auto/module\n+    fi\n+\n+    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS \\$(MAIL_DEPS)\"\n+fi\n+\n+\n+if [ $STREAM != NO ]; then\n+\n+    if [ $STREAM = YES ]; then\n+        modules=\"$modules $STREAM_MODULES\"\n+\n+    elif [ $STREAM = DYNAMIC ]; then\n+        ngx_module_name=$STREAM_MODULES\n+        ngx_module_incs=\n+        ngx_module_deps=\n+        ngx_module_srcs=$STREAM_SRCS\n+        ngx_module_libs=\n+        ngx_module_link=DYNAMIC\n+\n+        . auto/module\n+    fi\n+\n+    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS \\$(STREAM_DEPS)\"\n+fi\n+\n+\n+ngx_module_type=MISC\n+MISC_MODULES=\n+\n+if [ $NGX_GOOGLE_PERFTOOLS = YES ]; then\n+    ngx_module_name=ngx_google_perftools_module\n+    ngx_module_incs=\n+    ngx_module_deps=\n+    ngx_module_srcs=src/misc/ngx_google_perftools_module.c\n+    ngx_module_libs=\n+    ngx_module_link=$NGX_GOOGLE_PERFTOOLS\n+\n+    . auto/module\n+fi\n+\n+if [ $NGX_CPP_TEST = YES ]; then\n+    ngx_module_name=\n+    ngx_module_incs=\n+    ngx_module_deps=\n+    ngx_module_srcs=src/misc/ngx_cpp_test_module.cpp\n+    ngx_module_libs=-lstdc++\n+    ngx_module_link=$NGX_CPP_TEST\n+\n+    . auto/module\n+fi\n+\n+modules=\"$modules $MISC_MODULES\"\n+\n+\n+if [ $NGX_COMPAT = YES ]; then\n+    have=NGX_COMPAT . auto/have\n+    have=NGX_HTTP_GZIP . auto/have\n+    have=NGX_HTTP_DAV . auto/have\n+    have=NGX_HTTP_REALIP . auto/have\n+    have=NGX_HTTP_X_FORWARDED_FOR . auto/have\n+    have=NGX_HTTP_HEADERS . auto/have\n+    have=NGX_HTTP_UPSTREAM_ZONE . auto/have\n+    have=NGX_STREAM_UPSTREAM_ZONE . auto/have\n+fi\n+\n+\n+cat << END                                    > $NGX_MODULES_C\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+$NGX_PRAGMA\n+\n+END\n+\n+for mod in $modules\n+do\n+    echo \"extern ngx_module_t  $mod;\"         >> $NGX_MODULES_C\n+done\n+\n+echo                                          >> $NGX_MODULES_C\n+echo 'ngx_module_t *ngx_modules[] = {'        >> $NGX_MODULES_C\n+\n+for mod in $modules\n+do\n+    echo \"    &$mod,\"                         >> $NGX_MODULES_C\n+done\n+\n+cat << END                                    >> $NGX_MODULES_C\n+    NULL\n+};\n+\n+END\n+\n+echo 'char *ngx_module_names[] = {'           >> $NGX_MODULES_C\n+\n+for mod in $modules\n+do\n+    echo \"    \\\"$mod\\\",\"                      >> $NGX_MODULES_C\n+done\n+\n+cat << END                                    >> $NGX_MODULES_C\n+    NULL\n+};\n+\n+END\nDiff:\n@@ -0,0 +1,12 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#ifndef $have\n+#define $have  0\n+#endif\n+\n+END\nDiff:\n@@ -0,0 +1,627 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+help=no\n+\n+NGX_PREFIX=\n+NGX_SBIN_PATH=\n+NGX_MODULES_PATH=\n+NGX_CONF_PREFIX=\n+NGX_CONF_PATH=\n+NGX_ERROR_LOG_PATH=\n+NGX_PID_PATH=\n+NGX_LOCK_PATH=\n+NGX_USER=\n+NGX_GROUP=\n+NGX_BUILD=\n+\n+CC=${CC:-cc}\n+CPP=\n+NGX_OBJS=objs\n+\n+NGX_DEBUG=NO\n+NGX_CC_OPT=\n+NGX_LD_OPT=\n+CPU=NO\n+\n+NGX_RPATH=NO\n+\n+NGX_TEST_BUILD_DEVPOLL=NO\n+NGX_TEST_BUILD_EVENTPORT=NO\n+NGX_TEST_BUILD_EPOLL=NO\n+NGX_TEST_BUILD_SOLARIS_SENDFILEV=NO\n+\n+NGX_PLATFORM=\n+NGX_WINE=\n+\n+EVENT_FOUND=NO\n+\n+EVENT_SELECT=NO\n+EVENT_POLL=NO\n+\n+USE_THREADS=NO\n+\n+NGX_FILE_AIO=NO\n+\n+HTTP=YES\n+\n+NGX_HTTP_LOG_PATH=\n+NGX_HTTP_CLIENT_TEMP_PATH=\n+NGX_HTTP_PROXY_TEMP_PATH=\n+NGX_HTTP_FASTCGI_TEMP_PATH=\n+NGX_HTTP_UWSGI_TEMP_PATH=\n+NGX_HTTP_SCGI_TEMP_PATH=\n+\n+HTTP_CACHE=YES\n+HTTP_CHARSET=YES\n+HTTP_GZIP=YES\n+HTTP_SSL=NO\n+HTTP_V2=NO\n+HTTP_SSI=YES\n+HTTP_REALIP=NO\n+HTTP_XSLT=NO\n+HTTP_IMAGE_FILTER=NO\n+HTTP_SUB=NO\n+HTTP_ADDITION=NO\n+HTTP_DAV=NO\n+HTTP_ACCESS=YES\n+HTTP_AUTH_BASIC=YES\n+HTTP_AUTH_REQUEST=NO\n+HTTP_MIRROR=YES\n+HTTP_USERID=YES\n+HTTP_SLICE=NO\n+HTTP_AUTOINDEX=YES\n+HTTP_RANDOM_INDEX=NO\n+HTTP_STATUS=NO\n+HTTP_GEO=YES\n+HTTP_GEOIP=NO\n+HTTP_MAP=YES\n+HTTP_SPLIT_CLIENTS=YES\n+HTTP_REFERER=YES\n+HTTP_REWRITE=YES\n+HTTP_PROXY=YES\n+HTTP_FASTCGI=YES\n+HTTP_UWSGI=YES\n+HTTP_SCGI=YES\n+HTTP_GRPC=YES\n+HTTP_PERL=NO\n+HTTP_MEMCACHED=YES\n+HTTP_LIMIT_CONN=YES\n+HTTP_LIMIT_REQ=YES\n+HTTP_EMPTY_GIF=YES\n+HTTP_BROWSER=YES\n+HTTP_SECURE_LINK=NO\n+HTTP_DEGRADATION=NO\n+HTTP_FLV=NO\n+HTTP_MP4=NO\n+HTTP_GUNZIP=NO\n+HTTP_GZIP_STATIC=NO\n+HTTP_UPSTREAM_HASH=YES\n+HTTP_UPSTREAM_IP_HASH=YES\n+HTTP_UPSTREAM_LEAST_CONN=YES\n+HTTP_UPSTREAM_RANDOM=YES\n+HTTP_UPSTREAM_KEEPALIVE=YES\n+HTTP_UPSTREAM_ZONE=YES\n+\n+# STUB\n+HTTP_STUB_STATUS=NO\n+\n+MAIL=NO\n+MAIL_SSL=NO\n+MAIL_POP3=YES\n+MAIL_IMAP=YES\n+MAIL_SMTP=YES\n+\n+STREAM=NO\n+STREAM_SSL=NO\n+STREAM_REALIP=NO\n+STREAM_LIMIT_CONN=YES\n+STREAM_ACCESS=YES\n+STREAM_GEO=YES\n+STREAM_GEOIP=NO\n+STREAM_MAP=YES\n+STREAM_SPLIT_CLIENTS=YES\n+STREAM_RETURN=YES\n+STREAM_UPSTREAM_HASH=YES\n+STREAM_UPSTREAM_LEAST_CONN=YES\n+STREAM_UPSTREAM_RANDOM=YES\n+STREAM_UPSTREAM_ZONE=YES\n+STREAM_SSL_PREREAD=NO\n+\n+DYNAMIC_MODULES=\n+\n+NGX_ADDONS=\n+NGX_ADDON_DEPS=\n+DYNAMIC_ADDONS=\n+\n+NGX_COMPAT=NO\n+\n+USE_PCRE=NO\n+PCRE=NONE\n+PCRE_OPT=\n+PCRE_CONF_OPT=\n+PCRE_JIT=NO\n+\n+USE_OPENSSL=NO\n+OPENSSL=NONE\n+\n+USE_ZLIB=NO\n+ZLIB=NONE\n+ZLIB_OPT=\n+ZLIB_ASM=NO\n+\n+USE_PERL=NO\n+NGX_PERL=perl\n+\n+USE_LIBXSLT=NO\n+USE_LIBGD=NO\n+USE_GEOIP=NO\n+\n+NGX_GOOGLE_PERFTOOLS=NO\n+NGX_CPP_TEST=NO\n+\n+NGX_LIBATOMIC=NO\n+\n+NGX_CPU_CACHE_LINE=\n+\n+NGX_POST_CONF_MSG=\n+\n+opt=\n+\n+for option\n+do\n+    opt=\"$opt `echo $option | sed -e \\\"s/\\(--[^=]*=\\)\\(.* .*\\)/\\1'\\2'/\\\"`\"\n+\n+    case \"$option\" in\n+        -*=*) value=`echo \"$option\" | sed -e 's/[-_a-zA-Z0-9]*=//'` ;;\n+           *) value=\"\" ;;\n+    esac\n+\n+    case \"$option\" in\n+        --help)                          help=yes                   ;;\n+\n+        --prefix=)                       NGX_PREFIX=\"!\"             ;;\n+        --prefix=*)                      NGX_PREFIX=\"$value\"        ;;\n+        --sbin-path=*)                   NGX_SBIN_PATH=\"$value\"     ;;\n+        --modules-path=*)                NGX_MODULES_PATH=\"$value\"  ;;\n+        --conf-path=*)                   NGX_CONF_PATH=\"$value\"     ;;\n+        --error-log-path=*)              NGX_ERROR_LOG_PATH=\"$value\";;\n+        --pid-path=*)                    NGX_PID_PATH=\"$value\"      ;;\n+        --lock-path=*)                   NGX_LOCK_PATH=\"$value\"     ;;\n+        --user=*)                        NGX_USER=\"$value\"          ;;\n+        --group=*)                       NGX_GROUP=\"$value\"         ;;\n+\n+        --crossbuild=*)                  NGX_PLATFORM=\"$value\"      ;;\n+\n+        --build=*)                       NGX_BUILD=\"$value\"         ;;\n+        --builddir=*)                    NGX_OBJS=\"$value\"          ;;\n+\n+        --with-select_module)            EVENT_SELECT=YES           ;;\n+        --without-select_module)         EVENT_SELECT=NONE          ;;\n+        --with-poll_module)              EVENT_POLL=YES             ;;\n+        --without-poll_module)           EVENT_POLL=NONE            ;;\n+\n+        --with-threads)                  USE_THREADS=YES            ;;\n+\n+        --with-file-aio)                 NGX_FILE_AIO=YES           ;;\n+\n+        --with-ipv6)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-ipv6\\\" option is deprecated\"\n+        ;;\n+\n+        --without-http)                  HTTP=NO                    ;;\n+        --without-http-cache)            HTTP_CACHE=NO              ;;\n+\n+        --http-log-path=*)               NGX_HTTP_LOG_PATH=\"$value\" ;;\n+        --http-client-body-temp-path=*)  NGX_HTTP_CLIENT_TEMP_PATH=\"$value\" ;;\n+        --http-proxy-temp-path=*)        NGX_HTTP_PROXY_TEMP_PATH=\"$value\" ;;\n+        --http-fastcgi-temp-path=*)      NGX_HTTP_FASTCGI_TEMP_PATH=\"$value\" ;;\n+        --http-uwsgi-temp-path=*)        NGX_HTTP_UWSGI_TEMP_PATH=\"$value\" ;;\n+        --http-scgi-temp-path=*)         NGX_HTTP_SCGI_TEMP_PATH=\"$value\" ;;\n+\n+        --with-http_ssl_module)          HTTP_SSL=YES               ;;\n+        --with-http_v2_module)           HTTP_V2=YES                ;;\n+        --with-http_realip_module)       HTTP_REALIP=YES            ;;\n+        --with-http_addition_module)     HTTP_ADDITION=YES          ;;\n+        --with-http_xslt_module)         HTTP_XSLT=YES              ;;\n+        --with-http_xslt_module=dynamic) HTTP_XSLT=DYNAMIC          ;;\n+        --with-http_image_filter_module) HTTP_IMAGE_FILTER=YES      ;;\n+        --with-http_image_filter_module=dynamic)\n+                                         HTTP_IMAGE_FILTER=DYNAMIC  ;;\n+        --with-http_geoip_module)        HTTP_GEOIP=YES             ;;\n+        --with-http_geoip_module=dynamic)\n+                                         HTTP_GEOIP=DYNAMIC         ;;\n+        --with-http_sub_module)          HTTP_SUB=YES               ;;\n+        --with-http_dav_module)          HTTP_DAV=YES               ;;\n+        --with-http_flv_module)          HTTP_FLV=YES               ;;\n+        --with-http_mp4_module)          HTTP_MP4=YES               ;;\n+        --with-http_gunzip_module)       HTTP_GUNZIP=YES            ;;\n+        --with-http_gzip_static_module)  HTTP_GZIP_STATIC=YES       ;;\n+        --with-http_auth_request_module) HTTP_AUTH_REQUEST=YES      ;;\n+        --with-http_random_index_module) HTTP_RANDOM_INDEX=YES      ;;\n+        --with-http_secure_link_module)  HTTP_SECURE_LINK=YES       ;;\n+        --with-http_degradation_module)  HTTP_DEGRADATION=YES       ;;\n+        --with-http_slice_module)        HTTP_SLICE=YES             ;;\n+\n+        --without-http_charset_module)   HTTP_CHARSET=NO            ;;\n+        --without-http_gzip_module)      HTTP_GZIP=NO               ;;\n+        --without-http_ssi_module)       HTTP_SSI=NO                ;;\n+        --without-http_userid_module)    HTTP_USERID=NO             ;;\n+        --without-http_access_module)    HTTP_ACCESS=NO             ;;\n+        --without-http_auth_basic_module) HTTP_AUTH_BASIC=NO        ;;\n+        --without-http_mirror_module)    HTTP_MIRROR=NO             ;;\n+        --without-http_autoindex_module) HTTP_AUTOINDEX=NO          ;;\n+        --without-http_status_module)    HTTP_STATUS=NO             ;;\n+        --without-http_geo_module)       HTTP_GEO=NO                ;;\n+        --without-http_map_module)       HTTP_MAP=NO                ;;\n+        --without-http_split_clients_module) HTTP_SPLIT_CLIENTS=NO  ;;\n+        --without-http_referer_module)   HTTP_REFERER=NO            ;;\n+        --without-http_rewrite_module)   HTTP_REWRITE=NO            ;;\n+        --without-http_proxy_module)     HTTP_PROXY=NO              ;;\n+        --without-http_fastcgi_module)   HTTP_FASTCGI=NO            ;;\n+        --without-http_uwsgi_module)     HTTP_UWSGI=NO              ;;\n+        --without-http_scgi_module)      HTTP_SCGI=NO               ;;\n+        --without-http_grpc_module)      HTTP_GRPC=NO               ;;\n+        --without-http_memcached_module) HTTP_MEMCACHED=NO          ;;\n+        --without-http_limit_conn_module) HTTP_LIMIT_CONN=NO        ;;\n+        --without-http_limit_req_module) HTTP_LIMIT_REQ=NO         ;;\n+        --without-http_empty_gif_module) HTTP_EMPTY_GIF=NO          ;;\n+        --without-http_browser_module)   HTTP_BROWSER=NO            ;;\n+        --without-http_upstream_hash_module) HTTP_UPSTREAM_HASH=NO  ;;\n+        --without-http_upstream_ip_hash_module) HTTP_UPSTREAM_IP_HASH=NO ;;\n+        --without-http_upstream_least_conn_module)\n+                                         HTTP_UPSTREAM_LEAST_CONN=NO ;;\n+        --without-http_upstream_random_module)\n+                                         HTTP_UPSTREAM_RANDOM=NO    ;;\n+        --without-http_upstream_keepalive_module) HTTP_UPSTREAM_KEEPALIVE=NO ;;\n+        --without-http_upstream_zone_module) HTTP_UPSTREAM_ZONE=NO  ;;\n+\n+        --with-http_perl_module)         HTTP_PERL=YES              ;;\n+        --with-http_perl_module=dynamic) HTTP_PERL=DYNAMIC          ;;\n+        --with-perl_modules_path=*)      NGX_PERL_MODULES=\"$value\"  ;;\n+        --with-perl=*)                   NGX_PERL=\"$value\"          ;;\n+\n+        # STUB\n+        --with-http_stub_status_module)  HTTP_STUB_STATUS=YES       ;;\n+\n+        --with-mail)                     MAIL=YES                   ;;\n+        --with-mail=dynamic)             MAIL=DYNAMIC               ;;\n+        --with-mail_ssl_module)          MAIL_SSL=YES               ;;\n+        # STUB\n+        --with-imap)\n+            MAIL=YES\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-imap\\\" option is deprecated, \\\n+use the \\\"--with-mail\\\" option instead\"\n+        ;;\n+        --with-imap_ssl_module)\n+            MAIL_SSL=YES\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-imap_ssl_module\\\" option is deprecated, \\\n+use the \\\"--with-mail_ssl_module\\\" option instead\"\n+        ;;\n+        --without-mail_pop3_module)      MAIL_POP3=NO               ;;\n+        --without-mail_imap_module)      MAIL_IMAP=NO               ;;\n+        --without-mail_smtp_module)      MAIL_SMTP=NO               ;;\n+\n+        --with-stream)                   STREAM=YES                 ;;\n+        --with-stream=dynamic)           STREAM=DYNAMIC             ;;\n+        --with-stream_ssl_module)        STREAM_SSL=YES             ;;\n+        --with-stream_realip_module)     STREAM_REALIP=YES          ;;\n+        --with-stream_geoip_module)      STREAM_GEOIP=YES           ;;\n+        --with-stream_geoip_module=dynamic)\n+                                         STREAM_GEOIP=DYNAMIC       ;;\n+        --with-stream_ssl_preread_module)\n+                                         STREAM_SSL_PREREAD=YES     ;;\n+        --without-stream_limit_conn_module)\n+                                         STREAM_LIMIT_CONN=NO       ;;\n+        --without-stream_access_module)  STREAM_ACCESS=NO           ;;\n+        --without-stream_geo_module)     STREAM_GEO=NO              ;;\n+        --without-stream_map_module)     STREAM_MAP=NO              ;;\n+        --without-stream_split_clients_module)\n+                                         STREAM_SPLIT_CLIENTS=NO    ;;\n+        --without-stream_return_module)  STREAM_RETURN=NO           ;;\n+        --without-stream_upstream_hash_module)\n+                                         STREAM_UPSTREAM_HASH=NO    ;;\n+        --without-stream_upstream_least_conn_module)\n+                                         STREAM_UPSTREAM_LEAST_CONN=NO ;;\n+        --without-stream_upstream_random_module)\n+                                         STREAM_UPSTREAM_RANDOM=NO  ;;\n+        --without-stream_upstream_zone_module)\n+                                         STREAM_UPSTREAM_ZONE=NO    ;;\n+\n+        --with-google_perftools_module)  NGX_GOOGLE_PERFTOOLS=YES   ;;\n+        --with-cpp_test_module)          NGX_CPP_TEST=YES           ;;\n+\n+        --add-module=*)                  NGX_ADDONS=\"$NGX_ADDONS $value\" ;;\n+        --add-dynamic-module=*)          DYNAMIC_ADDONS=\"$DYNAMIC_ADDONS $value\" ;;\n+\n+        --with-compat)                   NGX_COMPAT=YES             ;;\n+\n+        --with-cc=*)                     CC=\"$value\"                ;;\n+        --with-cpp=*)                    CPP=\"$value\"               ;;\n+        --with-cc-opt=*)                 NGX_CC_OPT=\"$value\"        ;;\n+        --with-ld-opt=*)                 NGX_LD_OPT=\"$value\"        ;;\n+        --with-cpu-opt=*)                CPU=\"$value\"               ;;\n+        --with-debug)                    NGX_DEBUG=YES              ;;\n+\n+        --without-pcre)                  USE_PCRE=DISABLED          ;;\n+        --with-pcre)                     USE_PCRE=YES               ;;\n+        --with-pcre=*)                   PCRE=\"$value\"              ;;\n+        --with-pcre-opt=*)               PCRE_OPT=\"$value\"          ;;\n+        --with-pcre-jit)                 PCRE_JIT=YES               ;;\n+\n+        --with-openssl=*)                OPENSSL=\"$value\"           ;;\n+        --with-openssl-opt=*)            OPENSSL_OPT=\"$value\"       ;;\n+\n+        --with-md5=*)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-md5\\\" option is deprecated\"\n+        ;;\n+        --with-md5-opt=*)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-md5-opt\\\" option is deprecated\"\n+        ;;\n+        --with-md5-asm)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-md5-asm\\\" option is deprecated\"\n+        ;;\n+\n+        --with-sha1=*)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-sha1\\\" option is deprecated\"\n+        ;;\n+        --with-sha1-opt=*)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-sha1-opt\\\" option is deprecated\"\n+        ;;\n+        --with-sha1-asm)\n+            NGX_POST_CONF_MSG=\"$NGX_POST_CONF_MSG\n+$0: warning: the \\\"--with-sha1-asm\\\" option is deprecated\"\n+        ;;\n+\n+        --with-zlib=*)                   ZLIB=\"$value\"              ;;\n+        --with-zlib-opt=*)               ZLIB_OPT=\"$value\"          ;;\n+        --with-zlib-asm=*)               ZLIB_ASM=\"$value\"          ;;\n+\n+        --with-libatomic)                NGX_LIBATOMIC=YES          ;;\n+        --with-libatomic=*)              NGX_LIBATOMIC=\"$value\"     ;;\n+\n+        --test-build-devpoll)            NGX_TEST_BUILD_DEVPOLL=YES ;;\n+        --test-build-eventport)          NGX_TEST_BUILD_EVENTPORT=YES ;;\n+        --test-build-epoll)              NGX_TEST_BUILD_EPOLL=YES   ;;\n+        --test-build-solaris-sendfilev)  NGX_TEST_BUILD_SOLARIS_SENDFILEV=YES ;;\n+\n+        *)\n+            echo \"$0: error: invalid option \\\"$option\\\"\"\n+            exit 1\n+        ;;\n+    esac\n+done\n+\n+\n+NGX_CONFIGURE=\"$opt\"\n+\n+\n+if [ $help = yes ]; then\n+\n+cat << END\n+\n+  --help                             print this message\n+\n+  --prefix=PATH                      set installation prefix\n+  --sbin-path=PATH                   set nginx binary pathname\n+  --modules-path=PATH                set modules path\n+  --conf-path=PATH                   set nginx.conf pathname\n+  --error-log-path=PATH              set error log pathname\n+  --pid-path=PATH                    set nginx.pid pathname\n+  --lock-path=PATH                   set nginx.lock pathname\n+\n+  --user=USER                        set non-privileged user for\n+                                     worker processes\n+  --group=GROUP                      set non-privileged group for\n+                                     worker processes\n+\n+  --build=NAME                       set build name\n+  --builddir=DIR                     set build directory\n+\n+  --with-select_module               enable select module\n+  --without-select_module            disable select module\n+  --with-poll_module                 enable poll module\n+  --without-poll_module              disable poll module\n+\n+  --with-threads                     enable thread pool support\n+\n+  --with-file-aio                    enable file AIO support\n+\n+  --with-http_ssl_module             enable ngx_http_ssl_module\n+  --with-http_v2_module              enable ngx_http_v2_module\n+  --with-http_realip_module          enable ngx_http_realip_module\n+  --with-http_addition_module        enable ngx_http_addition_module\n+  --with-http_xslt_module            enable ngx_http_xslt_module\n+  --with-http_xslt_module=dynamic    enable dynamic ngx_http_xslt_module\n+  --with-http_image_filter_module    enable ngx_http_image_filter_module\n+  --with-http_image_filter_module=dynamic\n+                                     enable dynamic ngx_http_image_filter_module\n+  --with-http_geoip_module           enable ngx_http_geoip_module\n+  --with-http_geoip_module=dynamic   enable dynamic ngx_http_geoip_module\n+  --with-http_sub_module             enable ngx_http_sub_module\n+  --with-http_dav_module             enable ngx_http_dav_module\n+  --with-http_flv_module             enable ngx_http_flv_module\n+  --with-http_mp4_module             enable ngx_http_mp4_module\n+  --with-http_gunzip_module          enable ngx_http_gunzip_module\n+  --with-http_gzip_static_module     enable ngx_http_gzip_static_module\n+  --with-http_auth_request_module    enable ngx_http_auth_request_module\n+  --with-http_random_index_module    enable ngx_http_random_index_module\n+  --with-http_secure_link_module     enable ngx_http_secure_link_module\n+  --with-http_degradation_module     enable ngx_http_degradation_module\n+  --with-http_slice_module           enable ngx_http_slice_module\n+  --with-http_stub_status_module     enable ngx_http_stub_status_module\n+\n+  --without-http_charset_module      disable ngx_http_charset_module\n+  --without-http_gzip_module         disable ngx_http_gzip_module\n+  --without-http_ssi_module          disable ngx_http_ssi_module\n+  --without-http_userid_module       disable ngx_http_userid_module\n+  --without-http_access_module       disable ngx_http_access_module\n+  --without-http_auth_basic_module   disable ngx_http_auth_basic_module\n+  --without-http_mirror_module       disable ngx_http_mirror_module\n+  --without-http_autoindex_module    disable ngx_http_autoindex_module\n+  --without-http_geo_module          disable ngx_http_geo_module\n+  --without-http_map_module          disable ngx_http_map_module\n+  --without-http_split_clients_module disable ngx_http_split_clients_module\n+  --without-http_referer_module      disable ngx_http_referer_module\n+  --without-http_rewrite_module      disable ngx_http_rewrite_module\n+  --without-http_proxy_module        disable ngx_http_proxy_module\n+  --without-http_fastcgi_module      disable ngx_http_fastcgi_module\n+  --without-http_uwsgi_module        disable ngx_http_uwsgi_module\n+  --without-http_scgi_module         disable ngx_http_scgi_module\n+  --without-http_grpc_module         disable ngx_http_grpc_module\n+  --without-http_memcached_module    disable ngx_http_memcached_module\n+  --without-http_limit_conn_module   disable ngx_http_limit_conn_module\n+  --without-http_limit_req_module    disable ngx_http_limit_req_module\n+  --without-http_empty_gif_module    disable ngx_http_empty_gif_module\n+  --without-http_browser_module      disable ngx_http_browser_module\n+  --without-http_upstream_hash_module\n+                                     disable ngx_http_upstream_hash_module\n+  --without-http_upstream_ip_hash_module\n+                                     disable ngx_http_upstream_ip_hash_module\n+  --without-http_upstream_least_conn_module\n+                                     disable ngx_http_upstream_least_conn_module\n+  --without-http_upstream_random_module\n+                                     disable ngx_http_upstream_random_module\n+  --without-http_upstream_keepalive_module\n+                                     disable ngx_http_upstream_keepalive_module\n+  --without-http_upstream_zone_module\n+                                     disable ngx_http_upstream_zone_module\n+\n+  --with-http_perl_module            enable ngx_http_perl_module\n+  --with-http_perl_module=dynamic    enable dynamic ngx_http_perl_module\n+  --with-perl_modules_path=PATH      set Perl modules path\n+  --with-perl=PATH                   set perl binary pathname\n+\n+  --http-log-path=PATH               set http access log pathname\n+  --http-client-body-temp-path=PATH  set path to store\n+                                     http client request body temporary files\n+  --http-proxy-temp-path=PATH        set path to store\n+                                     http proxy temporary files\n+  --http-fastcgi-temp-path=PATH      set path to store\n+                                     http fastcgi temporary files\n+  --http-uwsgi-temp-path=PATH        set path to store\n+                                     http uwsgi temporary files\n+  --http-scgi-temp-path=PATH         set path to store\n+                                     http scgi temporary files\n+\n+  --without-http                     disable HTTP server\n+  --without-http-cache               disable HTTP cache\n+\n+  --with-mail                        enable POP3/IMAP4/SMTP proxy module\n+  --with-mail=dynamic                enable dynamic POP3/IMAP4/SMTP proxy module\n+  --with-mail_ssl_module             enable ngx_mail_ssl_module\n+  --without-mail_pop3_module         disable ngx_mail_pop3_module\n+  --without-mail_imap_module         disable ngx_mail_imap_module\n+  --without-mail_smtp_module         disable ngx_mail_smtp_module\n+\n+  --with-stream                      enable TCP/UDP proxy module\n+  --with-stream=dynamic              enable dynamic TCP/UDP proxy module\n+  --with-stream_ssl_module           enable ngx_stream_ssl_module\n+  --with-stream_realip_module        enable ngx_stream_realip_module\n+  --with-stream_geoip_module         enable ngx_stream_geoip_module\n+  --with-stream_geoip_module=dynamic enable dynamic ngx_stream_geoip_module\n+  --with-stream_ssl_preread_module   enable ngx_stream_ssl_preread_module\n+  --without-stream_limit_conn_module disable ngx_stream_limit_conn_module\n+  --without-stream_access_module     disable ngx_stream_access_module\n+  --without-stream_geo_module        disable ngx_stream_geo_module\n+  --without-stream_map_module        disable ngx_stream_map_module\n+  --without-stream_split_clients_module\n+                                     disable ngx_stream_split_clients_module\n+  --without-stream_return_module     disable ngx_stream_return_module\n+  --without-stream_upstream_hash_module\n+                                     disable ngx_stream_upstream_hash_module\n+  --without-stream_upstream_least_conn_module\n+                                     disable ngx_stream_upstream_least_conn_module\n+  --without-stream_upstream_random_module\n+                                     disable ngx_stream_upstream_random_module\n+  --without-stream_upstream_zone_module\n+                                     disable ngx_stream_upstream_zone_module\n+\n+  --with-google_perftools_module     enable ngx_google_perftools_module\n+  --with-cpp_test_module             enable ngx_cpp_test_module\n+\n+  --add-module=PATH                  enable external module\n+  --add-dynamic-module=PATH          enable dynamic external module\n+\n+  --with-compat                      dynamic modules compatibility\n+\n+  --with-cc=PATH                     set C compiler pathname\n+  --with-cpp=PATH                    set C preprocessor pathname\n+  --with-cc-opt=OPTIONS              set additional C compiler options\n+  --with-ld-opt=OPTIONS              set additional linker options\n+  --with-cpu-opt=CPU                 build for the specified CPU, valid values:\n+                                     pentium, pentiumpro, pentium3, pentium4,\n+                                     athlon, opteron, sparc32, sparc64, ppc64\n+\n+  --without-pcre                     disable PCRE library usage\n+  --with-pcre                        force PCRE library usage\n+  --with-pcre=DIR                    set path to PCRE library sources\n+  --with-pcre-opt=OPTIONS            set additional build options for PCRE\n+  --with-pcre-jit                    build PCRE with JIT compilation support\n+\n+  --with-zlib=DIR                    set path to zlib library sources\n+  --with-zlib-opt=OPTIONS            set additional build options for zlib\n+  --with-zlib-asm=CPU                use zlib assembler sources optimized\n+                                     for the specified CPU, valid values:\n+                                     pentium, pentiumpro\n+\n+  --with-libatomic                   force libatomic_ops library usage\n+  --with-libatomic=DIR               set path to libatomic_ops library sources\n+\n+  --with-openssl=DIR                 set path to OpenSSL library sources\n+  --with-openssl-opt=OPTIONS         set additional build options for OpenSSL\n+\n+  --with-debug                       enable debug logging\n+\n+END\n+\n+    exit 1\n+fi\n+\n+\n+if [ \".$NGX_PLATFORM\" = \".win32\" ]; then\n+    NGX_WINE=$WINE\n+fi\n+\n+\n+NGX_SBIN_PATH=${NGX_SBIN_PATH:-sbin/nginx}\n+NGX_MODULES_PATH=${NGX_MODULES_PATH:-modules}\n+NGX_CONF_PATH=${NGX_CONF_PATH:-conf/nginx.conf}\n+NGX_CONF_PREFIX=`dirname $NGX_CONF_PATH`\n+NGX_PID_PATH=${NGX_PID_PATH:-logs/nginx.pid}\n+NGX_LOCK_PATH=${NGX_LOCK_PATH:-logs/nginx.lock}\n+\n+if [ \".$NGX_ERROR_LOG_PATH\" = \".stderr\" ]; then\n+    NGX_ERROR_LOG_PATH=\n+else\n+    NGX_ERROR_LOG_PATH=${NGX_ERROR_LOG_PATH:-logs/error.log}\n+fi\n+\n+NGX_HTTP_LOG_PATH=${NGX_HTTP_LOG_PATH:-logs/access.log}\n+NGX_HTTP_CLIENT_TEMP_PATH=${NGX_HTTP_CLIENT_TEMP_PATH:-client_body_temp}\n+NGX_HTTP_PROXY_TEMP_PATH=${NGX_HTTP_PROXY_TEMP_PATH:-proxy_temp}\n+NGX_HTTP_FASTCGI_TEMP_PATH=${NGX_HTTP_FASTCGI_TEMP_PATH:-fastcgi_temp}\n+NGX_HTTP_UWSGI_TEMP_PATH=${NGX_HTTP_UWSGI_TEMP_PATH:-uwsgi_temp}\n+NGX_HTTP_SCGI_TEMP_PATH=${NGX_HTTP_SCGI_TEMP_PATH:-scgi_temp}\n+\n+case \".$NGX_PERL_MODULES\" in\n+    ./*)\n+    ;;\n+\n+    .)\n+    ;;\n+\n+    *)\n+        NGX_PERL_MODULES=$NGX_PREFIX/$NGX_PERL_MODULES\n+    ;;\n+esac\nDiff:\n@@ -0,0 +1,129 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo \"checking for $NGX_SYSTEM specific features\"\n+\n+case \"$NGX_PLATFORM\" in\n+\n+    FreeBSD:*)\n+        . auto/os/freebsd\n+    ;;\n+\n+    Linux:*)\n+        . auto/os/linux\n+    ;;\n+\n+    SunOS:*)\n+        . auto/os/solaris\n+    ;;\n+\n+    Darwin:*)\n+        . auto/os/darwin\n+    ;;\n+\n+    win32)\n+        . auto/os/win32\n+    ;;\n+\n+    DragonFly:*)\n+        have=NGX_FREEBSD . auto/have_headers\n+        CORE_INCS=\"$UNIX_INCS\"\n+        CORE_DEPS=\"$UNIX_DEPS $FREEBSD_DEPS\"\n+        CORE_SRCS=\"$UNIX_SRCS $FREEBSD_SRCS\"\n+\n+        echo \" + sendfile() found\"\n+        have=NGX_HAVE_SENDFILE . auto/have\n+        CORE_SRCS=\"$CORE_SRCS $FREEBSD_SENDFILE_SRCS\"\n+\n+        ngx_spacer='\n+'\n+    ;;\n+\n+    NetBSD:*)\n+        CORE_INCS=\"$UNIX_INCS\"\n+        CORE_DEPS=\"$UNIX_DEPS $POSIX_DEPS\"\n+        CORE_SRCS=\"$UNIX_SRCS\"\n+\n+        NGX_RPATH=YES\n+    ;;\n+\n+    HP-UX:*)\n+        # HP/UX\n+        have=NGX_HPUX . auto/have_headers\n+        CORE_INCS=\"$UNIX_INCS\"\n+        CORE_DEPS=\"$UNIX_DEPS $POSIX_DEPS\"\n+        CORE_SRCS=\"$UNIX_SRCS\"\n+        CC_AUX_FLAGS=\"$CC_AUX_FLAGS -D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED=1\"\n+        CC_AUX_FLAGS=\"$CC_AUX_FLAGS -D_HPUX_ALT_XOPEN_SOCKET_API\"\n+    ;;\n+\n+    OSF1:*)\n+        # Tru64 UNIX\n+        have=NGX_TRU64 . auto/have_headers\n+        have=NGX_HAVE_STRERROR_R . auto/nohave\n+        CORE_INCS=\"$UNIX_INCS\"\n+        CORE_DEPS=\"$UNIX_DEPS $POSIX_DEPS\"\n+        CORE_SRCS=\"$UNIX_SRCS\"\n+    ;;\n+\n+    GNU:*)\n+        # GNU Hurd\n+        have=NGX_GNU_HURD . auto/have_headers\n+        CORE_INCS=\"$UNIX_INCS\"\n+        CORE_DEPS=\"$UNIX_DEPS $POSIX_DEPS\"\n+        CORE_SRCS=\"$UNIX_SRCS\"\n+        CC_AUX_FLAGS=\"$CC_AUX_FLAGS -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\"\n+    ;;\n+\n+    *)\n+        CORE_INCS=\"$UNIX_INCS\"\n+        CORE_DEPS=\"$UNIX_DEPS $POSIX_DEPS\"\n+        CORE_SRCS=\"$UNIX_SRCS\"\n+    ;;\n+\n+esac\n+\n+\n+case \"$NGX_MACHINE\" in\n+\n+    i386 | i686 | i86pc)\n+        have=NGX_HAVE_NONALIGNED . auto/have\n+        NGX_MACH_CACHE_LINE=32\n+    ;;\n+\n+    amd64 | x86_64)\n+        have=NGX_HAVE_NONALIGNED . auto/have\n+        NGX_MACH_CACHE_LINE=64\n+    ;;\n+\n+    sun4u | sun4v | sparc | sparc64)\n+        have=NGX_ALIGNMENT value=16 . auto/define\n+        # TODO\n+        NGX_MACH_CACHE_LINE=64\n+    ;;\n+\n+    ia64 )\n+        have=NGX_ALIGNMENT value=16 . auto/define\n+        # TODO\n+        NGX_MACH_CACHE_LINE=64\n+    ;;\n+\n+    aarch64 )\n+        have=NGX_ALIGNMENT value=16 . auto/define\n+        NGX_MACH_CACHE_LINE=64\n+    ;;\n+\n+    *)\n+        have=NGX_ALIGNMENT value=16 . auto/define\n+        NGX_MACH_CACHE_LINE=32\n+    ;;\n+\n+esac\n+\n+if test -z \"$NGX_CPU_CACHE_LINE\"; then\n+    NGX_CPU_CACHE_LINE=$NGX_MACH_CACHE_LINE\n+fi\n+\n+have=NGX_CPU_CACHE_LINE value=$NGX_CPU_CACHE_LINE . auto/define\nDiff:\n@@ -0,0 +1,120 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+have=NGX_DARWIN . auto/have_headers\n+\n+CORE_INCS=\"$UNIX_INCS\"\n+CORE_DEPS=\"$UNIX_DEPS $DARWIN_DEPS\"\n+CORE_SRCS=\"$UNIX_SRCS $DARWIN_SRCS\"\n+\n+\n+\n+ngx_spacer='\n+'\n+\n+MAIN_LINK=\n+MODULE_LINK=\"-shared -Wl,-undefined,dynamic_lookup\"\n+\n+CC_AUX_FLAGS=\"$CC_AUX_FLAGS -D__APPLE_USE_RFC_3542\"\n+\n+\n+# kqueue\n+\n+echo \" + kqueue found\"\n+have=NGX_HAVE_KQUEUE . auto/have\n+have=NGX_HAVE_CLEAR_EVENT . auto/have\n+EVENT_MODULES=\"$EVENT_MODULES $KQUEUE_MODULE\"\n+CORE_SRCS=\"$CORE_SRCS $KQUEUE_SRCS\"\n+EVENT_FOUND=YES\n+NGX_KQUEUE_CHECKED=YES\n+\n+ngx_feature=\"kqueue's EVFILT_TIMER\"\n+ngx_feature_name=\"NGX_HAVE_TIMER_EVENT\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/event.h>\n+                  #include <sys/time.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int      kq;\n+                  struct kevent    kev;\n+                  struct timespec  ts;\n+\n+                  if ((kq = kqueue()) == -1) return 1;\n+\n+                  kev.ident = 0;\n+                  kev.filter = EVFILT_TIMER;\n+                  kev.flags = EV_ADD|EV_ENABLE;\n+                  kev.fflags = 0;\n+                  kev.data = 1000;\n+                  kev.udata = 0;\n+\n+                  ts.tv_sec = 0;\n+                  ts.tv_nsec = 0;\n+\n+                  if (kevent(kq, &kev, 1, &kev, 1, &ts) == -1) return 1;\n+\n+                  if (kev.flags & EV_ERROR) return 1;\"\n+\n+. auto/feature\n+\n+\n+ngx_feature=\"Darwin 64-bit kqueue millisecond timeout bug\"\n+ngx_feature_name=NGX_DARWIN_KEVENT_BUG\n+ngx_feature_run=bug\n+ngx_feature_incs=\"#include <sys/event.h>\n+                  #include <sys/time.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int  kq;\n+                  struct kevent    kev;\n+                  struct timespec  ts;\n+                  struct timeval   tv, tv0;\n+\n+                  kq = kqueue();\n+\n+                  ts.tv_sec = 0;\n+                  ts.tv_nsec = 999000000;\n+\n+                  gettimeofday(&tv, 0);\n+                  kevent(kq, NULL, 0, &kev, 1, &ts);\n+                  gettimeofday(&tv0, 0);\n+                  timersub(&tv0, &tv, &tv);\n+\n+                  if (tv.tv_sec * 1000000 + tv.tv_usec < 900000) return 1;\"\n+\n+. auto/feature\n+\n+\n+# sendfile()\n+\n+ngx_feature=\"sendfile()\"\n+ngx_feature_name=\"NGX_HAVE_SENDFILE\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/types.h>\n+                  #include <sys/socket.h>\n+                  #include <sys/uio.h>\n+                  #include <sys/errno.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int s = 0, fd = 1;\n+                  off_t n; off_t off = 0;\n+                  n = sendfile(s, fd, off, &n, NULL, 0);\n+                  if (n == -1 && errno == ENOSYS) return 1\"\n+. auto/feature\n+\n+if [ $ngx_found = yes ]; then\n+    CORE_SRCS=\"$CORE_SRCS $DARWIN_SENDFILE_SRCS\"\n+fi\n+\n+\n+ngx_feature=\"atomic(3)\"\n+ngx_feature_name=NGX_DARWIN_ATOMIC\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <libkern/OSAtomic.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int32_t  lock = 0;\n+                  if (!OSAtomicCompareAndSwap32Barrier(0, 1, &lock)) return 1\"\n+. auto/feature\nDiff:\n@@ -0,0 +1,107 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+have=NGX_FREEBSD . auto/have_headers\n+\n+CORE_INCS=\"$UNIX_INCS\"\n+CORE_DEPS=\"$UNIX_DEPS $FREEBSD_DEPS\"\n+CORE_SRCS=\"$UNIX_SRCS $FREEBSD_SRCS\"\n+\n+ngx_spacer='\n+'\n+\n+\n+# __FreeBSD_version and sysctl kern.osreldate are the best ways\n+# to determine whether some capability exists and is safe to use.\n+# __FreeBSD_version is used for the testing of the build environment.\n+# sysctl kern.osreldate is used for the testing of the kernel capabilities.\n+\n+version=`grep \"#define __FreeBSD_version\" /usr/include/osreldate.h \\\n+         | sed -e 's/^.* \\(.*\\)$/\\1/'`\n+\n+osreldate=`/sbin/sysctl -n kern.osreldate`\n+\n+\n+# setproctitle() in libutil\n+\n+if [ \\( $version -ge 500000 -a $version -lt 500012 \\) \\\n+     -o $version -lt 410002 ]\n+then\n+    echo \" + setproctitle() in libutil\"\n+\n+    CORE_LIBS=\"$CORE_LIBS -lutil\"\n+    NGX_SETPROCTITLE_LIB=\"-lutil\"\n+fi\n+\n+# sendfile\n+\n+if [ $osreldate -gt 300007 ]; then\n+    echo \" + sendfile() found\"\n+\n+    have=NGX_HAVE_SENDFILE . auto/have\n+    CORE_SRCS=\"$CORE_SRCS $FREEBSD_SENDFILE_SRCS\"\n+fi\n+\n+if [ $NGX_FILE_AIO = YES ]; then\n+    if [ $osreldate -gt 502103 ]; then\n+        echo \" + sendfile()'s SF_NODISKIO found\"\n+\n+        have=NGX_HAVE_AIO_SENDFILE . auto/have\n+    fi\n+fi\n+\n+# POSIX semaphores\n+# http://www.freebsd.org/cgi/query-pr.cgi?pr=kern/127545\n+\n+if [ $osreldate -ge 701106 ]; then\n+    echo \" + POSIX semaphores should work\"\n+else\n+    have=NGX_HAVE_POSIX_SEM . auto/nohave\n+fi\n+\n+\n+# kqueue\n+\n+if [ \\( $osreldate -lt 500000 -a $osreldate -ge 410000 \\) \\\n+     -o $osreldate -ge 500011 ]\n+then\n+    echo \" + kqueue found\"\n+\n+    have=NGX_HAVE_KQUEUE . auto/have\n+    have=NGX_HAVE_CLEAR_EVENT . auto/have\n+    EVENT_MODULES=\"$EVENT_MODULES $KQUEUE_MODULE\"\n+    CORE_SRCS=\"$CORE_SRCS $KQUEUE_SRCS\"\n+    EVENT_FOUND=YES\n+fi\n+\n+\n+NGX_KQUEUE_CHECKED=YES\n+\n+\n+# kqueue's NOTE_LOWAT\n+\n+if [ \\( $version -lt 500000 -a $version -ge 430000 \\) \\\n+     -o $version -ge 500018 ]\n+then\n+    echo \" + kqueue's NOTE_LOWAT found\"\n+    have=NGX_HAVE_LOWAT_EVENT . auto/have\n+fi\n+\n+# kqueue's EVFILT_TIMER\n+\n+if [ \\( $version -lt 500000 -a $version -ge 440001 \\) \\\n+     -o $version -ge 500023 ]\n+then\n+    echo \" + kqueue's EVFILT_TIMER found\"\n+    have=NGX_HAVE_TIMER_EVENT . auto/have\n+fi\n+\n+\n+# cpuset_setaffinity()\n+\n+if [ $version -ge 701000 ]; then\n+    echo \" + cpuset_setaffinity() found\"\n+    have=NGX_HAVE_CPUSET_SETAFFINITY . auto/have\n+fi\nDiff:\n@@ -0,0 +1,210 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+have=NGX_LINUX . auto/have_headers\n+\n+CORE_INCS=\"$UNIX_INCS\"\n+CORE_DEPS=\"$UNIX_DEPS $LINUX_DEPS\"\n+CORE_SRCS=\"$UNIX_SRCS $LINUX_SRCS\"\n+\n+ngx_spacer='\n+'\n+\n+cc_aux_flags=\"$CC_AUX_FLAGS\"\n+CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\"\n+\n+\n+# Linux kernel version\n+\n+version=$((`uname -r \\\n+    | sed -n -e 's/^\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/ \\\n+                                                 \\1*256*256+\\2*256+\\3/p' \\\n+             -e 's/^\\([0-9][0-9]*\\)\\.\\([0-9][0-9]*\\).*/\\1*256*256+\\2*256/p'`))\n+\n+version=${version:-0}\n+\n+\n+# posix_fadvise64() had been implemented in 2.5.60\n+\n+if [ $version -lt 132412 ]; then\n+    have=NGX_HAVE_POSIX_FADVISE . auto/nohave\n+fi\n+\n+# epoll, EPOLLET version\n+\n+ngx_feature=\"epoll\"\n+ngx_feature_name=\"NGX_HAVE_EPOLL\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/epoll.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int efd = 0;\n+                  struct epoll_event ee;\n+                  ee.events = EPOLLIN|EPOLLOUT|EPOLLET;\n+                  ee.data.ptr = NULL;\n+                  (void) ee;\n+                  efd = epoll_create(100);\n+                  if (efd == -1) return 1;\"\n+. auto/feature\n+\n+if [ $ngx_found = yes ]; then\n+    have=NGX_HAVE_CLEAR_EVENT . auto/have\n+    CORE_SRCS=\"$CORE_SRCS $EPOLL_SRCS\"\n+    EVENT_MODULES=\"$EVENT_MODULES $EPOLL_MODULE\"\n+    EVENT_FOUND=YES\n+\n+\n+    # EPOLLRDHUP appeared in Linux 2.6.17, glibc 2.8\n+\n+    ngx_feature=\"EPOLLRDHUP\"\n+    ngx_feature_name=\"NGX_HAVE_EPOLLRDHUP\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <sys/epoll.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"int efd = 0, fd = 0;\n+                      struct epoll_event ee;\n+                      ee.events = EPOLLIN|EPOLLRDHUP|EPOLLET;\n+                      ee.data.ptr = NULL;\n+                      epoll_ctl(efd, EPOLL_CTL_ADD, fd, &ee)\"\n+    . auto/feature\n+\n+\n+    # EPOLLEXCLUSIVE appeared in Linux 4.5, glibc 2.24\n+\n+    ngx_feature=\"EPOLLEXCLUSIVE\"\n+    ngx_feature_name=\"NGX_HAVE_EPOLLEXCLUSIVE\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <sys/epoll.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"int efd = 0, fd = 0;\n+                      struct epoll_event ee;\n+                      ee.events = EPOLLIN|EPOLLEXCLUSIVE;\n+                      ee.data.ptr = NULL;\n+                      epoll_ctl(efd, EPOLL_CTL_ADD, fd, &ee)\"\n+    . auto/feature\n+fi\n+\n+\n+# O_PATH and AT_EMPTY_PATH were introduced in 2.6.39, glibc 2.14\n+\n+ngx_feature=\"O_PATH\"\n+ngx_feature_name=\"NGX_HAVE_O_PATH\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/types.h>\n+                  #include <sys/stat.h>\n+                  #include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int fd; struct stat sb;\n+                  fd = openat(AT_FDCWD, \\\".\\\", O_PATH|O_DIRECTORY|O_NOFOLLOW);\n+                  if (fstatat(fd, \\\"\\\", &sb, AT_EMPTY_PATH) != 0) return 1\"\n+. auto/feature\n+\n+\n+# sendfile()\n+\n+CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE\"\n+ngx_feature=\"sendfile()\"\n+ngx_feature_name=\"NGX_HAVE_SENDFILE\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/sendfile.h>\n+                  #include <errno.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int s = 0, fd = 1;\n+                  ssize_t n; off_t off = 0;\n+                  n = sendfile(s, fd, &off, 1);\n+                  if (n == -1 && errno == ENOSYS) return 1\"\n+. auto/feature\n+\n+if [ $ngx_found = yes ]; then\n+    CORE_SRCS=\"$CORE_SRCS $LINUX_SENDFILE_SRCS\"\n+fi\n+\n+\n+# sendfile64()\n+\n+CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\"\n+ngx_feature=\"sendfile64()\"\n+ngx_feature_name=\"NGX_HAVE_SENDFILE64\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/sendfile.h>\n+                  #include <errno.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int s = 0, fd = 1;\n+                  ssize_t n; off_t off = 0;\n+                  n = sendfile(s, fd, &off, 1);\n+                  if (n == -1 && errno == ENOSYS) return 1\"\n+. auto/feature\n+\n+\n+ngx_include=\"sys/prctl.h\"; . auto/include\n+\n+# prctl(PR_SET_DUMPABLE)\n+\n+ngx_feature=\"prctl(PR_SET_DUMPABLE)\"\n+ngx_feature_name=\"NGX_HAVE_PR_SET_DUMPABLE\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/prctl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) return 1\"\n+. auto/feature\n+\n+\n+# prctl(PR_SET_KEEPCAPS)\n+\n+ngx_feature=\"prctl(PR_SET_KEEPCAPS)\"\n+ngx_feature_name=\"NGX_HAVE_PR_SET_KEEPCAPS\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/prctl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"if (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1) return 1\"\n+. auto/feature\n+\n+\n+# capabilities\n+\n+ngx_feature=\"capabilities\"\n+ngx_feature_name=\"NGX_HAVE_CAPABILITIES\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <linux/capability.h>\n+                  #include <sys/syscall.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct __user_cap_data_struct    data;\n+                  struct __user_cap_header_struct  header;\n+\n+                  header.version = _LINUX_CAPABILITY_VERSION_1;\n+                  data.effective = CAP_TO_MASK(CAP_NET_RAW);\n+                  data.permitted = 0;\n+\n+                  (void) header;\n+                  (void) data;\n+                  (void) SYS_capset\"\n+. auto/feature\n+\n+\n+# crypt_r()\n+\n+ngx_feature=\"crypt_r()\"\n+ngx_feature_name=\"NGX_HAVE_GNU_CRYPT_R\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <crypt.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=-lcrypt\n+ngx_feature_test=\"struct crypt_data  cd;\n+                  crypt_r(\\\"key\\\", \\\"salt\\\", &cd);\"\n+. auto/feature\n+\n+\n+ngx_include=\"sys/vfs.h\";     . auto/include\n+\n+\n+CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\"\nDiff:\n@@ -0,0 +1,61 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+have=NGX_SOLARIS . auto/have_headers\n+\n+CORE_INCS=\"$UNIX_INCS\"\n+CORE_DEPS=\"$UNIX_DEPS $SOLARIS_DEPS\"\n+CORE_SRCS=\"$UNIX_SRCS $SOLARIS_SRCS \"\n+CORE_LIBS=\"$CORE_LIBS -lsocket -lnsl\"\n+\n+NGX_RPATH=YES\n+\n+# Solaris's make does not support a blank line between target and rules\n+ngx_spacer=\n+\n+CC_AUX_FLAGS=\"$CC_AUX_FLAGS -D_FILE_OFFSET_BITS=64 -lsocket -lnsl\"\n+\n+\n+if [ $ZLIB_ASM != NO ]; then\n+    echo \"$0: error: the --with-zlib-asm=CPU option is not supported\"\n+    echo \"on that platform\"\n+    echo\n+\n+    exit 1\n+fi\n+\n+\n+ngx_feature=\"sendfilev()\"\n+ngx_feature_name=\"NGX_HAVE_SENDFILE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/sendfile.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\"-lsendfile\"\n+ngx_feature_test=\"int fd = 1; sendfilevec_t vec[1];\n+                  size_t sent; ssize_t n;\n+                  n = sendfilev(fd, vec, 1, &sent);\n+                  if (n == -1) return 1\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = yes ]; then\n+    CORE_SRCS=\"$CORE_SRCS $SOLARIS_SENDFILEV_SRCS\"\n+    CORE_LIBS=\"$CORE_LIBS -lsendfile\"\n+fi\n+\n+\n+ngx_feature=\"event ports\"\n+ngx_feature_name=\"NGX_HAVE_EVENTPORT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <port.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"(void) port_create()\"\n+. auto/feature\n+\n+if [ $ngx_found = yes ]; then\n+    CORE_SRCS=\"$CORE_SRCS $EVENTPORT_SRCS\"\n+    EVENT_MODULES=\"$EVENT_MODULES $EVENTPORT_MODULE\"\n+fi\nDiff:\n@@ -0,0 +1,39 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+have=NGX_WIN32 . auto/have_headers\n+\n+CORE_INCS=\"$WIN32_INCS\"\n+CORE_DEPS=\"$WIN32_DEPS\"\n+CORE_SRCS=\"$WIN32_SRCS $IOCP_SRCS\"\n+OS_CONFIG=\"$WIN32_CONFIG\"\n+NGX_ICONS=\"$NGX_WIN32_ICONS\"\n+SELECT_SRCS=$WIN32_SELECT_SRCS\n+POLL_SRCS=$WIN32_POLL_SRCS\n+\n+ngx_pic_opt=\n+ngx_binext=\".exe\"\n+\n+case \"$NGX_CC_NAME\" in\n+\n+    gcc)\n+        CORE_LIBS=\"$CORE_LIBS -ladvapi32 -lws2_32\"\n+        MAIN_LINK=\"$MAIN_LINK -Wl,--export-all-symbols\"\n+        MAIN_LINK=\"$MAIN_LINK -Wl,--out-implib=$NGX_OBJS/libnginx.a\"\n+        MODULE_LINK=\"-shared -L $NGX_OBJS -lnginx\"\n+    ;;\n+\n+    *)\n+        CORE_LIBS=\"$CORE_LIBS advapi32.lib ws2_32.lib\"\n+    ;;\n+\n+esac\n+\n+EVENT_MODULES=\"$EVENT_MODULES $IOCP_MODULE\"\n+#EVENT_FOUND=YES\n+\n+have=NGX_HAVE_INET6 . auto/have\n+\n+have=NGX_HAVE_IOCP . auto/have\nDiff:\n@@ -0,0 +1,257 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+CORE_MODULES=\"ngx_core_module ngx_errlog_module ngx_conf_module\"\n+\n+CORE_INCS=\"src/core\"\n+\n+CORE_DEPS=\"src/core/nginx.h \\\n+           src/core/ngx_config.h \\\n+           src/core/ngx_core.h \\\n+           src/core/ngx_log.h \\\n+           src/core/ngx_palloc.h \\\n+           src/core/ngx_array.h \\\n+           src/core/ngx_list.h \\\n+           src/core/ngx_hash.h \\\n+           src/core/ngx_buf.h \\\n+           src/core/ngx_queue.h \\\n+           src/core/ngx_string.h \\\n+           src/core/ngx_parse.h \\\n+           src/core/ngx_parse_time.h \\\n+           src/core/ngx_inet.h \\\n+           src/core/ngx_file.h \\\n+           src/core/ngx_crc.h \\\n+           src/core/ngx_crc32.h \\\n+           src/core/ngx_murmurhash.h \\\n+           src/core/ngx_md5.h \\\n+           src/core/ngx_sha1.h \\\n+           src/core/ngx_rbtree.h \\\n+           src/core/ngx_radix_tree.h \\\n+           src/core/ngx_rwlock.h \\\n+           src/core/ngx_slab.h \\\n+           src/core/ngx_times.h \\\n+           src/core/ngx_shmtx.h \\\n+           src/core/ngx_connection.h \\\n+           src/core/ngx_cycle.h \\\n+           src/core/ngx_conf_file.h \\\n+           src/core/ngx_module.h \\\n+           src/core/ngx_resolver.h \\\n+           src/core/ngx_open_file_cache.h \\\n+           src/core/ngx_crypt.h \\\n+           src/core/ngx_proxy_protocol.h \\\n+           src/core/ngx_syslog.h\"\n+\n+\n+CORE_SRCS=\"src/core/nginx.c \\\n+           src/core/ngx_log.c \\\n+           src/core/ngx_palloc.c \\\n+           src/core/ngx_array.c \\\n+           src/core/ngx_list.c \\\n+           src/core/ngx_hash.c \\\n+           src/core/ngx_buf.c \\\n+           src/core/ngx_queue.c \\\n+           src/core/ngx_output_chain.c \\\n+           src/core/ngx_string.c \\\n+           src/core/ngx_parse.c \\\n+           src/core/ngx_parse_time.c \\\n+           src/core/ngx_inet.c \\\n+           src/core/ngx_file.c \\\n+           src/core/ngx_crc32.c \\\n+           src/core/ngx_murmurhash.c \\\n+           src/core/ngx_md5.c \\\n+           src/core/ngx_sha1.c \\\n+           src/core/ngx_rbtree.c \\\n+           src/core/ngx_radix_tree.c \\\n+           src/core/ngx_slab.c \\\n+           src/core/ngx_times.c \\\n+           src/core/ngx_shmtx.c \\\n+           src/core/ngx_connection.c \\\n+           src/core/ngx_cycle.c \\\n+           src/core/ngx_spinlock.c \\\n+           src/core/ngx_rwlock.c \\\n+           src/core/ngx_cpuinfo.c \\\n+           src/core/ngx_conf_file.c \\\n+           src/core/ngx_module.c \\\n+           src/core/ngx_resolver.c \\\n+           src/core/ngx_open_file_cache.c \\\n+           src/core/ngx_crypt.c \\\n+           src/core/ngx_proxy_protocol.c \\\n+           src/core/ngx_syslog.c\"\n+\n+\n+EVENT_MODULES=\"ngx_events_module ngx_event_core_module\"\n+\n+EVENT_INCS=\"src/event src/event/modules\"\n+\n+EVENT_DEPS=\"src/event/ngx_event.h \\\n+            src/event/ngx_event_timer.h \\\n+            src/event/ngx_event_posted.h \\\n+            src/event/ngx_event_connect.h \\\n+            src/event/ngx_event_pipe.h\"\n+\n+EVENT_SRCS=\"src/event/ngx_event.c \\\n+            src/event/ngx_event_timer.c \\\n+            src/event/ngx_event_posted.c \\\n+            src/event/ngx_event_accept.c \\\n+            src/event/ngx_event_udp.c \\\n+            src/event/ngx_event_connect.c \\\n+            src/event/ngx_event_pipe.c\"\n+\n+\n+SELECT_MODULE=ngx_select_module\n+SELECT_SRCS=src/event/modules/ngx_select_module.c\n+WIN32_SELECT_SRCS=src/event/modules/ngx_win32_select_module.c\n+\n+POLL_MODULE=ngx_poll_module\n+POLL_SRCS=src/event/modules/ngx_poll_module.c\n+WIN32_POLL_SRCS=src/event/modules/ngx_win32_poll_module.c\n+\n+KQUEUE_MODULE=ngx_kqueue_module\n+KQUEUE_SRCS=src/event/modules/ngx_kqueue_module.c\n+\n+DEVPOLL_MODULE=ngx_devpoll_module\n+DEVPOLL_SRCS=src/event/modules/ngx_devpoll_module.c\n+\n+EVENTPORT_MODULE=ngx_eventport_module\n+EVENTPORT_SRCS=src/event/modules/ngx_eventport_module.c\n+\n+EPOLL_MODULE=ngx_epoll_module\n+EPOLL_SRCS=src/event/modules/ngx_epoll_module.c\n+\n+IOCP_MODULE=ngx_iocp_module\n+IOCP_SRCS=src/event/modules/ngx_iocp_module.c\n+\n+FILE_AIO_SRCS=\"src/os/unix/ngx_file_aio_read.c\"\n+LINUX_AIO_SRCS=\"src/os/unix/ngx_linux_aio_read.c\"\n+\n+UNIX_INCS=\"$CORE_INCS $EVENT_INCS src/os/unix\"\n+\n+UNIX_DEPS=\"$CORE_DEPS $EVENT_DEPS \\\n+            src/os/unix/ngx_time.h \\\n+            src/os/unix/ngx_errno.h \\\n+            src/os/unix/ngx_alloc.h \\\n+            src/os/unix/ngx_files.h \\\n+            src/os/unix/ngx_channel.h \\\n+            src/os/unix/ngx_shmem.h \\\n+            src/os/unix/ngx_process.h \\\n+            src/os/unix/ngx_setaffinity.h \\\n+            src/os/unix/ngx_setproctitle.h \\\n+            src/os/unix/ngx_atomic.h \\\n+            src/os/unix/ngx_gcc_atomic_x86.h \\\n+            src/os/unix/ngx_thread.h \\\n+            src/os/unix/ngx_socket.h \\\n+            src/os/unix/ngx_os.h \\\n+            src/os/unix/ngx_user.h \\\n+            src/os/unix/ngx_dlopen.h \\\n+            src/os/unix/ngx_process_cycle.h\"\n+\n+# add to UNIX_DEPS\n+#            src/os/unix/ngx_gcc_atomic_amd64.h \\\n+#            src/os/unix/ngx_gcc_atomic_sparc64.h \\\n+#            src/os/unix/ngx_gcc_atomic_ppc.h \\\n+#            src/os/unix/ngx_sunpro_atomic_sparc64.h \\\n+#            src/os/unix/ngx_sunpro_x86.il \\\n+#            src/os/unix/ngx_sunpro_amd64.il \\\n+#            src/os/unix/ngx_sunpro_sparc64.il \\\n+\n+\n+UNIX_SRCS=\"$CORE_SRCS $EVENT_SRCS \\\n+            src/os/unix/ngx_time.c \\\n+            src/os/unix/ngx_errno.c \\\n+            src/os/unix/ngx_alloc.c \\\n+            src/os/unix/ngx_files.c \\\n+            src/os/unix/ngx_socket.c \\\n+            src/os/unix/ngx_recv.c \\\n+            src/os/unix/ngx_readv_chain.c \\\n+            src/os/unix/ngx_udp_recv.c \\\n+            src/os/unix/ngx_send.c \\\n+            src/os/unix/ngx_writev_chain.c \\\n+            src/os/unix/ngx_udp_send.c \\\n+            src/os/unix/ngx_udp_sendmsg_chain.c \\\n+            src/os/unix/ngx_channel.c \\\n+            src/os/unix/ngx_shmem.c \\\n+            src/os/unix/ngx_process.c \\\n+            src/os/unix/ngx_daemon.c \\\n+            src/os/unix/ngx_setaffinity.c \\\n+            src/os/unix/ngx_setproctitle.c \\\n+            src/os/unix/ngx_posix_init.c \\\n+            src/os/unix/ngx_user.c \\\n+            src/os/unix/ngx_dlopen.c \\\n+            src/os/unix/ngx_process_cycle.c\"\n+\n+POSIX_DEPS=src/os/unix/ngx_posix_config.h\n+\n+THREAD_POOL_MODULE=ngx_thread_pool_module\n+THREAD_POOL_DEPS=src/core/ngx_thread_pool.h\n+THREAD_POOL_SRCS=\"src/core/ngx_thread_pool.c\n+                  src/os/unix/ngx_thread_cond.c\n+                  src/os/unix/ngx_thread_mutex.c\n+                  src/os/unix/ngx_thread_id.c\"\n+\n+FREEBSD_DEPS=\"src/os/unix/ngx_freebsd_config.h src/os/unix/ngx_freebsd.h\"\n+FREEBSD_SRCS=src/os/unix/ngx_freebsd_init.c\n+FREEBSD_SENDFILE_SRCS=src/os/unix/ngx_freebsd_sendfile_chain.c\n+\n+LINUX_DEPS=\"src/os/unix/ngx_linux_config.h src/os/unix/ngx_linux.h\"\n+LINUX_SRCS=src/os/unix/ngx_linux_init.c\n+LINUX_SENDFILE_SRCS=src/os/unix/ngx_linux_sendfile_chain.c\n+\n+\n+SOLARIS_DEPS=\"src/os/unix/ngx_solaris_config.h src/os/unix/ngx_solaris.h\"\n+SOLARIS_SRCS=src/os/unix/ngx_solaris_init.c\n+SOLARIS_SENDFILEV_SRCS=src/os/unix/ngx_solaris_sendfilev_chain.c\n+\n+\n+DARWIN_DEPS=\"src/os/unix/ngx_darwin_config.h src/os/unix/ngx_darwin.h\"\n+DARWIN_SRCS=src/os/unix/ngx_darwin_init.c\n+DARWIN_SENDFILE_SRCS=src/os/unix/ngx_darwin_sendfile_chain.c\n+\n+\n+WIN32_INCS=\"$CORE_INCS $EVENT_INCS src/os/win32\"\n+\n+WIN32_DEPS=\"$CORE_DEPS $EVENT_DEPS \\\n+            src/os/win32/ngx_win32_config.h \\\n+            src/os/win32/ngx_time.h \\\n+            src/os/win32/ngx_errno.h \\\n+            src/os/win32/ngx_alloc.h \\\n+            src/os/win32/ngx_files.h \\\n+            src/os/win32/ngx_shmem.h \\\n+            src/os/win32/ngx_process.h \\\n+            src/os/win32/ngx_atomic.h \\\n+            src/os/win32/ngx_thread.h \\\n+            src/os/win32/ngx_socket.h \\\n+            src/os/win32/ngx_os.h \\\n+            src/os/win32/ngx_user.h \\\n+            src/os/win32/ngx_dlopen.h \\\n+            src/os/win32/ngx_process_cycle.h\"\n+\n+WIN32_CONFIG=src/os/win32/ngx_win32_config.h\n+\n+WIN32_SRCS=\"$CORE_SRCS $EVENT_SRCS \\\n+            src/os/win32/ngx_errno.c \\\n+            src/os/win32/ngx_alloc.c \\\n+            src/os/win32/ngx_files.c \\\n+            src/os/win32/ngx_shmem.c \\\n+            src/os/win32/ngx_time.c \\\n+            src/os/win32/ngx_process.c \\\n+            src/os/win32/ngx_thread.c \\\n+            src/os/win32/ngx_socket.c \\\n+            src/os/win32/ngx_wsarecv.c \\\n+            src/os/win32/ngx_wsarecv_chain.c \\\n+            src/os/win32/ngx_udp_wsarecv.c \\\n+            src/os/win32/ngx_wsasend.c \\\n+            src/os/win32/ngx_wsasend_chain.c \\\n+            src/os/win32/ngx_win32_init.c \\\n+            src/os/win32/ngx_user.c \\\n+            src/os/win32/ngx_dlopen.c \\\n+            src/os/win32/ngx_event_log.c \\\n+            src/os/win32/ngx_process_cycle.c \\\n+            src/event/ngx_event_acceptex.c\"\n+\n+NGX_WIN32_ICONS=\"src/os/win32/nginx.ico\"\n+NGX_WIN32_RC=\"src/os/win32/nginx.rc\"\n+\n+\n+HTTP_FILE_CACHE_SRCS=src/http/ngx_http_file_cache.c\nDiff:\n@@ -0,0 +1,8 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+have=NGX_SUPPRESS_WARN . auto/have\n+\n+have=NGX_SMP . auto/have\nDiff:\n@@ -0,0 +1,82 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo\n+echo \"Configuration summary\"\n+\n+\n+if [ $USE_THREADS = YES ]; then\n+    echo \"  + using threads\"\n+fi\n+\n+if [ $USE_PCRE = DISABLED ]; then\n+    echo \"  + PCRE library is disabled\"\n+\n+else\n+    case $PCRE in\n+        YES)   echo \"  + using system PCRE library\" ;;\n+        NONE)  echo \"  + PCRE library is not used\" ;;\n+        *)     echo \"  + using PCRE library: $PCRE\" ;;\n+    esac\n+fi\n+\n+case $OPENSSL in\n+    YES)   echo \"  + using system OpenSSL library\" ;;\n+    NONE)  echo \"  + OpenSSL library is not used\" ;;\n+    *)     echo \"  + using OpenSSL library: $OPENSSL\" ;;\n+esac\n+\n+case $ZLIB in\n+    YES)   echo \"  + using system zlib library\" ;;\n+    NONE)  echo \"  + zlib library is not used\" ;;\n+    *)     echo \"  + using zlib library: $ZLIB\" ;;\n+esac\n+\n+case $NGX_LIBATOMIC in\n+    YES)   echo \"  + using system libatomic_ops library\" ;;\n+    NO)    ;; # not used\n+    *)     echo \"  + using libatomic_ops library: $NGX_LIBATOMIC\" ;;\n+esac\n+\n+echo\n+\n+\n+cat << END\n+  nginx path prefix: \"$NGX_PREFIX\"\n+  nginx binary file: \"$NGX_SBIN_PATH\"\n+  nginx modules path: \"$NGX_MODULES_PATH\"\n+  nginx configuration prefix: \"$NGX_CONF_PREFIX\"\n+  nginx configuration file: \"$NGX_CONF_PATH\"\n+  nginx pid file: \"$NGX_PID_PATH\"\n+END\n+\n+if test -n \"$NGX_ERROR_LOG_PATH\"; then\n+    echo \"  nginx error log file: \\\"$NGX_ERROR_LOG_PATH\\\"\"\n+else\n+    echo \"  nginx logs errors to stderr\"\n+fi\n+\n+cat << END\n+  nginx http access log file: \"$NGX_HTTP_LOG_PATH\"\n+  nginx http client request body temporary files: \"$NGX_HTTP_CLIENT_TEMP_PATH\"\n+END\n+\n+if [ $HTTP_PROXY = YES ]; then\n+    echo \"  nginx http proxy temporary files: \\\"$NGX_HTTP_PROXY_TEMP_PATH\\\"\"\n+fi\n+\n+if [ $HTTP_FASTCGI = YES ]; then\n+    echo \"  nginx http fastcgi temporary files: \\\"$NGX_HTTP_FASTCGI_TEMP_PATH\\\"\"\n+fi\n+\n+if [ $HTTP_UWSGI = YES ]; then\n+    echo \"  nginx http uwsgi temporary files: \\\"$NGX_HTTP_UWSGI_TEMP_PATH\\\"\"\n+fi\n+\n+if [ $HTTP_SCGI = YES ]; then\n+    echo \"  nginx http scgi temporary files: \\\"$NGX_HTTP_SCGI_TEMP_PATH\\\"\"\n+fi\n+\n+echo \"$NGX_POST_CONF_MSG\"\nDiff:\n@@ -0,0 +1,21 @@\n+\n+# Copyright (C) Nginx, Inc.\n+\n+\n+if [ $USE_THREADS = YES ]; then\n+\n+    if [ \"$NGX_PLATFORM\" = win32 ]; then\n+        cat << END\n+\n+$0: --with-threads is not supported on Windows\n+\n+END\n+        exit 1\n+    fi\n+\n+    have=NGX_THREADS . auto/have\n+    CORE_DEPS=\"$CORE_DEPS $THREAD_POOL_DEPS\"\n+    CORE_SRCS=\"$CORE_SRCS $THREAD_POOL_SRCS\"\n+    CORE_LIBS=\"$CORE_LIBS -lpthread\"\n+    NGX_LIBPTHREAD=\"-lpthread\"\n+fi\nDiff:\n@@ -0,0 +1,76 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo $ngx_n \"checking for $ngx_type size ...$ngx_c\"\n+\n+cat << END >> $NGX_AUTOCONF_ERR\n+\n+----------------------------------------\n+checking for $ngx_type size\n+\n+END\n+\n+ngx_size=\n+\n+cat << END > $NGX_AUTOTEST.c\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+$NGX_INCLUDE_UNISTD_H\n+#include <signal.h>\n+#include <stdio.h>\n+#include <sys/resource.h>\n+$NGX_INCLUDE_INTTYPES_H\n+$NGX_INCLUDE_AUTO_CONFIG_H\n+\n+int main(void) {\n+    printf(\"%d\", (int) sizeof($ngx_type));\n+    return 0;\n+}\n+\n+END\n+\n+\n+ngx_test=\"$CC $CC_TEST_FLAGS $CC_AUX_FLAGS \\\n+          -o $NGX_AUTOTEST $NGX_AUTOTEST.c $NGX_LD_OPT $ngx_feature_libs\"\n+\n+eval \"$ngx_test >> $NGX_AUTOCONF_ERR 2>&1\"\n+\n+\n+if [ -x $NGX_AUTOTEST ]; then\n+    ngx_size=`$NGX_AUTOTEST`\n+    echo \" $ngx_size bytes\"\n+fi\n+\n+\n+case $ngx_size in\n+    4)\n+        ngx_max_value=2147483647\n+        ngx_max_len='(sizeof(\"-2147483648\") - 1)'\n+    ;;\n+\n+    8)\n+        ngx_max_value=9223372036854775807LL\n+        ngx_max_len='(sizeof(\"-9223372036854775808\") - 1)'\n+    ;;\n+\n+    *)\n+        echo\n+        echo \"$0: error: can not detect $ngx_type size\"\n+\n+        echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+        cat $NGX_AUTOTEST.c  >> $NGX_AUTOCONF_ERR\n+        echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+        echo $ngx_test       >> $NGX_AUTOCONF_ERR\n+        echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+\n+        rm -rf $NGX_AUTOTEST*\n+\n+        exit 1\n+esac\n+\n+\n+rm -rf $NGX_AUTOTEST*\n+\nDiff:\n@@ -0,0 +1,82 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo $ngx_n \"checking for $ngx_type ...$ngx_c\"\n+\n+cat << END >> $NGX_AUTOCONF_ERR\n+\n+----------------------------------------\n+checking for $ngx_type\n+\n+END\n+\n+ngx_found=no\n+\n+for ngx_try in $ngx_type $ngx_types\n+do\n+\n+    cat << END > $NGX_AUTOTEST.c\n+\n+#include <sys/types.h>\n+#include <signal.h>\n+#include <sys/socket.h>\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#include <netinet/in.h>\n+$NGX_INCLUDE_INTTYPES_H\n+\n+int main(void) {\n+    $ngx_try i = 0;\n+    return (int) i;\n+}\n+\n+END\n+\n+    ngx_test=\"$CC $CC_TEST_FLAGS $CC_AUX_FLAGS \\\n+              -o $NGX_AUTOTEST $NGX_AUTOTEST.c $NGX_LD_OPT $ngx_feature_libs\"\n+\n+    eval \"$ngx_test >> $NGX_AUTOCONF_ERR 2>&1\"\n+\n+    if [ -x $NGX_AUTOTEST ]; then\n+        if [ $ngx_try = $ngx_type ]; then\n+            echo \" found\"\n+            ngx_found=yes\n+        else\n+            echo \", $ngx_try used\"\n+            ngx_found=$ngx_try\n+        fi\n+    fi\n+\n+    if [ $ngx_found = no ]; then\n+        if [ $ngx_try = $ngx_type ]; then\n+            echo $ngx_n \" $ngx_try not found$ngx_c\"\n+        else\n+            echo $ngx_n \", $ngx_try not found$ngx_c\"\n+        fi\n+\n+        echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+        cat $NGX_AUTOTEST.c  >> $NGX_AUTOCONF_ERR\n+        echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+        echo $ngx_test       >> $NGX_AUTOCONF_ERR\n+        echo \"----------\"    >> $NGX_AUTOCONF_ERR\n+    fi\n+\n+    rm -rf $NGX_AUTOTEST*\n+\n+    if [ $ngx_found != no ]; then\n+        break\n+    fi\n+done\n+\n+if [ $ngx_found = no ]; then\n+    echo\n+    echo \"$0: error: can not define $ngx_type\"\n+\n+    exit 1\n+fi\n+\n+if [ $ngx_found != yes ]; then\n+    echo \"typedef $ngx_found  $ngx_type;\"   >> $NGX_AUTO_CONFIG_H\n+fi\nDiff:\n@@ -0,0 +1,50 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+echo $ngx_n \"checking for uintptr_t ...$ngx_c\"\n+\n+cat << END >> $NGX_AUTOCONF_ERR\n+\n+----------------------------------------\n+checking for uintptr_t\n+\n+END\n+\n+found=no\n+\n+cat << END > $NGX_AUTOTEST.c\n+\n+#include <sys/types.h>\n+$NGX_INCLUDE_INTTYPES_H\n+\n+int main(void) {\n+    uintptr_t i = 0;\n+    return (int) i;\n+}\n+\n+END\n+\n+ngx_test=\"$CC $CC_TEST_FLAGS $CC_AUX_FLAGS \\\n+          -o $NGX_AUTOTEST $NGX_AUTOTEST.c $NGX_LD_OPT\"\n+\n+eval \"$ngx_test >> $NGX_AUTOCONF_ERR 2>&1\"\n+\n+if [ -x $NGX_AUTOTEST ]; then\n+    echo \" uintptr_t found\"\n+    found=yes\n+else\n+    echo $ngx_n \" uintptr_t not found\" $ngx_c\n+fi\n+\n+rm -rf $NGX_AUTOTEST*\n+\n+\n+if [ $found = no ]; then\n+    found=\"uint`expr 8 \\* $ngx_ptr_size`_t\"\n+    echo \", $found used\"\n+\n+    echo \"typedef $found  uintptr_t;\"                   >> $NGX_AUTO_CONFIG_H\n+    echo \"typedef $found  intptr_t;\" | sed -e 's/u//g'  >> $NGX_AUTO_CONFIG_H\n+fi\nDiff:\n@@ -0,0 +1,12 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#ifndef $ngx_param\n+#define $ngx_param  $ngx_value\n+#endif\n+\n+END\nDiff:\n@@ -0,0 +1,1039 @@\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+NGX_USER=${NGX_USER:-nobody}\n+\n+if [ -z \"$NGX_GROUP\" ]; then\n+    if [ $NGX_USER = nobody ]; then\n+        if grep nobody /etc/group 2>&1 >/dev/null; then\n+            echo \"checking for nobody group ... found\"\n+            NGX_GROUP=nobody\n+        else\n+            echo \"checking for nobody group ... not found\"\n+\n+            if grep nogroup /etc/group 2>&1 >/dev/null; then\n+                echo \"checking for nogroup group ... found\"\n+                NGX_GROUP=nogroup\n+            else\n+                echo \"checking for nogroup group ... not found\"\n+                NGX_GROUP=nobody\n+            fi\n+        fi\n+    else\n+        NGX_GROUP=$NGX_USER\n+    fi\n+fi\n+\n+\n+ngx_feature=\"poll()\"\n+ngx_feature_name=\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <poll.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int  n; struct pollfd  pl;\n+                  pl.fd = 0;\n+                  pl.events = 0;\n+                  pl.revents = 0;\n+                  n = poll(&pl, 1, 0);\n+                  if (n == -1) return 1\"\n+. auto/feature\n+\n+if [ $ngx_found = no ]; then\n+    EVENT_POLL=NONE\n+fi\n+\n+\n+ngx_feature=\"/dev/poll\"\n+ngx_feature_name=\"NGX_HAVE_DEVPOLL\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/devpoll.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int  n, dp; struct dvpoll  dvp;\n+                  dp = 0;\n+                  dvp.dp_fds = NULL;\n+                  dvp.dp_nfds = 0;\n+                  dvp.dp_timeout = 0;\n+                  n = ioctl(dp, DP_POLL, &dvp);\n+                  if (n == -1) return 1\"\n+. auto/feature\n+\n+if [ $ngx_found = yes ]; then\n+    CORE_SRCS=\"$CORE_SRCS $DEVPOLL_SRCS\"\n+    EVENT_MODULES=\"$EVENT_MODULES $DEVPOLL_MODULE\"\n+    EVENT_FOUND=YES\n+fi\n+\n+\n+if test -z \"$NGX_KQUEUE_CHECKED\"; then\n+    ngx_feature=\"kqueue\"\n+    ngx_feature_name=\"NGX_HAVE_KQUEUE\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <sys/event.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"(void) kqueue()\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+\n+        have=NGX_HAVE_CLEAR_EVENT . auto/have\n+        EVENT_MODULES=\"$EVENT_MODULES $KQUEUE_MODULE\"\n+        CORE_SRCS=\"$CORE_SRCS $KQUEUE_SRCS\"\n+        EVENT_FOUND=YES\n+\n+        ngx_feature=\"kqueue's NOTE_LOWAT\"\n+        ngx_feature_name=\"NGX_HAVE_LOWAT_EVENT\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#include <sys/event.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\n+        ngx_feature_test=\"struct kevent  kev;\n+                          kev.fflags = NOTE_LOWAT;\n+                          (void) kev\"\n+        . auto/feature\n+\n+\n+        ngx_feature=\"kqueue's EVFILT_TIMER\"\n+        ngx_feature_name=\"NGX_HAVE_TIMER_EVENT\"\n+        ngx_feature_run=yes\n+        ngx_feature_incs=\"#include <sys/event.h>\n+                          #include <sys/time.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\n+        ngx_feature_test=\"int      kq;\n+                  struct kevent    kev;\n+                  struct timespec  ts;\n+\n+                  if ((kq = kqueue()) == -1) return 1;\n+\n+                  kev.ident = 0;\n+                  kev.filter = EVFILT_TIMER;\n+                  kev.flags = EV_ADD|EV_ENABLE;\n+                  kev.fflags = 0;\n+                  kev.data = 1000;\n+                  kev.udata = 0;\n+\n+                  ts.tv_sec = 0;\n+                  ts.tv_nsec = 0;\n+\n+                  if (kevent(kq, &kev, 1, &kev, 1, &ts) == -1) return 1;\n+\n+                  if (kev.flags & EV_ERROR) return 1;\"\n+\n+        . auto/feature\n+    fi\n+fi\n+\n+\n+if [ \"$NGX_SYSTEM\" = \"NetBSD\" ]; then\n+\n+    # NetBSD 2.0 incompatibly defines kevent.udata as \"intptr_t\"\n+\n+    cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#define NGX_KQUEUE_UDATA_T\n+\n+END\n+\n+else\n+    cat << END >> $NGX_AUTO_CONFIG_H\n+\n+#define NGX_KQUEUE_UDATA_T  (void *)\n+\n+END\n+\n+fi\n+\n+\n+ngx_feature=\"crypt()\"\n+ngx_feature_name=\n+ngx_feature_run=no\n+ngx_feature_incs=\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"crypt(\\\"test\\\", \\\"salt\\\");\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    ngx_feature=\"crypt() in libcrypt\"\n+    ngx_feature_name=\n+    ngx_feature_run=no\n+    ngx_feature_incs=\n+    ngx_feature_path=\n+    ngx_feature_libs=-lcrypt\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CRYPT_LIB=\"-lcrypt\"\n+    fi\n+fi\n+\n+\n+ngx_feature=\"F_READAHEAD\"\n+ngx_feature_name=\"NGX_HAVE_F_READAHEAD\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"fcntl(0, F_READAHEAD, 1);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"posix_fadvise()\"\n+ngx_feature_name=\"NGX_HAVE_POSIX_FADVISE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"O_DIRECT\"\n+ngx_feature_name=\"NGX_HAVE_O_DIRECT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"fcntl(0, F_SETFL, O_DIRECT);\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = yes -a \"$NGX_SYSTEM\" = \"Linux\" ]; then\n+    have=NGX_HAVE_ALIGNED_DIRECTIO . auto/have\n+fi\n+\n+ngx_feature=\"F_NOCACHE\"\n+ngx_feature_name=\"NGX_HAVE_F_NOCACHE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"fcntl(0, F_NOCACHE, 1);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"directio()\"\n+ngx_feature_name=\"NGX_HAVE_DIRECTIO\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/types.h>\n+                  #include <sys/fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"directio(0, DIRECTIO_ON);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"statfs()\"\n+ngx_feature_name=\"NGX_HAVE_STATFS\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"$NGX_INCLUDE_SYS_PARAM_H\n+                  $NGX_INCLUDE_SYS_MOUNT_H\n+                  $NGX_INCLUDE_SYS_VFS_H\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct statfs  fs;\n+                  statfs(\\\".\\\", &fs);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"statvfs()\"\n+ngx_feature_name=\"NGX_HAVE_STATVFS\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/types.h>\n+                  #include <sys/statvfs.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct statvfs  fs;\n+                  statvfs(\\\".\\\", &fs);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"dlopen()\"\n+ngx_feature_name=\"NGX_HAVE_DLOPEN\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <dlfcn.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"dlopen(NULL, RTLD_NOW | RTLD_GLOBAL); dlsym(NULL, \\\"\\\")\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    ngx_feature=\"dlopen() in libdl\"\n+    ngx_feature_libs=\"-ldl\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_LIBS=\"$CORE_LIBS -ldl\"\n+        NGX_LIBDL=\"-ldl\"\n+    fi\n+fi\n+\n+\n+ngx_feature=\"sched_yield()\"\n+ngx_feature_name=\"NGX_HAVE_SCHED_YIELD\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sched.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"sched_yield()\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    ngx_feature=\"sched_yield() in librt\"\n+    ngx_feature_libs=\"-lrt\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_LIBS=\"$CORE_LIBS -lrt\"\n+    fi\n+fi\n+\n+\n+ngx_feature=\"sched_setaffinity()\"\n+ngx_feature_name=\"NGX_HAVE_SCHED_SETAFFINITY\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sched.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"cpu_set_t mask;\n+                  CPU_ZERO(&mask);\n+                  sched_setaffinity(0, sizeof(cpu_set_t), &mask)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"SO_SETFIB\"\n+ngx_feature_name=\"NGX_HAVE_SETFIB\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_SETFIB, NULL, 0)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"SO_REUSEPORT\"\n+ngx_feature_name=\"NGX_HAVE_REUSEPORT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_REUSEPORT, NULL, 0)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"SO_ACCEPTFILTER\"\n+ngx_feature_name=\"NGX_HAVE_DEFERRED_ACCEPT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_ACCEPTFILTER, NULL, 0)\"\n+. auto/feature\n+\n+\n+# OpenBSD bind to any address for transparent proxying\n+\n+ngx_feature=\"SO_BINDANY\"\n+ngx_feature_name=\"NGX_HAVE_TRANSPARENT_PROXY\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, SOL_SOCKET, SO_BINDANY, NULL, 0)\"\n+. auto/feature\n+\n+\n+# Linux transparent proxying\n+\n+ngx_feature=\"IP_TRANSPARENT\"\n+ngx_feature_name=\"NGX_HAVE_TRANSPARENT_PROXY\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_TRANSPARENT, NULL, 0)\"\n+. auto/feature\n+\n+\n+# FreeBSD bind to any address for transparent proxying\n+\n+ngx_feature=\"IP_BINDANY\"\n+ngx_feature_name=\"NGX_HAVE_TRANSPARENT_PROXY\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_BINDANY, NULL, 0)\"\n+. auto/feature\n+\n+\n+# Linux IP_BIND_ADDRESS_NO_PORT\n+\n+ngx_feature=\"IP_BIND_ADDRESS_NO_PORT\"\n+ngx_feature_name=\"NGX_HAVE_IP_BIND_ADDRESS_NO_PORT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_BIND_ADDRESS_NO_PORT, NULL, 0)\"\n+. auto/feature\n+\n+\n+# BSD way to get IPv4 datagram destination address\n+\n+ngx_feature=\"IP_RECVDSTADDR\"\n+ngx_feature_name=\"NGX_HAVE_IP_RECVDSTADDR\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_RECVDSTADDR, NULL, 0)\"\n+. auto/feature\n+\n+\n+# BSD way to set IPv4 datagram source address\n+\n+ngx_feature=\"IP_SENDSRCADDR\"\n+ngx_feature_name=\"NGX_HAVE_IP_SENDSRCADDR\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_IP, IP_SENDSRCADDR, NULL, 0)\"\n+. auto/feature\n+\n+\n+# Linux way to get IPv4 datagram destination address\n+\n+ngx_feature=\"IP_PKTINFO\"\n+ngx_feature_name=\"NGX_HAVE_IP_PKTINFO\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct in_pktinfo  pkt;\n+                  pkt.ipi_spec_dst.s_addr = INADDR_ANY;\n+                  (void) pkt;\n+                  setsockopt(0, IPPROTO_IP, IP_PKTINFO, NULL, 0)\"\n+. auto/feature\n+\n+\n+# RFC 3542 way to get IPv6 datagram destination address\n+\n+ngx_feature=\"IPV6_RECVPKTINFO\"\n+ngx_feature_name=\"NGX_HAVE_IPV6_RECVPKTINFO\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_IPV6, IPV6_RECVPKTINFO, NULL, 0)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"TCP_DEFER_ACCEPT\"\n+ngx_feature_name=\"NGX_HAVE_DEFERRED_ACCEPT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\n+                  #include <netinet/tcp.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_TCP, TCP_DEFER_ACCEPT, NULL, 0)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"TCP_KEEPIDLE\"\n+ngx_feature_name=\"NGX_HAVE_KEEPALIVE_TUNABLE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\n+                  #include <netinet/tcp.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_TCP, TCP_KEEPIDLE, NULL, 0);\n+                  setsockopt(0, IPPROTO_TCP, TCP_KEEPINTVL, NULL, 0);\n+                  setsockopt(0, IPPROTO_TCP, TCP_KEEPCNT, NULL, 0)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"TCP_FASTOPEN\"\n+ngx_feature_name=\"NGX_HAVE_TCP_FASTOPEN\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\n+                  #include <netinet/tcp.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"setsockopt(0, IPPROTO_TCP, TCP_FASTOPEN, NULL, 0)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"TCP_INFO\"\n+ngx_feature_name=\"NGX_HAVE_TCP_INFO\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\n+                  #include <netinet/tcp.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"socklen_t optlen = sizeof(struct tcp_info);\n+                  struct tcp_info ti;\n+                  ti.tcpi_rtt = 0;\n+                  ti.tcpi_rttvar = 0;\n+                  ti.tcpi_snd_cwnd = 0;\n+                  ti.tcpi_rcv_space = 0;\n+                  getsockopt(0, IPPROTO_TCP, TCP_INFO, &ti, &optlen)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"accept4()\"\n+ngx_feature_name=\"NGX_HAVE_ACCEPT4\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"accept4(0, NULL, NULL, SOCK_NONBLOCK)\"\n+. auto/feature\n+\n+if [ $NGX_FILE_AIO = YES ]; then\n+\n+    ngx_feature=\"kqueue AIO support\"\n+    ngx_feature_name=\"NGX_HAVE_FILE_AIO\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <aio.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"struct aiocb  iocb;\n+                      iocb.aio_sigevent.sigev_notify = SIGEV_KEVENT;\n+                      (void) aio_read(&iocb)\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_SRCS=\"$CORE_SRCS $FILE_AIO_SRCS\"\n+    fi\n+\n+    if [ $ngx_found = no ]; then\n+\n+        ngx_feature=\"Linux AIO support\"\n+        ngx_feature_name=\"NGX_HAVE_FILE_AIO\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#include <linux/aio_abi.h>\n+                          #include <sys/eventfd.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\n+        ngx_feature_test=\"struct iocb  iocb;\n+                          iocb.aio_lio_opcode = IOCB_CMD_PREAD;\n+                          iocb.aio_flags = IOCB_FLAG_RESFD;\n+                          iocb.aio_resfd = -1;\n+                          (void) iocb;\n+                          (void) eventfd(0, 0)\"\n+        . auto/feature\n+\n+        if [ $ngx_found = yes ]; then\n+            have=NGX_HAVE_EVENTFD . auto/have\n+            have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n+            CORE_SRCS=\"$CORE_SRCS $LINUX_AIO_SRCS\"\n+        fi\n+    fi\n+\n+    if [ $ngx_found = no ]; then\n+\n+        ngx_feature=\"Linux AIO support (SYS_eventfd)\"\n+        ngx_feature_incs=\"#include <linux/aio_abi.h>\n+                          #include <sys/syscall.h>\"\n+        ngx_feature_test=\"struct iocb  iocb;\n+                          iocb.aio_lio_opcode = IOCB_CMD_PREAD;\n+                          iocb.aio_flags = IOCB_FLAG_RESFD;\n+                          iocb.aio_resfd = -1;\n+                          (void) iocb;\n+                          (void) SYS_eventfd\"\n+        . auto/feature\n+\n+        if [ $ngx_found = yes ]; then\n+            have=NGX_HAVE_EVENTFD . auto/have\n+            CORE_SRCS=\"$CORE_SRCS $LINUX_AIO_SRCS\"\n+        fi\n+    fi\n+\n+    if [ $ngx_found = no ]; then\n+        cat << END\n+\n+$0: no supported file AIO was found\n+Currently file AIO is supported on FreeBSD 4.3+ and Linux 2.6.22+ only\n+\n+END\n+        exit 1\n+    fi\n+\n+else\n+\n+    ngx_feature=\"eventfd()\"\n+    ngx_feature_name=\"NGX_HAVE_EVENTFD\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <sys/eventfd.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"(void) eventfd(0, 0)\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n+    fi\n+\n+    if [ $ngx_found = no ]; then\n+\n+        ngx_feature=\"eventfd() (SYS_eventfd)\"\n+        ngx_feature_incs=\"#include <sys/syscall.h>\"\n+        ngx_feature_test=\"(void) SYS_eventfd\"\n+        . auto/feature\n+    fi\n+fi\n+\n+\n+have=NGX_HAVE_UNIX_DOMAIN . auto/have\n+\n+ngx_feature_libs=\n+\n+\n+# C types\n+\n+ngx_type=\"int\"; . auto/types/sizeof\n+\n+ngx_type=\"long\"; . auto/types/sizeof\n+\n+ngx_type=\"long long\"; . auto/types/sizeof\n+\n+ngx_type=\"void *\"; . auto/types/sizeof; ngx_ptr_size=$ngx_size\n+ngx_param=NGX_PTR_SIZE; ngx_value=$ngx_size; . auto/types/value\n+\n+\n+# POSIX types\n+\n+NGX_INCLUDE_AUTO_CONFIG_H=\"#include \\\"ngx_auto_config.h\\\"\"\n+\n+ngx_type=\"uint32_t\"; ngx_types=\"u_int32_t\"; . auto/types/typedef\n+ngx_type=\"uint64_t\"; ngx_types=\"u_int64_t\"; . auto/types/typedef\n+\n+ngx_type=\"sig_atomic_t\"; ngx_types=\"int\"; . auto/types/typedef\n+. auto/types/sizeof\n+ngx_param=NGX_SIG_ATOMIC_T_SIZE; ngx_value=$ngx_size; . auto/types/value\n+\n+ngx_type=\"socklen_t\"; ngx_types=\"int\"; . auto/types/typedef\n+\n+ngx_type=\"in_addr_t\"; ngx_types=\"uint32_t u_int32_t\"; . auto/types/typedef\n+\n+ngx_type=\"in_port_t\"; ngx_types=\"u_short\"; . auto/types/typedef\n+\n+ngx_type=\"rlim_t\"; ngx_types=\"int\"; . auto/types/typedef\n+\n+. auto/types/uintptr_t\n+\n+. auto/endianness\n+\n+ngx_type=\"size_t\"; . auto/types/sizeof\n+ngx_param=NGX_MAX_SIZE_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value\n+ngx_param=NGX_SIZE_T_LEN; ngx_value=$ngx_max_len; . auto/types/value\n+\n+ngx_type=\"off_t\"; . auto/types/sizeof\n+ngx_param=NGX_MAX_OFF_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value\n+ngx_param=NGX_OFF_T_LEN; ngx_value=$ngx_max_len; . auto/types/value\n+\n+ngx_type=\"time_t\"; . auto/types/sizeof\n+ngx_param=NGX_TIME_T_SIZE; ngx_value=$ngx_size; . auto/types/value\n+ngx_param=NGX_TIME_T_LEN; ngx_value=$ngx_max_len; . auto/types/value\n+ngx_param=NGX_MAX_TIME_T_VALUE; ngx_value=$ngx_max_value; . auto/types/value\n+\n+\n+# syscalls, libc calls and some features\n+\n+\n+ngx_feature=\"AF_INET6\"\n+ngx_feature_name=\"NGX_HAVE_INET6\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <netinet/in.h>\n+                  #include <arpa/inet.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct sockaddr_in6  sin6;\n+                  sin6.sin6_family = AF_INET6;\n+                  (void) sin6\"\n+. auto/feature\n+\n+\n+ngx_feature=\"setproctitle()\"\n+ngx_feature_name=\"NGX_HAVE_SETPROCTITLE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <stdlib.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=$NGX_SETPROCTITLE_LIB\n+ngx_feature_test=\"setproctitle(\\\"test\\\");\"\n+. auto/feature\n+\n+\n+ngx_feature=\"pread()\"\n+ngx_feature_name=\"NGX_HAVE_PREAD\"\n+ngx_feature_run=no\n+ngx_feature_incs=\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"char buf[1]; ssize_t n; n = pread(0, buf, 1, 0);\n+                  if (n == -1) return 1\"\n+. auto/feature\n+\n+\n+ngx_feature=\"pwrite()\"\n+ngx_feature_name=\"NGX_HAVE_PWRITE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"char buf[1]; ssize_t n; n = pwrite(1, buf, 1, 0);\n+                  if (n == -1) return 1\"\n+. auto/feature\n+\n+\n+# pwritev() was introduced in FreeBSD 6 and Linux 2.6.30, glibc 2.10\n+\n+ngx_feature=\"pwritev()\"\n+ngx_feature_name=\"NGX_HAVE_PWRITEV\"\n+ngx_feature_run=no\n+ngx_feature_incs='#include <sys/uio.h>'\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"char buf[1]; struct iovec vec[1]; ssize_t n;\n+                  vec[0].iov_base = buf;\n+                  vec[0].iov_len = 1;\n+                  n = pwritev(1, vec, 1, 0);\n+                  if (n == -1) return 1\"\n+. auto/feature\n+\n+\n+ngx_feature=\"sys_nerr\"\n+ngx_feature_name=\"NGX_SYS_NERR\"\n+ngx_feature_run=value\n+ngx_feature_incs='#include <errno.h>\n+                  #include <stdio.h>'\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test='printf(\"%d\", sys_nerr);'\n+. auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # Cygiwn defines _sys_nerr\n+    ngx_feature=\"_sys_nerr\"\n+    ngx_feature_name=\"NGX_SYS_NERR\"\n+    ngx_feature_run=value\n+    ngx_feature_incs='#include <errno.h>\n+                      #include <stdio.h>'\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test='printf(\"%d\", _sys_nerr);'\n+    . auto/feature\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # Solaris has no sys_nerr\n+    ngx_feature='maximum errno'\n+    ngx_feature_name=NGX_SYS_NERR\n+    ngx_feature_run=value\n+    ngx_feature_incs='#include <errno.h>\n+                      #include <string.h>\n+                      #include <stdio.h>'\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test='int  n;\n+                      char *p;\n+                      for (n = 1; n < 1000; n++) {\n+                          errno = 0;\n+                          p = strerror(n);\n+                          if (errno == EINVAL\n+                              || p == NULL\n+                              || strncmp(p, \"Unknown error\", 13) == 0)\n+                          {\n+                              break;\n+                          }\n+                      }\n+                      printf(\"%d\", n);'\n+    . auto/feature\n+fi\n+\n+\n+ngx_feature=\"localtime_r()\"\n+ngx_feature_name=\"NGX_HAVE_LOCALTIME_R\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <time.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct tm t; time_t c=0; localtime_r(&c, &t)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"clock_gettime(CLOCK_MONOTONIC)\"\n+ngx_feature_name=\"NGX_HAVE_CLOCK_MONOTONIC\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <time.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts)\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # Linux before glibc 2.17, notably CentOS 6\n+\n+    ngx_feature=\"clock_gettime(CLOCK_MONOTONIC) in librt\"\n+    ngx_feature_libs=\"-lrt\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_LIBS=\"$CORE_LIBS -lrt\"\n+    fi\n+fi\n+\n+\n+ngx_feature=\"posix_memalign()\"\n+ngx_feature_name=\"NGX_HAVE_POSIX_MEMALIGN\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <stdlib.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"void *p; int n; n = posix_memalign(&p, 4096, 4096);\n+                  if (n != 0) return 1\"\n+. auto/feature\n+\n+\n+ngx_feature=\"memalign()\"\n+ngx_feature_name=\"NGX_HAVE_MEMALIGN\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <stdlib.h>\n+                  #include <malloc.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"void *p; p = memalign(4096, 4096);\n+                  if (p == NULL) return 1\"\n+. auto/feature\n+\n+\n+ngx_feature=\"mmap(MAP_ANON|MAP_SHARED)\"\n+ngx_feature_name=\"NGX_HAVE_MAP_ANON\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/mman.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"void *p;\n+                  p = mmap(NULL, 4096, PROT_READ|PROT_WRITE,\n+                           MAP_ANON|MAP_SHARED, -1, 0);\n+                  if (p == MAP_FAILED) return 1;\"\n+. auto/feature\n+\n+\n+ngx_feature='mmap(\"/dev/zero\", MAP_SHARED)'\n+ngx_feature_name=\"NGX_HAVE_MAP_DEVZERO\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/mman.h>\n+                  #include <sys/stat.h>\n+                  #include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test='void *p; int  fd;\n+                  fd = open(\"/dev/zero\", O_RDWR);\n+                  p = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+                  if (p == MAP_FAILED) return 1;'\n+. auto/feature\n+\n+\n+ngx_feature=\"System V shared memory\"\n+ngx_feature_name=\"NGX_HAVE_SYSVSHM\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <sys/ipc.h>\n+                  #include <sys/shm.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int  id;\n+                  id = shmget(IPC_PRIVATE, 4096, (SHM_R|SHM_W|IPC_CREAT));\n+                  if (id == -1) return 1;\n+                  shmctl(id, IPC_RMID, NULL);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"POSIX semaphores\"\n+ngx_feature_name=\"NGX_HAVE_POSIX_SEM\"\n+ngx_feature_run=yes\n+ngx_feature_incs=\"#include <semaphore.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"sem_t  sem;\n+                  if (sem_init(&sem, 1, 0) == -1) return 1;\n+                  sem_destroy(&sem);\"\n+. auto/feature\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # Linux has POSIX semaphores in libpthread\n+    ngx_feature=\"POSIX semaphores in libpthread\"\n+    ngx_feature_libs=-lpthread\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_LIBS=\"$CORE_LIBS -lpthread\"\n+        NGX_LIBPTHREAD=\"-lpthread\"\n+    fi\n+fi\n+\n+\n+if [ $ngx_found = no ]; then\n+\n+    # Solaris has POSIX semaphores in librt\n+    ngx_feature=\"POSIX semaphores in librt\"\n+    ngx_feature_libs=-lrt\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        CORE_LIBS=\"$CORE_LIBS -lrt\"\n+    fi\n+fi\n+\n+\n+ngx_feature=\"struct msghdr.msg_control\"\n+ngx_feature_name=\"NGX_HAVE_MSGHDR_MSG_CONTROL\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <stdio.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct msghdr  msg;\n+                  printf(\\\"%d\\\", (int) sizeof(msg.msg_control))\"\n+. auto/feature\n+\n+\n+ngx_feature=\"ioctl(FIONBIO)\"\n+ngx_feature_name=\"NGX_HAVE_FIONBIO\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/ioctl.h>\n+                  #include <stdio.h>\n+                  $NGX_INCLUDE_SYS_FILIO_H\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int i = FIONBIO; printf(\\\"%d\\\", i)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"ioctl(FIONREAD)\"\n+ngx_feature_name=\"NGX_HAVE_FIONREAD\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/ioctl.h>\n+                  #include <stdio.h>\n+                  $NGX_INCLUDE_SYS_FILIO_H\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"int i = FIONREAD; printf(\\\"%d\\\", i)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"struct tm.tm_gmtoff\"\n+ngx_feature_name=\"NGX_HAVE_GMTOFF\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <time.h>\n+                  #include <stdio.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct tm  tm; tm.tm_gmtoff = 0;\n+                  printf(\\\"%d\\\", (int) tm.tm_gmtoff)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"struct dirent.d_namlen\"\n+ngx_feature_name=\"NGX_HAVE_D_NAMLEN\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <dirent.h>\n+                  #include <stdio.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct dirent  dir; dir.d_namlen = 0;\n+                  printf(\\\"%d\\\", (int) dir.d_namlen)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"struct dirent.d_type\"\n+ngx_feature_name=\"NGX_HAVE_D_TYPE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <dirent.h>\n+                  #include <stdio.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct dirent  dir; dir.d_type = DT_REG;\n+                  printf(\\\"%d\\\", (int) dir.d_type)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"sysconf(_SC_NPROCESSORS_ONLN)\"\n+ngx_feature_name=\"NGX_HAVE_SC_NPROCESSORS_ONLN\"\n+ngx_feature_run=no\n+ngx_feature_incs=\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"sysconf(_SC_NPROCESSORS_ONLN)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"sysconf(_SC_LEVEL1_DCACHE_LINESIZE)\"\n+ngx_feature_name=\"NGX_HAVE_LEVEL1_DCACHE_LINESIZE\"\n+ngx_feature_run=no\n+ngx_feature_incs=\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"sysconf(_SC_LEVEL1_DCACHE_LINESIZE)\"\n+. auto/feature\n+\n+\n+ngx_feature=\"openat(), fstatat()\"\n+ngx_feature_name=\"NGX_HAVE_OPENAT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/types.h>\n+                  #include <sys/stat.h>\n+                  #include <fcntl.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"struct stat sb;\n+                  openat(AT_FDCWD, \\\".\\\", O_RDONLY|O_NOFOLLOW);\n+                  fstatat(AT_FDCWD, \\\".\\\", &sb, AT_SYMLINK_NOFOLLOW);\"\n+. auto/feature\n+\n+\n+ngx_feature=\"getaddrinfo()\"\n+ngx_feature_name=\"NGX_HAVE_GETADDRINFO\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/types.h>\n+                  #include <sys/socket.h>\n+                  #include <netdb.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test='struct addrinfo *res;\n+                  if (getaddrinfo(\"localhost\", NULL, NULL, &res) != 0) return 1;\n+                  freeaddrinfo(res)'\n+. auto/feature\nDiff:\n@@ -0,0 +1,26 @@\n+\n+fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;\n+fastcgi_param  QUERY_STRING       $query_string;\n+fastcgi_param  REQUEST_METHOD     $request_method;\n+fastcgi_param  CONTENT_TYPE       $content_type;\n+fastcgi_param  CONTENT_LENGTH     $content_length;\n+\n+fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;\n+fastcgi_param  REQUEST_URI        $request_uri;\n+fastcgi_param  DOCUMENT_URI       $document_uri;\n+fastcgi_param  DOCUMENT_ROOT      $document_root;\n+fastcgi_param  SERVER_PROTOCOL    $server_protocol;\n+fastcgi_param  REQUEST_SCHEME     $scheme;\n+fastcgi_param  HTTPS              $https if_not_empty;\n+\n+fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;\n+fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;\n+\n+fastcgi_param  REMOTE_ADDR        $remote_addr;\n+fastcgi_param  REMOTE_PORT        $remote_port;\n+fastcgi_param  SERVER_ADDR        $server_addr;\n+fastcgi_param  SERVER_PORT        $server_port;\n+fastcgi_param  SERVER_NAME        $server_name;\n+\n+# PHP only, required if PHP was built with --enable-force-cgi-redirect\n+fastcgi_param  REDIRECT_STATUS    200;\nDiff:\n@@ -0,0 +1,25 @@\n+\n+fastcgi_param  QUERY_STRING       $query_string;\n+fastcgi_param  REQUEST_METHOD     $request_method;\n+fastcgi_param  CONTENT_TYPE       $content_type;\n+fastcgi_param  CONTENT_LENGTH     $content_length;\n+\n+fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;\n+fastcgi_param  REQUEST_URI        $request_uri;\n+fastcgi_param  DOCUMENT_URI       $document_uri;\n+fastcgi_param  DOCUMENT_ROOT      $document_root;\n+fastcgi_param  SERVER_PROTOCOL    $server_protocol;\n+fastcgi_param  REQUEST_SCHEME     $scheme;\n+fastcgi_param  HTTPS              $https if_not_empty;\n+\n+fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;\n+fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;\n+\n+fastcgi_param  REMOTE_ADDR        $remote_addr;\n+fastcgi_param  REMOTE_PORT        $remote_port;\n+fastcgi_param  SERVER_ADDR        $server_addr;\n+fastcgi_param  SERVER_PORT        $server_port;\n+fastcgi_param  SERVER_NAME        $server_name;\n+\n+# PHP only, required if PHP was built with --enable-force-cgi-redirect\n+fastcgi_param  REDIRECT_STATUS    200;\nDiff:\n@@ -0,0 +1,109 @@\n+\n+# This map is not a full koi8-r <> utf8 map: it does not contain\n+# box-drawing and some other characters.  Besides this map contains\n+# several koi8-u and Byelorussian letters which are not in koi8-r.\n+# If you need a full and standard map, use contrib/unicode2nginx/koi-utf\n+# map instead.\n+\n+charset_map  koi8-r  utf-8 {\n+\n+    80  E282AC ; # euro\n+\n+    95  E280A2 ; # bullet\n+\n+    9A  C2A0 ;   # &nbsp;\n+\n+    9E  C2B7 ;   # &middot;\n+\n+    A3  D191 ;   # small yo\n+    A4  D194 ;   # small Ukrainian ye\n+\n+    A6  D196 ;   # small Ukrainian i\n+    A7  D197 ;   # small Ukrainian yi\n+\n+    AD  D291 ;   # small Ukrainian soft g\n+    AE  D19E ;   # small Byelorussian short u\n+\n+    B0  C2B0 ;   # &deg;\n+\n+    B3  D081 ;   # capital YO\n+    B4  D084 ;   # capital Ukrainian YE\n+\n+    B6  D086 ;   # capital Ukrainian I\n+    B7  D087 ;   # capital Ukrainian YI\n+\n+    B9  E28496 ; # numero sign\n+\n+    BD  D290 ;   # capital Ukrainian soft G\n+    BE  D18E ;   # capital Byelorussian short U\n+\n+    BF  C2A9 ;   # (C)\n+\n+    C0  D18E ;   # small yu\n+    C1  D0B0 ;   # small a\n+    C2  D0B1 ;   # small b\n+    C3  D186 ;   # small ts\n+    C4  D0B4 ;   # small d\n+    C5  D0B5 ;   # small ye\n+    C6  D184 ;   # small f\n+    C7  D0B3 ;   # small g\n+    C8  D185 ;   # small kh\n+    C9  D0B8 ;   # small i\n+    CA  D0B9 ;   # small j\n+    CB  D0BA ;   # small k\n+    CC  D0BB ;   # small l\n+    CD  D0BC ;   # small m\n+    CE  D0BD ;   # small n\n+    CF  D0BE ;   # small o\n+\n+    D0  D0BF ;   # small p\n+    D1  D18F ;   # small ya\n+    D2  D180 ;   # small r\n+    D3  D181 ;   # small s\n+    D4  D182 ;   # small t\n+    D5  D183 ;   # small u\n+    D6  D0B6 ;   # small zh\n+    D7  D0B2 ;   # small v\n+    D8  D18C ;   # small soft sign\n+    D9  D18B ;   # small y\n+    DA  D0B7 ;   # small z\n+    DB  D188 ;   # small sh\n+    DC  D18D ;   # small e\n+    DD  D189 ;   # small shch\n+    DE  D187 ;   # small ch\n+    DF  D18A ;   # small hard sign\n+\n+    E0  D0AE ;   # capital YU\n+    E1  D090 ;   # capital A\n+    E2  D091 ;   # capital B\n+    E3  D0A6 ;   # capital TS\n+    E4  D094 ;   # capital D\n+    E5  D095 ;   # capital YE\n+    E6  D0A4 ;   # capital F\n+    E7  D093 ;   # capital G\n+    E8  D0A5 ;   # capital KH\n+    E9  D098 ;   # capital I\n+    EA  D099 ;   # capital J\n+    EB  D09A ;   # capital K\n+    EC  D09B ;   # capital L\n+    ED  D09C ;   # capital M\n+    EE  D09D ;   # capital N\n+    EF  D09E ;   # capital O\n+\n+    F0  D09F ;   # capital P\n+    F1  D0AF ;   # capital YA\n+    F2  D0A0 ;   # capital R\n+    F3  D0A1 ;   # capital S\n+    F4  D0A2 ;   # capital T\n+    F5  D0A3 ;   # capital U\n+    F6  D096 ;   # capital ZH\n+    F7  D092 ;   # capital V\n+    F8  D0AC ;   # capital soft sign\n+    F9  D0AB ;   # capital Y\n+    FA  D097 ;   # capital Z\n+    FB  D0A8 ;   # capital SH\n+    FC  D0AD ;   # capital E\n+    FD  D0A9 ;   # capital SHCH\n+    FE  D0A7 ;   # capital CH\n+    FF  D0AA ;   # capital hard sign\n+}\nDiff:\n@@ -0,0 +1,103 @@\n+\n+charset_map  koi8-r  windows-1251 {\n+\n+    80  88 ; # euro\n+\n+    95  95 ; # bullet\n+\n+    9A  A0 ; # &nbsp;\n+\n+    9E  B7 ; # &middot;\n+\n+    A3  B8 ; # small yo\n+    A4  BA ; # small Ukrainian ye\n+\n+    A6  B3 ; # small Ukrainian i\n+    A7  BF ; # small Ukrainian yi\n+\n+    AD  B4 ; # small Ukrainian soft g\n+    AE  A2 ; # small Byelorussian short u\n+\n+    B0  B0 ; # &deg;\n+\n+    B3  A8 ; # capital YO\n+    B4  AA ; # capital Ukrainian YE\n+\n+    B6  B2 ; # capital Ukrainian I\n+    B7  AF ; # capital Ukrainian YI\n+\n+    B9  B9 ; # numero sign\n+\n+    BD  A5 ; # capital Ukrainian soft G\n+    BE  A1 ; # capital Byelorussian short U\n+\n+    BF  A9 ; # (C)\n+\n+    C0  FE ; # small yu\n+    C1  E0 ; # small a\n+    C2  E1 ; # small b\n+    C3  F6 ; # small ts\n+    C4  E4 ; # small d\n+    C5  E5 ; # small ye\n+    C6  F4 ; # small f\n+    C7  E3 ; # small g\n+    C8  F5 ; # small kh\n+    C9  E8 ; # small i\n+    CA  E9 ; # small j\n+    CB  EA ; # small k\n+    CC  EB ; # small l\n+    CD  EC ; # small m\n+    CE  ED ; # small n\n+    CF  EE ; # small o\n+\n+    D0  EF ; # small p\n+    D1  FF ; # small ya\n+    D2  F0 ; # small r\n+    D3  F1 ; # small s\n+    D4  F2 ; # small t\n+    D5  F3 ; # small u\n+    D6  E6 ; # small zh\n+    D7  E2 ; # small v\n+    D8  FC ; # small soft sign\n+    D9  FB ; # small y\n+    DA  E7 ; # small z\n+    DB  F8 ; # small sh\n+    DC  FD ; # small e\n+    DD  F9 ; # small shch\n+    DE  F7 ; # small ch\n+    DF  FA ; # small hard sign\n+\n+    E0  DE ; # capital YU\n+    E1  C0 ; # capital A\n+    E2  C1 ; # capital B\n+    E3  D6 ; # capital TS\n+    E4  C4 ; # capital D\n+    E5  C5 ; # capital YE\n+    E6  D4 ; # capital F\n+    E7  C3 ; # capital G\n+    E8  D5 ; # capital KH\n+    E9  C8 ; # capital I\n+    EA  C9 ; # capital J\n+    EB  CA ; # capital K\n+    EC  CB ; # capital L\n+    ED  CC ; # capital M\n+    EE  CD ; # capital N\n+    EF  CE ; # capital O\n+\n+    F0  CF ; # capital P\n+    F1  DF ; # capital YA\n+    F2  D0 ; # capital R\n+    F3  D1 ; # capital S\n+    F4  D2 ; # capital T\n+    F5  D3 ; # capital U\n+    F6  C6 ; # capital ZH\n+    F7  C2 ; # capital V\n+    F8  DC ; # capital soft sign\n+    F9  DB ; # capital Y\n+    FA  C7 ; # capital Z\n+    FB  D8 ; # capital SH\n+    FC  DD ; # capital E\n+    FD  D9 ; # capital SHCH\n+    FE  D7 ; # capital CH\n+    FF  DA ; # capital hard sign\n+}\nDiff:\n@@ -0,0 +1,97 @@\n+\n+types {\n+    text/html                                        html htm shtml;\n+    text/css                                         css;\n+    text/xml                                         xml;\n+    image/gif                                        gif;\n+    image/jpeg                                       jpeg jpg;\n+    application/javascript                           js;\n+    application/atom+xml                             atom;\n+    application/rss+xml                              rss;\n+\n+    text/mathml                                      mml;\n+    text/plain                                       txt;\n+    text/vnd.sun.j2me.app-descriptor                 jad;\n+    text/vnd.wap.wml                                 wml;\n+    text/x-component                                 htc;\n+\n+    image/png                                        png;\n+    image/svg+xml                                    svg svgz;\n+    image/tiff                                       tif tiff;\n+    image/vnd.wap.wbmp                               wbmp;\n+    image/webp                                       webp;\n+    image/x-icon                                     ico;\n+    image/x-jng                                      jng;\n+    image/x-ms-bmp                                   bmp;\n+\n+    font/woff                                        woff;\n+    font/woff2                                       woff2;\n+\n+    application/java-archive                         jar war ear;\n+    application/json                                 json;\n+    application/mac-binhex40                         hqx;\n+    application/msword                               doc;\n+    application/pdf                                  pdf;\n+    application/postscript                           ps eps ai;\n+    application/rtf                                  rtf;\n+    application/vnd.apple.mpegurl                    m3u8;\n+    application/vnd.google-earth.kml+xml             kml;\n+    application/vnd.google-earth.kmz                 kmz;\n+    application/vnd.ms-excel                         xls;\n+    application/vnd.ms-fontobject                    eot;\n+    application/vnd.ms-powerpoint                    ppt;\n+    application/vnd.oasis.opendocument.graphics      odg;\n+    application/vnd.oasis.opendocument.presentation  odp;\n+    application/vnd.oasis.opendocument.spreadsheet   ods;\n+    application/vnd.oasis.opendocument.text          odt;\n+    application/vnd.openxmlformats-officedocument.presentationml.presentation\n+                                                     pptx;\n+    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n+                                                     xlsx;\n+    application/vnd.openxmlformats-officedocument.wordprocessingml.document\n+                                                     docx;\n+    application/vnd.wap.wmlc                         wmlc;\n+    application/x-7z-compressed                      7z;\n+    application/x-cocoa                              cco;\n+    application/x-java-archive-diff                  jardiff;\n+    application/x-java-jnlp-file                     jnlp;\n+    application/x-makeself                           run;\n+    application/x-perl                               pl pm;\n+    application/x-pilot                              prc pdb;\n+    application/x-rar-compressed                     rar;\n+    application/x-redhat-package-manager             rpm;\n+    application/x-sea                                sea;\n+    application/x-shockwave-flash                    swf;\n+    application/x-stuffit                            sit;\n+    application/x-tcl                                tcl tk;\n+    application/x-x509-ca-cert                       der pem crt;\n+    application/x-xpinstall                          xpi;\n+    application/xhtml+xml                            xhtml;\n+    application/xspf+xml                             xspf;\n+    application/zip                                  zip;\n+\n+    application/octet-stream                         bin exe dll;\n+    application/octet-stream                         deb;\n+    application/octet-stream                         dmg;\n+    application/octet-stream                         iso img;\n+    application/octet-stream                         msi msp msm;\n+\n+    audio/midi                                       mid midi kar;\n+    audio/mpeg                                       mp3;\n+    audio/ogg                                        ogg;\n+    audio/x-m4a                                      m4a;\n+    audio/x-realaudio                                ra;\n+\n+    video/3gpp                                       3gpp 3gp;\n+    video/mp2t                                       ts;\n+    video/mp4                                        mp4;\n+    video/mpeg                                       mpeg mpg;\n+    video/quicktime                                  mov;\n+    video/webm                                       webm;\n+    video/x-flv                                      flv;\n+    video/x-m4v                                      m4v;\n+    video/x-mng                                      mng;\n+    video/x-ms-asf                                   asx asf;\n+    video/x-ms-wmv                                   wmv;\n+    video/x-msvideo                                  avi;\n+}\nDiff:\n@@ -0,0 +1,117 @@\n+\n+#user  nobody;\n+worker_processes  1;\n+\n+#error_log  logs/error.log;\n+#error_log  logs/error.log  notice;\n+#error_log  logs/error.log  info;\n+\n+#pid        logs/nginx.pid;\n+\n+\n+events {\n+    worker_connections  1024;\n+}\n+\n+\n+http {\n+    include       mime.types;\n+    default_type  application/octet-stream;\n+\n+    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n+    #                  '$status $body_bytes_sent \"$http_referer\" '\n+    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n+\n+    #access_log  logs/access.log  main;\n+\n+    sendfile        on;\n+    #tcp_nopush     on;\n+\n+    #keepalive_timeout  0;\n+    keepalive_timeout  65;\n+\n+    #gzip  on;\n+\n+    server {\n+        listen       80;\n+        server_name  localhost;\n+\n+        #charset koi8-r;\n+\n+        #access_log  logs/host.access.log  main;\n+\n+        location / {\n+            root   html;\n+            index  index.html index.htm;\n+        }\n+\n+        #error_page  404              /404.html;\n+\n+        # redirect server error pages to the static page /50x.html\n+        #\n+        error_page   500 502 503 504  /50x.html;\n+        location = /50x.html {\n+            root   html;\n+        }\n+\n+        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n+        #\n+        #location ~ \\.php$ {\n+        #    proxy_pass   http://127.0.0.1;\n+        #}\n+\n+        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n+        #\n+        #location ~ \\.php$ {\n+        #    root           html;\n+        #    fastcgi_pass   127.0.0.1:9000;\n+        #    fastcgi_index  index.php;\n+        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n+        #    include        fastcgi_params;\n+        #}\n+\n+        # deny access to .htaccess files, if Apache's document root\n+        # concurs with nginx's one\n+        #\n+        #location ~ /\\.ht {\n+        #    deny  all;\n+        #}\n+    }\n+\n+\n+    # another virtual host using mix of IP-, name-, and port-based configuration\n+    #\n+    #server {\n+    #    listen       8000;\n+    #    listen       somename:8080;\n+    #    server_name  somename  alias  another.alias;\n+\n+    #    location / {\n+    #        root   html;\n+    #        index  index.html index.htm;\n+    #    }\n+    #}\n+\n+\n+    # HTTPS server\n+    #\n+    #server {\n+    #    listen       443 ssl;\n+    #    server_name  localhost;\n+\n+    #    ssl_certificate      cert.pem;\n+    #    ssl_certificate_key  cert.key;\n+\n+    #    ssl_session_cache    shared:SSL:1m;\n+    #    ssl_session_timeout  5m;\n+\n+    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n+    #    ssl_prefer_server_ciphers  on;\n+\n+    #    location / {\n+    #        root   html;\n+    #        index  index.html index.htm;\n+    #    }\n+    #}\n+\n+}\nDiff:\n@@ -0,0 +1,17 @@\n+\n+scgi_param  REQUEST_METHOD     $request_method;\n+scgi_param  REQUEST_URI        $request_uri;\n+scgi_param  QUERY_STRING       $query_string;\n+scgi_param  CONTENT_TYPE       $content_type;\n+\n+scgi_param  DOCUMENT_URI       $document_uri;\n+scgi_param  DOCUMENT_ROOT      $document_root;\n+scgi_param  SCGI               1;\n+scgi_param  SERVER_PROTOCOL    $server_protocol;\n+scgi_param  REQUEST_SCHEME     $scheme;\n+scgi_param  HTTPS              $https if_not_empty;\n+\n+scgi_param  REMOTE_ADDR        $remote_addr;\n+scgi_param  REMOTE_PORT        $remote_port;\n+scgi_param  SERVER_PORT        $server_port;\n+scgi_param  SERVER_NAME        $server_name;\nDiff:\n@@ -0,0 +1,17 @@\n+\n+uwsgi_param  QUERY_STRING       $query_string;\n+uwsgi_param  REQUEST_METHOD     $request_method;\n+uwsgi_param  CONTENT_TYPE       $content_type;\n+uwsgi_param  CONTENT_LENGTH     $content_length;\n+\n+uwsgi_param  REQUEST_URI        $request_uri;\n+uwsgi_param  PATH_INFO          $document_uri;\n+uwsgi_param  DOCUMENT_ROOT      $document_root;\n+uwsgi_param  SERVER_PROTOCOL    $server_protocol;\n+uwsgi_param  REQUEST_SCHEME     $scheme;\n+uwsgi_param  HTTPS              $https if_not_empty;\n+\n+uwsgi_param  REMOTE_ADDR        $remote_addr;\n+uwsgi_param  REMOTE_PORT        $remote_port;\n+uwsgi_param  SERVER_PORT        $server_port;\n+uwsgi_param  SERVER_NAME        $server_name;\nDiff:\n@@ -0,0 +1,126 @@\n+\n+# This map is not a full windows-1251 <> utf8 map: it does not\n+# contain Serbian and Macedonian letters.  If you need a full map,\n+# use contrib/unicode2nginx/win-utf map instead.\n+\n+charset_map  windows-1251  utf-8 {\n+\n+    82  E2809A ; # single low-9 quotation mark\n+\n+    84  E2809E ; # double low-9 quotation mark\n+    85  E280A6 ; # ellipsis\n+    86  E280A0 ; # dagger\n+    87  E280A1 ; # double dagger\n+    88  E282AC ; # euro\n+    89  E280B0 ; # per mille\n+\n+    91  E28098 ; # left single quotation mark\n+    92  E28099 ; # right single quotation mark\n+    93  E2809C ; # left double quotation mark\n+    94  E2809D ; # right double quotation mark\n+    95  E280A2 ; # bullet\n+    96  E28093 ; # en dash\n+    97  E28094 ; # em dash\n+\n+    99  E284A2 ; # trade mark sign\n+\n+    A0  C2A0 ;   # &nbsp;\n+    A1  D18E ;   # capital Byelorussian short U\n+    A2  D19E ;   # small Byelorussian short u\n+\n+    A4  C2A4 ;   # currency sign\n+    A5  D290 ;   # capital Ukrainian soft G\n+    A6  C2A6 ;   # borken bar\n+    A7  C2A7 ;   # section sign\n+    A8  D081 ;   # capital YO\n+    A9  C2A9 ;   # (C)\n+    AA  D084 ;   # capital Ukrainian YE\n+    AB  C2AB ;   # left-pointing double angle quotation mark\n+    AC  C2AC ;   # not sign\n+    AD  C2AD ;   # soft hypen\n+    AE  C2AE ;   # (R)\n+    AF  D087 ;   # capital Ukrainian YI\n+\n+    B0  C2B0 ;   # &deg;\n+    B1  C2B1 ;   # plus-minus sign\n+    B2  D086 ;   # capital Ukrainian I\n+    B3  D196 ;   # small Ukrainian i\n+    B4  D291 ;   # small Ukrainian soft g\n+    B5  C2B5 ;   # micro sign\n+    B6  C2B6 ;   # pilcrow sign\n+    B7  C2B7 ;   # &middot;\n+    B8  D191 ;   # small yo\n+    B9  E28496 ; # numero sign\n+    BA  D194 ;   # small Ukrainian ye\n+    BB  C2BB ;   # right-pointing double angle quotation mark\n+\n+    BF  D197 ;   # small Ukrainian yi\n+\n+    C0  D090 ;   # capital A\n+    C1  D091 ;   # capital B\n+    C2  D092 ;   # capital V\n+    C3  D093 ;   # capital G\n+    C4  D094 ;   # capital D\n+    C5  D095 ;   # capital YE\n+    C6  D096 ;   # capital ZH\n+    C7  D097 ;   # capital Z\n+    C8  D098 ;   # capital I\n+    C9  D099 ;   # capital J\n+    CA  D09A ;   # capital K\n+    CB  D09B ;   # capital L\n+    CC  D09C ;   # capital M\n+    CD  D09D ;   # capital N\n+    CE  D09E ;   # capital O\n+    CF  D09F ;   # capital P\n+\n+    D0  D0A0 ;   # capital R\n+    D1  D0A1 ;   # capital S\n+    D2  D0A2 ;   # capital T\n+    D3  D0A3 ;   # capital U\n+    D4  D0A4 ;   # capital F\n+    D5  D0A5 ;   # capital KH\n+    D6  D0A6 ;   # capital TS\n+    D7  D0A7 ;   # capital CH\n+    D8  D0A8 ;   # capital SH\n+    D9  D0A9 ;   # capital SHCH\n+    DA  D0AA ;   # capital hard sign\n+    DB  D0AB ;   # capital Y\n+    DC  D0AC ;   # capital soft sign\n+    DD  D0AD ;   # capital E\n+    DE  D0AE ;   # capital YU\n+    DF  D0AF ;   # capital YA\n+\n+    E0  D0B0 ;   # small a\n+    E1  D0B1 ;   # small b\n+    E2  D0B2 ;   # small v\n+    E3  D0B3 ;   # small g\n+    E4  D0B4 ;   # small d\n+    E5  D0B5 ;   # small ye\n+    E6  D0B6 ;   # small zh\n+    E7  D0B7 ;   # small z\n+    E8  D0B8 ;   # small i\n+    E9  D0B9 ;   # small j\n+    EA  D0BA ;   # small k\n+    EB  D0BB ;   # small l\n+    EC  D0BC ;   # small m\n+    ED  D0BD ;   # small n\n+    EE  D0BE ;   # small o\n+    EF  D0BF ;   # small p\n+\n+    F0  D180 ;   # small r\n+    F1  D181 ;   # small s\n+    F2  D182 ;   # small t\n+    F3  D183 ;   # small u\n+    F4  D184 ;   # small f\n+    F5  D185 ;   # small kh\n+    F6  D186 ;   # small ts\n+    F7  D187 ;   # small ch\n+    F8  D188 ;   # small sh\n+    F9  D189 ;   # small shch\n+    FA  D18A ;   # small hard sign\n+    FB  D18B ;   # small y\n+    FC  D18C ;   # small soft sign\n+    FD  D18D ;   # small e\n+    FE  D18E ;   # small yu\n+    FF  D18F ;   # small ya\n+}\nDiff:\n@@ -0,0 +1,121 @@\n+#!/bin/sh\n+\n+# Copyright (C) Igor Sysoev\n+# Copyright (C) Nginx, Inc.\n+\n+\n+LC_ALL=C\n+export LC_ALL\n+\n+. auto/options\n+. auto/init\n+. auto/sources\n+\n+test -d $NGX_OBJS || mkdir -p $NGX_OBJS\n+\n+echo > $NGX_AUTO_HEADERS_H\n+echo > $NGX_AUTOCONF_ERR\n+\n+echo \"#define NGX_CONFIGURE \\\"$NGX_CONFIGURE\\\"\" > $NGX_AUTO_CONFIG_H\n+\n+\n+if [ $NGX_DEBUG = YES ]; then\n+    have=NGX_DEBUG . auto/have\n+fi\n+\n+\n+if test -z \"$NGX_PLATFORM\"; then\n+    echo \"checking for OS\"\n+\n+    NGX_SYSTEM=`uname -s 2>/dev/null`\n+    NGX_RELEASE=`uname -r 2>/dev/null`\n+    NGX_MACHINE=`uname -m 2>/dev/null`\n+\n+    echo \" + $NGX_SYSTEM $NGX_RELEASE $NGX_MACHINE\"\n+\n+    NGX_PLATFORM=\"$NGX_SYSTEM:$NGX_RELEASE:$NGX_MACHINE\";\n+\n+    case \"$NGX_SYSTEM\" in\n+        MINGW32_* | MINGW64_* | MSYS_*)\n+            NGX_PLATFORM=win32\n+        ;;\n+    esac\n+\n+else\n+    echo \"building for $NGX_PLATFORM\"\n+    NGX_SYSTEM=$NGX_PLATFORM\n+    NGX_MACHINE=i386\n+fi\n+\n+. auto/cc/conf\n+\n+if [ \"$NGX_PLATFORM\" != win32 ]; then\n+    . auto/headers\n+fi\n+\n+. auto/os/conf\n+\n+if [ \"$NGX_PLATFORM\" != win32 ]; then\n+    . auto/unix\n+fi\n+\n+. auto/threads\n+. auto/modules\n+. auto/lib/conf\n+\n+case \".$NGX_PREFIX\" in\n+    .)\n+        NGX_PREFIX=${NGX_PREFIX:-/usr/local/nginx}\n+        have=NGX_PREFIX value=\"\\\"$NGX_PREFIX/\\\"\" . auto/define\n+    ;;\n+\n+    .!)\n+        NGX_PREFIX=\n+    ;;\n+\n+    *)\n+        have=NGX_PREFIX value=\"\\\"$NGX_PREFIX/\\\"\" . auto/define\n+    ;;\n+esac\n+\n+if [ \".$NGX_CONF_PREFIX\" != \".\" ]; then\n+    have=NGX_CONF_PREFIX value=\"\\\"$NGX_CONF_PREFIX/\\\"\" . auto/define\n+fi\n+\n+have=NGX_SBIN_PATH value=\"\\\"$NGX_SBIN_PATH\\\"\" . auto/define\n+have=NGX_CONF_PATH value=\"\\\"$NGX_CONF_PATH\\\"\" . auto/define\n+have=NGX_PID_PATH value=\"\\\"$NGX_PID_PATH\\\"\" . auto/define\n+have=NGX_LOCK_PATH value=\"\\\"$NGX_LOCK_PATH\\\"\" . auto/define\n+have=NGX_ERROR_LOG_PATH value=\"\\\"$NGX_ERROR_LOG_PATH\\\"\" . auto/define\n+\n+if [ \".$NGX_ERROR_LOG_PATH\" = \".\" ]; then\n+    have=NGX_ERROR_LOG_STDERR . auto/have\n+fi\n+\n+have=NGX_HTTP_LOG_PATH value=\"\\\"$NGX_HTTP_LOG_PATH\\\"\" . auto/define\n+have=NGX_HTTP_CLIENT_TEMP_PATH value=\"\\\"$NGX_HTTP_CLIENT_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_PROXY_TEMP_PATH value=\"\\\"$NGX_HTTP_PROXY_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_FASTCGI_TEMP_PATH value=\"\\\"$NGX_HTTP_FASTCGI_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_UWSGI_TEMP_PATH value=\"\\\"$NGX_HTTP_UWSGI_TEMP_PATH\\\"\"\n+. auto/define\n+have=NGX_HTTP_SCGI_TEMP_PATH value=\"\\\"$NGX_HTTP_SCGI_TEMP_PATH\\\"\"\n+. auto/define\n+\n+. auto/make\n+. auto/lib/make\n+. auto/install\n+\n+# STUB\n+. auto/stubs\n+\n+have=NGX_USER value=\"\\\"$NGX_USER\\\"\" . auto/define\n+have=NGX_GROUP value=\"\\\"$NGX_GROUP\\\"\" . auto/define\n+\n+if [ \".$NGX_BUILD\" != \".\" ]; then\n+    have=NGX_BUILD value=\"\\\"$NGX_BUILD\\\"\" . auto/define\n+fi\n+\n+. auto/summary\nDiff:\n@@ -0,0 +1,21 @@\n+\n+geo2nginx.pl \t\tby Andrei Nigmatulin\n+\n+\tThe perl script to convert CSV geoip database ( free download\n+\tat http://www.maxmind.com/app/geoip_country ) to format, suitable\n+\tfor use by the ngx_http_geo_module.\n+\n+\n+unicode2nginx\t\tby Maxim Dounin\n+\n+\tThe perl script to convert unicode mappings ( available\n+\tat http://www.unicode.org/Public/MAPPINGS/ ) to the nginx\n+\tconfiguration file format.\n+\tTwo generated full maps for windows-1251 and koi8-r.\n+\n+\n+vim\t\t\tby Evan Miller\n+\n+\tSyntax highlighting of nginx configuration for vim, to be\n+\tplaced into ~/.vim/.\n+\nDiff:\n@@ -0,0 +1,58 @@\n+#!/usr/bin/perl -w\r\n+\r\n+# (c) Andrei Nigmatulin, 2005\r\n+#\r\n+# this script provided \"as is\", without any warranties. use it at your own risk.\r\n+#\r\n+# special thanx to Andrew Sitnikov for perl port\r\n+#\r\n+# this script converts CSV geoip database (free download at http://www.maxmind.com/app/geoip_country)\r\n+# to format, suitable for use with nginx_http_geo module (http://sysoev.ru/nginx)\r\n+#\r\n+# for example, line with ip range\r\n+#\r\n+#   \"62.16.68.0\",\"62.16.127.255\",\"1041253376\",\"1041268735\",\"RU\",\"Russian Federation\"\r\n+#\r\n+# will be converted to four subnetworks:\r\n+#\r\n+#   62.16.68.0/22 RU;\r\n+#   62.16.72.0/21 RU;\r\n+#   62.16.80.0/20 RU;\r\n+#   62.16.96.0/19 RU;\r\n+\r\n+\r\n+use warnings;\r\n+use strict;\r\n+\r\n+while( <STDIN> ){\r\n+\tif (/\"[^\"]+\",\"[^\"]+\",\"([^\"]+)\",\"([^\"]+)\",\"([^\"]+)\"/){\r\n+\t\tprint_subnets($1, $2, $3);\r\n+\t}\r\n+}\r\n+\r\n+sub  print_subnets {\r\n+\tmy ($a1, $a2, $c) = @_;\r\n+\tmy $l;\r\n+    while ($a1 <= $a2) {\r\n+\t\tfor ($l = 0; ($a1 & (1 << $l)) == 0 && ($a1 + ((1 << ($l + 1)) - 1)) <= $a2; $l++){};\r\n+\t\tprint long2ip($a1) . \"/\" . (32 - $l) . \" \" . $c . \";\\n\";\r\n+    \t$a1 += (1 << $l);\r\n+\t}\r\n+}\r\n+\r\n+sub long2ip {\r\n+\tmy $ip = shift;\r\n+\r\n+\tmy $str = 0;\r\n+\r\n+\t$str = ($ip & 255);\r\n+\r\n+\t$ip >>= 8;\r\n+\t$str = ($ip & 255).\".$str\";\r\n+\r\n+\t$ip >>= 8;\r\n+\t$str = ($ip & 255).\".$str\";\r\n+\r\n+\t$ip >>= 8;\r\n+\t$str = ($ip & 255).\".$str\";\r\n+}\r\nDiff:\n@@ -0,0 +1,131 @@\n+charset_map  koi8-r  utf-8 {\n+\n+    80  E29480 ; #\tBOX DRAWINGS LIGHT HORIZONTAL\n+    81  E29482 ; #\tBOX DRAWINGS LIGHT VERTICAL\n+    82  E2948C ; #\tBOX DRAWINGS LIGHT DOWN AND RIGHT\n+    83  E29490 ; #\tBOX DRAWINGS LIGHT DOWN AND LEFT\n+    84  E29494 ; #\tBOX DRAWINGS LIGHT UP AND RIGHT\n+    85  E29498 ; #\tBOX DRAWINGS LIGHT UP AND LEFT\n+    86  E2949C ; #\tBOX DRAWINGS LIGHT VERTICAL AND RIGHT\n+    87  E294A4 ; #\tBOX DRAWINGS LIGHT VERTICAL AND LEFT\n+    88  E294AC ; #\tBOX DRAWINGS LIGHT DOWN AND HORIZONTAL\n+    89  E294B4 ; #\tBOX DRAWINGS LIGHT UP AND HORIZONTAL\n+    8A  E294BC ; #\tBOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL\n+    8B  E29680 ; #\tUPPER HALF BLOCK\n+    8C  E29684 ; #\tLOWER HALF BLOCK\n+    8D  E29688 ; #\tFULL BLOCK\n+    8E  E2968C ; #\tLEFT HALF BLOCK\n+    8F  E29690 ; #\tRIGHT HALF BLOCK\n+    90  E29691 ; #\tLIGHT SHADE\n+    91  E29692 ; #\tMEDIUM SHADE\n+    92  E29693 ; #\tDARK SHADE\n+    93  E28CA0 ; #\tTOP HALF INTEGRAL\n+    94  E296A0 ; #\tBLACK SQUARE\n+    95  E28899 ; #\tBULLET OPERATOR\n+    96  E2889A ; #\tSQUARE ROOT\n+    97  E28988 ; #\tALMOST EQUAL TO\n+    98  E289A4 ; #\tLESS-THAN OR EQUAL TO\n+    99  E289A5 ; #\tGREATER-THAN OR EQUAL TO\n+    9A  C2A0 ; #\tNO-BREAK SPACE\n+    9B  E28CA1 ; #\tBOTTOM HALF INTEGRAL\n+    9C  C2B0 ; #\tDEGREE SIGN\n+    9D  C2B2 ; #\tSUPERSCRIPT TWO\n+    9E  C2B7 ; #\tMIDDLE DOT\n+    9F  C3B7 ; #\tDIVISION SIGN\n+    A0  E29590 ; #\tBOX DRAWINGS DOUBLE HORIZONTAL\n+    A1  E29591 ; #\tBOX DRAWINGS DOUBLE VERTICAL\n+    A2  E29592 ; #\tBOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE\n+    A3  D191 ; #\tCYRILLIC SMALL LETTER IO\n+    A4  E29593 ; #\tBOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE\n+    A5  E29594 ; #\tBOX DRAWINGS DOUBLE DOWN AND RIGHT\n+    A6  E29595 ; #\tBOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE\n+    A7  E29596 ; #\tBOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE\n+    A8  E29597 ; #\tBOX DRAWINGS DOUBLE DOWN AND LEFT\n+    A9  E29598 ; #\tBOX DRAWINGS UP SINGLE AND RIGHT DOUBLE\n+    AA  E29599 ; #\tBOX DRAWINGS UP DOUBLE AND RIGHT SINGLE\n+    AB  E2959A ; #\tBOX DRAWINGS DOUBLE UP AND RIGHT\n+    AC  E2959B ; #\tBOX DRAWINGS UP SINGLE AND LEFT DOUBLE\n+    AD  E2959C ; #\tBOX DRAWINGS UP DOUBLE AND LEFT SINGLE\n+    AE  E2959D ; #\tBOX DRAWINGS DOUBLE UP AND LEFT\n+    AF  E2959E ; #\tBOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE\n+    B0  E2959F ; #\tBOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE\n+    B1  E295A0 ; #\tBOX DRAWINGS DOUBLE VERTICAL AND RIGHT\n+    B2  E295A1 ; #\tBOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE\n+    B3  D081 ; #\tCYRILLIC CAPITAL LETTER IO\n+    B4  E295A2 ; #\tBOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE\n+    B5  E295A3 ; #\tBOX DRAWINGS DOUBLE VERTICAL AND LEFT\n+    B6  E295A4 ; #\tBOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE\n+    B7  E295A5 ; #\tBOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE\n+    B8  E295A6 ; #\tBOX DRAWINGS DOUBLE DOWN AND HORIZONTAL\n+    B9  E295A7 ; #\tBOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE\n+    BA  E295A8 ; #\tBOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE\n+    BB  E295A9 ; #\tBOX DRAWINGS DOUBLE UP AND HORIZONTAL\n+    BC  E295AA ; #\tBOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE\n+    BD  E295AB ; #\tBOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE\n+    BE  E295AC ; #\tBOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL\n+    BF  C2A9 ; #\tCOPYRIGHT SIGN\n+    C0  D18E ; #\tCYRILLIC SMALL LETTER YU\n+    C1  D0B0 ; #\tCYRILLIC SMALL LETTER A\n+    C2  D0B1 ; #\tCYRILLIC SMALL LETTER BE\n+    C3  D186 ; #\tCYRILLIC SMALL LETTER TSE\n+    C4  D0B4 ; #\tCYRILLIC SMALL LETTER DE\n+    C5  D0B5 ; #\tCYRILLIC SMALL LETTER IE\n+    C6  D184 ; #\tCYRILLIC SMALL LETTER EF\n+    C7  D0B3 ; #\tCYRILLIC SMALL LETTER GHE\n+    C8  D185 ; #\tCYRILLIC SMALL LETTER HA\n+    C9  D0B8 ; #\tCYRILLIC SMALL LETTER I\n+    CA  D0B9 ; #\tCYRILLIC SMALL LETTER SHORT I\n+    CB  D0BA ; #\tCYRILLIC SMALL LETTER KA\n+    CC  D0BB ; #\tCYRILLIC SMALL LETTER EL\n+    CD  D0BC ; #\tCYRILLIC SMALL LETTER EM\n+    CE  D0BD ; #\tCYRILLIC SMALL LETTER EN\n+    CF  D0BE ; #\tCYRILLIC SMALL LETTER O\n+    D0  D0BF ; #\tCYRILLIC SMALL LETTER PE\n+    D1  D18F ; #\tCYRILLIC SMALL LETTER YA\n+    D2  D180 ; #\tCYRILLIC SMALL LETTER ER\n+    D3  D181 ; #\tCYRILLIC SMALL LETTER ES\n+    D4  D182 ; #\tCYRILLIC SMALL LETTER TE\n+    D5  D183 ; #\tCYRILLIC SMALL LETTER U\n+    D6  D0B6 ; #\tCYRILLIC SMALL LETTER ZHE\n+    D7  D0B2 ; #\tCYRILLIC SMALL LETTER VE\n+    D8  D18C ; #\tCYRILLIC SMALL LETTER SOFT SIGN\n+    D9  D18B ; #\tCYRILLIC SMALL LETTER YERU\n+    DA  D0B7 ; #\tCYRILLIC SMALL LETTER ZE\n+    DB  D188 ; #\tCYRILLIC SMALL LETTER SHA\n+    DC  D18D ; #\tCYRILLIC SMALL LETTER E\n+    DD  D189 ; #\tCYRILLIC SMALL LETTER SHCHA\n+    DE  D187 ; #\tCYRILLIC SMALL LETTER CHE\n+    DF  D18A ; #\tCYRILLIC SMALL LETTER HARD SIGN\n+    E0  D0AE ; #\tCYRILLIC CAPITAL LETTER YU\n+    E1  D090 ; #\tCYRILLIC CAPITAL LETTER A\n+    E2  D091 ; #\tCYRILLIC CAPITAL LETTER BE\n+    E3  D0A6 ; #\tCYRILLIC CAPITAL LETTER TSE\n+    E4  D094 ; #\tCYRILLIC CAPITAL LETTER DE\n+    E5  D095 ; #\tCYRILLIC CAPITAL LETTER IE\n+    E6  D0A4 ; #\tCYRILLIC CAPITAL LETTER EF\n+    E7  D093 ; #\tCYRILLIC CAPITAL LETTER GHE\n+    E8  D0A5 ; #\tCYRILLIC CAPITAL LETTER HA\n+    E9  D098 ; #\tCYRILLIC CAPITAL LETTER I\n+    EA  D099 ; #\tCYRILLIC CAPITAL LETTER SHORT I\n+    EB  D09A ; #\tCYRILLIC CAPITAL LETTER KA\n+    EC  D09B ; #\tCYRILLIC CAPITAL LETTER EL\n+    ED  D09C ; #\tCYRILLIC CAPITAL LETTER EM\n+    EE  D09D ; #\tCYRILLIC CAPITAL LETTER EN\n+    EF  D09E ; #\tCYRILLIC CAPITAL LETTER O\n+    F0  D09F ; #\tCYRILLIC CAPITAL LETTER PE\n+    F1  D0AF ; #\tCYRILLIC CAPITAL LETTER YA\n+    F2  D0A0 ; #\tCYRILLIC CAPITAL LETTER ER\n+    F3  D0A1 ; #\tCYRILLIC CAPITAL LETTER ES\n+    F4  D0A2 ; #\tCYRILLIC CAPITAL LETTER TE\n+    F5  D0A3 ; #\tCYRILLIC CAPITAL LETTER U\n+    F6  D096 ; #\tCYRILLIC CAPITAL LETTER ZHE\n+    F7  D092 ; #\tCYRILLIC CAPITAL LETTER VE\n+    F8  D0AC ; #\tCYRILLIC CAPITAL LETTER SOFT SIGN\n+    F9  D0AB ; #\tCYRILLIC CAPITAL LETTER YERU\n+    FA  D097 ; #\tCYRILLIC CAPITAL LETTER ZE\n+    FB  D0A8 ; #\tCYRILLIC CAPITAL LETTER SHA\n+    FC  D0AD ; #\tCYRILLIC CAPITAL LETTER E\n+    FD  D0A9 ; #\tCYRILLIC CAPITAL LETTER SHCHA\n+    FE  D0A7 ; #\tCYRILLIC CAPITAL LETTER CHE\n+    FF  D0AA ; #\tCYRILLIC CAPITAL LETTER HARD SIGN\n+}\nDiff:\n@@ -0,0 +1,48 @@\n+#!/usr/bin/perl -w\n+\n+# Convert unicode mappings to nginx configuration file format.\n+\n+# You may find useful mappings in various places, including\n+# unicode.org official site:\n+#\n+# http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1251.TXT\n+# http://www.unicode.org/Public/MAPPINGS/VENDORS/MISC/KOI8-R.TXT\n+\n+# Needs perl 5.6 or later.\n+\n+# Written by Maxim Dounin, mdounin@mdounin.ru\n+\n+###############################################################################\n+\n+require 5.006;\n+\n+while (<>) {\n+\t# Skip comments and empty lines\n+\n+\tnext if /^#/;\n+\tnext if /^\\s*$/;\n+\tchomp;\n+\n+\t# Convert mappings\n+\n+\tif (/^\\s*0x(..)\\s*0x(....)\\s*(#.*)/) {\n+\t\t# Mapping <from-code> <unicode-code> \"#\" <unicode-name>\n+\t\tmy $cs_code = $1;\n+\t\tmy $un_code = $2;\n+\t\tmy $un_name = $3;\n+\n+\t\t# Produce UTF-8 sequence from character code;\n+\n+\t\tmy $un_utf8 = join('',\n+\t\t\tmap { sprintf(\"%02X\", $_) }\n+\t\t\tunpack(\"U0C*\", pack(\"U\", hex($un_code)))\n+\t\t);\n+\n+\t\tprint \"    $cs_code  $un_utf8 ; $un_name\\n\";\n+\n+\t} else {\n+\t\twarn \"Unrecognized line: '$_'\";\n+\t}\n+}\n+\n+###############################################################################\nDiff:\n@@ -0,0 +1,130 @@\n+charset_map  windows-1251  utf-8 {\n+\n+    80  D082 ; #CYRILLIC CAPITAL LETTER DJE\n+    81  D083 ; #CYRILLIC CAPITAL LETTER GJE\n+    82  E2809A ; #SINGLE LOW-9 QUOTATION MARK\n+    83  D193 ; #CYRILLIC SMALL LETTER GJE\n+    84  E2809E ; #DOUBLE LOW-9 QUOTATION MARK\n+    85  E280A6 ; #HORIZONTAL ELLIPSIS\n+    86  E280A0 ; #DAGGER\n+    87  E280A1 ; #DOUBLE DAGGER\n+    88  E282AC ; #EURO SIGN\n+    89  E280B0 ; #PER MILLE SIGN\n+    8A  D089 ; #CYRILLIC CAPITAL LETTER LJE\n+    8B  E280B9 ; #SINGLE LEFT-POINTING ANGLE QUOTATION MARK\n+    8C  D08A ; #CYRILLIC CAPITAL LETTER NJE\n+    8D  D08C ; #CYRILLIC CAPITAL LETTER KJE\n+    8E  D08B ; #CYRILLIC CAPITAL LETTER TSHE\n+    8F  D08F ; #CYRILLIC CAPITAL LETTER DZHE\n+    90  D192 ; #CYRILLIC SMALL LETTER DJE\n+    91  E28098 ; #LEFT SINGLE QUOTATION MARK\n+    92  E28099 ; #RIGHT SINGLE QUOTATION MARK\n+    93  E2809C ; #LEFT DOUBLE QUOTATION MARK\n+    94  E2809D ; #RIGHT DOUBLE QUOTATION MARK\n+    95  E280A2 ; #BULLET\n+    96  E28093 ; #EN DASH\n+    97  E28094 ; #EM DASH\n+    99  E284A2 ; #TRADE MARK SIGN\n+    9A  D199 ; #CYRILLIC SMALL LETTER LJE\n+    9B  E280BA ; #SINGLE RIGHT-POINTING ANGLE QUOTATION MARK\n+    9C  D19A ; #CYRILLIC SMALL LETTER NJE\n+    9D  D19C ; #CYRILLIC SMALL LETTER KJE\n+    9E  D19B ; #CYRILLIC SMALL LETTER TSHE\n+    9F  D19F ; #CYRILLIC SMALL LETTER DZHE\n+    A0  C2A0 ; #NO-BREAK SPACE\n+    A1  D08E ; #CYRILLIC CAPITAL LETTER SHORT U\n+    A2  D19E ; #CYRILLIC SMALL LETTER SHORT U\n+    A3  D088 ; #CYRILLIC CAPITAL LETTER JE\n+    A4  C2A4 ; #CURRENCY SIGN\n+    A5  D290 ; #CYRILLIC CAPITAL LETTER GHE WITH UPTURN\n+    A6  C2A6 ; #BROKEN BAR\n+    A7  C2A7 ; #SECTION SIGN\n+    A8  D081 ; #CYRILLIC CAPITAL LETTER IO\n+    A9  C2A9 ; #COPYRIGHT SIGN\n+    AA  D084 ; #CYRILLIC CAPITAL LETTER UKRAINIAN IE\n+    AB  C2AB ; #LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\n+    AC  C2AC ; #NOT SIGN\n+    AD  C2AD ; #SOFT HYPHEN\n+    AE  C2AE ; #REGISTERED SIGN\n+    AF  D087 ; #CYRILLIC CAPITAL LETTER YI\n+    B0  C2B0 ; #DEGREE SIGN\n+    B1  C2B1 ; #PLUS-MINUS SIGN\n+    B2  D086 ; #CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I\n+    B3  D196 ; #CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I\n+    B4  D291 ; #CYRILLIC SMALL LETTER GHE WITH UPTURN\n+    B5  C2B5 ; #MICRO SIGN\n+    B6  C2B6 ; #PILCROW SIGN\n+    B7  C2B7 ; #MIDDLE DOT\n+    B8  D191 ; #CYRILLIC SMALL LETTER IO\n+    B9  E28496 ; #NUMERO SIGN\n+    BA  D194 ; #CYRILLIC SMALL LETTER UKRAINIAN IE\n+    BB  C2BB ; #RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\n+    BC  D198 ; #CYRILLIC SMALL LETTER JE\n+    BD  D085 ; #CYRILLIC CAPITAL LETTER DZE\n+    BE  D195 ; #CYRILLIC SMALL LETTER DZE\n+    BF  D197 ; #CYRILLIC SMALL LETTER YI\n+    C0  D090 ; #CYRILLIC CAPITAL LETTER A\n+    C1  D091 ; #CYRILLIC CAPITAL LETTER BE\n+    C2  D092 ; #CYRILLIC CAPITAL LETTER VE\n+    C3  D093 ; #CYRILLIC CAPITAL LETTER GHE\n+    C4  D094 ; #CYRILLIC CAPITAL LETTER DE\n+    C5  D095 ; #CYRILLIC CAPITAL LETTER IE\n+    C6  D096 ; #CYRILLIC CAPITAL LETTER ZHE\n+    C7  D097 ; #CYRILLIC CAPITAL LETTER ZE\n+    C8  D098 ; #CYRILLIC CAPITAL LETTER I\n+    C9  D099 ; #CYRILLIC CAPITAL LETTER SHORT I\n+    CA  D09A ; #CYRILLIC CAPITAL LETTER KA\n+    CB  D09B ; #CYRILLIC CAPITAL LETTER EL\n+    CC  D09C ; #CYRILLIC CAPITAL LETTER EM\n+    CD  D09D ; #CYRILLIC CAPITAL LETTER EN\n+    CE  D09E ; #CYRILLIC CAPITAL LETTER O\n+    CF  D09F ; #CYRILLIC CAPITAL LETTER PE\n+    D0  D0A0 ; #CYRILLIC CAPITAL LETTER ER\n+    D1  D0A1 ; #CYRILLIC CAPITAL LETTER ES\n+    D2  D0A2 ; #CYRILLIC CAPITAL LETTER TE\n+    D3  D0A3 ; #CYRILLIC CAPITAL LETTER U\n+    D4  D0A4 ; #CYRILLIC CAPITAL LETTER EF\n+    D5  D0A5 ; #CYRILLIC CAPITAL LETTER HA\n+    D6  D0A6 ; #CYRILLIC CAPITAL LETTER TSE\n+    D7  D0A7 ; #CYRILLIC CAPITAL LETTER CHE\n+    D8  D0A8 ; #CYRILLIC CAPITAL LETTER SHA\n+    D9  D0A9 ; #CYRILLIC CAPITAL LETTER SHCHA\n+    DA  D0AA ; #CYRILLIC CAPITAL LETTER HARD SIGN\n+    DB  D0AB ; #CYRILLIC CAPITAL LETTER YERU\n+    DC  D0AC ; #CYRILLIC CAPITAL LETTER SOFT SIGN\n+    DD  D0AD ; #CYRILLIC CAPITAL LETTER E\n+    DE  D0AE ; #CYRILLIC CAPITAL LETTER YU\n+    DF  D0AF ; #CYRILLIC CAPITAL LETTER YA\n+    E0  D0B0 ; #CYRILLIC SMALL LETTER A\n+    E1  D0B1 ; #CYRILLIC SMALL LETTER BE\n+    E2  D0B2 ; #CYRILLIC SMALL LETTER VE\n+    E3  D0B3 ; #CYRILLIC SMALL LETTER GHE\n+    E4  D0B4 ; #CYRILLIC SMALL LETTER DE\n+    E5  D0B5 ; #CYRILLIC SMALL LETTER IE\n+    E6  D0B6 ; #CYRILLIC SMALL LETTER ZHE\n+    E7  D0B7 ; #CYRILLIC SMALL LETTER ZE\n+    E8  D0B8 ; #CYRILLIC SMALL LETTER I\n+    E9  D0B9 ; #CYRILLIC SMALL LETTER SHORT I\n+    EA  D0BA ; #CYRILLIC SMALL LETTER KA\n+    EB  D0BB ; #CYRILLIC SMALL LETTER EL\n+    EC  D0BC ; #CYRILLIC SMALL LETTER EM\n+    ED  D0BD ; #CYRILLIC SMALL LETTER EN\n+    EE  D0BE ; #CYRILLIC SMALL LETTER O\n+    EF  D0BF ; #CYRILLIC SMALL LETTER PE\n+    F0  D180 ; #CYRILLIC SMALL LETTER ER\n+    F1  D181 ; #CYRILLIC SMALL LETTER ES\n+    F2  D182 ; #CYRILLIC SMALL LETTER TE\n+    F3  D183 ; #CYRILLIC SMALL LETTER U\n+    F4  D184 ; #CYRILLIC SMALL LETTER EF\n+    F5  D185 ; #CYRILLIC SMALL LETTER HA\n+    F6  D186 ; #CYRILLIC SMALL LETTER TSE\n+    F7  D187 ; #CYRILLIC SMALL LETTER CHE\n+    F8  D188 ; #CYRILLIC SMALL LETTER SHA\n+    F9  D189 ; #CYRILLIC SMALL LETTER SHCHA\n+    FA  D18A ; #CYRILLIC SMALL LETTER HARD SIGN\n+    FB  D18B ; #CYRILLIC SMALL LETTER YERU\n+    FC  D18C ; #CYRILLIC SMALL LETTER SOFT SIGN\n+    FD  D18D ; #CYRILLIC SMALL LETTER E\n+    FE  D18E ; #CYRILLIC SMALL LETTER YU\n+    FF  D18F ; #CYRILLIC SMALL LETTER YA\n+}\nDiff:\n@@ -0,0 +1,4 @@\n+au BufRead,BufNewFile *.nginx set ft=nginx\n+au BufRead,BufNewFile */etc/nginx/* set ft=nginx\n+au BufRead,BufNewFile */usr/local/nginx/conf/* set ft=nginx\n+au BufRead,BufNewFile nginx.conf set ft=nginx\nDiff:\n@@ -0,0 +1 @@\n+setlocal commentstring=#\\ %s\nDiff:\n@@ -0,0 +1,11 @@\n+if exists(\"b:did_indent\")\n+    finish\n+endif\n+let b:did_indent = 1\n+\n+setlocal indentexpr=\n+\n+\" cindent actually works for nginx' simple file structure\n+setlocal cindent\n+\" Just make sure that the comments are not reset as defs would be.\n+setlocal cinkeys-=0#\nDiff:\nNone\nDiff:\n@@ -0,0 +1,41 @@\n+\n+VER=\t$(shell grep 'define NGINX_VERSION' src/core/nginx.h\t\t\\\n+\t\t| sed -e 's/^.*\"\\(.*\\)\".*/\\1/')\n+NGINX=\tnginx-$(VER)\n+TEMP=\ttmp\n+XSLS?=\txslscript.pl\n+\n+\n+all:\t\tchanges\n+\n+changes:\t$(TEMP)/$(NGINX)/CHANGES.ru\t\t\t\t\\\n+\t\t$(TEMP)/$(NGINX)/CHANGES\n+\n+\n+$(TEMP)/$(NGINX)/CHANGES.ru:\tdocs/dtd/changes.dtd\t\t\t\\\n+\t\t\t\tdocs/xml/nginx/changes.xml\t\t\\\n+\t\t\t\tdocs/xml/change_log_conf.xml\t\t\\\n+\t\t\t\tdocs/xslt/changes.xslt\n+\n+\tmkdir -p $(TEMP)/$(NGINX)\n+\n+\txmllint --noout --valid docs/xml/nginx/changes.xml\n+\txsltproc --stringparam lang ru\t\t\t\t\t\\\n+\t\t-o $@ docs/xslt/changes.xslt docs/xml/nginx/changes.xml\n+\n+\n+$(TEMP)/$(NGINX)/CHANGES:\tdocs/dtd/changes.dtd\t\t\t\\\n+\t\t\t\tdocs/xml/nginx/changes.xml\t\t\\\n+\t\t\t\tdocs/xml/change_log_conf.xml\t\t\\\n+\t\t\t\tdocs/xslt/changes.xslt\n+\n+\tmkdir -p $(TEMP)/$(NGINX)\n+\n+\txmllint --noout --valid docs/xml/nginx/changes.xml\n+\txsltproc --stringparam lang en\t\t\t\t\t\\\n+\t\t-o $@ docs/xslt/changes.xslt docs/xml/nginx/changes.xml\n+\n+\n+docs/xslt/changes.xslt:\t\tdocs/xsls/changes.xsls\n+\n+\t$(XSLS) -o $@ $<\nDiff:\n@@ -0,0 +1,22 @@\n+\n+<!ELEMENT configuration   (length, start, indent, changes+) >\n+\n+<!ELEMENT length          (#PCDATA) >\n+<!ELEMENT start           (#PCDATA) >\n+<!ELEMENT indent          (#PCDATA) >\n+\n+<!ELEMENT changes         (title, length,\n+                           bugfix, feature, change, workaround,\n+                           (month, month, month, month, month, month,\n+                            month, month, month, month, month, month)?) >\n+\n+<!ATTLIST changes         lang ( ru | en) #REQUIRED>\n+\n+<!ELEMENT title           (#PCDATA) >\n+\n+<!ELEMENT bugfix          (#PCDATA) >\n+<!ELEMENT feature         (#PCDATA) >\n+<!ELEMENT change          (#PCDATA) >\n+<!ELEMENT workaround      (#PCDATA) >\n+\n+<!ELEMENT month           (#PCDATA) >\nDiff:\n@@ -0,0 +1,22 @@\n+\n+<!ENTITY  nbsp         \"&#xA0;\" >\n+<!ENTITY  mdash        \"&#xA0;- \" >\n+\n+\n+<!ELEMENT change_log   (changes)* >\n+<!ATTLIST change_log   title  CDATA #REQUIRED >\n+\n+<!ELEMENT changes      (change)* >\n+<!ATTLIST changes      ver    CDATA #REQUIRED\n+                       date   CDATA #REQUIRED\n+>\n+\n+<!ELEMENT change       (para)* >\n+<!ATTLIST change       type (bugfix | feature | change | security | workaround) #IMPLIED >\n+\n+<!ELEMENT para         (#PCDATA | at | br | nobr)* >\n+<!ATTLIST para         lang (ru | en) #REQUIRED >\n+\n+<!ELEMENT at           EMPTY >\n+<!ELEMENT br           EMPTY >\n+<!ELEMENT nobr         (#PCDATA) >\nDiff:\n@@ -0,0 +1,21 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<title>Error</title>\n+<style>\n+    body {\n+        width: 35em;\n+        margin: 0 auto;\n+        font-family: Tahoma, Verdana, Arial, sans-serif;\n+    }\n+</style>\n+</head>\n+<body>\n+<h1>An error occurred.</h1>\n+<p>Sorry, the page you are looking for is currently unavailable.<br/>\n+Please try again later.</p>\n+<p>If you are the system administrator of this resource then you should check\n+the error log for details.</p>\n+<p><em>Faithfully yours, nginx.</em></p>\n+</body>\n+</html>\nDiff:\n@@ -0,0 +1,25 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<title>Welcome to nginx!</title>\n+<style>\n+    body {\n+        width: 35em;\n+        margin: 0 auto;\n+        font-family: Tahoma, Verdana, Arial, sans-serif;\n+    }\n+</style>\n+</head>\n+<body>\n+<h1>Welcome to nginx!</h1>\n+<p>If you see this page, the nginx web server is successfully installed and\n+working. Further configuration is required.</p>\n+\n+<p>For online documentation and support please refer to\n+<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\n+Commercial support is available at\n+<a href=\"http://nginx.com/\">nginx.com</a>.</p>\n+\n+<p><em>Thank you for using nginx.</em></p>\n+</body>\n+</html>\nDiff:\n@@ -0,0 +1,206 @@\n+.\\\"\n+.\\\" Copyright (C) 2010 Sergey A. Osokin\n+.\\\" Copyright (C) Nginx, Inc.\n+.\\\" All rights reserved.\n+.\\\"\n+.\\\" Redistribution and use in source and binary forms, with or without\n+.\\\" modification, are permitted provided that the following conditions\n+.\\\" are met:\n+.\\\" 1. Redistributions of source code must retain the above copyright\n+.\\\"    notice, this list of conditions and the following disclaimer.\n+.\\\" 2. Redistributions in binary form must reproduce the above copyright\n+.\\\"    notice, this list of conditions and the following disclaimer in the\n+.\\\"    documentation and/or other materials provided with the distribution.\n+.\\\"\n+.\\\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n+.\\\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+.\\\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+.\\\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+.\\\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+.\\\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+.\\\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+.\\\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+.\\\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+.\\\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+.\\\" SUCH DAMAGE.\n+.\\\"\n+.\\\"\n+.Dd June 16, 2015\n+.Dt NGINX 8\n+.Os\n+.Sh NAME\n+.Nm nginx\n+.Nd \"HTTP and reverse proxy server, mail proxy server\"\n+.Sh SYNOPSIS\n+.Nm\n+.Op Fl ?hqTtVv\n+.Op Fl c Ar file\n+.Op Fl g Ar directives\n+.Op Fl p Ar prefix\n+.Op Fl s Ar signal\n+.Sh DESCRIPTION\n+.Nm\n+(pronounced\n+.Dq engine x )\n+is an HTTP and reverse proxy server, as well as a mail proxy server.\n+It is known for its high performance, stability, rich feature set, simple\n+configuration, and low resource consumption.\n+.Pp\n+The options are as follows:\n+.Bl -tag -width \".Fl d Ar directives\"\n+.It Fl ?\\& , h\n+Print help.\n+.It Fl c Ar file\n+Use an alternative configuration\n+.Ar file .\n+.It Fl g Ar directives\n+Set global configuration directives.\n+See\n+.Sx EXAMPLES\n+for details.\n+.It Fl p Ar prefix\n+Set the prefix path.\n+The default value is\n+.Pa %%PREFIX%% .\n+.It Fl q\n+Suppress non-error messages during configuration testing.\n+.It Fl s Ar signal\n+Send a signal to the master process.\n+The argument\n+.Ar signal\n+can be one of:\n+.Cm stop , quit , reopen , reload .\n+The following table shows the corresponding system signals:\n+.Pp\n+.Bl -tag -width \".Cm reopen\" -compact\n+.It Cm stop\n+.Dv SIGTERM\n+.It Cm quit\n+.Dv SIGQUIT\n+.It Cm reopen\n+.Dv SIGUSR1\n+.It Cm reload\n+.Dv SIGHUP\n+.El\n+.It Fl t\n+Do not run, just test the configuration file.\n+.Nm\n+checks the configuration file syntax and then tries to open files\n+referenced in the configuration file.\n+.It Fl T\n+Same as\n+.Fl t ,\n+but additionally dump configuration files to standard output.\n+.It Fl V\n+Print the\n+.Nm\n+version, compiler version, and\n+.Pa configure\n+script parameters.\n+.It Fl v\n+Print the\n+.Nm\n+version.\n+.El\n+.Sh SIGNALS\n+The master process of\n+.Nm\n+can handle the following signals:\n+.Pp\n+.Bl -tag -width \".Dv SIGINT , SIGTERM\" -compact\n+.It Dv SIGINT , SIGTERM\n+Shut down quickly.\n+.It Dv SIGHUP\n+Reload configuration, start the new worker process with a new\n+configuration, and gracefully shut down old worker processes.\n+.It Dv SIGQUIT\n+Shut down gracefully.\n+.It Dv SIGUSR1\n+Reopen log files.\n+.It Dv SIGUSR2\n+Upgrade the\n+.Nm\n+executable on the fly.\n+.It Dv SIGWINCH\n+Shut down worker processes gracefully.\n+.El\n+.Pp\n+While there is no need to explicitly control worker processes normally,\n+they support some signals too:\n+.Pp\n+.Bl -tag -width \".Dv SIGINT , SIGTERM\" -compact\n+.It Dv SIGTERM\n+Shut down quickly.\n+.It Dv SIGQUIT\n+Shut down gracefully.\n+.It Dv SIGUSR1\n+Reopen log files.\n+.El\n+.Sh DEBUGGING LOG\n+To enable a debugging log, reconfigure\n+.Nm\n+to build with debugging:\n+.Pp\n+.Dl \"./configure --with-debug ...\"\n+.Pp\n+and then set the\n+.Cm debug\n+level of the\n+.Va error_log :\n+.Pp\n+.Dl \"error_log /path/to/log debug;\"\n+.Pp\n+It is also possible to enable the debugging for a particular IP address:\n+.Bd -literal -offset indent\n+events {\n+\tdebug_connection 127.0.0.1;\n+}\n+.Ed\n+.Sh ENVIRONMENT\n+The\n+.Ev NGINX\n+environment variable is used internally by\n+.Nm\n+and should not be set directly by the user.\n+.Sh FILES\n+.Bl -tag -width indent\n+.It Pa %%PID_PATH%%\n+Contains the process ID of\n+.Nm .\n+The contents of this file are not sensitive, so it can be world-readable.\n+.It Pa %%CONF_PATH%%\n+The main configuration file.\n+.It Pa %%ERROR_LOG_PATH%%\n+Error log file.\n+.El\n+.Sh EXIT STATUS\n+Exit status is 0 on success, or 1 if the command fails.\n+.Sh EXAMPLES\n+Test configuration file\n+.Pa ~/mynginx.conf\n+with global directives for PID and quantity of worker processes:\n+.Bd -literal -offset indent\n+nginx -t -c ~/mynginx.conf \\e\n+\t-g \"pid /var/run/mynginx.pid; worker_processes 2;\"\n+.Ed\n+.Sh SEE ALSO\n+.\\\"Xr nginx.conf 5\n+.\\\"Pp\n+Documentation at\n+.Pa http://nginx.org/en/docs/ .\n+.Pp\n+For questions and technical support, please refer to\n+.Pa http://nginx.org/en/support.html .\n+.Sh HISTORY\n+Development of\n+.Nm\n+started in 2002, with the first public release on October 4, 2004.\n+.Sh AUTHORS\n+.An -nosplit\n+.An Igor Sysoev Aq igor@sysoev.ru .\n+.Pp\n+This manual page was originally written by\n+.An Sergey A. Osokin Aq osa@FreeBSD.org.ru\n+as a result of compiling many\n+.Nm\n+documents from all over the world.\nDiff:\n@@ -0,0 +1,26 @@\n+/* \n+ * Copyright (C) 2002-2019 Igor Sysoev\n+ * Copyright (C) 2011-2019 Nginx, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\nDiff:\n@@ -0,0 +1,3 @@\n+\n+Documentation is available at http://nginx.org\n+\nDiff:\n@@ -0,0 +1,47 @@\n+<?xml version=\"1.0\" ?>\n+<!DOCTYPE configuration SYSTEM \"../dtd/change_log_conf.dtd\" >\n+\n+<configuration>\n+\n+<length>76</length>\n+\n+<start>    *) </start>\n+<indent>       </indent>\n+\n+<changes lang=\"ru\">\n+    <title>Изменения в </title>\n+    <length>66</length>\n+\n+    <bugfix>Исправление</bugfix>\n+    <feature>Добавление</feature>\n+    <change>Изменение</change>\n+    <security>Безопасность</security>\n+    <workaround>Изменение</workaround>\n+</changes>\n+\n+<changes lang=\"en\">\n+    <title>Changes with </title>\n+    <length>65</length>\n+\n+    <bugfix>Bugfix</bugfix>\n+    <feature>Feature</feature>\n+    <change>Change</change>\n+    <security>Security</security>\n+    <workaround>Workaround</workaround>\n+\n+    <month> Jan </month>\n+    <month> Feb </month>\n+    <month> Mar </month>\n+    <month> Apr </month>\n+    <month> May </month>\n+    <month> Jun </month>\n+    <month> Jul </month>\n+    <month> Aug </month>\n+    <month> Sep </month>\n+    <month> Oct </month>\n+    <month> Nov </month>\n+    <month> Dec </month>\n+\n+</changes>\n+\n+</configuration>\nDiff:\nNone\nDiff:\n@@ -0,0 +1,134 @@\n+X:stylesheet {\n+\n+X:output method=\"text\";\n+\n+X:param lang=\"'en'\";\n+X:param configuration=\"'../xml/change_log_conf.xml'\";\n+\n+X:var conf = \"document($configuration)/configuration\";\n+X:var start = \"$conf/start\";\n+X:var indent = \"$conf/indent\";\n+X:var max = \"$conf/length\";\n+X:var br = {&lt;br&gt;}\n+\n+\n+X:template = \"/\" { !! \"change_log\"; }\n+X:template = \"change_log\" { !! \"changes\"; }\n+\n+\n+X:template = \"changes\" {\n+    X:text {&#10;}\n+\n+    !{substring(concat($conf/changes[@lang=$lang]/title,\n+                       //change_log/@title,\n+                       ' ', @ver,\n+                       '                                                    '),\n+                1, $conf/changes[@lang=$lang]/length)}\n+\n+    X:if \"$lang='ru'\" {\n+        !{substring(@date, 9, 2)}\n+        X:text {.}\n+        !{substring(@date, 6, 2)}\n+        X:text {.}\n+        !{substring(@date, 1, 4)}\n+    }\n+\n+    X:if \"$lang='en'\" {\n+        !{substring(@date, 9, 2)}\n+        !{$conf/changes[@lang=$lang]/month[number(substring(current()/@date,\n+                                                            6, 2))]}\n+        !{substring(@date, 1, 4)}\n+    }\n+\n+    X:text {&#10;}\n+\n+    !! \"change\";\n+\n+    X:text {&#10;}\n+}\n+\n+\n+X:template = \"change\" {\n+    X:var prefix = \"$conf/changes[@lang=$lang]/*[local-name(.)=current()/@type]\"\n+\n+    X:var postfix = { X:if \"$prefix\" { X:text {: } } }\n+\n+    !! \"para[@lang=$lang]\" (prefix = \"concat($start, $prefix, $postfix)\");\n+}\n+\n+\n+X:template para(prefix) = \"para\" {\n+    X:var text = { !!; }\n+\n+    X:text {&#10;}\n+\n+    !wrap(text = \"normalize-space($text)\",\n+          prefix = { X:if \"position() = 1\" { !{$prefix} } else { !{$indent} } })\n+}\n+\n+\n+X:template wrap(text, prefix) {\n+    X:if \"$text\" {\n+        X:var offset = {\n+            X:choose {\n+                X:when \"starts-with($text, concat($br, ' '))\" {\n+                    !{string-length($br) + 2}\n+                }\n+                X:when \"starts-with($text, $br)\" {\n+                    !{string-length($br) + 1}\n+                }\n+                X:otherwise {\n+                    1\n+                }\n+            }\n+        }\n+\n+        X:var length = {\n+            !length(text = \"substring($text, $offset)\",\n+                    prefix = \"string-length($prefix)\",\n+                    length = \"$max\")\n+        }\n+\n+        !{$prefix}\n+\n+        !{normalize-space(translate(substring($text, $offset, $length),\n+                                    '&#xA0;', ' '))}\n+\n+        X:text {&#10;}\n+\n+        !wrap(text = \"substring($text, $length + $offset)\", prefix = \"$indent\")\n+    }\n+}\n+\n+\n+X:template length(text, prefix, length) {\n+    X:var break = \"substring-before(substring($text, 1,\n+                                    $length - $prefix + string-length($br)),\n+                                    $br)\"\n+\n+    X:choose {\n+        X:when \"$break\" { !{string-length($break)} }\n+\n+        X:when \"$length = 0\" { !{$max - $prefix} }\n+\n+        X:when \"string-length($text) + $prefix &lt;= $length\" {\n+            !{$length - $prefix}\n+        }\n+\n+        X:when \"substring($text, $length - $prefix + 1, 1) = ' '\" {\n+            !{$length - $prefix + 1}\n+        }\n+\n+        X:otherwise {\n+            !length(text = \"$text\", prefix = \"$prefix\", length = \"$length - 1\")\n+        }\n+    }\n+}\n+\n+\n+X:template = \"at\" {@}\n+X:template = \"br\" { !{$br} }\n+X:template = \"nobr\" { !{translate(., ' ', '&#xA0;')} }\n+\n+\n+}\nDiff:\n@@ -0,0 +1,128 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n+\n+<xsl:output method=\"text\"/>\n+\n+<xsl:param select=\"'en'\" name=\"lang\"/>\n+<xsl:param select=\"'../xml/change_log_conf.xml'\" name=\"configuration\"/>\n+\n+<xsl:variable select=\"document($configuration)/configuration\" name=\"conf\"/>\n+<xsl:variable select=\"$conf/start\" name=\"start\"/>\n+<xsl:variable select=\"$conf/indent\" name=\"indent\"/>\n+<xsl:variable select=\"$conf/length\" name=\"max\"/>\n+<xsl:variable name=\"br\">&lt;br&gt;</xsl:variable>\n+\n+\n+<xsl:template match=\"/\"> <xsl:apply-templates select=\"change_log\"/> </xsl:template>\n+<xsl:template match=\"change_log\"> <xsl:apply-templates select=\"changes\"/> </xsl:template>\n+\n+\n+<xsl:template match=\"changes\">\n+    <xsl:text>&#10;</xsl:text>\n+\n+    <xsl:value-of select=\"substring(concat($conf/changes[@lang=$lang]/title,\n+                       //change_log/@title,\n+                       ' ', @ver,\n+                       '                                                    '),\n+                1, $conf/changes[@lang=$lang]/length)\"/>\n+\n+    <xsl:if test=\"$lang='ru'\">\n+        <xsl:value-of select=\"substring(@date, 9, 2)\"/>\n+        <xsl:text>.</xsl:text>\n+        <xsl:value-of select=\"substring(@date, 6, 2)\"/>\n+        <xsl:text>.</xsl:text>\n+        <xsl:value-of select=\"substring(@date, 1, 4)\"/>\n+    </xsl:if>\n+\n+    <xsl:if test=\"$lang='en'\">\n+        <xsl:value-of select=\"substring(@date, 9, 2)\"/>\n+        <xsl:value-of select=\"$conf/changes[@lang=$lang]/month[number(substring(current()/@date,\n+                                                            6, 2))]\"/>\n+        <xsl:value-of select=\"substring(@date, 1, 4)\"/>\n+    </xsl:if>\n+\n+    <xsl:text>&#10;</xsl:text>\n+\n+    <xsl:apply-templates select=\"change\"/>\n+\n+    <xsl:text>&#10;</xsl:text>\n+</xsl:template>\n+\n+\n+<xsl:template match=\"change\">\n+    <xsl:variable select=\"$conf/changes[@lang=$lang]/*[local-name(.)=current()/@type]\" name=\"prefix\"/>\n+\n+    <xsl:variable name=\"postfix\"> <xsl:if test=\"$prefix\"> <xsl:text>: </xsl:text> </xsl:if> </xsl:variable>\n+\n+    <xsl:apply-templates select=\"para[@lang=$lang]\"><xsl:with-param select=\"concat($start, $prefix, $postfix)\" name=\"prefix\"/></xsl:apply-templates>\n+</xsl:template>\n+\n+\n+<xsl:template name=\"para\" match=\"para\"><xsl:param name=\"prefix\"/>\n+    <xsl:variable name=\"text\"> <xsl:apply-templates/> </xsl:variable>\n+\n+    <xsl:text>&#10;</xsl:text>\n+\n+    <xsl:call-template name=\"wrap\"><xsl:with-param select=\"normalize-space($text)\" name=\"text\"/><xsl:with-param name=\"prefix\"> <xsl:choose><xsl:when test=\"position() = 1\"> <xsl:value-of select=\"$prefix\"/> </xsl:when><xsl:otherwise> <xsl:value-of select=\"$indent\"/> </xsl:otherwise></xsl:choose> </xsl:with-param></xsl:call-template></xsl:template>\n+\n+\n+<xsl:template name=\"wrap\"><xsl:param name=\"text\"/><xsl:param name=\"prefix\"/>\n+    <xsl:if test=\"$text\">\n+        <xsl:variable name=\"offset\">\n+            <xsl:choose>\n+                <xsl:when test=\"starts-with($text, concat($br, ' '))\">\n+                    <xsl:value-of select=\"string-length($br) + 2\"/>\n+                </xsl:when>\n+                <xsl:when test=\"starts-with($text, $br)\">\n+                    <xsl:value-of select=\"string-length($br) + 1\"/>\n+                </xsl:when>\n+                <xsl:otherwise>\n+                    1\n+                </xsl:otherwise>\n+            </xsl:choose>\n+        </xsl:variable>\n+\n+        <xsl:variable name=\"length\">\n+            <xsl:call-template name=\"length\"><xsl:with-param select=\"substring($text, $offset)\" name=\"text\"/><xsl:with-param select=\"string-length($prefix)\" name=\"prefix\"/><xsl:with-param select=\"$max\" name=\"length\"/></xsl:call-template></xsl:variable>\n+\n+        <xsl:value-of select=\"$prefix\"/>\n+\n+        <xsl:value-of select=\"normalize-space(translate(substring($text, $offset, $length),\n+                                    '&#xA0;', ' '))\"/>\n+\n+        <xsl:text>&#10;</xsl:text>\n+\n+        <xsl:call-template name=\"wrap\"><xsl:with-param select=\"substring($text, $length + $offset)\" name=\"text\"/><xsl:with-param select=\"$indent\" name=\"prefix\"/></xsl:call-template></xsl:if>\n+</xsl:template>\n+\n+\n+<xsl:template name=\"length\"><xsl:param name=\"text\"/><xsl:param name=\"prefix\"/><xsl:param name=\"length\"/>\n+    <xsl:variable select=\"substring-before(substring($text, 1,\n+                                    $length - $prefix + string-length($br)),\n+                                    $br)\" name=\"break\"/>\n+\n+    <xsl:choose>\n+        <xsl:when test=\"$break\"> <xsl:value-of select=\"string-length($break)\"/> </xsl:when>\n+\n+        <xsl:when test=\"$length = 0\"> <xsl:value-of select=\"$max - $prefix\"/> </xsl:when>\n+\n+        <xsl:when test=\"string-length($text) + $prefix &lt;= $length\">\n+            <xsl:value-of select=\"$length - $prefix\"/>\n+        </xsl:when>\n+\n+        <xsl:when test=\"substring($text, $length - $prefix + 1, 1) = ' '\">\n+            <xsl:value-of select=\"$length - $prefix + 1\"/>\n+        </xsl:when>\n+\n+        <xsl:otherwise>\n+            <xsl:call-template name=\"length\"><xsl:with-param select=\"$text\" name=\"text\"/><xsl:with-param select=\"$prefix\" name=\"prefix\"/><xsl:with-param select=\"$length - 1\" name=\"length\"/></xsl:call-template></xsl:otherwise>\n+    </xsl:choose>\n+</xsl:template>\n+\n+\n+<xsl:template match=\"at\">@</xsl:template>\n+<xsl:template match=\"br\"> <xsl:value-of select=\"$br\"/> </xsl:template>\n+<xsl:template match=\"nobr\"> <xsl:value-of select=\"translate(., ' ', '&#xA0;')\"/> </xsl:template>\n+\n+\n+</xsl:stylesheet>\nDiff:\n@@ -0,0 +1,19 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<title>Error</title>\n+<style>\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n+</style>\n+</head>\n+<body>\n+<h1>An error occurred.</h1>\n+<p>Sorry, the page you are looking for is currently unavailable.<br/>\n+Please try again later.</p>\n+<p>If you are the system administrator of this resource then you should check\n+the error log for details.</p>\n+<p><em>Faithfully yours, nginx.</em></p>\n+</body>\n+</html>\nDiff:\n@@ -0,0 +1,23 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<title>Welcome to nginx!</title>\n+<style>\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n+</style>\n+</head>\n+<body>\n+<h1>Welcome to nginx!</h1>\n+<p>If you see this page, the nginx web server is successfully installed and\n+working. Further configuration is required.</p>\n+\n+<p>For online documentation and support please refer to\n+<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\n+Commercial support is available at\n+<a href=\"http://nginx.com/\">nginx.com</a>.</p>\n+\n+<p><em>Thank you for using nginx.</em></p>\n+</body>\n+</html>\nDiff:\n@@ -0,0 +1,154 @@\n+\n+VER =\t\t$(shell grep 'define NGINX_VERSION' src/core/nginx.h\t\\\n+\t\t\t| sed -e 's/^.*\"\\(.*\\)\".*/\\1/')\n+NGINX =\t\tnginx-$(VER)\n+TEMP =\t\ttmp\n+\n+CC =\t\tcl\n+OBJS =\t\tobjs.msvc8\n+OPENSSL =\topenssl-1.1.1d\n+ZLIB =\t\tzlib-1.2.11\n+PCRE =\t\tpcre-8.43\n+\n+\n+release: export\n+\n+\tmv $(TEMP)/$(NGINX)/auto/configure $(TEMP)/$(NGINX)\n+\n+\t# delete incomplete sources\n+\trm $(TEMP)/$(NGINX)/src/event/ngx_event_acceptex.c\n+\trm $(TEMP)/$(NGINX)/src/event/ngx_event_connectex.c\n+\trm $(TEMP)/$(NGINX)/src/event/modules/ngx_iocp_module.*\n+\trm -r $(TEMP)/$(NGINX)/src/os/win32\n+\n+\tmv $(TEMP)/$(NGINX)/docs/text/LICENSE $(TEMP)/$(NGINX)\n+\tmv $(TEMP)/$(NGINX)/docs/text/README $(TEMP)/$(NGINX)\n+\tmv $(TEMP)/$(NGINX)/docs/html $(TEMP)/$(NGINX)\n+\tmv $(TEMP)/$(NGINX)/docs/man $(TEMP)/$(NGINX)\n+\n+\t$(MAKE) -f docs/GNUmakefile changes\n+\n+\trm -r $(TEMP)/$(NGINX)/docs\n+\trm -r $(TEMP)/$(NGINX)/misc\n+\n+\ttar -c -z -f $(NGINX).tar.gz --directory $(TEMP) $(NGINX)\n+\n+\n+export:\n+\trm -rf $(TEMP)\n+\thg archive -X '.hg*' $(TEMP)/$(NGINX)\n+\n+\n+RELEASE:\n+\thg ci -m nginx-$(VER)-RELEASE\n+\thg tag -m \"release-$(VER) tag\" release-$(VER)\n+\n+\t$(MAKE) -f misc/GNUmakefile release\n+\n+\n+win32:\n+\t./auto/configure\t\t\t\t\t\t\\\n+\t\t--with-cc=$(CC)\t\t\t\t\t\t\\\n+\t\t--builddir=$(OBJS)\t\t\t\t\t\\\n+\t\t--with-debug\t\t\t\t\t\t\\\n+\t\t--prefix= \t\t\t\t\t\t\\\n+\t\t--conf-path=conf/nginx.conf\t\t\t\t\\\n+\t\t--pid-path=logs/nginx.pid\t\t\t\t\\\n+\t\t--http-log-path=logs/access.log\t\t\t\t\\\n+\t\t--error-log-path=logs/error.log\t\t\t\t\\\n+\t\t--sbin-path=nginx.exe\t\t\t\t\t\\\n+\t\t--http-client-body-temp-path=temp/client_body_temp\t\\\n+\t\t--http-proxy-temp-path=temp/proxy_temp\t\t\t\\\n+\t\t--http-fastcgi-temp-path=temp/fastcgi_temp\t\t\\\n+\t\t--http-scgi-temp-path=temp/scgi_temp\t\t\t\\\n+\t\t--http-uwsgi-temp-path=temp/uwsgi_temp\t\t\t\\\n+\t\t--with-cc-opt=-DFD_SETSIZE=1024\t\t\t\t\\\n+\t\t--with-pcre=$(OBJS)/lib/$(PCRE)\t\t\t\t\\\n+\t\t--with-zlib=$(OBJS)/lib/$(ZLIB)\t\t\t\t\\\n+\t\t--with-http_v2_module\t\t\t\t\t\\\n+\t\t--with-http_realip_module\t\t\t\t\\\n+\t\t--with-http_addition_module\t\t\t\t\\\n+\t\t--with-http_sub_module\t\t\t\t\t\\\n+\t\t--with-http_dav_module\t\t\t\t\t\\\n+\t\t--with-http_stub_status_module\t\t\t\t\\\n+\t\t--with-http_flv_module\t\t\t\t\t\\\n+\t\t--with-http_mp4_module\t\t\t\t\t\\\n+\t\t--with-http_gunzip_module\t\t\t\t\\\n+\t\t--with-http_gzip_static_module\t\t\t\t\\\n+\t\t--with-http_auth_request_module\t\t\t\t\\\n+\t\t--with-http_random_index_module\t\t\t\t\\\n+\t\t--with-http_secure_link_module\t\t\t\t\\\n+\t\t--with-http_slice_module\t\t\t\t\\\n+\t\t--with-mail\t\t\t\t\t\t\\\n+\t\t--with-stream\t\t\t\t\t\t\\\n+\t\t--with-openssl=$(OBJS)/lib/$(OPENSSL)\t\t\t\\\n+\t\t--with-openssl-opt=\"no-asm no-tests -D_WIN32_WINNT=0x0501\" \\\n+\t\t--with-http_ssl_module\t\t\t\t\t\\\n+\t\t--with-mail_ssl_module\t\t\t\t\t\\\n+\t\t--with-stream_ssl_module\n+\n+\n+zip: export\n+\trm -f $(NGINX).zip\n+\n+\tmkdir -p $(TEMP)/$(NGINX)/docs.new\n+\tmkdir -p $(TEMP)/$(NGINX)/logs\n+\tmkdir -p $(TEMP)/$(NGINX)/temp\n+\n+\tsed -i '' -e \"s/$$/`printf '\\r'`/\" $(TEMP)/$(NGINX)/conf/*\n+\n+\tmv $(TEMP)/$(NGINX)/docs/text/LICENSE $(TEMP)/$(NGINX)/docs.new\n+\tmv $(TEMP)/$(NGINX)/docs/text/README $(TEMP)/$(NGINX)/docs.new\n+\tmv $(TEMP)/$(NGINX)/docs/html $(TEMP)/$(NGINX)\n+\n+\trm -r $(TEMP)/$(NGINX)/docs\n+\tmv $(TEMP)/$(NGINX)/docs.new $(TEMP)/$(NGINX)/docs\n+\n+\tcp -p $(OBJS)/nginx.exe $(TEMP)/$(NGINX)\n+\n+\t$(MAKE) -f docs/GNUmakefile changes\n+\tmv $(TEMP)/$(NGINX)/CHANGES* $(TEMP)/$(NGINX)/docs/\n+\n+\tcp -p $(OBJS)/lib/$(OPENSSL)/LICENSE\t\t\t\t\\\n+\t\t$(TEMP)/$(NGINX)/docs/OpenSSL.LICENSE\n+\n+\tcp -p $(OBJS)/lib/$(PCRE)/LICENCE\t\t\t\t\\\n+\t\t$(TEMP)/$(NGINX)/docs/PCRE.LICENCE\n+\n+\tsed -ne '/^ (C) 1995-20/,/^  jloup@gzip\\.org/p'\t\t\t\\\n+\t\t$(OBJS)/lib/$(ZLIB)/README\t\t\t\t\\\n+\t\t> $(TEMP)/$(NGINX)/docs/zlib.LICENSE\n+\n+\ttouch -r $(OBJS)/lib/$(ZLIB)/README\t\t\t\t\\\n+\t\t$(TEMP)/$(NGINX)/docs/zlib.LICENSE\n+\n+\trm -r $(TEMP)/$(NGINX)/auto\n+\trm -r $(TEMP)/$(NGINX)/misc\n+\trm -r $(TEMP)/$(NGINX)/src\n+\n+\tcd $(TEMP) && zip -r ../$(NGINX).zip $(NGINX)\n+\n+\n+icons:\tsrc/os/win32/nginx.ico\n+\n+# 48x48, 32x32 and 16x16 icons\n+\n+src/os/win32/nginx.ico:\tsrc/os/win32/nginx_icon48.xpm\t\t\t\\\n+\t\t\tsrc/os/win32/nginx_icon32.xpm\t\t\t\\\n+\t\t\tsrc/os/win32/nginx_icon16.xpm\n+\n+\ttest -d $(TEMP) || mkdir $(TEMP)\n+\n+\txpmtoppm --alphaout=$(TEMP)/nginx48.pbm\t\t\t\t\\\n+\t\tsrc/os/win32/nginx_icon48.xpm > $(TEMP)/nginx48.ppm\n+\n+\txpmtoppm --alphaout=$(TEMP)/nginx32.pbm\t\t\t\t\\\n+\t\tsrc/os/win32/nginx_icon32.xpm > $(TEMP)/nginx32.ppm\n+\n+\txpmtoppm --alphaout=$(TEMP)/nginx16.pbm\t\t\t\t\\\n+\t\tsrc/os/win32/nginx_icon16.xpm > $(TEMP)/nginx16.ppm\n+\n+\tppmtowinicon -output src/os/win32/nginx.ico -andpgms\t\t\\\n+\t\t$(TEMP)/nginx48.ppm $(TEMP)/nginx48.pbm\t\t\t\\\n+\t\t$(TEMP)/nginx32.ppm $(TEMP)/nginx32.pbm\t\t\t\\\n+\t\t$(TEMP)/nginx16.ppm $(TEMP)/nginx16.pbm\nDiff:\n@@ -0,0 +1,13 @@\n+\n+make -f misc/GNUmakefile release\n+\n+the required tools:\n+*) xsltproc to build CHANGES,\n+*) xslscript.pl ( http://hg.nginx.org/xslscript ) to build XSLTs\n+   from XSLScript sources.\n+\n+\n+make -f misc/GNUmakefile icons\n+\n+the required tool:\n+*) netpbm to create Win32 icons from xpm sources.\nDiff:\n@@ -0,0 +1,1606 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <nginx.h>\n+\n+\n+static void ngx_show_version_info(void);\n+static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle);\n+static void ngx_cleanup_environment(void *data);\n+static ngx_int_t ngx_get_options(int argc, char *const *argv);\n+static ngx_int_t ngx_process_options(ngx_cycle_t *cycle);\n+static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv);\n+static void *ngx_core_module_create_conf(ngx_cycle_t *cycle);\n+static char *ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf);\n+static char *ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+static char *ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+static char *ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+static char *ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+#if (NGX_HAVE_DLOPEN)\n+static void ngx_unload_module(void *data);\n+#endif\n+\n+\n+static ngx_conf_enum_t  ngx_debug_points[] = {\n+    { ngx_string(\"stop\"), NGX_DEBUG_POINTS_STOP },\n+    { ngx_string(\"abort\"), NGX_DEBUG_POINTS_ABORT },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+static ngx_command_t  ngx_core_commands[] = {\n+\n+    { ngx_string(\"daemon\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, daemon),\n+      NULL },\n+\n+    { ngx_string(\"master_process\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, master),\n+      NULL },\n+\n+    { ngx_string(\"remote_admin\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, remote_admin),\n+      NULL },\n+\n+    { ngx_string(\"trace\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, trace_enable),\n+      NULL },\n+\n+    { ngx_string(\"timer_resolution\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, timer_resolution),\n+      NULL },\n+\n+    { ngx_string(\"pid\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, pid),\n+      NULL },\n+\n+    { ngx_string(\"lock_file\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, lock_file),\n+      NULL },\n+\n+    { ngx_string(\"worker_processes\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_set_worker_processes,\n+      0,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"debug_points\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_enum_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, debug_points),\n+      &ngx_debug_points },\n+\n+    { ngx_string(\"user\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE12,\n+      ngx_set_user,\n+      0,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"worker_priority\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_set_priority,\n+      0,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"worker_cpu_affinity\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_1MORE,\n+      ngx_set_cpu_affinity,\n+      0,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"worker_rlimit_nofile\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_num_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, rlimit_nofile),\n+      NULL },\n+\n+    { ngx_string(\"worker_rlimit_core\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_off_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, rlimit_core),\n+      NULL },\n+\n+    { ngx_string(\"worker_shutdown_timeout\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, shutdown_timeout),\n+      NULL },\n+\n+    { ngx_string(\"working_directory\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      0,\n+      offsetof(ngx_core_conf_t, working_directory),\n+      NULL },\n+\n+    { ngx_string(\"env\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_set_env,\n+      0,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"load_module\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_load_module,\n+      0,\n+      0,\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_core_module_t  ngx_core_module_ctx = {\n+    ngx_string(\"core\"),\n+    ngx_core_module_create_conf,\n+    ngx_core_module_init_conf\n+};\n+\n+\n+ngx_module_t  ngx_core_module = {\n+    NGX_MODULE_V1,\n+    &ngx_core_module_ctx,                  /* module context */\n+    ngx_core_commands,                     /* module directives */\n+    NGX_CORE_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static ngx_uint_t   ngx_show_help;\n+static ngx_uint_t   ngx_show_version;\n+static ngx_uint_t   ngx_show_configure;\n+static u_char      *ngx_prefix;\n+static u_char      *ngx_conf_file;\n+static u_char      *ngx_conf_params;\n+static char        *ngx_signal;\n+\n+\n+static char **ngx_os_environ;\n+\n+\n+int ngx_cdecl\n+main(int argc, char *const *argv)\n+{\n+    ngx_buf_t        *b;\n+    ngx_log_t        *log;\n+    ngx_uint_t        i;\n+    ngx_cycle_t      *cycle, init_cycle;\n+    ngx_conf_dump_t  *cd;\n+    ngx_core_conf_t  *ccf;\n+\n+    ngx_debug_init();\n+\n+    if (ngx_strerror_init() != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (ngx_get_options(argc, argv) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (ngx_show_version) {\n+        ngx_show_version_info();\n+\n+        if (!ngx_test_config) {\n+            return 0;\n+        }\n+    }\n+\n+    /* TODO */ ngx_max_sockets = -1;\n+\n+    ngx_time_init();\n+\n+#if (NGX_PCRE)\n+    ngx_regex_init();\n+#endif\n+\n+    ngx_pid = ngx_getpid();\n+    ngx_parent = ngx_getppid();\n+\n+    log = ngx_log_init(ngx_prefix);\n+    if (log == NULL) {\n+        return 1;\n+    }\n+\n+    /* STUB */\n+#if (NGX_OPENSSL)\n+    ngx_ssl_init(log);\n+#endif\n+\n+    /*\n+     * init_cycle->log is required for signal handlers and\n+     * ngx_process_options()\n+     */\n+\n+    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));\n+    init_cycle.log = log;\n+    ngx_cycle = &init_cycle;\n+\n+    init_cycle.pool = ngx_create_pool(1024, log);\n+    if (init_cycle.pool == NULL) {\n+        return 1;\n+    }\n+\n+    if (ngx_save_argv(&init_cycle, argc, argv) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (ngx_process_options(&init_cycle) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (ngx_os_init(log) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    /*\n+     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()\n+     */\n+\n+    if (ngx_crc32_table_init() != NGX_OK) {\n+        return 1;\n+    }\n+\n+    /*\n+     * ngx_slab_sizes_init() requires ngx_pagesize set in ngx_os_init()\n+     */\n+\n+    ngx_slab_sizes_init();\n+\n+    if (ngx_add_inherited_sockets(&init_cycle) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (ngx_preinit_modules() != NGX_OK) {\n+        return 1;\n+    }\n+\n+    cycle = ngx_init_cycle(&init_cycle);\n+    if (cycle == NULL) {\n+        if (ngx_test_config) {\n+            ngx_log_stderr(0, \"configuration file %s test failed\",\n+                           init_cycle.conf_file.data);\n+        }\n+\n+        return 1;\n+    }\n+\n+    if (ngx_test_config) {\n+        if (!ngx_quiet_mode) {\n+            ngx_log_stderr(0, \"configuration file %s test is successful\",\n+                           cycle->conf_file.data);\n+        }\n+\n+        if (ngx_dump_config) {\n+            cd = cycle->config_dump.elts;\n+\n+            for (i = 0; i < cycle->config_dump.nelts; i++) {\n+\n+                ngx_write_stdout(\"# configuration file \");\n+                (void) ngx_write_fd(ngx_stdout, cd[i].name.data,\n+                                    cd[i].name.len);\n+                ngx_write_stdout(\":\" NGX_LINEFEED);\n+\n+                b = cd[i].buffer;\n+\n+                (void) ngx_write_fd(ngx_stdout, b->pos, b->last - b->pos);\n+                ngx_write_stdout(NGX_LINEFEED);\n+            }\n+        }\n+\n+        return 0;\n+    }\n+\n+    if (ngx_signal) {\n+        return ngx_signal_process(cycle, ngx_signal);\n+    }\n+\n+    ngx_os_status(cycle->log);\n+\n+    ngx_cycle = cycle;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {\n+        ngx_process = NGX_PROCESS_MASTER;\n+    }\n+\n+#if !(NGX_WIN32)\n+\n+    if (ngx_init_signals(cycle->log) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (!ngx_inherited && ccf->daemon) {\n+        if (ngx_daemon(cycle->log) != NGX_OK) {\n+            return 1;\n+        }\n+\n+        ngx_daemonized = 1;\n+    }\n+\n+    if (ngx_inherited) {\n+        ngx_daemonized = 1;\n+    }\n+\n+#endif\n+\n+    if (ngx_create_pidfile(&ccf->pid, cycle->log) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (ngx_log_redirect_stderr(cycle) != NGX_OK) {\n+        return 1;\n+    }\n+\n+    if (log->file->fd != ngx_stderr) {\n+        if (ngx_close_file(log->file->fd) == NGX_FILE_ERROR) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          ngx_close_file_n \" built-in log failed\");\n+        }\n+    }\n+\n+    ngx_use_stderr = 0;\n+\n+    if (ngx_process == NGX_PROCESS_SINGLE) {\n+        ngx_single_process_cycle(cycle);\n+\n+    } else {\n+        ngx_master_process_cycle(cycle);\n+    }\n+\n+    return 0;\n+}\n+\n+\n+static void\n+ngx_show_version_info(void)\n+{\n+    ngx_write_stderr(\"nginx version: \" NGINX_VER_BUILD NGX_LINEFEED);\n+\n+    if (ngx_show_help) {\n+        ngx_write_stderr(\n+            \"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] \"\n+                         \"[-p prefix] [-g directives]\" NGX_LINEFEED\n+                         NGX_LINEFEED\n+            \"Options:\" NGX_LINEFEED\n+            \"  -?,-h         : this help\" NGX_LINEFEED\n+            \"  -v            : show version and exit\" NGX_LINEFEED\n+            \"  -V            : show version and configure options then exit\"\n+                               NGX_LINEFEED\n+            \"  -t            : test configuration and exit\" NGX_LINEFEED\n+            \"  -T            : test configuration, dump it and exit\"\n+                               NGX_LINEFEED\n+            \"  -q            : suppress non-error messages \"\n+                               \"during configuration testing\" NGX_LINEFEED\n+            \"  -s signal     : send signal to a master process: \"\n+                               \"stop, quit, reopen, reload\" NGX_LINEFEED\n+#ifdef NGX_PREFIX\n+            \"  -p prefix     : set prefix path (default: \" NGX_PREFIX \")\"\n+                               NGX_LINEFEED\n+#else\n+            \"  -p prefix     : set prefix path (default: NONE)\" NGX_LINEFEED\n+#endif\n+            \"  -c filename   : set configuration file (default: \" NGX_CONF_PATH\n+                               \")\" NGX_LINEFEED\n+            \"  -g directives : set global directives out of configuration \"\n+                               \"file\" NGX_LINEFEED NGX_LINEFEED\n+        );\n+    }\n+\n+    if (ngx_show_configure) {\n+\n+#ifdef NGX_COMPILER\n+        ngx_write_stderr(\"built by \" NGX_COMPILER NGX_LINEFEED);\n+#endif\n+\n+#if (NGX_SSL)\n+        if (ngx_strcmp(ngx_ssl_version(), OPENSSL_VERSION_TEXT) == 0) {\n+            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT NGX_LINEFEED);\n+        } else {\n+            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT\n+                             \" (running with \");\n+            ngx_write_stderr((char *) (uintptr_t) ngx_ssl_version());\n+            ngx_write_stderr(\")\" NGX_LINEFEED);\n+        }\n+#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n+        ngx_write_stderr(\"TLS SNI support enabled\" NGX_LINEFEED);\n+#else\n+        ngx_write_stderr(\"TLS SNI support disabled\" NGX_LINEFEED);\n+#endif\n+#endif\n+\n+        ngx_write_stderr(\"configure arguments:\" NGX_CONFIGURE NGX_LINEFEED);\n+    }\n+}\n+\n+\n+static ngx_int_t\n+ngx_add_inherited_sockets(ngx_cycle_t *cycle)\n+{\n+    u_char           *p, *v, *inherited;\n+    ngx_int_t         s;\n+    ngx_listening_t  *ls;\n+\n+    inherited = (u_char *) getenv(NGINX_VAR);\n+\n+    if (inherited == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,\n+                  \"using inherited sockets from \\\"%s\\\"\", inherited);\n+\n+    if (ngx_array_init(&cycle->listening, cycle->pool, 10,\n+                       sizeof(ngx_listening_t))\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    for (p = inherited, v = p; *p; p++) {\n+        if (*p == ':' || *p == ';') {\n+            s = ngx_atoi(v, p - v);\n+            if (s == NGX_ERROR) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n+                              \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n+                              \" environment variable, ignoring the rest\"\n+                              \" of the variable\", v);\n+                break;\n+            }\n+\n+            v = p + 1;\n+\n+            ls = ngx_array_push(&cycle->listening);\n+            if (ls == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_memzero(ls, sizeof(ngx_listening_t));\n+\n+            ls->fd = (ngx_socket_t) s;\n+        }\n+    }\n+\n+    if (v != p) {\n+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n+                      \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n+                      \" environment variable, ignoring\", v);\n+    }\n+\n+    ngx_inherited = 1;\n+\n+    return ngx_set_inherited_sockets(cycle);\n+}\n+\n+\n+char **\n+ngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)\n+{\n+    char                **p, **env;\n+    ngx_str_t            *var;\n+    ngx_uint_t            i, n;\n+    ngx_core_conf_t      *ccf;\n+    ngx_pool_cleanup_t   *cln;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (last == NULL && ccf->environment) {\n+        return ccf->environment;\n+    }\n+\n+    var = ccf->env.elts;\n+\n+    for (i = 0; i < ccf->env.nelts; i++) {\n+        if (ngx_strcmp(var[i].data, \"TZ\") == 0\n+            || ngx_strncmp(var[i].data, \"TZ=\", 3) == 0)\n+        {\n+            goto tz_found;\n+        }\n+    }\n+\n+    var = ngx_array_push(&ccf->env);\n+    if (var == NULL) {\n+        return NULL;\n+    }\n+\n+    var->len = 2;\n+    var->data = (u_char *) \"TZ\";\n+\n+    var = ccf->env.elts;\n+\n+tz_found:\n+\n+    n = 0;\n+\n+    for (i = 0; i < ccf->env.nelts; i++) {\n+\n+        if (var[i].data[var[i].len] == '=') {\n+            n++;\n+            continue;\n+        }\n+\n+        for (p = ngx_os_environ; *p; p++) {\n+\n+            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n+                && (*p)[var[i].len] == '=')\n+            {\n+                n++;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (last) {\n+        env = ngx_alloc((*last + n + 1) * sizeof(char *), cycle->log);\n+        if (env == NULL) {\n+            return NULL;\n+        }\n+\n+        *last = n;\n+\n+    } else {\n+        cln = ngx_pool_cleanup_add(cycle->pool, 0);\n+        if (cln == NULL) {\n+            return NULL;\n+        }\n+\n+        env = ngx_alloc((n + 1) * sizeof(char *), cycle->log);\n+        if (env == NULL) {\n+            return NULL;\n+        }\n+\n+        cln->handler = ngx_cleanup_environment;\n+        cln->data = env;\n+    }\n+\n+    n = 0;\n+\n+    for (i = 0; i < ccf->env.nelts; i++) {\n+\n+        if (var[i].data[var[i].len] == '=') {\n+            env[n++] = (char *) var[i].data;\n+            continue;\n+        }\n+\n+        for (p = ngx_os_environ; *p; p++) {\n+\n+            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n+                && (*p)[var[i].len] == '=')\n+            {\n+                env[n++] = *p;\n+                break;\n+            }\n+        }\n+    }\n+\n+    env[n] = NULL;\n+\n+    if (last == NULL) {\n+        ccf->environment = env;\n+        environ = env;\n+    }\n+\n+    return env;\n+}\n+\n+\n+static void\n+ngx_cleanup_environment(void *data)\n+{\n+    char  **env = data;\n+\n+    if (environ == env) {\n+\n+        /*\n+         * if the environment is still used, as it happens on exit,\n+         * the only option is to leak it\n+         */\n+\n+        return;\n+    }\n+\n+    ngx_free(env);\n+}\n+\n+\n+ngx_pid_t\n+ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\n+{\n+    char             **env, *var;\n+    u_char            *p;\n+    ngx_uint_t         i, n;\n+    ngx_pid_t          pid;\n+    ngx_exec_ctx_t     ctx;\n+    ngx_core_conf_t   *ccf;\n+    ngx_listening_t   *ls;\n+\n+    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));\n+\n+    ctx.path = argv[0];\n+    ctx.name = \"new binary process\";\n+    ctx.argv = argv;\n+\n+    n = 2;\n+    env = ngx_set_environment(cycle, &n);\n+    if (env == NULL) {\n+        return NGX_INVALID_PID;\n+    }\n+\n+    var = ngx_alloc(sizeof(NGINX_VAR)\n+                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,\n+                    cycle->log);\n+    if (var == NULL) {\n+        ngx_free(env);\n+        return NGX_INVALID_PID;\n+    }\n+\n+    p = ngx_cpymem(var, NGINX_VAR \"=\", sizeof(NGINX_VAR));\n+\n+    ls = cycle->listening.elts;\n+    for (i = 0; i < cycle->listening.nelts; i++) {\n+        p = ngx_sprintf(p, \"%ud;\", ls[i].fd);\n+    }\n+\n+    *p = '\\0';\n+\n+    env[n++] = var;\n+\n+#if (NGX_SETPROCTITLE_USES_ENV)\n+\n+    /* allocate the spare 300 bytes for the new binary process title */\n+\n+    env[n++] = \"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n+               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n+               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n+               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n+               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n+\n+#endif\n+\n+    env[n] = NULL;\n+\n+#if (NGX_DEBUG)\n+    {\n+    char  **e;\n+    for (e = env; *e; e++) {\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"env: %s\", *e);\n+    }\n+    }\n+#endif\n+\n+    ctx.envp = (char *const *) env;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (ngx_rename_file(ccf->pid.data, ccf->oldpid.data) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      ngx_rename_file_n \" %s to %s failed \"\n+                      \"before executing new binary process \\\"%s\\\"\",\n+                      ccf->pid.data, ccf->oldpid.data, argv[0]);\n+\n+        ngx_free(env);\n+        ngx_free(var);\n+\n+        return NGX_INVALID_PID;\n+    }\n+\n+    pid = ngx_execute(cycle, &ctx);\n+\n+    if (pid == NGX_INVALID_PID) {\n+        if (ngx_rename_file(ccf->oldpid.data, ccf->pid.data)\n+            == NGX_FILE_ERROR)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          ngx_rename_file_n \" %s back to %s failed after \"\n+                          \"an attempt to execute new binary process \\\"%s\\\"\",\n+                          ccf->oldpid.data, ccf->pid.data, argv[0]);\n+        }\n+    }\n+\n+    ngx_free(env);\n+    ngx_free(var);\n+\n+    return pid;\n+}\n+\n+\n+static ngx_int_t\n+ngx_get_options(int argc, char *const *argv)\n+{\n+    u_char     *p;\n+    ngx_int_t   i;\n+\n+    for (i = 1; i < argc; i++) {\n+\n+        p = (u_char *) argv[i];\n+\n+        if (*p++ != '-') {\n+            ngx_log_stderr(0, \"invalid option: \\\"%s\\\"\", argv[i]);\n+            return NGX_ERROR;\n+        }\n+\n+        while (*p) {\n+\n+            switch (*p++) {\n+\n+            case '?':\n+            case 'h':\n+                ngx_show_version = 1;\n+                ngx_show_help = 1;\n+                break;\n+\n+            case 'v':\n+                ngx_show_version = 1;\n+                break;\n+\n+            case 'V':\n+                ngx_show_version = 1;\n+                ngx_show_configure = 1;\n+                break;\n+\n+            case 't':\n+                ngx_test_config = 1;\n+                break;\n+\n+            case 'T':\n+                ngx_test_config = 1;\n+                ngx_dump_config = 1;\n+                break;\n+\n+            case 'q':\n+                ngx_quiet_mode = 1;\n+                break;\n+\n+            case 'p':\n+                if (*p) {\n+                    ngx_prefix = p;\n+                    goto next;\n+                }\n+\n+                if (argv[++i]) {\n+                    ngx_prefix = (u_char *) argv[i];\n+                    goto next;\n+                }\n+\n+                ngx_log_stderr(0, \"option \\\"-p\\\" requires directory name\");\n+                return NGX_ERROR;\n+\n+            case 'c':\n+                if (*p) {\n+                    ngx_conf_file = p;\n+                    goto next;\n+                }\n+\n+                if (argv[++i]) {\n+                    ngx_conf_file = (u_char *) argv[i];\n+                    goto next;\n+                }\n+\n+                ngx_log_stderr(0, \"option \\\"-c\\\" requires file name\");\n+                return NGX_ERROR;\n+\n+            case 'g':\n+                if (*p) {\n+                    ngx_conf_params = p;\n+                    goto next;\n+                }\n+\n+                if (argv[++i]) {\n+                    ngx_conf_params = (u_char *) argv[i];\n+                    goto next;\n+                }\n+\n+                ngx_log_stderr(0, \"option \\\"-g\\\" requires parameter\");\n+                return NGX_ERROR;\n+\n+            case 's':\n+                if (*p) {\n+                    ngx_signal = (char *) p;\n+\n+                } else if (argv[++i]) {\n+                    ngx_signal = argv[i];\n+\n+                } else {\n+                    ngx_log_stderr(0, \"option \\\"-s\\\" requires parameter\");\n+                    return NGX_ERROR;\n+                }\n+\n+                if (ngx_strcmp(ngx_signal, \"stop\") == 0\n+                    || ngx_strcmp(ngx_signal, \"quit\") == 0\n+                    || ngx_strcmp(ngx_signal, \"reopen\") == 0\n+                    || ngx_strcmp(ngx_signal, \"reload\") == 0)\n+                {\n+                    ngx_process = NGX_PROCESS_SIGNALLER;\n+                    goto next;\n+                }\n+\n+                ngx_log_stderr(0, \"invalid option: \\\"-s %s\\\"\", ngx_signal);\n+                return NGX_ERROR;\n+\n+            default:\n+                ngx_log_stderr(0, \"invalid option: \\\"%c\\\"\", *(p - 1));\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+    next:\n+\n+        continue;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)\n+{\n+#if (NGX_FREEBSD)\n+\n+    ngx_os_argv = (char **) argv;\n+    ngx_argc = argc;\n+    ngx_argv = (char **) argv;\n+\n+#else\n+    size_t     len;\n+    ngx_int_t  i;\n+\n+    ngx_os_argv = (char **) argv;\n+    ngx_argc = argc;\n+\n+    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);\n+    if (ngx_argv == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    for (i = 0; i < argc; i++) {\n+        len = ngx_strlen(argv[i]) + 1;\n+\n+        ngx_argv[i] = ngx_alloc(len, cycle->log);\n+        if (ngx_argv[i] == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);\n+    }\n+\n+    ngx_argv[i] = NULL;\n+\n+#endif\n+\n+    ngx_os_environ = environ;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_process_options(ngx_cycle_t *cycle)\n+{\n+    u_char  *p;\n+    size_t   len;\n+\n+    if (ngx_prefix) {\n+        len = ngx_strlen(ngx_prefix);\n+        p = ngx_prefix;\n+\n+        if (len && !ngx_path_separator(p[len - 1])) {\n+            p = ngx_pnalloc(cycle->pool, len + 1);\n+            if (p == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_memcpy(p, ngx_prefix, len);\n+            p[len++] = '/';\n+        }\n+\n+        cycle->conf_prefix.len = len;\n+        cycle->conf_prefix.data = p;\n+        cycle->prefix.len = len;\n+        cycle->prefix.data = p;\n+\n+    } else {\n+\n+#ifndef NGX_PREFIX\n+\n+        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);\n+        if (p == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {\n+            ngx_log_stderr(ngx_errno, \"[emerg]: \" ngx_getcwd_n \" failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        len = ngx_strlen(p);\n+\n+        p[len++] = '/';\n+\n+        cycle->conf_prefix.len = len;\n+        cycle->conf_prefix.data = p;\n+        cycle->prefix.len = len;\n+        cycle->prefix.data = p;\n+\n+#else\n+\n+#ifdef NGX_CONF_PREFIX\n+        ngx_str_set(&cycle->conf_prefix, NGX_CONF_PREFIX);\n+#else\n+        ngx_str_set(&cycle->conf_prefix, NGX_PREFIX);\n+#endif\n+        ngx_str_set(&cycle->prefix, NGX_PREFIX);\n+\n+#endif\n+    }\n+\n+    if (ngx_conf_file) {\n+        cycle->conf_file.len = ngx_strlen(ngx_conf_file);\n+        cycle->conf_file.data = ngx_conf_file;\n+\n+    } else {\n+        ngx_str_set(&cycle->conf_file, NGX_CONF_PATH);\n+    }\n+\n+    if (ngx_conf_full_name(cycle, &cycle->conf_file, 0) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    for (p = cycle->conf_file.data + cycle->conf_file.len - 1;\n+         p > cycle->conf_file.data;\n+         p--)\n+    {\n+        if (ngx_path_separator(*p)) {\n+            cycle->conf_prefix.len = p - cycle->conf_file.data + 1;\n+            cycle->conf_prefix.data = cycle->conf_file.data;\n+            break;\n+        }\n+    }\n+\n+    if (ngx_conf_params) {\n+        cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n+        cycle->conf_param.data = ngx_conf_params;\n+    }\n+\n+    if (ngx_test_config) {\n+        cycle->log->log_level = NGX_LOG_INFO;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void *\n+ngx_core_module_create_conf(ngx_cycle_t *cycle)\n+{\n+    ngx_core_conf_t  *ccf;\n+\n+    ccf = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t));\n+    if (ccf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc()\n+     *\n+     *     ccf->pid = NULL;\n+     *     ccf->oldpid = NULL;\n+     *     ccf->priority = 0;\n+     *     ccf->cpu_affinity_auto = 0;\n+     *     ccf->cpu_affinity_n = 0;\n+     *     ccf->cpu_affinity = NULL;\n+     */\n+\n+    ccf->daemon = NGX_CONF_UNSET;\n+    ccf->master = NGX_CONF_UNSET;\n+    ccf->remote_admin = NGX_CONF_UNSET;\n+    ccf->trace_enable = NGX_CONF_UNSET;\n+    ccf->timer_resolution = NGX_CONF_UNSET_MSEC;\n+    ccf->shutdown_timeout = NGX_CONF_UNSET_MSEC;\n+\n+    ccf->worker_processes = NGX_CONF_UNSET;\n+    ccf->debug_points = NGX_CONF_UNSET;\n+\n+    ccf->rlimit_nofile = NGX_CONF_UNSET;\n+    ccf->rlimit_core = NGX_CONF_UNSET;\n+\n+    ccf->user = (ngx_uid_t) NGX_CONF_UNSET_UINT;\n+    ccf->group = (ngx_gid_t) NGX_CONF_UNSET_UINT;\n+\n+    if (ngx_array_init(&ccf->env, cycle->pool, 1, sizeof(ngx_str_t))\n+        != NGX_OK)\n+    {\n+        return NULL;\n+    }\n+\n+    return ccf;\n+}\n+\n+\n+static char *\n+ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf)\n+{\n+    ngx_core_conf_t  *ccf = conf;\n+\n+    ngx_conf_init_value(ccf->daemon, 1);\n+    ngx_conf_init_value(ccf->master, 1);\n+    ngx_conf_init_msec_value(ccf->timer_resolution, 0);\n+    ngx_conf_init_msec_value(ccf->shutdown_timeout, 0);\n+\n+    ngx_conf_init_value(ccf->worker_processes, 1);\n+    ngx_conf_init_value(ccf->debug_points, 0);\n+\n+#if (NGX_HAVE_CPU_AFFINITY)\n+\n+    if (!ccf->cpu_affinity_auto\n+        && ccf->cpu_affinity_n\n+        && ccf->cpu_affinity_n != 1\n+        && ccf->cpu_affinity_n != (ngx_uint_t) ccf->worker_processes)\n+    {\n+        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n+                      \"the number of \\\"worker_processes\\\" is not equal to \"\n+                      \"the number of \\\"worker_cpu_affinity\\\" masks, \"\n+                      \"using last mask for remaining worker processes\");\n+    }\n+\n+#endif\n+\n+\n+    if (ccf->pid.len == 0) {\n+        ngx_str_set(&ccf->pid, NGX_PID_PATH);\n+    }\n+\n+    if (ngx_conf_full_name(cycle, &ccf->pid, 0) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ccf->oldpid.len = ccf->pid.len + sizeof(NGX_OLDPID_EXT);\n+\n+    ccf->oldpid.data = ngx_pnalloc(cycle->pool, ccf->oldpid.len);\n+    if (ccf->oldpid.data == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ngx_memcpy(ngx_cpymem(ccf->oldpid.data, ccf->pid.data, ccf->pid.len),\n+               NGX_OLDPID_EXT, sizeof(NGX_OLDPID_EXT));\n+\n+\n+#if !(NGX_WIN32)\n+\n+    if (ccf->user == (uid_t) NGX_CONF_UNSET_UINT && geteuid() == 0) {\n+        struct group   *grp;\n+        struct passwd  *pwd;\n+\n+        ngx_set_errno(0);\n+        pwd = getpwnam(NGX_USER);\n+        if (pwd == NULL) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          \"getpwnam(\\\"\" NGX_USER \"\\\") failed\");\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        ccf->username = NGX_USER;\n+        ccf->user = pwd->pw_uid;\n+\n+        ngx_set_errno(0);\n+        grp = getgrnam(NGX_GROUP);\n+        if (grp == NULL) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          \"getgrnam(\\\"\" NGX_GROUP \"\\\") failed\");\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        ccf->group = grp->gr_gid;\n+    }\n+\n+\n+    if (ccf->lock_file.len == 0) {\n+        ngx_str_set(&ccf->lock_file, NGX_LOCK_PATH);\n+    }\n+\n+    if (ngx_conf_full_name(cycle, &ccf->lock_file, 0) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    {\n+    ngx_str_t  lock_file;\n+\n+    lock_file = cycle->old_cycle->lock_file;\n+\n+    if (lock_file.len) {\n+        lock_file.len--;\n+\n+        if (ccf->lock_file.len != lock_file.len\n+            || ngx_strncmp(ccf->lock_file.data, lock_file.data, lock_file.len)\n+               != 0)\n+        {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n+                          \"\\\"lock_file\\\" could not be changed, ignored\");\n+        }\n+\n+        cycle->lock_file.len = lock_file.len + 1;\n+        lock_file.len += sizeof(\".accept\");\n+\n+        cycle->lock_file.data = ngx_pstrdup(cycle->pool, &lock_file);\n+        if (cycle->lock_file.data == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+    } else {\n+        cycle->lock_file.len = ccf->lock_file.len + 1;\n+        cycle->lock_file.data = ngx_pnalloc(cycle->pool,\n+                                      ccf->lock_file.len + sizeof(\".accept\"));\n+        if (cycle->lock_file.data == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        ngx_memcpy(ngx_cpymem(cycle->lock_file.data, ccf->lock_file.data,\n+                              ccf->lock_file.len),\n+                   \".accept\", sizeof(\".accept\"));\n+    }\n+    }\n+\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+#if (NGX_WIN32)\n+\n+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                       \"\\\"user\\\" is not supported, ignored\");\n+\n+    return NGX_CONF_OK;\n+\n+#else\n+\n+    ngx_core_conf_t  *ccf = conf;\n+\n+    char             *group;\n+    struct passwd    *pwd;\n+    struct group     *grp;\n+    ngx_str_t        *value;\n+\n+    if (ccf->user != (uid_t) NGX_CONF_UNSET_UINT) {\n+        return \"is duplicate\";\n+    }\n+\n+    if (geteuid() != 0) {\n+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                           \"the \\\"user\\\" directive makes sense only \"\n+                           \"if the master process runs \"\n+                           \"with super-user privileges, ignored\");\n+        return NGX_CONF_OK;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    ccf->username = (char *) value[1].data;\n+\n+    ngx_set_errno(0);\n+    pwd = getpwnam((const char *) value[1].data);\n+    if (pwd == NULL) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n+                           \"getpwnam(\\\"%s\\\") failed\", value[1].data);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ccf->user = pwd->pw_uid;\n+\n+    group = (char *) ((cf->args->nelts == 2) ? value[1].data : value[2].data);\n+\n+    ngx_set_errno(0);\n+    grp = getgrnam(group);\n+    if (grp == NULL) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n+                           \"getgrnam(\\\"%s\\\") failed\", group);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ccf->group = grp->gr_gid;\n+\n+    return NGX_CONF_OK;\n+\n+#endif\n+}\n+\n+\n+static char *\n+ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_core_conf_t  *ccf = conf;\n+\n+    ngx_str_t   *value, *var;\n+    ngx_uint_t   i;\n+\n+    var = ngx_array_push(&ccf->env);\n+    if (var == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+    *var = value[1];\n+\n+    for (i = 0; i < value[1].len; i++) {\n+\n+        if (value[1].data[i] == '=') {\n+\n+            var->len = i;\n+\n+            return NGX_CONF_OK;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_core_conf_t  *ccf = conf;\n+\n+    ngx_str_t        *value;\n+    ngx_uint_t        n, minus;\n+\n+    if (ccf->priority != 0) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (value[1].data[0] == '-') {\n+        n = 1;\n+        minus = 1;\n+\n+    } else if (value[1].data[0] == '+') {\n+        n = 1;\n+        minus = 0;\n+\n+    } else {\n+        n = 0;\n+        minus = 0;\n+    }\n+\n+    ccf->priority = ngx_atoi(&value[1].data[n], value[1].len - n);\n+    if (ccf->priority == NGX_ERROR) {\n+        return \"invalid number\";\n+    }\n+\n+    if (minus) {\n+        ccf->priority = -ccf->priority;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+#if (NGX_HAVE_CPU_AFFINITY)\n+    ngx_core_conf_t  *ccf = conf;\n+\n+    u_char            ch, *p;\n+    ngx_str_t        *value;\n+    ngx_uint_t        i, n;\n+    ngx_cpuset_t     *mask;\n+\n+    if (ccf->cpu_affinity) {\n+        return \"is duplicate\";\n+    }\n+\n+    mask = ngx_palloc(cf->pool, (cf->args->nelts - 1) * sizeof(ngx_cpuset_t));\n+    if (mask == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ccf->cpu_affinity_n = cf->args->nelts - 1;\n+    ccf->cpu_affinity = mask;\n+\n+    value = cf->args->elts;\n+\n+    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n+\n+        if (cf->args->nelts > 3) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"invalid number of arguments in \"\n+                               \"\\\"worker_cpu_affinity\\\" directive\");\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        ccf->cpu_affinity_auto = 1;\n+\n+        CPU_ZERO(&mask[0]);\n+        for (i = 0; i < (ngx_uint_t) ngx_min(ngx_ncpu, CPU_SETSIZE); i++) {\n+            CPU_SET(i, &mask[0]);\n+        }\n+\n+        n = 2;\n+\n+    } else {\n+        n = 1;\n+    }\n+\n+    for ( /* void */ ; n < cf->args->nelts; n++) {\n+\n+        if (value[n].len > CPU_SETSIZE) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                         \"\\\"worker_cpu_affinity\\\" supports up to %d CPUs only\",\n+                         CPU_SETSIZE);\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        i = 0;\n+        CPU_ZERO(&mask[n - 1]);\n+\n+        for (p = value[n].data + value[n].len - 1;\n+             p >= value[n].data;\n+             p--)\n+        {\n+            ch = *p;\n+\n+            if (ch == ' ') {\n+                continue;\n+            }\n+\n+            i++;\n+\n+            if (ch == '0') {\n+                continue;\n+            }\n+\n+            if (ch == '1') {\n+                CPU_SET(i - 1, &mask[n - 1]);\n+                continue;\n+            }\n+\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                          \"invalid character \\\"%c\\\" in \\\"worker_cpu_affinity\\\"\",\n+                          ch);\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+#else\n+\n+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                       \"\\\"worker_cpu_affinity\\\" is not supported \"\n+                       \"on this platform, ignored\");\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+ngx_cpuset_t *\n+ngx_get_cpu_affinity(ngx_uint_t n)\n+{\n+#if (NGX_HAVE_CPU_AFFINITY)\n+    ngx_uint_t        i, j;\n+    ngx_cpuset_t     *mask;\n+    ngx_core_conf_t  *ccf;\n+\n+    static ngx_cpuset_t  result;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n+                                           ngx_core_module);\n+\n+    if (ccf->cpu_affinity == NULL) {\n+        return NULL;\n+    }\n+\n+    if (ccf->cpu_affinity_auto) {\n+        mask = &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n+\n+        for (i = 0, j = n; /* void */ ; i++) {\n+\n+            if (CPU_ISSET(i % CPU_SETSIZE, mask) && j-- == 0) {\n+                break;\n+            }\n+\n+            if (i == CPU_SETSIZE && j == n) {\n+                /* empty mask */\n+                return NULL;\n+            }\n+\n+            /* void */\n+        }\n+\n+        CPU_ZERO(&result);\n+        CPU_SET(i % CPU_SETSIZE, &result);\n+\n+        return &result;\n+    }\n+\n+    if (ccf->cpu_affinity_n > n) {\n+        return &ccf->cpu_affinity[n];\n+    }\n+\n+    return &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n+\n+#else\n+\n+    return NULL;\n+\n+#endif\n+}\n+\n+\n+static char *\n+ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_str_t        *value;\n+    ngx_core_conf_t  *ccf;\n+\n+    ccf = (ngx_core_conf_t *) conf;\n+\n+    if (ccf->worker_processes != NGX_CONF_UNSET) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n+        ccf->worker_processes = ngx_ncpu;\n+        return NGX_CONF_OK;\n+    }\n+\n+    ccf->worker_processes = ngx_atoi(value[1].data, value[1].len);\n+\n+    if (ccf->worker_processes == NGX_ERROR) {\n+        return \"invalid value\";\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+#if (NGX_HAVE_DLOPEN)\n+    void                *handle;\n+    char               **names, **order;\n+    ngx_str_t           *value, file;\n+    ngx_uint_t           i;\n+    ngx_module_t        *module, **modules;\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (cf->cycle->modules_used) {\n+        return \"is specified too late\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    file = value[1];\n+\n+    if (ngx_conf_full_name(cf->cycle, &file, 0) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);\n+    if (cln == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    handle = ngx_dlopen(file.data);\n+    if (handle == NULL) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           ngx_dlopen_n \" \\\"%s\\\" failed (%s)\",\n+                           file.data, ngx_dlerror());\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cln->handler = ngx_unload_module;\n+    cln->data = handle;\n+\n+    modules = ngx_dlsym(handle, \"ngx_modules\");\n+    if (modules == NULL) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n+                           &value[1], \"ngx_modules\", ngx_dlerror());\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    names = ngx_dlsym(handle, \"ngx_module_names\");\n+    if (names == NULL) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n+                           &value[1], \"ngx_module_names\", ngx_dlerror());\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    order = ngx_dlsym(handle, \"ngx_module_order\");\n+\n+    for (i = 0; modules[i]; i++) {\n+        module = modules[i];\n+        module->name = names[i];\n+\n+        if (ngx_add_module(cf, &file, module, order) != NGX_OK) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cf->log, 0, \"module: %s i:%ui\",\n+                       module->name, module->index);\n+    }\n+\n+    return NGX_CONF_OK;\n+\n+#else\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"\\\"load_module\\\" is not supported \"\n+                       \"on this platform\");\n+    return NGX_CONF_ERROR;\n+\n+#endif\n+}\n+\n+\n+#if (NGX_HAVE_DLOPEN)\n+\n+static void\n+ngx_unload_module(void *data)\n+{\n+    void  *handle = data;\n+\n+    if (ngx_dlclose(handle) != 0) {\n+        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n+                      ngx_dlclose_n \" failed (%s)\", ngx_dlerror());\n+    }\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,26 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGINX_H_INCLUDED_\n+#define _NGINX_H_INCLUDED_\n+\n+\n+#define nginx_version      1017005\n+#define NGINX_VERSION      \"1.17.5\"\n+#define NGINX_VER          \"nginx/\" NGINX_VERSION\n+\n+#ifdef NGX_BUILD\n+#define NGINX_VER_BUILD    NGINX_VER \" (\" NGX_BUILD \")\"\n+#else\n+#define NGINX_VER_BUILD    NGINX_VER\n+#endif\n+\n+#define NGINX_VAR          \"NGINX\"\n+#define NGX_OLDPID_EXT     \".oldbin\"\n+\n+\n+#endif /* _NGINX_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,141 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_array_t *\n+ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size)\n+{\n+    ngx_array_t *a;\n+\n+    a = ngx_palloc(p, sizeof(ngx_array_t));\n+    if (a == NULL) {\n+        return NULL;\n+    }\n+\n+    if (ngx_array_init(a, p, n, size) != NGX_OK) {\n+        return NULL;\n+    }\n+\n+    return a;\n+}\n+\n+\n+void\n+ngx_array_destroy(ngx_array_t *a)\n+{\n+    ngx_pool_t  *p;\n+\n+    p = a->pool;\n+\n+    if ((u_char *) a->elts + a->size * a->nalloc == p->d.last) {\n+        p->d.last -= a->size * a->nalloc;\n+    }\n+\n+    if ((u_char *) a + sizeof(ngx_array_t) == p->d.last) {\n+        p->d.last = (u_char *) a;\n+    }\n+}\n+\n+\n+void *\n+ngx_array_push(ngx_array_t *a)\n+{\n+    void        *elt, *new;\n+    size_t       size;\n+    ngx_pool_t  *p;\n+\n+    if (a->nelts == a->nalloc) {\n+\n+        /* the array is full */\n+\n+        size = a->size * a->nalloc;\n+\n+        p = a->pool;\n+\n+        if ((u_char *) a->elts + size == p->d.last\n+            && p->d.last + a->size <= p->d.end)\n+        {\n+            /*\n+             * the array allocation is the last in the pool\n+             * and there is space for new allocation\n+             */\n+\n+            p->d.last += a->size;\n+            a->nalloc++;\n+\n+        } else {\n+            /* allocate a new array */\n+\n+            new = ngx_palloc(p, 2 * size);\n+            if (new == NULL) {\n+                return NULL;\n+            }\n+\n+            ngx_memcpy(new, a->elts, size);\n+            a->elts = new;\n+            a->nalloc *= 2;\n+        }\n+    }\n+\n+    elt = (u_char *) a->elts + a->size * a->nelts;\n+    a->nelts++;\n+\n+    return elt;\n+}\n+\n+\n+void *\n+ngx_array_push_n(ngx_array_t *a, ngx_uint_t n)\n+{\n+    void        *elt, *new;\n+    size_t       size;\n+    ngx_uint_t   nalloc;\n+    ngx_pool_t  *p;\n+\n+    size = n * a->size;\n+\n+    if (a->nelts + n > a->nalloc) {\n+\n+        /* the array is full */\n+\n+        p = a->pool;\n+\n+        if ((u_char *) a->elts + a->size * a->nalloc == p->d.last\n+            && p->d.last + size <= p->d.end)\n+        {\n+            /*\n+             * the array allocation is the last in the pool\n+             * and there is space for new allocation\n+             */\n+\n+            p->d.last += size;\n+            a->nalloc += n;\n+\n+        } else {\n+            /* allocate a new array */\n+\n+            nalloc = 2 * ((n >= a->nalloc) ? n : a->nalloc);\n+\n+            new = ngx_palloc(p, nalloc * a->size);\n+            if (new == NULL) {\n+                return NULL;\n+            }\n+\n+            ngx_memcpy(new, a->elts, a->nelts * a->size);\n+            a->elts = new;\n+            a->nalloc = nalloc;\n+        }\n+    }\n+\n+    elt = (u_char *) a->elts + a->size * a->nelts;\n+    a->nelts += n;\n+\n+    return elt;\n+}\nDiff:\n@@ -0,0 +1,53 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_ARRAY_H_INCLUDED_\n+#define _NGX_ARRAY_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef struct {\n+    void        *elts;\n+    ngx_uint_t   nelts;\n+    size_t       size;\n+    ngx_uint_t   nalloc;\n+    ngx_pool_t  *pool;\n+} ngx_array_t;\n+\n+\n+ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);\n+void ngx_array_destroy(ngx_array_t *a);\n+void *ngx_array_push(ngx_array_t *a);\n+void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n);\n+\n+\n+static ngx_inline ngx_int_t\n+ngx_array_init(ngx_array_t *array, ngx_pool_t *pool, ngx_uint_t n, size_t size)\n+{\n+    /*\n+     * set \"array->nelts\" before \"array->elts\", otherwise MSVC thinks\n+     * that \"array->nelts\" may be used without having been initialized\n+     */\n+\n+    array->nelts = 0;\n+    array->size = size;\n+    array->nalloc = n;\n+    array->pool = pool;\n+\n+    array->elts = ngx_palloc(pool, n * size);\n+    if (array->elts == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+#endif /* _NGX_ARRAY_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,314 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_buf_t *\n+ngx_create_temp_buf(ngx_pool_t *pool, size_t size)\n+{\n+    ngx_buf_t *b;\n+\n+    b = ngx_calloc_buf(pool);\n+    if (b == NULL) {\n+        return NULL;\n+    }\n+\n+    b->start = ngx_palloc(pool, size);\n+    if (b->start == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_calloc_buf():\n+     *\n+     *     b->file_pos = 0;\n+     *     b->file_last = 0;\n+     *     b->file = NULL;\n+     *     b->shadow = NULL;\n+     *     b->tag = 0;\n+     *     and flags\n+     */\n+\n+    b->pos = b->start;\n+    b->last = b->start;\n+    b->end = b->last + size;\n+    b->temporary = 1;\n+\n+    return b;\n+}\n+\n+\n+ngx_chain_t *\n+ngx_alloc_chain_link(ngx_pool_t *pool)\n+{\n+    ngx_chain_t  *cl;\n+\n+    cl = pool->chain;\n+\n+    if (cl) {\n+        pool->chain = cl->next;\n+        return cl;\n+    }\n+\n+    cl = ngx_palloc(pool, sizeof(ngx_chain_t));\n+    if (cl == NULL) {\n+        return NULL;\n+    }\n+\n+    return cl;\n+}\n+\n+\n+ngx_chain_t *\n+ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs)\n+{\n+    u_char       *p;\n+    ngx_int_t     i;\n+    ngx_buf_t    *b;\n+    ngx_chain_t  *chain, *cl, **ll;\n+\n+    p = ngx_palloc(pool, bufs->num * bufs->size);\n+    if (p == NULL) {\n+        return NULL;\n+    }\n+\n+    ll = &chain;\n+\n+    for (i = 0; i < bufs->num; i++) {\n+\n+        b = ngx_calloc_buf(pool);\n+        if (b == NULL) {\n+            return NULL;\n+        }\n+\n+        /*\n+         * set by ngx_calloc_buf():\n+         *\n+         *     b->file_pos = 0;\n+         *     b->file_last = 0;\n+         *     b->file = NULL;\n+         *     b->shadow = NULL;\n+         *     b->tag = 0;\n+         *     and flags\n+         *\n+         */\n+\n+        b->pos = p;\n+        b->last = p;\n+        b->temporary = 1;\n+\n+        b->start = p;\n+        p += bufs->size;\n+        b->end = p;\n+\n+        cl = ngx_alloc_chain_link(pool);\n+        if (cl == NULL) {\n+            return NULL;\n+        }\n+\n+        cl->buf = b;\n+        *ll = cl;\n+        ll = &cl->next;\n+    }\n+\n+    *ll = NULL;\n+\n+    return chain;\n+}\n+\n+\n+ngx_int_t\n+ngx_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain, ngx_chain_t *in)\n+{\n+    ngx_chain_t  *cl, **ll;\n+\n+    ll = chain;\n+\n+    for (cl = *chain; cl; cl = cl->next) {\n+        ll = &cl->next;\n+    }\n+\n+    while (in) {\n+        cl = ngx_alloc_chain_link(pool);\n+        if (cl == NULL) {\n+            *ll = NULL;\n+            return NGX_ERROR;\n+        }\n+\n+        cl->buf = in->buf;\n+        *ll = cl;\n+        ll = &cl->next;\n+        in = in->next;\n+    }\n+\n+    *ll = NULL;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_chain_t *\n+ngx_chain_get_free_buf(ngx_pool_t *p, ngx_chain_t **free)\n+{\n+    ngx_chain_t  *cl;\n+\n+    if (*free) {\n+        cl = *free;\n+        *free = cl->next;\n+        cl->next = NULL;\n+        return cl;\n+    }\n+\n+    cl = ngx_alloc_chain_link(p);\n+    if (cl == NULL) {\n+        return NULL;\n+    }\n+\n+    cl->buf = ngx_calloc_buf(p);\n+    if (cl->buf == NULL) {\n+        return NULL;\n+    }\n+\n+    cl->next = NULL;\n+\n+    return cl;\n+}\n+\n+\n+void\n+ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free, ngx_chain_t **busy,\n+    ngx_chain_t **out, ngx_buf_tag_t tag)\n+{\n+    ngx_chain_t  *cl;\n+\n+    if (*out) {\n+        if (*busy == NULL) {\n+            *busy = *out;\n+\n+        } else {\n+            for (cl = *busy; cl->next; cl = cl->next) { /* void */ }\n+\n+            cl->next = *out;\n+        }\n+\n+        *out = NULL;\n+    }\n+\n+    while (*busy) {\n+        cl = *busy;\n+\n+        if (ngx_buf_size(cl->buf) != 0) {\n+            break;\n+        }\n+\n+        if (cl->buf->tag != tag) {\n+            *busy = cl->next;\n+            ngx_free_chain(p, cl);\n+            continue;\n+        }\n+\n+        cl->buf->pos = cl->buf->start;\n+        cl->buf->last = cl->buf->start;\n+\n+        *busy = cl->next;\n+        cl->next = *free;\n+        *free = cl;\n+    }\n+}\n+\n+\n+off_t\n+ngx_chain_coalesce_file(ngx_chain_t **in, off_t limit)\n+{\n+    off_t         total, size, aligned, fprev;\n+    ngx_fd_t      fd;\n+    ngx_chain_t  *cl;\n+\n+    total = 0;\n+\n+    cl = *in;\n+    fd = cl->buf->file->fd;\n+\n+    do {\n+        size = cl->buf->file_last - cl->buf->file_pos;\n+\n+        if (size > limit - total) {\n+            size = limit - total;\n+\n+            aligned = (cl->buf->file_pos + size + ngx_pagesize - 1)\n+                       & ~((off_t) ngx_pagesize - 1);\n+\n+            if (aligned <= cl->buf->file_last) {\n+                size = aligned - cl->buf->file_pos;\n+            }\n+\n+            total += size;\n+            break;\n+        }\n+\n+        total += size;\n+        fprev = cl->buf->file_pos + size;\n+        cl = cl->next;\n+\n+    } while (cl\n+             && cl->buf->in_file\n+             && total < limit\n+             && fd == cl->buf->file->fd\n+             && fprev == cl->buf->file_pos);\n+\n+    *in = cl;\n+\n+    return total;\n+}\n+\n+\n+ngx_chain_t *\n+ngx_chain_update_sent(ngx_chain_t *in, off_t sent)\n+{\n+    off_t  size;\n+\n+    for ( /* void */ ; in; in = in->next) {\n+\n+        if (ngx_buf_special(in->buf)) {\n+            continue;\n+        }\n+\n+        if (sent == 0) {\n+            break;\n+        }\n+\n+        size = ngx_buf_size(in->buf);\n+\n+        if (sent >= size) {\n+            sent -= size;\n+\n+            if (ngx_buf_in_memory(in->buf)) {\n+                in->buf->pos = in->buf->last;\n+            }\n+\n+            if (in->buf->in_file) {\n+                in->buf->file_pos = in->buf->file_last;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (ngx_buf_in_memory(in->buf)) {\n+            in->buf->pos += (size_t) sent;\n+        }\n+\n+        if (in->buf->in_file) {\n+            in->buf->file_pos += sent;\n+        }\n+\n+        break;\n+    }\n+\n+    return in;\n+}\nDiff:\n@@ -0,0 +1,170 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_BUF_H_INCLUDED_\n+#define _NGX_BUF_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef void *            ngx_buf_tag_t;\n+\n+typedef struct ngx_buf_s  ngx_buf_t;\n+\n+struct ngx_buf_s {\n+    u_char          *pos;\n+    u_char          *last;\n+    off_t            file_pos;\n+    off_t            file_last;\n+\n+    u_char          *start;         /* start of buffer */\n+    u_char          *end;           /* end of buffer */\n+    ngx_buf_tag_t    tag;\n+    ngx_file_t      *file;\n+    ngx_buf_t       *shadow;\n+\n+\n+    /* the buf's content could be changed */\n+    unsigned         temporary:1;\n+\n+    /*\n+     * the buf's content is in a memory cache or in a read only memory\n+     * and must not be changed\n+     */\n+    unsigned         memory:1;\n+\n+    /* the buf's content is mmap()ed and must not be changed */\n+    unsigned         mmap:1;\n+\n+    unsigned         recycled:1;\n+    unsigned         in_file:1;\n+    unsigned         flush:1;\n+    unsigned         sync:1;\n+    unsigned         last_buf:1;\n+    unsigned         last_in_chain:1;\n+\n+    unsigned         last_shadow:1;\n+    unsigned         temp_file:1;\n+\n+    /* STUB */ int   num;\n+};\n+\n+\n+struct ngx_chain_s {\n+    ngx_buf_t    *buf;\n+    ngx_chain_t  *next;\n+};\n+\n+\n+typedef struct {\n+    ngx_int_t    num;\n+    size_t       size;\n+} ngx_bufs_t;\n+\n+\n+typedef struct ngx_output_chain_ctx_s  ngx_output_chain_ctx_t;\n+\n+typedef ngx_int_t (*ngx_output_chain_filter_pt)(void *ctx, ngx_chain_t *in);\n+\n+typedef void (*ngx_output_chain_aio_pt)(ngx_output_chain_ctx_t *ctx,\n+    ngx_file_t *file);\n+\n+struct ngx_output_chain_ctx_s {\n+    ngx_buf_t                   *buf;\n+    ngx_chain_t                 *in;\n+    ngx_chain_t                 *free;\n+    ngx_chain_t                 *busy;\n+\n+    unsigned                     sendfile:1;\n+    unsigned                     directio:1;\n+    unsigned                     unaligned:1;\n+    unsigned                     need_in_memory:1;\n+    unsigned                     need_in_temp:1;\n+    unsigned                     aio:1;\n+\n+#if (NGX_HAVE_FILE_AIO || NGX_COMPAT)\n+    ngx_output_chain_aio_pt      aio_handler;\n+#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n+    ssize_t                    (*aio_preload)(ngx_buf_t *file);\n+#endif\n+#endif\n+\n+#if (NGX_THREADS || NGX_COMPAT)\n+    ngx_int_t                  (*thread_handler)(ngx_thread_task_t *task,\n+                                                 ngx_file_t *file);\n+    ngx_thread_task_t           *thread_task;\n+#endif\n+\n+    off_t                        alignment;\n+\n+    ngx_pool_t                  *pool;\n+    ngx_int_t                    allocated;\n+    ngx_bufs_t                   bufs;\n+    ngx_buf_tag_t                tag;\n+\n+    ngx_output_chain_filter_pt   output_filter;\n+    void                        *filter_ctx;\n+};\n+\n+\n+typedef struct {\n+    ngx_chain_t                 *out;\n+    ngx_chain_t                **last;\n+    ngx_connection_t            *connection;\n+    ngx_pool_t                  *pool;\n+    off_t                        limit;\n+} ngx_chain_writer_ctx_t;\n+\n+\n+#define NGX_CHAIN_ERROR     (ngx_chain_t *) NGX_ERROR\n+\n+\n+#define ngx_buf_in_memory(b)        (b->temporary || b->memory || b->mmap)\n+#define ngx_buf_in_memory_only(b)   (ngx_buf_in_memory(b) && !b->in_file)\n+\n+#define ngx_buf_special(b)                                                   \\\n+    ((b->flush || b->last_buf || b->sync)                                    \\\n+     && !ngx_buf_in_memory(b) && !b->in_file)\n+\n+#define ngx_buf_sync_only(b)                                                 \\\n+    (b->sync                                                                 \\\n+     && !ngx_buf_in_memory(b) && !b->in_file && !b->flush && !b->last_buf)\n+\n+#define ngx_buf_size(b)                                                      \\\n+    (ngx_buf_in_memory(b) ? (off_t) (b->last - b->pos):                      \\\n+                            (b->file_last - b->file_pos))\n+\n+ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);\n+ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs);\n+\n+\n+#define ngx_alloc_buf(pool)  ngx_palloc(pool, sizeof(ngx_buf_t))\n+#define ngx_calloc_buf(pool) ngx_pcalloc(pool, sizeof(ngx_buf_t))\n+\n+ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool);\n+#define ngx_free_chain(pool, cl)                                             \\\n+    cl->next = pool->chain;                                                  \\\n+    pool->chain = cl\n+\n+\n+\n+ngx_int_t ngx_output_chain(ngx_output_chain_ctx_t *ctx, ngx_chain_t *in);\n+ngx_int_t ngx_chain_writer(void *ctx, ngx_chain_t *in);\n+\n+ngx_int_t ngx_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain,\n+    ngx_chain_t *in);\n+ngx_chain_t *ngx_chain_get_free_buf(ngx_pool_t *p, ngx_chain_t **free);\n+void ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free,\n+    ngx_chain_t **busy, ngx_chain_t **out, ngx_buf_tag_t tag);\n+\n+off_t ngx_chain_coalesce_file(ngx_chain_t **in, off_t limit);\n+\n+ngx_chain_t *ngx_chain_update_sent(ngx_chain_t *in, off_t sent);\n+\n+#endif /* _NGX_BUF_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,1486 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+#define NGX_CONF_BUFFER  4096\n+\n+static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf, ngx_str_t *filename);\n+static ngx_int_t ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last);\n+static ngx_int_t ngx_conf_read_token(ngx_conf_t *cf);\n+static void ngx_conf_flush_files(ngx_cycle_t *cycle);\n+\n+\n+static ngx_command_t  ngx_conf_commands[] = {\n+\n+    { ngx_string(\"include\"),\n+      NGX_ANY_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_include,\n+      0,\n+      0,\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+ngx_module_t  ngx_conf_module = {\n+    NGX_MODULE_V1,\n+    NULL,                                  /* module context */\n+    ngx_conf_commands,                     /* module directives */\n+    NGX_CONF_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    ngx_conf_flush_files,                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+/* The eight fixed arguments */\n+\n+static ngx_uint_t argument_number[] = {\n+    NGX_CONF_NOARGS,\n+    NGX_CONF_TAKE1,\n+    NGX_CONF_TAKE2,\n+    NGX_CONF_TAKE3,\n+    NGX_CONF_TAKE4,\n+    NGX_CONF_TAKE5,\n+    NGX_CONF_TAKE6,\n+    NGX_CONF_TAKE7\n+};\n+\n+\n+char *\n+ngx_conf_param(ngx_conf_t *cf)\n+{\n+    char             *rv;\n+    ngx_str_t        *param;\n+    ngx_buf_t         b;\n+    ngx_conf_file_t   conf_file;\n+\n+    param = &cf->cycle->conf_param;\n+\n+    if (param->len == 0) {\n+        return NGX_CONF_OK;\n+    }\n+\n+    ngx_memzero(&conf_file, sizeof(ngx_conf_file_t));\n+\n+    ngx_memzero(&b, sizeof(ngx_buf_t));\n+\n+    b.start = param->data;\n+    b.pos = param->data;\n+    b.last = param->data + param->len;\n+    b.end = b.last;\n+    b.temporary = 1;\n+\n+    conf_file.file.fd = NGX_INVALID_FILE;\n+    conf_file.file.name.data = NULL;\n+    conf_file.line = 0;\n+\n+    cf->conf_file = &conf_file;\n+    cf->conf_file->buffer = &b;\n+\n+    rv = ngx_conf_parse(cf, NULL);\n+\n+    cf->conf_file = NULL;\n+\n+    return rv;\n+}\n+\n+\n+static ngx_int_t\n+ngx_conf_add_dump(ngx_conf_t *cf, ngx_str_t *filename)\n+{\n+    off_t             size;\n+    u_char           *p;\n+    uint32_t          hash;\n+    ngx_buf_t        *buf;\n+    ngx_str_node_t   *sn;\n+    ngx_conf_dump_t  *cd;\n+\n+    hash = ngx_crc32_long(filename->data, filename->len);\n+\n+    sn = ngx_str_rbtree_lookup(&cf->cycle->config_dump_rbtree, filename, hash);\n+\n+    if (sn) {\n+        cf->conf_file->dump = NULL;\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_pstrdup(cf->cycle->pool, filename);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    cd = ngx_array_push(&cf->cycle->config_dump);\n+    if (cd == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    size = ngx_file_size(&cf->conf_file->file.info);\n+\n+    buf = ngx_create_temp_buf(cf->cycle->pool, (size_t) size);\n+    if (buf == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    cd->name.data = p;\n+    cd->name.len = filename->len;\n+    cd->buffer = buf;\n+\n+    cf->conf_file->dump = buf;\n+\n+    sn = ngx_palloc(cf->temp_pool, sizeof(ngx_str_node_t));\n+    if (sn == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    sn->node.key = hash;\n+    sn->str = cd->name;\n+\n+    ngx_rbtree_insert(&cf->cycle->config_dump_rbtree, &sn->node);\n+\n+    return NGX_OK;\n+}\n+\n+\n+char *\n+ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename)\n+{\n+    char             *rv;\n+    ngx_fd_t          fd;\n+    ngx_int_t         rc;\n+    ngx_buf_t         buf;\n+    ngx_conf_file_t  *prev, conf_file;\n+    enum {\n+        parse_file = 0,\n+        parse_block,\n+        parse_param\n+    } type;\n+\n+#if (NGX_SUPPRESS_WARN)\n+    fd = NGX_INVALID_FILE;\n+    prev = NULL;\n+#endif\n+\n+    if (filename) {\n+\n+        /* open configuration file */\n+\n+        fd = ngx_open_file(filename->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);\n+\n+        if (fd == NGX_INVALID_FILE) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n+                               ngx_open_file_n \" \\\"%s\\\" failed\",\n+                               filename->data);\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        prev = cf->conf_file;\n+\n+        cf->conf_file = &conf_file;\n+\n+        if (ngx_fd_info(fd, &cf->conf_file->file.info) == NGX_FILE_ERROR) {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, ngx_errno,\n+                          ngx_fd_info_n \" \\\"%s\\\" failed\", filename->data);\n+        }\n+\n+        cf->conf_file->buffer = &buf;\n+\n+        buf.start = ngx_alloc(NGX_CONF_BUFFER, cf->log);\n+        if (buf.start == NULL) {\n+            goto failed;\n+        }\n+\n+        buf.pos = buf.start;\n+        buf.last = buf.start;\n+        buf.end = buf.last + NGX_CONF_BUFFER;\n+        buf.temporary = 1;\n+\n+        cf->conf_file->file.fd = fd;\n+        cf->conf_file->file.name.len = filename->len;\n+        cf->conf_file->file.name.data = filename->data;\n+        cf->conf_file->file.offset = 0;\n+        cf->conf_file->file.log = cf->log;\n+        cf->conf_file->line = 1;\n+\n+        type = parse_file;\n+\n+        if (ngx_dump_config\n+#if (NGX_DEBUG)\n+            || 1\n+#endif\n+           )\n+        {\n+            if (ngx_conf_add_dump(cf, filename) != NGX_OK) {\n+                goto failed;\n+            }\n+\n+        } else {\n+            cf->conf_file->dump = NULL;\n+        }\n+\n+    } else if (cf->conf_file->file.fd != NGX_INVALID_FILE) {\n+\n+        type = parse_block;\n+\n+    } else {\n+        type = parse_param;\n+    }\n+\n+\n+    for ( ;; ) {\n+        rc = ngx_conf_read_token(cf);\n+\n+        /*\n+         * ngx_conf_read_token() may return\n+         *\n+         *    NGX_ERROR             there is error\n+         *    NGX_OK                the token terminated by \";\" was found\n+         *    NGX_CONF_BLOCK_START  the token terminated by \"{\" was found\n+         *    NGX_CONF_BLOCK_DONE   the \"}\" was found\n+         *    NGX_CONF_FILE_DONE    the configuration file is done\n+         */\n+\n+        if (rc == NGX_ERROR) {\n+            goto done;\n+        }\n+\n+        if (rc == NGX_CONF_BLOCK_DONE) {\n+\n+            if (type != parse_block) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"unexpected \\\"}\\\"\");\n+                goto failed;\n+            }\n+\n+            goto done;\n+        }\n+\n+        if (rc == NGX_CONF_FILE_DONE) {\n+\n+            if (type == parse_block) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"unexpected end of file, expecting \\\"}\\\"\");\n+                goto failed;\n+            }\n+\n+            goto done;\n+        }\n+\n+        if (rc == NGX_CONF_BLOCK_START) {\n+\n+            if (type == parse_param) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"block directives are not supported \"\n+                                   \"in -g option\");\n+                goto failed;\n+            }\n+        }\n+\n+        /* rc == NGX_OK || rc == NGX_CONF_BLOCK_START */\n+\n+        if (cf->handler) {\n+\n+            /*\n+             * the custom handler, i.e., that is used in the http's\n+             * \"types { ... }\" directive\n+             */\n+\n+            if (rc == NGX_CONF_BLOCK_START) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"unexpected \\\"{\\\"\");\n+                goto failed;\n+            }\n+\n+            rv = (*cf->handler)(cf, NULL, cf->handler_conf);\n+            if (rv == NGX_CONF_OK) {\n+                continue;\n+            }\n+\n+            if (rv == NGX_CONF_ERROR) {\n+                goto failed;\n+            }\n+\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"%s\", rv);\n+\n+            goto failed;\n+        }\n+\n+\n+        rc = ngx_conf_handler(cf, rc);\n+\n+        if (rc == NGX_ERROR) {\n+            goto failed;\n+        }\n+    }\n+\n+failed:\n+\n+    rc = NGX_ERROR;\n+\n+done:\n+\n+    if (filename) {\n+        if (cf->conf_file->buffer->start) {\n+            ngx_free(cf->conf_file->buffer->start);\n+        }\n+\n+        if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n+            ngx_log_error(NGX_LOG_ALERT, cf->log, ngx_errno,\n+                          ngx_close_file_n \" %s failed\",\n+                          filename->data);\n+            rc = NGX_ERROR;\n+        }\n+\n+        cf->conf_file = prev;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last)\n+{\n+    char           *rv;\n+    void           *conf, **confp;\n+    ngx_uint_t      i, found;\n+    ngx_str_t      *name;\n+    ngx_command_t  *cmd;\n+\n+    name = cf->args->elts;\n+\n+    found = 0;\n+\n+    for (i = 0; cf->cycle->modules[i]; i++) {\n+\n+        cmd = cf->cycle->modules[i]->commands;\n+        if (cmd == NULL) {\n+            continue;\n+        }\n+\n+        for ( /* void */ ; cmd->name.len; cmd++) {\n+\n+            if (name->len != cmd->name.len) {\n+                continue;\n+            }\n+\n+            if (ngx_strcmp(name->data, cmd->name.data) != 0) {\n+                continue;\n+            }\n+\n+            found = 1;\n+\n+            if (cf->cycle->modules[i]->type != NGX_CONF_MODULE\n+                && cf->cycle->modules[i]->type != cf->module_type)\n+            {\n+                continue;\n+            }\n+\n+            /* is the directive's location right ? */\n+\n+            if (!(cmd->type & cf->cmd_type)) {\n+                continue;\n+            }\n+\n+            if (!(cmd->type & NGX_CONF_BLOCK) && last != NGX_OK) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                  \"directive \\\"%s\\\" is not terminated by \\\";\\\"\",\n+                                  name->data);\n+                return NGX_ERROR;\n+            }\n+\n+            if ((cmd->type & NGX_CONF_BLOCK) && last != NGX_CONF_BLOCK_START) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"directive \\\"%s\\\" has no opening \\\"{\\\"\",\n+                                   name->data);\n+                return NGX_ERROR;\n+            }\n+\n+            /* is the directive's argument count right ? */\n+\n+            if (!(cmd->type & NGX_CONF_ANY)) {\n+\n+                if (cmd->type & NGX_CONF_FLAG) {\n+\n+                    if (cf->args->nelts != 2) {\n+                        goto invalid;\n+                    }\n+\n+                } else if (cmd->type & NGX_CONF_1MORE) {\n+\n+                    if (cf->args->nelts < 2) {\n+                        goto invalid;\n+                    }\n+\n+                } else if (cmd->type & NGX_CONF_2MORE) {\n+\n+                    if (cf->args->nelts < 3) {\n+                        goto invalid;\n+                    }\n+\n+                } else if (cf->args->nelts > NGX_CONF_MAX_ARGS) {\n+\n+                    goto invalid;\n+\n+                } else if (!(cmd->type & argument_number[cf->args->nelts - 1]))\n+                {\n+                    goto invalid;\n+                }\n+            }\n+\n+            /* set up the directive's configuration context */\n+\n+            conf = NULL;\n+\n+            if (cmd->type & NGX_DIRECT_CONF) {\n+                conf = ((void **) cf->ctx)[cf->cycle->modules[i]->index];\n+\n+            } else if (cmd->type & NGX_MAIN_CONF) {\n+                conf = &(((void **) cf->ctx)[cf->cycle->modules[i]->index]);\n+\n+            } else if (cf->ctx) {\n+                confp = *(void **) ((char *) cf->ctx + cmd->conf);\n+\n+                if (confp) {\n+                    conf = confp[cf->cycle->modules[i]->ctx_index];\n+                }\n+            }\n+\n+            rv = cmd->set(cf, cmd, conf);\n+\n+            if (rv == NGX_CONF_OK) {\n+                return NGX_OK;\n+            }\n+\n+            if (rv == NGX_CONF_ERROR) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"\\\"%s\\\" directive %s\", name->data, rv);\n+\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    if (found) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"\\\"%s\\\" directive is not allowed here\", name->data);\n+\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"unknown directive \\\"%s\\\"\", name->data);\n+\n+    return NGX_ERROR;\n+\n+invalid:\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"invalid number of arguments in \\\"%s\\\" directive\",\n+                       name->data);\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+static ngx_int_t\n+ngx_conf_read_token(ngx_conf_t *cf)\n+{\n+    u_char      *start, ch, *src, *dst;\n+    off_t        file_size;\n+    size_t       len;\n+    ssize_t      n, size;\n+    ngx_uint_t   found, need_space, last_space, sharp_comment, variable;\n+    ngx_uint_t   quoted, s_quoted, d_quoted, start_line;\n+    ngx_str_t   *word;\n+    ngx_buf_t   *b, *dump;\n+\n+    found = 0;\n+    need_space = 0;\n+    last_space = 1;\n+    sharp_comment = 0;\n+    variable = 0;\n+    quoted = 0;\n+    s_quoted = 0;\n+    d_quoted = 0;\n+\n+    cf->args->nelts = 0;\n+    b = cf->conf_file->buffer;\n+    dump = cf->conf_file->dump;\n+    start = b->pos;\n+    start_line = cf->conf_file->line;\n+\n+    file_size = ngx_file_size(&cf->conf_file->file.info);\n+\n+    for ( ;; ) {\n+\n+        if (b->pos >= b->last) {\n+\n+            if (cf->conf_file->file.offset >= file_size) {\n+\n+                if (cf->args->nelts > 0 || !last_space) {\n+\n+                    if (cf->conf_file->file.fd == NGX_INVALID_FILE) {\n+                        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                           \"unexpected end of parameter, \"\n+                                           \"expecting \\\";\\\"\");\n+                        return NGX_ERROR;\n+                    }\n+\n+                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                  \"unexpected end of file, \"\n+                                  \"expecting \\\";\\\" or \\\"}\\\"\");\n+                    return NGX_ERROR;\n+                }\n+\n+                return NGX_CONF_FILE_DONE;\n+            }\n+\n+            len = b->pos - start;\n+\n+            if (len == NGX_CONF_BUFFER) {\n+                cf->conf_file->line = start_line;\n+\n+                if (d_quoted) {\n+                    ch = '\"';\n+\n+                } else if (s_quoted) {\n+                    ch = '\\'';\n+\n+                } else {\n+                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                       \"too long parameter \\\"%*s...\\\" started\",\n+                                       10, start);\n+                    return NGX_ERROR;\n+                }\n+\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"too long parameter, probably \"\n+                                   \"missing terminating \\\"%c\\\" character\", ch);\n+                return NGX_ERROR;\n+            }\n+\n+            if (len) {\n+                ngx_memmove(b->start, start, len);\n+            }\n+\n+            size = (ssize_t) (file_size - cf->conf_file->file.offset);\n+\n+            if (size > b->end - (b->start + len)) {\n+                size = b->end - (b->start + len);\n+            }\n+\n+            n = ngx_read_file(&cf->conf_file->file, b->start + len, size,\n+                              cf->conf_file->file.offset);\n+\n+            if (n == NGX_ERROR) {\n+                return NGX_ERROR;\n+            }\n+\n+            if (n != size) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   ngx_read_file_n \" returned \"\n+                                   \"only %z bytes instead of %z\",\n+                                   n, size);\n+                return NGX_ERROR;\n+            }\n+\n+            b->pos = b->start + len;\n+            b->last = b->pos + n;\n+            start = b->start;\n+\n+            if (dump) {\n+                dump->last = ngx_cpymem(dump->last, b->pos, size);\n+            }\n+        }\n+\n+        ch = *b->pos++;\n+\n+        if (ch == LF) {\n+            cf->conf_file->line++;\n+\n+            if (sharp_comment) {\n+                sharp_comment = 0;\n+            }\n+        }\n+\n+        if (sharp_comment) {\n+            continue;\n+        }\n+\n+        if (quoted) {\n+            quoted = 0;\n+            continue;\n+        }\n+\n+        if (need_space) {\n+            if (ch == ' ' || ch == '\\t' || ch == CR || ch == LF) {\n+                last_space = 1;\n+                need_space = 0;\n+                continue;\n+            }\n+\n+            if (ch == ';') {\n+                return NGX_OK;\n+            }\n+\n+            if (ch == '{') {\n+                return NGX_CONF_BLOCK_START;\n+            }\n+\n+            if (ch == ')') {\n+                last_space = 1;\n+                need_space = 0;\n+\n+            } else {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"unexpected \\\"%c\\\"\", ch);\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        if (last_space) {\n+\n+            start = b->pos - 1;\n+            start_line = cf->conf_file->line;\n+\n+            if (ch == ' ' || ch == '\\t' || ch == CR || ch == LF) {\n+                continue;\n+            }\n+\n+            switch (ch) {\n+\n+            case ';':\n+            case '{':\n+                if (cf->args->nelts == 0) {\n+                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                       \"unexpected \\\"%c\\\"\", ch);\n+                    return NGX_ERROR;\n+                }\n+\n+                if (ch == '{') {\n+                    return NGX_CONF_BLOCK_START;\n+                }\n+\n+                return NGX_OK;\n+\n+            case '}':\n+                if (cf->args->nelts != 0) {\n+                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                       \"unexpected \\\"}\\\"\");\n+                    return NGX_ERROR;\n+                }\n+\n+                return NGX_CONF_BLOCK_DONE;\n+\n+            case '#':\n+                sharp_comment = 1;\n+                continue;\n+\n+            case '\\\\':\n+                quoted = 1;\n+                last_space = 0;\n+                continue;\n+\n+            case '\"':\n+                start++;\n+                d_quoted = 1;\n+                last_space = 0;\n+                continue;\n+\n+            case '\\'':\n+                start++;\n+                s_quoted = 1;\n+                last_space = 0;\n+                continue;\n+\n+            case '$':\n+                variable = 1;\n+                last_space = 0;\n+                continue;\n+\n+            default:\n+                last_space = 0;\n+            }\n+\n+        } else {\n+            if (ch == '{' && variable) {\n+                continue;\n+            }\n+\n+            variable = 0;\n+\n+            if (ch == '\\\\') {\n+                quoted = 1;\n+                continue;\n+            }\n+\n+            if (ch == '$') {\n+                variable = 1;\n+                continue;\n+            }\n+\n+            if (d_quoted) {\n+                if (ch == '\"') {\n+                    d_quoted = 0;\n+                    need_space = 1;\n+                    found = 1;\n+                }\n+\n+            } else if (s_quoted) {\n+                if (ch == '\\'') {\n+                    s_quoted = 0;\n+                    need_space = 1;\n+                    found = 1;\n+                }\n+\n+            } else if (ch == ' ' || ch == '\\t' || ch == CR || ch == LF\n+                       || ch == ';' || ch == '{')\n+            {\n+                last_space = 1;\n+                found = 1;\n+            }\n+\n+            if (found) {\n+                word = ngx_array_push(cf->args);\n+                if (word == NULL) {\n+                    return NGX_ERROR;\n+                }\n+\n+                word->data = ngx_pnalloc(cf->pool, b->pos - 1 - start + 1);\n+                if (word->data == NULL) {\n+                    return NGX_ERROR;\n+                }\n+\n+                for (dst = word->data, src = start, len = 0;\n+                     src < b->pos - 1;\n+                     len++)\n+                {\n+                    if (*src == '\\\\') {\n+                        switch (src[1]) {\n+                        case '\"':\n+                        case '\\'':\n+                        case '\\\\':\n+                            src++;\n+                            break;\n+\n+                        case 't':\n+                            *dst++ = '\\t';\n+                            src += 2;\n+                            continue;\n+\n+                        case 'r':\n+                            *dst++ = '\\r';\n+                            src += 2;\n+                            continue;\n+\n+                        case 'n':\n+                            *dst++ = '\\n';\n+                            src += 2;\n+                            continue;\n+                        }\n+\n+                    }\n+                    *dst++ = *src++;\n+                }\n+                *dst = '\\0';\n+                word->len = len;\n+\n+                if (ch == ';') {\n+                    return NGX_OK;\n+                }\n+\n+                if (ch == '{') {\n+                    return NGX_CONF_BLOCK_START;\n+                }\n+\n+                found = 0;\n+            }\n+        }\n+    }\n+}\n+\n+\n+char *\n+ngx_conf_include(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char        *rv;\n+    ngx_int_t    n;\n+    ngx_str_t   *value, file, name;\n+    ngx_glob_t   gl;\n+\n+    value = cf->args->elts;\n+    file = value[1];\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n+\n+    if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (strpbrk((char *) file.data, \"*?[\") == NULL) {\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n+\n+        return ngx_conf_parse(cf, &file);\n+    }\n+\n+    ngx_memzero(&gl, sizeof(ngx_glob_t));\n+\n+    gl.pattern = file.data;\n+    gl.log = cf->log;\n+    gl.test = 1;\n+\n+    if (ngx_open_glob(&gl) != NGX_OK) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n+                           ngx_open_glob_n \" \\\"%s\\\" failed\", file.data);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    rv = NGX_CONF_OK;\n+\n+    for ( ;; ) {\n+        n = ngx_read_glob(&gl, &name);\n+\n+        if (n != NGX_OK) {\n+            break;\n+        }\n+\n+        file.len = name.len++;\n+        file.data = ngx_pstrdup(cf->pool, &name);\n+        if (file.data == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n+\n+        rv = ngx_conf_parse(cf, &file);\n+\n+        if (rv != NGX_CONF_OK) {\n+            break;\n+        }\n+    }\n+\n+    ngx_close_glob(&gl);\n+\n+    return rv;\n+}\n+\n+\n+ngx_int_t\n+ngx_conf_full_name(ngx_cycle_t *cycle, ngx_str_t *name, ngx_uint_t conf_prefix)\n+{\n+    ngx_str_t  *prefix;\n+\n+    prefix = conf_prefix ? &cycle->conf_prefix : &cycle->prefix;\n+\n+    return ngx_get_full_name(cycle->pool, prefix, name);\n+}\n+\n+\n+ngx_open_file_t *\n+ngx_conf_open_file(ngx_cycle_t *cycle, ngx_str_t *name)\n+{\n+    ngx_str_t         full;\n+    ngx_uint_t        i;\n+    ngx_list_part_t  *part;\n+    ngx_open_file_t  *file;\n+\n+#if (NGX_SUPPRESS_WARN)\n+    ngx_str_null(&full);\n+#endif\n+\n+    if (name->len) {\n+        full = *name;\n+\n+        if (ngx_conf_full_name(cycle, &full, 0) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        part = &cycle->open_files.part;\n+        file = part->elts;\n+\n+        for (i = 0; /* void */ ; i++) {\n+\n+            if (i >= part->nelts) {\n+                if (part->next == NULL) {\n+                    break;\n+                }\n+                part = part->next;\n+                file = part->elts;\n+                i = 0;\n+            }\n+\n+            if (full.len != file[i].name.len) {\n+                continue;\n+            }\n+\n+            if (ngx_strcmp(full.data, file[i].name.data) == 0) {\n+                return &file[i];\n+            }\n+        }\n+    }\n+\n+    file = ngx_list_push(&cycle->open_files);\n+    if (file == NULL) {\n+        return NULL;\n+    }\n+\n+    if (name->len) {\n+        file->fd = NGX_INVALID_FILE;\n+        file->name = full;\n+\n+    } else {\n+        file->fd = ngx_stderr;\n+        file->name = *name;\n+    }\n+\n+    file->flush = NULL;\n+    file->data = NULL;\n+\n+    return file;\n+}\n+\n+\n+static void\n+ngx_conf_flush_files(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t        i;\n+    ngx_list_part_t  *part;\n+    ngx_open_file_t  *file;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"flush files\");\n+\n+    part = &cycle->open_files.part;\n+    file = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            file = part->elts;\n+            i = 0;\n+        }\n+\n+        if (file[i].flush) {\n+            file[i].flush(&file[i], cycle->log);\n+        }\n+    }\n+}\n+\n+\n+void ngx_cdecl\n+ngx_conf_log_error(ngx_uint_t level, ngx_conf_t *cf, ngx_err_t err,\n+    const char *fmt, ...)\n+{\n+    u_char   errstr[NGX_MAX_CONF_ERRSTR], *p, *last;\n+    va_list  args;\n+\n+    last = errstr + NGX_MAX_CONF_ERRSTR;\n+\n+    va_start(args, fmt);\n+    p = ngx_vslprintf(errstr, last, fmt, args);\n+    va_end(args);\n+\n+    if (err) {\n+        p = ngx_log_errno(p, last, err);\n+    }\n+\n+    if (cf->conf_file == NULL) {\n+        ngx_log_error(level, cf->log, 0, \"%*s\", p - errstr, errstr);\n+        return;\n+    }\n+\n+    if (cf->conf_file->file.fd == NGX_INVALID_FILE) {\n+        ngx_log_error(level, cf->log, 0, \"%*s in command line\",\n+                      p - errstr, errstr);\n+        return;\n+    }\n+\n+    ngx_log_error(level, cf->log, 0, \"%*s in %s:%ui\",\n+                  p - errstr, errstr,\n+                  cf->conf_file->file.name.data, cf->conf_file->line);\n+}\n+\n+\n+char *\n+ngx_conf_set_flag_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t        *value;\n+    ngx_flag_t       *fp;\n+    ngx_conf_post_t  *post;\n+\n+    fp = (ngx_flag_t *) (p + cmd->offset);\n+\n+    if (*fp != NGX_CONF_UNSET) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (ngx_strcasecmp(value[1].data, (u_char *) \"on\") == 0) {\n+        *fp = 1;\n+\n+    } else if (ngx_strcasecmp(value[1].data, (u_char *) \"off\") == 0) {\n+        *fp = 0;\n+\n+    } else {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                     \"invalid value \\\"%s\\\" in \\\"%s\\\" directive, \"\n+                     \"it must be \\\"on\\\" or \\\"off\\\"\",\n+                     value[1].data, cmd->name.data);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, fp);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_str_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t        *field, *value;\n+    ngx_conf_post_t  *post;\n+\n+    field = (ngx_str_t *) (p + cmd->offset);\n+\n+    if (field->data) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    *field = value[1];\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, field);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_str_array_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t         *value, *s;\n+    ngx_array_t      **a;\n+    ngx_conf_post_t   *post;\n+\n+    a = (ngx_array_t **) (p + cmd->offset);\n+\n+    if (*a == NGX_CONF_UNSET_PTR) {\n+        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_str_t));\n+        if (*a == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    s = ngx_array_push(*a);\n+    if (s == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    *s = value[1];\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, s);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t         *value;\n+    ngx_array_t      **a;\n+    ngx_keyval_t      *kv;\n+    ngx_conf_post_t   *post;\n+\n+    a = (ngx_array_t **) (p + cmd->offset);\n+\n+    if (*a == NULL) {\n+        *a = ngx_array_create(cf->pool, 4, sizeof(ngx_keyval_t));\n+        if (*a == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    kv = ngx_array_push(*a);\n+    if (kv == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    kv->key = value[1];\n+    kv->value = value[2];\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, kv);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_num_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_int_t        *np;\n+    ngx_str_t        *value;\n+    ngx_conf_post_t  *post;\n+\n+\n+    np = (ngx_int_t *) (p + cmd->offset);\n+\n+    if (*np != NGX_CONF_UNSET) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+    *np = ngx_atoi(value[1].data, value[1].len);\n+    if (*np == NGX_ERROR) {\n+        return \"invalid number\";\n+    }\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, np);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_size_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    size_t           *sp;\n+    ngx_str_t        *value;\n+    ngx_conf_post_t  *post;\n+\n+\n+    sp = (size_t *) (p + cmd->offset);\n+    if (*sp != NGX_CONF_UNSET_SIZE) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    *sp = ngx_parse_size(&value[1]);\n+    if (*sp == (size_t) NGX_ERROR) {\n+        return \"invalid value\";\n+    }\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, sp);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_off_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    off_t            *op;\n+    ngx_str_t        *value;\n+    ngx_conf_post_t  *post;\n+\n+\n+    op = (off_t *) (p + cmd->offset);\n+    if (*op != NGX_CONF_UNSET) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    *op = ngx_parse_offset(&value[1]);\n+    if (*op == (off_t) NGX_ERROR) {\n+        return \"invalid value\";\n+    }\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, op);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_msec_t       *msp;\n+    ngx_str_t        *value;\n+    ngx_conf_post_t  *post;\n+\n+\n+    msp = (ngx_msec_t *) (p + cmd->offset);\n+    if (*msp != NGX_CONF_UNSET_MSEC) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    *msp = ngx_parse_time(&value[1], 0);\n+    if (*msp == (ngx_msec_t) NGX_ERROR) {\n+        return \"invalid value\";\n+    }\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, msp);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    time_t           *sp;\n+    ngx_str_t        *value;\n+    ngx_conf_post_t  *post;\n+\n+\n+    sp = (time_t *) (p + cmd->offset);\n+    if (*sp != NGX_CONF_UNSET) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    *sp = ngx_parse_time(&value[1], 1);\n+    if (*sp == (time_t) NGX_ERROR) {\n+        return \"invalid value\";\n+    }\n+\n+    if (cmd->post) {\n+        post = cmd->post;\n+        return post->post_handler(cf, post, sp);\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_bufs_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char *p = conf;\n+\n+    ngx_str_t   *value;\n+    ngx_bufs_t  *bufs;\n+\n+\n+    bufs = (ngx_bufs_t *) (p + cmd->offset);\n+    if (bufs->num) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    bufs->num = ngx_atoi(value[1].data, value[1].len);\n+    if (bufs->num == NGX_ERROR || bufs->num == 0) {\n+        return \"invalid value\";\n+    }\n+\n+    bufs->size = ngx_parse_size(&value[2]);\n+    if (bufs->size == (size_t) NGX_ERROR || bufs->size == 0) {\n+        return \"invalid value\";\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_set_enum_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_uint_t       *np, i;\n+    ngx_str_t        *value;\n+    ngx_conf_enum_t  *e;\n+\n+    np = (ngx_uint_t *) (p + cmd->offset);\n+\n+    if (*np != NGX_CONF_UNSET_UINT) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+    e = cmd->post;\n+\n+    for (i = 0; e[i].name.len != 0; i++) {\n+        if (e[i].name.len != value[1].len\n+            || ngx_strcasecmp(e[i].name.data, value[1].data) != 0)\n+        {\n+            continue;\n+        }\n+\n+        *np = e[i].value;\n+\n+        return NGX_CONF_OK;\n+    }\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"invalid value \\\"%s\\\"\", value[1].data);\n+\n+    return NGX_CONF_ERROR;\n+}\n+\n+\n+char *\n+ngx_conf_set_bitmask_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_uint_t          *np, i, m;\n+    ngx_str_t           *value;\n+    ngx_conf_bitmask_t  *mask;\n+\n+\n+    np = (ngx_uint_t *) (p + cmd->offset);\n+    value = cf->args->elts;\n+    mask = cmd->post;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+        for (m = 0; mask[m].name.len != 0; m++) {\n+\n+            if (mask[m].name.len != value[i].len\n+                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)\n+            {\n+                continue;\n+            }\n+\n+            if (*np & mask[m].mask) {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"duplicate value \\\"%s\\\"\", value[i].data);\n+\n+            } else {\n+                *np |= mask[m].mask;\n+            }\n+\n+            break;\n+        }\n+\n+        if (mask[m].name.len == 0) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"invalid value \\\"%s\\\"\", value[i].data);\n+\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+#if 0\n+\n+char *\n+ngx_conf_unsupported(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    return \"unsupported on this platform\";\n+}\n+\n+#endif\n+\n+\n+char *\n+ngx_conf_deprecated(ngx_conf_t *cf, void *post, void *data)\n+{\n+    ngx_conf_deprecated_t  *d = post;\n+\n+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                       \"the \\\"%s\\\" directive is deprecated, \"\n+                       \"use the \\\"%s\\\" directive instead\",\n+                       d->old_name, d->new_name);\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_conf_check_num_bounds(ngx_conf_t *cf, void *post, void *data)\n+{\n+    ngx_conf_num_bounds_t  *bounds = post;\n+    ngx_int_t  *np = data;\n+\n+    if (bounds->high == -1) {\n+        if (*np >= bounds->low) {\n+            return NGX_CONF_OK;\n+        }\n+\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"value must be equal to or greater than %i\",\n+                           bounds->low);\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (*np >= bounds->low && *np <= bounds->high) {\n+        return NGX_CONF_OK;\n+    }\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"value must be between %i and %i\",\n+                       bounds->low, bounds->high);\n+\n+    return NGX_CONF_ERROR;\n+}\nDiff:\n@@ -0,0 +1,295 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CONF_FILE_H_INCLUDED_\n+#define _NGX_CONF_FILE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/*\n+ *        AAAA  number of arguments\n+ *      FF      command flags\n+ *    TT        command type, i.e. HTTP \"location\" or \"server\" command\n+ */\n+\n+#define NGX_CONF_NOARGS      0x00000001\n+#define NGX_CONF_TAKE1       0x00000002\n+#define NGX_CONF_TAKE2       0x00000004\n+#define NGX_CONF_TAKE3       0x00000008\n+#define NGX_CONF_TAKE4       0x00000010\n+#define NGX_CONF_TAKE5       0x00000020\n+#define NGX_CONF_TAKE6       0x00000040\n+#define NGX_CONF_TAKE7       0x00000080\n+\n+#define NGX_CONF_MAX_ARGS    8\n+\n+#define NGX_CONF_TAKE12      (NGX_CONF_TAKE1|NGX_CONF_TAKE2)\n+#define NGX_CONF_TAKE13      (NGX_CONF_TAKE1|NGX_CONF_TAKE3)\n+\n+#define NGX_CONF_TAKE23      (NGX_CONF_TAKE2|NGX_CONF_TAKE3)\n+\n+#define NGX_CONF_TAKE123     (NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3)\n+#define NGX_CONF_TAKE1234    (NGX_CONF_TAKE1|NGX_CONF_TAKE2|NGX_CONF_TAKE3   \\\n+                              |NGX_CONF_TAKE4)\n+\n+#define NGX_CONF_ARGS_NUMBER 0x000000ff\n+#define NGX_CONF_BLOCK       0x00000100\n+#define NGX_CONF_FLAG        0x00000200\n+#define NGX_CONF_ANY         0x00000400\n+#define NGX_CONF_1MORE       0x00000800\n+#define NGX_CONF_2MORE       0x00001000\n+\n+#define NGX_DIRECT_CONF      0x00010000\n+\n+#define NGX_MAIN_CONF        0x01000000\n+#define NGX_ANY_CONF         0xFF000000\n+\n+\n+\n+#define NGX_CONF_UNSET       -1\n+#define NGX_CONF_UNSET_UINT  (ngx_uint_t) -1\n+#define NGX_CONF_UNSET_PTR   (void *) -1\n+#define NGX_CONF_UNSET_SIZE  (size_t) -1\n+#define NGX_CONF_UNSET_MSEC  (ngx_msec_t) -1\n+\n+\n+#define NGX_CONF_OK          NULL\n+#define NGX_CONF_ERROR       (void *) -1\n+\n+#define NGX_CONF_BLOCK_START 1\n+#define NGX_CONF_BLOCK_DONE  2\n+#define NGX_CONF_FILE_DONE   3\n+\n+#define NGX_CORE_MODULE      0x45524F43  /* \"CORE\" */\n+#define NGX_CONF_MODULE      0x464E4F43  /* \"CONF\" */\n+\n+\n+#define NGX_MAX_CONF_ERRSTR  1024\n+\n+\n+struct ngx_command_s {\n+    ngx_str_t             name;\n+    ngx_uint_t            type;\n+    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+    ngx_uint_t            conf;\n+    ngx_uint_t            offset;\n+    void                 *post;\n+};\n+\n+#define ngx_null_command  { ngx_null_string, 0, NULL, 0, 0, NULL }\n+\n+\n+struct ngx_open_file_s {\n+    ngx_fd_t              fd;\n+    ngx_str_t             name;\n+\n+    void                (*flush)(ngx_open_file_t *file, ngx_log_t *log);\n+    void                 *data;\n+};\n+\n+\n+typedef struct {\n+    ngx_file_t            file;\n+    ngx_buf_t            *buffer;\n+    ngx_buf_t            *dump;\n+    ngx_uint_t            line;\n+} ngx_conf_file_t;\n+\n+\n+typedef struct {\n+    ngx_str_t             name;\n+    ngx_buf_t            *buffer;\n+} ngx_conf_dump_t;\n+\n+\n+typedef char *(*ngx_conf_handler_pt)(ngx_conf_t *cf,\n+    ngx_command_t *dummy, void *conf);\n+\n+\n+struct ngx_conf_s {\n+    char                 *name;\n+    ngx_array_t          *args;\n+\n+    ngx_cycle_t          *cycle;\n+    ngx_pool_t           *pool;\n+    ngx_pool_t           *temp_pool;\n+    ngx_conf_file_t      *conf_file;\n+    ngx_log_t            *log;\n+\n+    void                 *ctx;\n+    ngx_uint_t            module_type;\n+    ngx_uint_t            cmd_type;\n+\n+    ngx_conf_handler_pt   handler;\n+    void                 *handler_conf;\n+};\n+\n+\n+typedef char *(*ngx_conf_post_handler_pt) (ngx_conf_t *cf,\n+    void *data, void *conf);\n+\n+typedef struct {\n+    ngx_conf_post_handler_pt  post_handler;\n+} ngx_conf_post_t;\n+\n+\n+typedef struct {\n+    ngx_conf_post_handler_pt  post_handler;\n+    char                     *old_name;\n+    char                     *new_name;\n+} ngx_conf_deprecated_t;\n+\n+\n+typedef struct {\n+    ngx_conf_post_handler_pt  post_handler;\n+    ngx_int_t                 low;\n+    ngx_int_t                 high;\n+} ngx_conf_num_bounds_t;\n+\n+\n+typedef struct {\n+    ngx_str_t                 name;\n+    ngx_uint_t                value;\n+} ngx_conf_enum_t;\n+\n+\n+#define NGX_CONF_BITMASK_SET  1\n+\n+typedef struct {\n+    ngx_str_t                 name;\n+    ngx_uint_t                mask;\n+} ngx_conf_bitmask_t;\n+\n+\n+\n+char * ngx_conf_deprecated(ngx_conf_t *cf, void *post, void *data);\n+char *ngx_conf_check_num_bounds(ngx_conf_t *cf, void *post, void *data);\n+\n+\n+#define ngx_get_conf(conf_ctx, module)  conf_ctx[module.index]\n+\n+\n+\n+#define ngx_conf_init_value(conf, default)                                   \\\n+    if (conf == NGX_CONF_UNSET) {                                            \\\n+        conf = default;                                                      \\\n+    }\n+\n+#define ngx_conf_init_ptr_value(conf, default)                               \\\n+    if (conf == NGX_CONF_UNSET_PTR) {                                        \\\n+        conf = default;                                                      \\\n+    }\n+\n+#define ngx_conf_init_uint_value(conf, default)                              \\\n+    if (conf == NGX_CONF_UNSET_UINT) {                                       \\\n+        conf = default;                                                      \\\n+    }\n+\n+#define ngx_conf_init_size_value(conf, default)                              \\\n+    if (conf == NGX_CONF_UNSET_SIZE) {                                       \\\n+        conf = default;                                                      \\\n+    }\n+\n+#define ngx_conf_init_msec_value(conf, default)                              \\\n+    if (conf == NGX_CONF_UNSET_MSEC) {                                       \\\n+        conf = default;                                                      \\\n+    }\n+\n+#define ngx_conf_merge_value(conf, prev, default)                            \\\n+    if (conf == NGX_CONF_UNSET) {                                            \\\n+        conf = (prev == NGX_CONF_UNSET) ? default : prev;                    \\\n+    }\n+\n+#define ngx_conf_merge_ptr_value(conf, prev, default)                        \\\n+    if (conf == NGX_CONF_UNSET_PTR) {                                        \\\n+        conf = (prev == NGX_CONF_UNSET_PTR) ? default : prev;                \\\n+    }\n+\n+#define ngx_conf_merge_uint_value(conf, prev, default)                       \\\n+    if (conf == NGX_CONF_UNSET_UINT) {                                       \\\n+        conf = (prev == NGX_CONF_UNSET_UINT) ? default : prev;               \\\n+    }\n+\n+#define ngx_conf_merge_msec_value(conf, prev, default)                       \\\n+    if (conf == NGX_CONF_UNSET_MSEC) {                                       \\\n+        conf = (prev == NGX_CONF_UNSET_MSEC) ? default : prev;               \\\n+    }\n+\n+#define ngx_conf_merge_sec_value(conf, prev, default)                        \\\n+    if (conf == NGX_CONF_UNSET) {                                            \\\n+        conf = (prev == NGX_CONF_UNSET) ? default : prev;                    \\\n+    }\n+\n+#define ngx_conf_merge_size_value(conf, prev, default)                       \\\n+    if (conf == NGX_CONF_UNSET_SIZE) {                                       \\\n+        conf = (prev == NGX_CONF_UNSET_SIZE) ? default : prev;               \\\n+    }\n+\n+#define ngx_conf_merge_off_value(conf, prev, default)                        \\\n+    if (conf == NGX_CONF_UNSET) {                                            \\\n+        conf = (prev == NGX_CONF_UNSET) ? default : prev;                    \\\n+    }\n+\n+#define ngx_conf_merge_str_value(conf, prev, default)                        \\\n+    if (conf.data == NULL) {                                                 \\\n+        if (prev.data) {                                                     \\\n+            conf.len = prev.len;                                             \\\n+            conf.data = prev.data;                                           \\\n+        } else {                                                             \\\n+            conf.len = sizeof(default) - 1;                                  \\\n+            conf.data = (u_char *) default;                                  \\\n+        }                                                                    \\\n+    }\n+\n+#define ngx_conf_merge_bufs_value(conf, prev, default_num, default_size)     \\\n+    if (conf.num == 0) {                                                     \\\n+        if (prev.num) {                                                      \\\n+            conf.num = prev.num;                                             \\\n+            conf.size = prev.size;                                           \\\n+        } else {                                                             \\\n+            conf.num = default_num;                                          \\\n+            conf.size = default_size;                                        \\\n+        }                                                                    \\\n+    }\n+\n+#define ngx_conf_merge_bitmask_value(conf, prev, default)                    \\\n+    if (conf == 0) {                                                         \\\n+        conf = (prev == 0) ? default : prev;                                 \\\n+    }\n+\n+\n+char *ngx_conf_param(ngx_conf_t *cf);\n+char *ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename);\n+char *ngx_conf_include(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+\n+\n+ngx_int_t ngx_conf_full_name(ngx_cycle_t *cycle, ngx_str_t *name,\n+    ngx_uint_t conf_prefix);\n+ngx_open_file_t *ngx_conf_open_file(ngx_cycle_t *cycle, ngx_str_t *name);\n+void ngx_cdecl ngx_conf_log_error(ngx_uint_t level, ngx_conf_t *cf,\n+    ngx_err_t err, const char *fmt, ...);\n+\n+\n+char *ngx_conf_set_flag_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_str_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_str_array_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+char *ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_num_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_size_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_off_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_bufs_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_enum_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+char *ngx_conf_set_bitmask_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+\n+\n+#endif /* _NGX_CONF_FILE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,145 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CONFIG_H_INCLUDED_\n+#define _NGX_CONFIG_H_INCLUDED_\n+\n+\n+#include <ngx_auto_headers.h>\n+\n+\n+#if defined __DragonFly__ && !defined __FreeBSD__\n+#define __FreeBSD__        4\n+#define __FreeBSD_version  480101\n+#endif\n+\n+\n+#if (NGX_FREEBSD)\n+#include <ngx_freebsd_config.h>\n+\n+\n+#elif (NGX_LINUX)\n+#include <ngx_linux_config.h>\n+\n+\n+#elif (NGX_SOLARIS)\n+#include <ngx_solaris_config.h>\n+\n+\n+#elif (NGX_DARWIN)\n+#include <ngx_darwin_config.h>\n+\n+\n+#elif (NGX_WIN32)\n+#include <ngx_win32_config.h>\n+\n+\n+#else /* POSIX */\n+#include <ngx_posix_config.h>\n+\n+#endif\n+\n+\n+#ifndef NGX_HAVE_SO_SNDLOWAT\n+#define NGX_HAVE_SO_SNDLOWAT     1\n+#endif\n+\n+\n+#if !(NGX_WIN32)\n+\n+#define ngx_signal_helper(n)     SIG##n\n+#define ngx_signal_value(n)      ngx_signal_helper(n)\n+\n+#define ngx_random               random\n+\n+/* TODO: #ifndef */\n+#define NGX_SHUTDOWN_SIGNAL      QUIT\n+#define NGX_TERMINATE_SIGNAL     TERM\n+#define NGX_NOACCEPT_SIGNAL      WINCH\n+#define NGX_RECONFIGURE_SIGNAL   HUP\n+\n+#if (NGX_LINUXTHREADS)\n+#define NGX_REOPEN_SIGNAL        INFO\n+#define NGX_CHANGEBIN_SIGNAL     XCPU\n+#else\n+#define NGX_REOPEN_SIGNAL        USR1\n+#define NGX_CHANGEBIN_SIGNAL     USR2\n+#endif\n+\n+#define ngx_cdecl\n+#define ngx_libc_cdecl\n+\n+#endif\n+\n+typedef intptr_t        ngx_int_t;\n+typedef uintptr_t       ngx_uint_t;\n+typedef intptr_t        ngx_flag_t;\n+\n+\n+#define NGX_INT32_LEN   (sizeof(\"-2147483648\") - 1)\n+#define NGX_INT64_LEN   (sizeof(\"-9223372036854775808\") - 1)\n+\n+#if (NGX_PTR_SIZE == 4)\n+#define NGX_INT_T_LEN   NGX_INT32_LEN\n+#define NGX_MAX_INT_T_VALUE  2147483647\n+\n+#else\n+#define NGX_INT_T_LEN   NGX_INT64_LEN\n+#define NGX_MAX_INT_T_VALUE  9223372036854775807\n+#endif\n+\n+\n+#ifndef NGX_ALIGNMENT\n+#define NGX_ALIGNMENT   sizeof(unsigned long)    /* platform word */\n+#endif\n+\n+#define ngx_align(d, a)     (((d) + (a - 1)) & ~(a - 1))\n+#define ngx_align_ptr(p, a)                                                   \\\n+    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) & ~((uintptr_t) a - 1))\n+\n+\n+#define ngx_abort       abort\n+\n+\n+/* TODO: platform specific: array[NGX_INVALID_ARRAY_INDEX] must cause SIGSEGV */\n+#define NGX_INVALID_ARRAY_INDEX 0x80000000\n+\n+\n+/* TODO: auto_conf: ngx_inline   inline __inline __inline__ */\n+#ifndef ngx_inline\n+#define ngx_inline      inline\n+#endif\n+\n+#ifndef INADDR_NONE  /* Solaris */\n+#define INADDR_NONE  ((unsigned int) -1)\n+#endif\n+\n+#ifdef MAXHOSTNAMELEN\n+#define NGX_MAXHOSTNAMELEN  MAXHOSTNAMELEN\n+#else\n+#define NGX_MAXHOSTNAMELEN  256\n+#endif\n+\n+\n+#define NGX_MAX_UINT32_VALUE  (uint32_t) 0xffffffff\n+#define NGX_MAX_INT32_VALUE   (uint32_t) 0x7fffffff\n+\n+\n+#if (NGX_COMPAT)\n+\n+#define NGX_COMPAT_BEGIN(slots)  uint64_t spare[slots];\n+#define NGX_COMPAT_END\n+\n+#else\n+\n+#define NGX_COMPAT_BEGIN(slots)\n+#define NGX_COMPAT_END\n+\n+#endif\n+\n+\n+#endif /* _NGX_CONFIG_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,1510 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ngx_os_io_t  ngx_io;\n+\n+\n+static void ngx_drain_connections(ngx_cycle_t *cycle);\n+\n+\n+ngx_listening_t *\n+ngx_create_listening(ngx_conf_t *cf, struct sockaddr *sockaddr,\n+    socklen_t socklen)\n+{\n+    size_t            len;\n+    ngx_listening_t  *ls;\n+    struct sockaddr  *sa;\n+    u_char            text[NGX_SOCKADDR_STRLEN];\n+\n+    ls = ngx_array_push(&cf->cycle->listening);\n+    if (ls == NULL) {\n+        return NULL;\n+    }\n+\n+    ngx_memzero(ls, sizeof(ngx_listening_t));\n+\n+    sa = ngx_palloc(cf->pool, socklen);\n+    if (sa == NULL) {\n+        return NULL;\n+    }\n+\n+    ngx_memcpy(sa, sockaddr, socklen);\n+\n+    ls->sockaddr = sa;\n+    ls->socklen = socklen;\n+\n+    len = ngx_sock_ntop(sa, socklen, text, NGX_SOCKADDR_STRLEN, 1);\n+    ls->addr_text.len = len;\n+\n+    switch (ls->sockaddr->sa_family) {\n+#if (NGX_HAVE_INET6)\n+    case AF_INET6:\n+        ls->addr_text_max_len = NGX_INET6_ADDRSTRLEN;\n+        break;\n+#endif\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+    case AF_UNIX:\n+        ls->addr_text_max_len = NGX_UNIX_ADDRSTRLEN;\n+        len++;\n+        break;\n+#endif\n+    case AF_INET:\n+        ls->addr_text_max_len = NGX_INET_ADDRSTRLEN;\n+        break;\n+    default:\n+        ls->addr_text_max_len = NGX_SOCKADDR_STRLEN;\n+        break;\n+    }\n+\n+    ls->addr_text.data = ngx_pnalloc(cf->pool, len);\n+    if (ls->addr_text.data == NULL) {\n+        return NULL;\n+    }\n+\n+    ngx_memcpy(ls->addr_text.data, text, len);\n+\n+#if !(NGX_WIN32)\n+    ngx_rbtree_init(&ls->rbtree, &ls->sentinel, ngx_udp_rbtree_insert_value);\n+#endif\n+\n+    ls->fd = (ngx_socket_t) -1;\n+    ls->type = SOCK_STREAM;\n+\n+    ls->backlog = NGX_LISTEN_BACKLOG;\n+    ls->rcvbuf = -1;\n+    ls->sndbuf = -1;\n+\n+#if (NGX_HAVE_SETFIB)\n+    ls->setfib = -1;\n+#endif\n+\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+    ls->fastopen = -1;\n+#endif\n+\n+    return ls;\n+}\n+\n+\n+ngx_int_t\n+ngx_clone_listening(ngx_cycle_t *cycle, ngx_listening_t *ls)\n+{\n+#if (NGX_HAVE_REUSEPORT)\n+\n+    ngx_int_t         n;\n+    ngx_core_conf_t  *ccf;\n+    ngx_listening_t   ols;\n+\n+    if (!ls->reuseport || ls->worker != 0) {\n+        return NGX_OK;\n+    }\n+\n+    ols = *ls;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    for (n = 1; n < ccf->worker_processes; n++) {\n+\n+        /* create a socket for each worker process */\n+\n+        ls = ngx_array_push(&cycle->listening);\n+        if (ls == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        *ls = ols;\n+        ls->worker = n;\n+    }\n+\n+#endif\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_set_inherited_sockets(ngx_cycle_t *cycle)\n+{\n+    size_t                     len;\n+    ngx_uint_t                 i;\n+    ngx_listening_t           *ls;\n+    socklen_t                  olen;\n+#if (NGX_HAVE_DEFERRED_ACCEPT || NGX_HAVE_TCP_FASTOPEN)\n+    ngx_err_t                  err;\n+#endif\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+    struct accept_filter_arg   af;\n+#endif\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n+    int                        timeout;\n+#endif\n+#if (NGX_HAVE_REUSEPORT)\n+    int                        reuseport;\n+#endif\n+\n+    ls = cycle->listening.elts;\n+    for (i = 0; i < cycle->listening.nelts; i++) {\n+\n+        ls[i].sockaddr = ngx_palloc(cycle->pool, sizeof(ngx_sockaddr_t));\n+        if (ls[i].sockaddr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ls[i].socklen = sizeof(ngx_sockaddr_t);\n+        if (getsockname(ls[i].fd, ls[i].sockaddr, &ls[i].socklen) == -1) {\n+            ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_socket_errno,\n+                          \"getsockname() of the inherited \"\n+                          \"socket #%d failed\", ls[i].fd);\n+            ls[i].ignore = 1;\n+            continue;\n+        }\n+\n+        if (ls[i].socklen > (socklen_t) sizeof(ngx_sockaddr_t)) {\n+            ls[i].socklen = sizeof(ngx_sockaddr_t);\n+        }\n+\n+        switch (ls[i].sockaddr->sa_family) {\n+\n+#if (NGX_HAVE_INET6)\n+        case AF_INET6:\n+            ls[i].addr_text_max_len = NGX_INET6_ADDRSTRLEN;\n+            len = NGX_INET6_ADDRSTRLEN + sizeof(\"[]:65535\") - 1;\n+            break;\n+#endif\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+        case AF_UNIX:\n+            ls[i].addr_text_max_len = NGX_UNIX_ADDRSTRLEN;\n+            len = NGX_UNIX_ADDRSTRLEN;\n+            break;\n+#endif\n+\n+        case AF_INET:\n+            ls[i].addr_text_max_len = NGX_INET_ADDRSTRLEN;\n+            len = NGX_INET_ADDRSTRLEN + sizeof(\":65535\") - 1;\n+            break;\n+\n+        default:\n+            ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_socket_errno,\n+                          \"the inherited socket #%d has \"\n+                          \"an unsupported protocol family\", ls[i].fd);\n+            ls[i].ignore = 1;\n+            continue;\n+        }\n+\n+        ls[i].addr_text.data = ngx_pnalloc(cycle->pool, len);\n+        if (ls[i].addr_text.data == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        len = ngx_sock_ntop(ls[i].sockaddr, ls[i].socklen,\n+                            ls[i].addr_text.data, len, 1);\n+        if (len == 0) {\n+            return NGX_ERROR;\n+        }\n+\n+        ls[i].addr_text.len = len;\n+\n+        ls[i].backlog = NGX_LISTEN_BACKLOG;\n+\n+        olen = sizeof(int);\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_TYPE, (void *) &ls[i].type,\n+                       &olen)\n+            == -1)\n+        {\n+            ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_socket_errno,\n+                          \"getsockopt(SO_TYPE) %V failed\", &ls[i].addr_text);\n+            ls[i].ignore = 1;\n+            continue;\n+        }\n+\n+        olen = sizeof(int);\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_RCVBUF, (void *) &ls[i].rcvbuf,\n+                       &olen)\n+            == -1)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                          \"getsockopt(SO_RCVBUF) %V failed, ignored\",\n+                          &ls[i].addr_text);\n+\n+            ls[i].rcvbuf = -1;\n+        }\n+\n+        olen = sizeof(int);\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_SNDBUF, (void *) &ls[i].sndbuf,\n+                       &olen)\n+            == -1)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                          \"getsockopt(SO_SNDBUF) %V failed, ignored\",\n+                          &ls[i].addr_text);\n+\n+            ls[i].sndbuf = -1;\n+        }\n+\n+#if 0\n+        /* SO_SETFIB is currently a set only option */\n+\n+#if (NGX_HAVE_SETFIB)\n+\n+        olen = sizeof(int);\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_SETFIB,\n+                       (void *) &ls[i].setfib, &olen)\n+            == -1)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                          \"getsockopt(SO_SETFIB) %V failed, ignored\",\n+                          &ls[i].addr_text);\n+\n+            ls[i].setfib = -1;\n+        }\n+\n+#endif\n+#endif\n+\n+#if (NGX_HAVE_REUSEPORT)\n+\n+        reuseport = 0;\n+        olen = sizeof(int);\n+\n+#ifdef SO_REUSEPORT_LB\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_REUSEPORT_LB,\n+                       (void *) &reuseport, &olen)\n+            == -1)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                          \"getsockopt(SO_REUSEPORT_LB) %V failed, ignored\",\n+                          &ls[i].addr_text);\n+\n+        } else {\n+            ls[i].reuseport = reuseport ? 1 : 0;\n+        }\n+\n+#else\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_REUSEPORT,\n+                       (void *) &reuseport, &olen)\n+            == -1)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                          \"getsockopt(SO_REUSEPORT) %V failed, ignored\",\n+                          &ls[i].addr_text);\n+\n+        } else {\n+            ls[i].reuseport = reuseport ? 1 : 0;\n+        }\n+#endif\n+\n+#endif\n+\n+        if (ls[i].type != SOCK_STREAM) {\n+            continue;\n+        }\n+\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+\n+        olen = sizeof(int);\n+\n+        if (getsockopt(ls[i].fd, IPPROTO_TCP, TCP_FASTOPEN,\n+                       (void *) &ls[i].fastopen, &olen)\n+            == -1)\n+        {\n+            err = ngx_socket_errno;\n+\n+            if (err != NGX_EOPNOTSUPP && err != NGX_ENOPROTOOPT\n+                && err != NGX_EINVAL)\n+            {\n+                ngx_log_error(NGX_LOG_NOTICE, cycle->log, err,\n+                              \"getsockopt(TCP_FASTOPEN) %V failed, ignored\",\n+                              &ls[i].addr_text);\n+            }\n+\n+            ls[i].fastopen = -1;\n+        }\n+\n+#endif\n+\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+\n+        ngx_memzero(&af, sizeof(struct accept_filter_arg));\n+        olen = sizeof(struct accept_filter_arg);\n+\n+        if (getsockopt(ls[i].fd, SOL_SOCKET, SO_ACCEPTFILTER, &af, &olen)\n+            == -1)\n+        {\n+            err = ngx_socket_errno;\n+\n+            if (err == NGX_EINVAL) {\n+                continue;\n+            }\n+\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, err,\n+                          \"getsockopt(SO_ACCEPTFILTER) for %V failed, ignored\",\n+                          &ls[i].addr_text);\n+            continue;\n+        }\n+\n+        if (olen < sizeof(struct accept_filter_arg) || af.af_name[0] == '\\0') {\n+            continue;\n+        }\n+\n+        ls[i].accept_filter = ngx_palloc(cycle->pool, 16);\n+        if (ls[i].accept_filter == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        (void) ngx_cpystrn((u_char *) ls[i].accept_filter,\n+                           (u_char *) af.af_name, 16);\n+#endif\n+\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n+\n+        timeout = 0;\n+        olen = sizeof(int);\n+\n+        if (getsockopt(ls[i].fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &timeout, &olen)\n+            == -1)\n+        {\n+            err = ngx_socket_errno;\n+\n+            if (err == NGX_EOPNOTSUPP) {\n+                continue;\n+            }\n+\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, err,\n+                          \"getsockopt(TCP_DEFER_ACCEPT) for %V failed, ignored\",\n+                          &ls[i].addr_text);\n+            continue;\n+        }\n+\n+        if (olen < sizeof(int) || timeout == 0) {\n+            continue;\n+        }\n+\n+        ls[i].deferred_accept = 1;\n+#endif\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_open_listening_sockets(ngx_cycle_t *cycle)\n+{\n+    int               reuseaddr;\n+    ngx_uint_t        i, tries, failed;\n+    ngx_err_t         err;\n+    ngx_log_t        *log;\n+    ngx_socket_t      s;\n+    ngx_listening_t  *ls;\n+\n+    reuseaddr = 1;\n+#if (NGX_SUPPRESS_WARN)\n+    failed = 0;\n+#endif\n+\n+    log = cycle->log;\n+\n+    /* TODO: configurable try number */\n+\n+    for (tries = 5; tries; tries--) {\n+        failed = 0;\n+\n+        /* for each listening socket */\n+\n+        ls = cycle->listening.elts;\n+        for (i = 0; i < cycle->listening.nelts; i++) {\n+\n+            if (ls[i].ignore) {\n+                continue;\n+            }\n+\n+#if (NGX_HAVE_REUSEPORT)\n+\n+            if (ls[i].add_reuseport) {\n+\n+                /*\n+                 * to allow transition from a socket without SO_REUSEPORT\n+                 * to multiple sockets with SO_REUSEPORT, we have to set\n+                 * SO_REUSEPORT on the old socket before opening new ones\n+                 */\n+\n+                int  reuseport = 1;\n+\n+#ifdef SO_REUSEPORT_LB\n+\n+                if (setsockopt(ls[i].fd, SOL_SOCKET, SO_REUSEPORT_LB,\n+                               (const void *) &reuseport, sizeof(int))\n+                    == -1)\n+                {\n+                    ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                                  \"setsockopt(SO_REUSEPORT_LB) %V failed, \"\n+                                  \"ignored\",\n+                                  &ls[i].addr_text);\n+                }\n+\n+#else\n+\n+                if (setsockopt(ls[i].fd, SOL_SOCKET, SO_REUSEPORT,\n+                               (const void *) &reuseport, sizeof(int))\n+                    == -1)\n+                {\n+                    ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                                  \"setsockopt(SO_REUSEPORT) %V failed, ignored\",\n+                                  &ls[i].addr_text);\n+                }\n+#endif\n+\n+                ls[i].add_reuseport = 0;\n+            }\n+#endif\n+\n+            if (ls[i].fd != (ngx_socket_t) -1) {\n+                continue;\n+            }\n+\n+            if (ls[i].inherited) {\n+\n+                /* TODO: close on exit */\n+                /* TODO: nonblocking */\n+                /* TODO: deferred accept */\n+\n+                continue;\n+            }\n+\n+            s = ngx_socket(ls[i].sockaddr->sa_family, ls[i].type, 0);\n+\n+            if (s == (ngx_socket_t) -1) {\n+                ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                              ngx_socket_n \" %V failed\", &ls[i].addr_text);\n+                return NGX_ERROR;\n+            }\n+\n+            if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n+                           (const void *) &reuseaddr, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                              \"setsockopt(SO_REUSEADDR) %V failed\",\n+                              &ls[i].addr_text);\n+\n+                if (ngx_close_socket(s) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  ngx_close_socket_n \" %V failed\",\n+                                  &ls[i].addr_text);\n+                }\n+\n+                return NGX_ERROR;\n+            }\n+\n+#if (NGX_HAVE_REUSEPORT)\n+\n+            if (ls[i].reuseport && !ngx_test_config) {\n+                int  reuseport;\n+\n+                reuseport = 1;\n+\n+#ifdef SO_REUSEPORT_LB\n+\n+                if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT_LB,\n+                               (const void *) &reuseport, sizeof(int))\n+                    == -1)\n+                {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  \"setsockopt(SO_REUSEPORT_LB) %V failed\",\n+                                  &ls[i].addr_text);\n+\n+                    if (ngx_close_socket(s) == -1) {\n+                        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                      ngx_close_socket_n \" %V failed\",\n+                                      &ls[i].addr_text);\n+                    }\n+\n+                    return NGX_ERROR;\n+                }\n+\n+#else\n+\n+                if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT,\n+                               (const void *) &reuseport, sizeof(int))\n+                    == -1)\n+                {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  \"setsockopt(SO_REUSEPORT) %V failed\",\n+                                  &ls[i].addr_text);\n+\n+                    if (ngx_close_socket(s) == -1) {\n+                        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                      ngx_close_socket_n \" %V failed\",\n+                                      &ls[i].addr_text);\n+                    }\n+\n+                    return NGX_ERROR;\n+                }\n+#endif\n+            }\n+#endif\n+\n+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n+\n+            if (ls[i].sockaddr->sa_family == AF_INET6) {\n+                int  ipv6only;\n+\n+                ipv6only = ls[i].ipv6only;\n+\n+                if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,\n+                               (const void *) &ipv6only, sizeof(int))\n+                    == -1)\n+                {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  \"setsockopt(IPV6_V6ONLY) %V failed, ignored\",\n+                                  &ls[i].addr_text);\n+                }\n+            }\n+#endif\n+            /* TODO: close on exit */\n+\n+            if (!(ngx_event_flags & NGX_USE_IOCP_EVENT)) {\n+                if (ngx_nonblocking(s) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  ngx_nonblocking_n \" %V failed\",\n+                                  &ls[i].addr_text);\n+\n+                    if (ngx_close_socket(s) == -1) {\n+                        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                      ngx_close_socket_n \" %V failed\",\n+                                      &ls[i].addr_text);\n+                    }\n+\n+                    return NGX_ERROR;\n+                }\n+            }\n+\n+            ngx_log_debug2(NGX_LOG_DEBUG_CORE, log, 0,\n+                           \"bind() %V #%d \", &ls[i].addr_text, s);\n+\n+            if (bind(s, ls[i].sockaddr, ls[i].socklen) == -1) {\n+                err = ngx_socket_errno;\n+\n+                if (err != NGX_EADDRINUSE || !ngx_test_config) {\n+                    ngx_log_error(NGX_LOG_EMERG, log, err,\n+                                  \"bind() to %V failed\", &ls[i].addr_text);\n+                }\n+\n+                if (ngx_close_socket(s) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  ngx_close_socket_n \" %V failed\",\n+                                  &ls[i].addr_text);\n+                }\n+\n+                if (err != NGX_EADDRINUSE) {\n+                    return NGX_ERROR;\n+                }\n+\n+                if (!ngx_test_config) {\n+                    failed = 1;\n+                }\n+\n+                continue;\n+            }\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+\n+            if (ls[i].sockaddr->sa_family == AF_UNIX) {\n+                mode_t   mode;\n+                u_char  *name;\n+\n+                name = ls[i].addr_text.data + sizeof(\"unix:\") - 1;\n+                mode = (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);\n+\n+                if (chmod((char *) name, mode) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                  \"chmod() \\\"%s\\\" failed\", name);\n+                }\n+\n+                if (ngx_test_config) {\n+                    if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n+                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                      ngx_delete_file_n \" %s failed\", name);\n+                    }\n+                }\n+            }\n+#endif\n+\n+            if (ls[i].type != SOCK_STREAM) {\n+                ls[i].fd = s;\n+                continue;\n+            }\n+\n+            if (listen(s, ls[i].backlog) == -1) {\n+                err = ngx_socket_errno;\n+\n+                /*\n+                 * on OpenVZ after suspend/resume EADDRINUSE\n+                 * may be returned by listen() instead of bind(), see\n+                 * https://bugzilla.openvz.org/show_bug.cgi?id=2470\n+                 */\n+\n+                if (err != NGX_EADDRINUSE || !ngx_test_config) {\n+                    ngx_log_error(NGX_LOG_EMERG, log, err,\n+                                  \"listen() to %V, backlog %d failed\",\n+                                  &ls[i].addr_text, ls[i].backlog);\n+                }\n+\n+                if (ngx_close_socket(s) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                  ngx_close_socket_n \" %V failed\",\n+                                  &ls[i].addr_text);\n+                }\n+\n+                if (err != NGX_EADDRINUSE) {\n+                    return NGX_ERROR;\n+                }\n+\n+                if (!ngx_test_config) {\n+                    failed = 1;\n+                }\n+\n+                continue;\n+            }\n+\n+            ls[i].listen = 1;\n+\n+            ls[i].fd = s;\n+        }\n+\n+        if (!failed) {\n+            break;\n+        }\n+\n+        /* TODO: delay configurable */\n+\n+        ngx_log_error(NGX_LOG_NOTICE, log, 0,\n+                      \"try again to bind() after 500ms\");\n+\n+        ngx_msleep(500);\n+    }\n+\n+    if (failed) {\n+        ngx_log_error(NGX_LOG_EMERG, log, 0, \"still could not bind()\");\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_configure_listening_sockets(ngx_cycle_t *cycle)\n+{\n+    int                        value;\n+    ngx_uint_t                 i;\n+    ngx_listening_t           *ls;\n+\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+    struct accept_filter_arg   af;\n+#endif\n+\n+    ls = cycle->listening.elts;\n+    for (i = 0; i < cycle->listening.nelts; i++) {\n+\n+        ls[i].log = *ls[i].logp;\n+\n+        if (ls[i].rcvbuf != -1) {\n+            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_RCVBUF,\n+                           (const void *) &ls[i].rcvbuf, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(SO_RCVBUF, %d) %V failed, ignored\",\n+                              ls[i].rcvbuf, &ls[i].addr_text);\n+            }\n+        }\n+\n+        if (ls[i].sndbuf != -1) {\n+            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_SNDBUF,\n+                           (const void *) &ls[i].sndbuf, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(SO_SNDBUF, %d) %V failed, ignored\",\n+                              ls[i].sndbuf, &ls[i].addr_text);\n+            }\n+        }\n+\n+        if (ls[i].keepalive) {\n+            value = (ls[i].keepalive == 1) ? 1 : 0;\n+\n+            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_KEEPALIVE,\n+                           (const void *) &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(SO_KEEPALIVE, %d) %V failed, ignored\",\n+                              value, &ls[i].addr_text);\n+            }\n+        }\n+\n+#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n+\n+        if (ls[i].keepidle) {\n+            value = ls[i].keepidle;\n+\n+#if (NGX_KEEPALIVE_FACTOR)\n+            value *= NGX_KEEPALIVE_FACTOR;\n+#endif\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_KEEPIDLE,\n+                           (const void *) &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(TCP_KEEPIDLE, %d) %V failed, ignored\",\n+                              value, &ls[i].addr_text);\n+            }\n+        }\n+\n+        if (ls[i].keepintvl) {\n+            value = ls[i].keepintvl;\n+\n+#if (NGX_KEEPALIVE_FACTOR)\n+            value *= NGX_KEEPALIVE_FACTOR;\n+#endif\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_KEEPINTVL,\n+                           (const void *) &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                             \"setsockopt(TCP_KEEPINTVL, %d) %V failed, ignored\",\n+                             value, &ls[i].addr_text);\n+            }\n+        }\n+\n+        if (ls[i].keepcnt) {\n+            if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_KEEPCNT,\n+                           (const void *) &ls[i].keepcnt, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(TCP_KEEPCNT, %d) %V failed, ignored\",\n+                              ls[i].keepcnt, &ls[i].addr_text);\n+            }\n+        }\n+\n+#endif\n+\n+#if (NGX_HAVE_SETFIB)\n+        if (ls[i].setfib != -1) {\n+            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_SETFIB,\n+                           (const void *) &ls[i].setfib, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(SO_SETFIB, %d) %V failed, ignored\",\n+                              ls[i].setfib, &ls[i].addr_text);\n+            }\n+        }\n+#endif\n+\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+        if (ls[i].fastopen != -1) {\n+            if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_FASTOPEN,\n+                           (const void *) &ls[i].fastopen, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(TCP_FASTOPEN, %d) %V failed, ignored\",\n+                              ls[i].fastopen, &ls[i].addr_text);\n+            }\n+        }\n+#endif\n+\n+#if 0\n+        if (1) {\n+            int tcp_nodelay = 1;\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_NODELAY,\n+                       (const void *) &tcp_nodelay, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(TCP_NODELAY) %V failed, ignored\",\n+                              &ls[i].addr_text);\n+            }\n+        }\n+#endif\n+\n+        if (ls[i].listen) {\n+\n+            /* change backlog via listen() */\n+\n+            if (listen(ls[i].fd, ls[i].backlog) == -1) {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"listen() to %V, backlog %d failed, ignored\",\n+                              &ls[i].addr_text, ls[i].backlog);\n+            }\n+        }\n+\n+        /*\n+         * setting deferred mode should be last operation on socket,\n+         * because code may prematurely continue cycle on failure\n+         */\n+\n+#if (NGX_HAVE_DEFERRED_ACCEPT)\n+\n+#ifdef SO_ACCEPTFILTER\n+\n+        if (ls[i].delete_deferred) {\n+            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_ACCEPTFILTER, NULL, 0)\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(SO_ACCEPTFILTER, NULL) \"\n+                              \"for %V failed, ignored\",\n+                              &ls[i].addr_text);\n+\n+                if (ls[i].accept_filter) {\n+                    ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n+                                  \"could not change the accept filter \"\n+                                  \"to \\\"%s\\\" for %V, ignored\",\n+                                  ls[i].accept_filter, &ls[i].addr_text);\n+                }\n+\n+                continue;\n+            }\n+\n+            ls[i].deferred_accept = 0;\n+        }\n+\n+        if (ls[i].add_deferred) {\n+            ngx_memzero(&af, sizeof(struct accept_filter_arg));\n+            (void) ngx_cpystrn((u_char *) af.af_name,\n+                               (u_char *) ls[i].accept_filter, 16);\n+\n+            if (setsockopt(ls[i].fd, SOL_SOCKET, SO_ACCEPTFILTER,\n+                           &af, sizeof(struct accept_filter_arg))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(SO_ACCEPTFILTER, \\\"%s\\\") \"\n+                              \"for %V failed, ignored\",\n+                              ls[i].accept_filter, &ls[i].addr_text);\n+                continue;\n+            }\n+\n+            ls[i].deferred_accept = 1;\n+        }\n+\n+#endif\n+\n+#ifdef TCP_DEFER_ACCEPT\n+\n+        if (ls[i].add_deferred || ls[i].delete_deferred) {\n+\n+            if (ls[i].add_deferred) {\n+                /*\n+                 * There is no way to find out how long a connection was\n+                 * in queue (and a connection may bypass deferred queue at all\n+                 * if syncookies were used), hence we use 1 second timeout\n+                 * here.\n+                 */\n+                value = 1;\n+\n+            } else {\n+                value = 0;\n+            }\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_TCP, TCP_DEFER_ACCEPT,\n+                           &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(TCP_DEFER_ACCEPT, %d) for %V failed, \"\n+                              \"ignored\",\n+                              value, &ls[i].addr_text);\n+\n+                continue;\n+            }\n+        }\n+\n+        if (ls[i].add_deferred) {\n+            ls[i].deferred_accept = 1;\n+        }\n+\n+#endif\n+\n+#endif /* NGX_HAVE_DEFERRED_ACCEPT */\n+\n+#if (NGX_HAVE_IP_RECVDSTADDR)\n+\n+        if (ls[i].wildcard\n+            && ls[i].type == SOCK_DGRAM\n+            && ls[i].sockaddr->sa_family == AF_INET)\n+        {\n+            value = 1;\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_IP, IP_RECVDSTADDR,\n+                           (const void *) &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(IP_RECVDSTADDR) \"\n+                              \"for %V failed, ignored\",\n+                              &ls[i].addr_text);\n+            }\n+        }\n+\n+#elif (NGX_HAVE_IP_PKTINFO)\n+\n+        if (ls[i].wildcard\n+            && ls[i].type == SOCK_DGRAM\n+            && ls[i].sockaddr->sa_family == AF_INET)\n+        {\n+            value = 1;\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_IP, IP_PKTINFO,\n+                           (const void *) &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(IP_PKTINFO) \"\n+                              \"for %V failed, ignored\",\n+                              &ls[i].addr_text);\n+            }\n+        }\n+\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+\n+        if (ls[i].wildcard\n+            && ls[i].type == SOCK_DGRAM\n+            && ls[i].sockaddr->sa_family == AF_INET6)\n+        {\n+            value = 1;\n+\n+            if (setsockopt(ls[i].fd, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n+                           (const void *) &value, sizeof(int))\n+                == -1)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_socket_errno,\n+                              \"setsockopt(IPV6_RECVPKTINFO) \"\n+                              \"for %V failed, ignored\",\n+                              &ls[i].addr_text);\n+            }\n+        }\n+\n+#endif\n+    }\n+\n+    return;\n+}\n+\n+\n+void\n+ngx_close_listening_sockets(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t         i;\n+    ngx_listening_t   *ls;\n+    ngx_connection_t  *c;\n+\n+    if (ngx_event_flags & NGX_USE_IOCP_EVENT) {\n+        return;\n+    }\n+\n+    ngx_accept_mutex_held = 0;\n+    ngx_use_accept_mutex = 0;\n+\n+    ls = cycle->listening.elts;\n+    for (i = 0; i < cycle->listening.nelts; i++) {\n+\n+        c = ls[i].connection;\n+\n+        if (c) {\n+            if (c->read->active) {\n+                if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+\n+                    /*\n+                     * it seems that Linux-2.6.x OpenVZ sends events\n+                     * for closed shared listening sockets unless\n+                     * the events was explicitly deleted\n+                     */\n+\n+                    ngx_del_event(c->read, NGX_READ_EVENT, 0);\n+\n+                } else {\n+                    ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);\n+                }\n+            }\n+\n+            ngx_free_connection(c);\n+\n+            c->fd = (ngx_socket_t) -1;\n+        }\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n+                       \"close listening %V #%d \", &ls[i].addr_text, ls[i].fd);\n+\n+        if (ngx_close_socket(ls[i].fd) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n+                          ngx_close_socket_n \" %V failed\", &ls[i].addr_text);\n+        }\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+\n+        if (ls[i].sockaddr->sa_family == AF_UNIX\n+            && ngx_process <= NGX_PROCESS_MASTER\n+            && ngx_new_binary == 0)\n+        {\n+            u_char *name = ls[i].addr_text.data + sizeof(\"unix:\") - 1;\n+\n+            if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n+                              ngx_delete_file_n \" %s failed\", name);\n+            }\n+        }\n+\n+#endif\n+\n+        ls[i].fd = (ngx_socket_t) -1;\n+    }\n+\n+    cycle->listening.nelts = 0;\n+}\n+\n+\n+ngx_connection_t *\n+ngx_get_connection(ngx_socket_t s, ngx_log_t *log)\n+{\n+    ngx_uint_t         instance;\n+    ngx_event_t       *rev, *wev;\n+    ngx_connection_t  *c;\n+\n+    /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */\n+\n+    if (ngx_cycle->files && (ngx_uint_t) s >= ngx_cycle->files_n) {\n+        ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                      \"the new socket has number %d, \"\n+                      \"but only %ui files are available\",\n+                      s, ngx_cycle->files_n);\n+        return NULL;\n+    }\n+\n+    c = ngx_cycle->free_connections;\n+\n+    if (c == NULL) {\n+        ngx_drain_connections((ngx_cycle_t *) ngx_cycle);\n+        c = ngx_cycle->free_connections;\n+    }\n+\n+    if (c == NULL) {\n+        ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                      \"%ui worker_connections are not enough\",\n+                      ngx_cycle->connection_n);\n+\n+        return NULL;\n+    }\n+\n+    ngx_cycle->free_connections = c->data;\n+    ngx_cycle->free_connection_n--;\n+\n+    if (ngx_cycle->files && ngx_cycle->files[s] == NULL) {\n+        ngx_cycle->files[s] = c;\n+    }\n+\n+    rev = c->read;\n+    wev = c->write;\n+\n+    ngx_memzero(c, sizeof(ngx_connection_t));\n+\n+    c->read = rev;\n+    c->write = wev;\n+    c->fd = s;\n+    c->log = log;\n+\n+    instance = rev->instance;\n+\n+    ngx_memzero(rev, sizeof(ngx_event_t));\n+    ngx_memzero(wev, sizeof(ngx_event_t));\n+\n+    rev->instance = !instance;\n+    wev->instance = !instance;\n+\n+    rev->index = NGX_INVALID_INDEX;\n+    wev->index = NGX_INVALID_INDEX;\n+\n+    rev->data = c;\n+    wev->data = c;\n+\n+    wev->write = 1;\n+\n+    return c;\n+}\n+\n+\n+void\n+ngx_free_connection(ngx_connection_t *c)\n+{\n+    c->data = ngx_cycle->free_connections;\n+    ngx_cycle->free_connections = c;\n+    ngx_cycle->free_connection_n++;\n+\n+    if (ngx_cycle->files && ngx_cycle->files[c->fd] == c) {\n+        ngx_cycle->files[c->fd] = NULL;\n+    }\n+}\n+\n+\n+void\n+ngx_close_connection(ngx_connection_t *c)\n+{\n+    ngx_err_t     err;\n+    ngx_uint_t    log_error, level;\n+    ngx_socket_t  fd;\n+\n+    if (c->fd == (ngx_socket_t) -1) {\n+        ngx_log_error(NGX_LOG_ALERT, c->log, 0, \"connection already closed\");\n+        return;\n+    }\n+\n+    if (c->read->timer_set) {\n+        ngx_del_timer(c->read);\n+    }\n+\n+    if (c->write->timer_set) {\n+        ngx_del_timer(c->write);\n+    }\n+\n+    if (!c->shared) {\n+        if (ngx_del_conn) {\n+            ngx_del_conn(c, NGX_CLOSE_EVENT);\n+\n+        } else {\n+            if (c->read->active || c->read->disabled) {\n+                ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);\n+            }\n+\n+            if (c->write->active || c->write->disabled) {\n+                ngx_del_event(c->write, NGX_WRITE_EVENT, NGX_CLOSE_EVENT);\n+            }\n+        }\n+    }\n+\n+    if (c->read->posted) {\n+        ngx_delete_posted_event(c->read);\n+    }\n+\n+    if (c->write->posted) {\n+        ngx_delete_posted_event(c->write);\n+    }\n+\n+    c->read->closed = 1;\n+    c->write->closed = 1;\n+\n+    ngx_reusable_connection(c, 0);\n+\n+    log_error = c->log_error;\n+\n+    ngx_free_connection(c);\n+\n+    fd = c->fd;\n+    c->fd = (ngx_socket_t) -1;\n+\n+    if (c->shared) {\n+        return;\n+    }\n+\n+    if (ngx_close_socket(fd) == -1) {\n+\n+        err = ngx_socket_errno;\n+\n+        if (err == NGX_ECONNRESET || err == NGX_ENOTCONN) {\n+\n+            switch (log_error) {\n+\n+            case NGX_ERROR_INFO:\n+                level = NGX_LOG_INFO;\n+                break;\n+\n+            case NGX_ERROR_ERR:\n+                level = NGX_LOG_ERR;\n+                break;\n+\n+            default:\n+                level = NGX_LOG_CRIT;\n+            }\n+\n+        } else {\n+            level = NGX_LOG_CRIT;\n+        }\n+\n+        ngx_log_error(level, c->log, err, ngx_close_socket_n \" %d failed\", fd);\n+    }\n+}\n+\n+\n+void\n+ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable)\n+{\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"reusable connection: %ui\", reusable);\n+\n+    if (c->reusable) {\n+        ngx_queue_remove(&c->queue);\n+        ngx_cycle->reusable_connections_n--;\n+\n+#if (NGX_STAT_STUB)\n+        (void) ngx_atomic_fetch_add(ngx_stat_waiting, -1);\n+#endif\n+    }\n+\n+    c->reusable = reusable;\n+\n+    if (reusable) {\n+        /* need cast as ngx_cycle is volatile */\n+\n+        ngx_queue_insert_head(\n+            (ngx_queue_t *) &ngx_cycle->reusable_connections_queue, &c->queue);\n+        ngx_cycle->reusable_connections_n++;\n+\n+#if (NGX_STAT_STUB)\n+        (void) ngx_atomic_fetch_add(ngx_stat_waiting, 1);\n+#endif\n+    }\n+}\n+\n+\n+static void\n+ngx_drain_connections(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t         i, n;\n+    ngx_queue_t       *q;\n+    ngx_connection_t  *c;\n+\n+    n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);\n+\n+    for (i = 0; i < n; i++) {\n+        if (ngx_queue_empty(&cycle->reusable_connections_queue)) {\n+            break;\n+        }\n+\n+        q = ngx_queue_last(&cycle->reusable_connections_queue);\n+        c = ngx_queue_data(q, ngx_connection_t, queue);\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                       \"reusing connection\");\n+\n+        c->close = 1;\n+        c->read->handler(c->read);\n+    }\n+}\n+\n+\n+void\n+ngx_close_idle_connections(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t         i;\n+    ngx_connection_t  *c;\n+\n+    c = cycle->connections;\n+\n+    for (i = 0; i < cycle->connection_n; i++) {\n+\n+        /* THREAD: lock */\n+\n+        if (c[i].fd != (ngx_socket_t) -1 && c[i].idle) {\n+            c[i].close = 1;\n+            c[i].read->handler(c[i].read);\n+        }\n+    }\n+}\n+\n+\n+ngx_int_t\n+ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,\n+    ngx_uint_t port)\n+{\n+    socklen_t             len;\n+    ngx_uint_t            addr;\n+    ngx_sockaddr_t        sa;\n+    struct sockaddr_in   *sin;\n+#if (NGX_HAVE_INET6)\n+    ngx_uint_t            i;\n+    struct sockaddr_in6  *sin6;\n+#endif\n+\n+    addr = 0;\n+\n+    if (c->local_socklen) {\n+        switch (c->local_sockaddr->sa_family) {\n+\n+#if (NGX_HAVE_INET6)\n+        case AF_INET6:\n+            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;\n+\n+            for (i = 0; addr == 0 && i < 16; i++) {\n+                addr |= sin6->sin6_addr.s6_addr[i];\n+            }\n+\n+            break;\n+#endif\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+        case AF_UNIX:\n+            addr = 1;\n+            break;\n+#endif\n+\n+        default: /* AF_INET */\n+            sin = (struct sockaddr_in *) c->local_sockaddr;\n+            addr = sin->sin_addr.s_addr;\n+            break;\n+        }\n+    }\n+\n+    if (addr == 0) {\n+\n+        len = sizeof(ngx_sockaddr_t);\n+\n+        if (getsockname(c->fd, &sa.sockaddr, &len) == -1) {\n+            ngx_connection_error(c, ngx_socket_errno, \"getsockname() failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        c->local_sockaddr = ngx_palloc(c->pool, len);\n+        if (c->local_sockaddr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_memcpy(c->local_sockaddr, &sa, len);\n+\n+        c->local_socklen = len;\n+    }\n+\n+    if (s == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    s->len = ngx_sock_ntop(c->local_sockaddr, c->local_socklen,\n+                           s->data, s->len, port);\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_tcp_nodelay(ngx_connection_t *c)\n+{\n+    int  tcp_nodelay;\n+\n+    if (c->tcp_nodelay != NGX_TCP_NODELAY_UNSET) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0, \"tcp_nodelay\");\n+\n+    tcp_nodelay = 1;\n+\n+    if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,\n+                   (const void *) &tcp_nodelay, sizeof(int))\n+        == -1)\n+    {\n+#if (NGX_SOLARIS)\n+        if (c->log_error == NGX_ERROR_INFO) {\n+\n+            /* Solaris returns EINVAL if a socket has been shut down */\n+            c->log_error = NGX_ERROR_IGNORE_EINVAL;\n+\n+            ngx_connection_error(c, ngx_socket_errno,\n+                                 \"setsockopt(TCP_NODELAY) failed\");\n+\n+            c->log_error = NGX_ERROR_INFO;\n+\n+            return NGX_ERROR;\n+        }\n+#endif\n+\n+        ngx_connection_error(c, ngx_socket_errno,\n+                             \"setsockopt(TCP_NODELAY) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    c->tcp_nodelay = NGX_TCP_NODELAY_SET;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text)\n+{\n+    ngx_uint_t  level;\n+\n+    /* Winsock may return NGX_ECONNABORTED instead of NGX_ECONNRESET */\n+\n+    if ((err == NGX_ECONNRESET\n+#if (NGX_WIN32)\n+         || err == NGX_ECONNABORTED\n+#endif\n+        ) && c->log_error == NGX_ERROR_IGNORE_ECONNRESET)\n+    {\n+        return 0;\n+    }\n+\n+#if (NGX_SOLARIS)\n+    if (err == NGX_EINVAL && c->log_error == NGX_ERROR_IGNORE_EINVAL) {\n+        return 0;\n+    }\n+#endif\n+\n+    if (err == 0\n+        || err == NGX_ECONNRESET\n+#if (NGX_WIN32)\n+        || err == NGX_ECONNABORTED\n+#else\n+        || err == NGX_EPIPE\n+#endif\n+        || err == NGX_ENOTCONN\n+        || err == NGX_ETIMEDOUT\n+        || err == NGX_ECONNREFUSED\n+        || err == NGX_ENETDOWN\n+        || err == NGX_ENETUNREACH\n+        || err == NGX_EHOSTDOWN\n+        || err == NGX_EHOSTUNREACH)\n+    {\n+        switch (c->log_error) {\n+\n+        case NGX_ERROR_IGNORE_EINVAL:\n+        case NGX_ERROR_IGNORE_ECONNRESET:\n+        case NGX_ERROR_INFO:\n+            level = NGX_LOG_INFO;\n+            break;\n+\n+        default:\n+            level = NGX_LOG_ERR;\n+        }\n+\n+    } else {\n+        level = NGX_LOG_ALERT;\n+    }\n+\n+    ngx_log_error(level, c->log, err, text);\n+\n+    return NGX_ERROR;\n+}\nDiff:\n@@ -0,0 +1,230 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CONNECTION_H_INCLUDED_\n+#define _NGX_CONNECTION_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef struct ngx_listening_s  ngx_listening_t;\n+\n+struct ngx_listening_s {\n+    ngx_socket_t        fd;\n+\n+    struct sockaddr    *sockaddr;\n+    socklen_t           socklen;    /* size of sockaddr */\n+    size_t              addr_text_max_len;\n+    ngx_str_t           addr_text;\n+\n+    int                 type;\n+\n+    int                 backlog;\n+    int                 rcvbuf;\n+    int                 sndbuf;\n+#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n+    int                 keepidle;\n+    int                 keepintvl;\n+    int                 keepcnt;\n+#endif\n+\n+    /* handler of accepted connection */\n+    ngx_connection_handler_pt   handler;\n+\n+    void               *servers;  /* array of ngx_http_in_addr_t, for example */\n+\n+    ngx_log_t           log;\n+    ngx_log_t          *logp;\n+\n+    size_t              pool_size;\n+    /* should be here because of the AcceptEx() preread */\n+    size_t              post_accept_buffer_size;\n+    /* should be here because of the deferred accept */\n+    ngx_msec_t          post_accept_timeout;\n+\n+    ngx_listening_t    *previous;\n+    ngx_connection_t   *connection;\n+\n+    ngx_rbtree_t        rbtree;\n+    ngx_rbtree_node_t   sentinel;\n+\n+    ngx_uint_t          worker;\n+\n+    unsigned            open:1;\n+    unsigned            remain:1;\n+    unsigned            ignore:1;\n+\n+    unsigned            bound:1;       /* already bound */\n+    unsigned            inherited:1;   /* inherited from previous process */\n+    unsigned            nonblocking_accept:1;\n+    unsigned            listen:1;\n+    unsigned            nonblocking:1;\n+    unsigned            shared:1;    /* shared between threads or processes */\n+    unsigned            addr_ntop:1;\n+    unsigned            wildcard:1;\n+\n+#if (NGX_HAVE_INET6)\n+    unsigned            ipv6only:1;\n+#endif\n+    unsigned            reuseport:1;\n+    unsigned            add_reuseport:1;\n+    unsigned            keepalive:2;\n+\n+    unsigned            deferred_accept:1;\n+    unsigned            delete_deferred:1;\n+    unsigned            add_deferred:1;\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+    char               *accept_filter;\n+#endif\n+#if (NGX_HAVE_SETFIB)\n+    int                 setfib;\n+#endif\n+\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+    int                 fastopen;\n+#endif\n+\n+};\n+\n+\n+typedef enum {\n+    NGX_ERROR_ALERT = 0,\n+    NGX_ERROR_ERR,\n+    NGX_ERROR_INFO,\n+    NGX_ERROR_IGNORE_ECONNRESET,\n+    NGX_ERROR_IGNORE_EINVAL\n+} ngx_connection_log_error_e;\n+\n+\n+typedef enum {\n+    NGX_TCP_NODELAY_UNSET = 0,\n+    NGX_TCP_NODELAY_SET,\n+    NGX_TCP_NODELAY_DISABLED\n+} ngx_connection_tcp_nodelay_e;\n+\n+\n+typedef enum {\n+    NGX_TCP_NOPUSH_UNSET = 0,\n+    NGX_TCP_NOPUSH_SET,\n+    NGX_TCP_NOPUSH_DISABLED\n+} ngx_connection_tcp_nopush_e;\n+\n+\n+#define NGX_LOWLEVEL_BUFFERED  0x0f\n+#define NGX_SSL_BUFFERED       0x01\n+#define NGX_HTTP_V2_BUFFERED   0x02\n+\n+\n+struct ngx_connection_s {\n+    void               *data;\n+    ngx_event_t        *read;\n+    ngx_event_t        *write;\n+\n+    ngx_socket_t        fd;\n+\n+    ngx_recv_pt         recv;\n+    ngx_send_pt         send;\n+    ngx_recv_chain_pt   recv_chain;\n+    ngx_send_chain_pt   send_chain;\n+\n+    ngx_listening_t    *listening;\n+\n+    off_t               sent;\n+\n+    ngx_log_t          *log;\n+\n+    ngx_pool_t         *pool;\n+\n+    int                 type;\n+\n+    struct sockaddr    *sockaddr;\n+    socklen_t           socklen;\n+    ngx_str_t           addr_text;\n+\n+    ngx_str_t           proxy_protocol_addr;\n+    in_port_t           proxy_protocol_port;\n+\n+#if (NGX_SSL || NGX_COMPAT)\n+    ngx_ssl_connection_t  *ssl;\n+#endif\n+\n+    ngx_udp_connection_t  *udp;\n+\n+    struct sockaddr    *local_sockaddr;\n+    socklen_t           local_socklen;\n+\n+    ngx_buf_t          *buffer;\n+\n+    ngx_queue_t         queue;\n+\n+    ngx_atomic_uint_t   number;\n+\n+    ngx_uint_t          requests;\n+\n+    unsigned            buffered:8;\n+\n+    unsigned            log_error:3;     /* ngx_connection_log_error_e */\n+\n+    unsigned            timedout:1;\n+    unsigned            error:1;\n+    unsigned            destroyed:1;\n+\n+    unsigned            idle:1;\n+    unsigned            reusable:1;\n+    unsigned            close:1;\n+    unsigned            shared:1;\n+\n+    unsigned            sendfile:1;\n+    unsigned            sndlowat:1;\n+    unsigned            tcp_nodelay:2;   /* ngx_connection_tcp_nodelay_e */\n+    unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */\n+\n+    unsigned            need_last_buf:1;\n+\n+#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n+    unsigned            busy_count:2;\n+#endif\n+\n+#if (NGX_THREADS || NGX_COMPAT)\n+    ngx_thread_task_t  *sendfile_task;\n+#endif\n+};\n+\n+\n+#define ngx_set_connection_log(c, l)                                         \\\n+                                                                             \\\n+    c->log->file = l->file;                                                  \\\n+    c->log->next = l->next;                                                  \\\n+    c->log->writer = l->writer;                                              \\\n+    c->log->wdata = l->wdata;                                                \\\n+    if (!(c->log->log_level & NGX_LOG_DEBUG_CONNECTION)) {                   \\\n+        c->log->log_level = l->log_level;                                    \\\n+    }\n+\n+\n+ngx_listening_t *ngx_create_listening(ngx_conf_t *cf, struct sockaddr *sockaddr,\n+    socklen_t socklen);\n+ngx_int_t ngx_clone_listening(ngx_cycle_t *cycle, ngx_listening_t *ls);\n+ngx_int_t ngx_set_inherited_sockets(ngx_cycle_t *cycle);\n+ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle);\n+void ngx_configure_listening_sockets(ngx_cycle_t *cycle);\n+void ngx_close_listening_sockets(ngx_cycle_t *cycle);\n+void ngx_close_connection(ngx_connection_t *c);\n+void ngx_close_idle_connections(ngx_cycle_t *cycle);\n+ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c, ngx_str_t *s,\n+    ngx_uint_t port);\n+ngx_int_t ngx_tcp_nodelay(ngx_connection_t *c);\n+ngx_int_t ngx_connection_error(ngx_connection_t *c, ngx_err_t err, char *text);\n+\n+ngx_connection_t *ngx_get_connection(ngx_socket_t s, ngx_log_t *log);\n+void ngx_free_connection(ngx_connection_t *c);\n+\n+void ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable);\n+\n+#endif /* _NGX_CONNECTION_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,112 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CORE_H_INCLUDED_\n+#define _NGX_CORE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+\n+\n+typedef struct ngx_module_s          ngx_module_t;\n+typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_cycle_s           ngx_cycle_t;\n+typedef struct ngx_pool_s            ngx_pool_t;\n+typedef struct ngx_chain_s           ngx_chain_t;\n+typedef struct ngx_log_s             ngx_log_t;\n+typedef struct ngx_open_file_s       ngx_open_file_t;\n+typedef struct ngx_command_s         ngx_command_t;\n+typedef struct ngx_file_s            ngx_file_t;\n+typedef struct ngx_event_s           ngx_event_t;\n+typedef struct ngx_event_aio_s       ngx_event_aio_t;\n+typedef struct ngx_connection_s      ngx_connection_t;\n+typedef struct ngx_thread_task_s     ngx_thread_task_t;\n+typedef struct ngx_ssl_s             ngx_ssl_t;\n+typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t;\n+typedef struct ngx_udp_connection_s  ngx_udp_connection_t;\n+\n+typedef void (*ngx_event_handler_pt)(ngx_event_t *ev);\n+typedef void (*ngx_connection_handler_pt)(ngx_connection_t *c);\n+\n+\n+#define  NGX_OK          0\n+#define  NGX_ERROR      -1\n+#define  NGX_AGAIN      -2\n+#define  NGX_BUSY       -3\n+#define  NGX_DONE       -4\n+#define  NGX_DECLINED   -5\n+#define  NGX_ABORT      -6\n+\n+\n+#include <ngx_errno.h>\n+#include <ngx_atomic.h>\n+#include <ngx_thread.h>\n+#include <ngx_rbtree.h>\n+#include <ngx_time.h>\n+#include <ngx_socket.h>\n+#include <ngx_string.h>\n+#include <ngx_files.h>\n+#include <ngx_shmem.h>\n+#include <ngx_process.h>\n+#include <ngx_user.h>\n+#include <ngx_dlopen.h>\n+#include <ngx_parse.h>\n+#include <ngx_parse_time.h>\n+#include <ngx_log.h>\n+#include <ngx_alloc.h>\n+#include <ngx_palloc.h>\n+#include <ngx_buf.h>\n+#include <ngx_queue.h>\n+#include <ngx_array.h>\n+#include <ngx_list.h>\n+#include <ngx_hash.h>\n+#include <ngx_file.h>\n+#include <ngx_crc.h>\n+#include <ngx_crc32.h>\n+#include <ngx_murmurhash.h>\n+#if (NGX_PCRE)\n+#include <ngx_regex.h>\n+#endif\n+#include <ngx_radix_tree.h>\n+#include <ngx_times.h>\n+#include <ngx_rwlock.h>\n+#include <ngx_shmtx.h>\n+#include <ngx_slab.h>\n+#include <ngx_inet.h>\n+#include <ngx_cycle.h>\n+#include <ngx_resolver.h>\n+#if (NGX_OPENSSL)\n+#include <ngx_event_openssl.h>\n+#endif\n+#include <ngx_process_cycle.h>\n+#include <ngx_conf_file.h>\n+#include <ngx_module.h>\n+#include <ngx_open_file_cache.h>\n+#include <ngx_os.h>\n+#include <ngx_connection.h>\n+#include <ngx_syslog.h>\n+#include <ngx_proxy_protocol.h>\n+\n+\n+#define LF     (u_char) '\\n'\n+#define CR     (u_char) '\\r'\n+#define CRLF   \"\\r\\n\"\n+\n+\n+#define ngx_abs(value)       (((value) >= 0) ? (value) : - (value))\n+#define ngx_max(val1, val2)  ((val1 < val2) ? (val2) : (val1))\n+#define ngx_min(val1, val2)  ((val1 > val2) ? (val2) : (val1))\n+\n+void ngx_cpuinfo(void);\n+\n+#if (NGX_HAVE_OPENAT)\n+#define NGX_DISABLE_SYMLINKS_OFF        0\n+#define NGX_DISABLE_SYMLINKS_ON         1\n+#define NGX_DISABLE_SYMLINKS_NOTOWNER   2\n+#endif\n+\n+#endif /* _NGX_CORE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,139 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (( __i386__ || __amd64__ ) && ( __GNUC__ || __INTEL_COMPILER ))\n+\n+\n+static ngx_inline void ngx_cpuid(uint32_t i, uint32_t *buf);\n+\n+\n+#if ( __i386__ )\n+\n+static ngx_inline void\n+ngx_cpuid(uint32_t i, uint32_t *buf)\n+{\n+\n+    /*\n+     * we could not use %ebx as output parameter if gcc builds PIC,\n+     * and we could not save %ebx on stack, because %esp is used,\n+     * when the -fomit-frame-pointer optimization is specified.\n+     */\n+\n+    __asm__ (\n+\n+    \"    mov    %%ebx, %%esi;  \"\n+\n+    \"    cpuid;                \"\n+    \"    mov    %%eax, (%1);   \"\n+    \"    mov    %%ebx, 4(%1);  \"\n+    \"    mov    %%edx, 8(%1);  \"\n+    \"    mov    %%ecx, 12(%1); \"\n+\n+    \"    mov    %%esi, %%ebx;  \"\n+\n+    : : \"a\" (i), \"D\" (buf) : \"ecx\", \"edx\", \"esi\", \"memory\" );\n+}\n+\n+\n+#else /* __amd64__ */\n+\n+\n+static ngx_inline void\n+ngx_cpuid(uint32_t i, uint32_t *buf)\n+{\n+    uint32_t  eax, ebx, ecx, edx;\n+\n+    __asm__ (\n+\n+        \"cpuid\"\n+\n+    : \"=a\" (eax), \"=b\" (ebx), \"=c\" (ecx), \"=d\" (edx) : \"a\" (i) );\n+\n+    buf[0] = eax;\n+    buf[1] = ebx;\n+    buf[2] = edx;\n+    buf[3] = ecx;\n+}\n+\n+\n+#endif\n+\n+\n+/* auto detect the L2 cache line size of modern and widespread CPUs */\n+\n+void\n+ngx_cpuinfo(void)\n+{\n+    u_char    *vendor;\n+    uint32_t   vbuf[5], cpu[4], model;\n+\n+    vbuf[0] = 0;\n+    vbuf[1] = 0;\n+    vbuf[2] = 0;\n+    vbuf[3] = 0;\n+    vbuf[4] = 0;\n+\n+    ngx_cpuid(0, vbuf);\n+\n+    vendor = (u_char *) &vbuf[1];\n+\n+    if (vbuf[0] == 0) {\n+        return;\n+    }\n+\n+    ngx_cpuid(1, cpu);\n+\n+    if (ngx_strcmp(vendor, \"GenuineIntel\") == 0) {\n+\n+        switch ((cpu[0] & 0xf00) >> 8) {\n+\n+        /* Pentium */\n+        case 5:\n+            ngx_cacheline_size = 32;\n+            break;\n+\n+        /* Pentium Pro, II, III */\n+        case 6:\n+            ngx_cacheline_size = 32;\n+\n+            model = ((cpu[0] & 0xf0000) >> 8) | (cpu[0] & 0xf0);\n+\n+            if (model >= 0xd0) {\n+                /* Intel Core, Core 2, Atom */\n+                ngx_cacheline_size = 64;\n+            }\n+\n+            break;\n+\n+        /*\n+         * Pentium 4, although its cache line size is 64 bytes,\n+         * it prefetches up to two cache lines during memory read\n+         */\n+        case 15:\n+            ngx_cacheline_size = 128;\n+            break;\n+        }\n+\n+    } else if (ngx_strcmp(vendor, \"AuthenticAMD\") == 0) {\n+        ngx_cacheline_size = 64;\n+    }\n+}\n+\n+#else\n+\n+\n+void\n+ngx_cpuinfo(void)\n+{\n+}\n+\n+\n+#endif\nDiff:\n@@ -0,0 +1,39 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CRC_H_INCLUDED_\n+#define _NGX_CRC_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/* 32-bit crc16 */\n+\n+static ngx_inline uint32_t\n+ngx_crc(u_char *data, size_t len)\n+{\n+    uint32_t  sum;\n+\n+    for (sum = 0; len; len--) {\n+\n+        /*\n+         * gcc 2.95.2 x86 and icc 7.1.006 compile\n+         * that operator into the single \"rol\" opcode,\n+         * msvc 6.0sp2 compiles it into four opcodes.\n+         */\n+        sum = sum >> 1 | sum << 31;\n+\n+        sum += *data++;\n+    }\n+\n+    return sum;\n+}\n+\n+\n+#endif /* _NGX_CRC_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,129 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/*\n+ * The code and lookup tables are based on the algorithm\n+ * described at http://www.w3.org/TR/PNG/\n+ *\n+ * The 256 element lookup table takes 1024 bytes, and it may be completely\n+ * cached after processing about 30-60 bytes of data.  So for short data\n+ * we use the 16 element lookup table that takes only 64 bytes and align it\n+ * to CPU cache line size.  Of course, the small table adds code inside\n+ * CRC32 loop, but the cache misses overhead is bigger than overhead of\n+ * the additional code.  For example, ngx_crc32_short() of 16 bytes of data\n+ * takes half as much CPU clocks than ngx_crc32_long().\n+ */\n+\n+\n+static uint32_t  ngx_crc32_table16[] = {\n+    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,\n+    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n+    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n+    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n+};\n+\n+\n+uint32_t  ngx_crc32_table256[] = {\n+    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,\n+    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n+    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n+    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n+    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n+    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n+    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,\n+    0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n+    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n+    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n+    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,\n+    0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n+    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,\n+    0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n+    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n+    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n+    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,\n+    0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n+    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,\n+    0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n+    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n+    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n+    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,\n+    0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n+    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n+    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n+    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n+    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n+    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,\n+    0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n+    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,\n+    0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n+    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n+    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n+    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n+    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n+    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,\n+    0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n+    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n+    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n+    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,\n+    0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n+    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,\n+    0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n+    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n+    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n+    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,\n+    0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n+    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,\n+    0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n+    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n+    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n+    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,\n+    0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n+    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n+    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n+    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n+    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n+    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,\n+    0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n+    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,\n+    0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n+    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n+    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n+};\n+\n+\n+uint32_t *ngx_crc32_table_short = ngx_crc32_table16;\n+\n+\n+ngx_int_t\n+ngx_crc32_table_init(void)\n+{\n+    void  *p;\n+\n+    if (((uintptr_t) ngx_crc32_table_short\n+          & ~((uintptr_t) ngx_cacheline_size - 1))\n+        == (uintptr_t) ngx_crc32_table_short)\n+    {\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_alloc(16 * sizeof(uint32_t) + ngx_cacheline_size, ngx_cycle->log);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_align_ptr(p, ngx_cacheline_size);\n+\n+    ngx_memcpy(p, ngx_crc32_table16, 16 * sizeof(uint32_t));\n+\n+    ngx_crc32_table_short = p;\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -0,0 +1,79 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CRC32_H_INCLUDED_\n+#define _NGX_CRC32_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+extern uint32_t  *ngx_crc32_table_short;\n+extern uint32_t   ngx_crc32_table256[];\n+\n+\n+static ngx_inline uint32_t\n+ngx_crc32_short(u_char *p, size_t len)\n+{\n+    u_char    c;\n+    uint32_t  crc;\n+\n+    crc = 0xffffffff;\n+\n+    while (len--) {\n+        c = *p++;\n+        crc = ngx_crc32_table_short[(crc ^ (c & 0xf)) & 0xf] ^ (crc >> 4);\n+        crc = ngx_crc32_table_short[(crc ^ (c >> 4)) & 0xf] ^ (crc >> 4);\n+    }\n+\n+    return crc ^ 0xffffffff;\n+}\n+\n+\n+static ngx_inline uint32_t\n+ngx_crc32_long(u_char *p, size_t len)\n+{\n+    uint32_t  crc;\n+\n+    crc = 0xffffffff;\n+\n+    while (len--) {\n+        crc = ngx_crc32_table256[(crc ^ *p++) & 0xff] ^ (crc >> 8);\n+    }\n+\n+    return crc ^ 0xffffffff;\n+}\n+\n+\n+#define ngx_crc32_init(crc)                                                   \\\n+    crc = 0xffffffff\n+\n+\n+static ngx_inline void\n+ngx_crc32_update(uint32_t *crc, u_char *p, size_t len)\n+{\n+    uint32_t  c;\n+\n+    c = *crc;\n+\n+    while (len--) {\n+        c = ngx_crc32_table256[(c ^ *p++) & 0xff] ^ (c >> 8);\n+    }\n+\n+    *crc = c;\n+}\n+\n+\n+#define ngx_crc32_final(crc)                                                  \\\n+    crc ^= 0xffffffff\n+\n+\n+ngx_int_t ngx_crc32_table_init(void);\n+\n+\n+#endif /* _NGX_CRC32_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,270 @@\n+\n+/*\n+ * Copyright (C) Maxim Dounin\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_crypt.h>\n+#include <ngx_md5.h>\n+#include <ngx_sha1.h>\n+\n+\n+#if (NGX_CRYPT)\n+\n+static ngx_int_t ngx_crypt_apr1(ngx_pool_t *pool, u_char *key, u_char *salt,\n+    u_char **encrypted);\n+static ngx_int_t ngx_crypt_plain(ngx_pool_t *pool, u_char *key, u_char *salt,\n+    u_char **encrypted);\n+static ngx_int_t ngx_crypt_ssha(ngx_pool_t *pool, u_char *key, u_char *salt,\n+    u_char **encrypted);\n+static ngx_int_t ngx_crypt_sha(ngx_pool_t *pool, u_char *key, u_char *salt,\n+    u_char **encrypted);\n+\n+\n+static u_char *ngx_crypt_to64(u_char *p, uint32_t v, size_t n);\n+\n+\n+ngx_int_t\n+ngx_crypt(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    if (ngx_strncmp(salt, \"$apr1$\", sizeof(\"$apr1$\") - 1) == 0) {\n+        return ngx_crypt_apr1(pool, key, salt, encrypted);\n+\n+    } else if (ngx_strncmp(salt, \"{PLAIN}\", sizeof(\"{PLAIN}\") - 1) == 0) {\n+        return ngx_crypt_plain(pool, key, salt, encrypted);\n+\n+    } else if (ngx_strncmp(salt, \"{SSHA}\", sizeof(\"{SSHA}\") - 1) == 0) {\n+        return ngx_crypt_ssha(pool, key, salt, encrypted);\n+\n+    } else if (ngx_strncmp(salt, \"{SHA}\", sizeof(\"{SHA}\") - 1) == 0) {\n+        return ngx_crypt_sha(pool, key, salt, encrypted);\n+    }\n+\n+    /* fallback to libc crypt() */\n+\n+    return ngx_libc_crypt(pool, key, salt, encrypted);\n+}\n+\n+\n+static ngx_int_t\n+ngx_crypt_apr1(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    ngx_int_t          n;\n+    ngx_uint_t         i;\n+    u_char            *p, *last, final[16];\n+    size_t             saltlen, keylen;\n+    ngx_md5_t          md5, ctx1;\n+\n+    /* Apache's apr1 crypt is Poul-Henning Kamp's md5 crypt with $apr1$ magic */\n+\n+    keylen = ngx_strlen(key);\n+\n+    /* true salt: no magic, max 8 chars, stop at first $ */\n+\n+    salt += sizeof(\"$apr1$\") - 1;\n+    last = salt + 8;\n+    for (p = salt; *p && *p != '$' && p < last; p++) { /* void */ }\n+    saltlen = p - salt;\n+\n+    /* hash key and salt */\n+\n+    ngx_md5_init(&md5);\n+    ngx_md5_update(&md5, key, keylen);\n+    ngx_md5_update(&md5, (u_char *) \"$apr1$\", sizeof(\"$apr1$\") - 1);\n+    ngx_md5_update(&md5, salt, saltlen);\n+\n+    ngx_md5_init(&ctx1);\n+    ngx_md5_update(&ctx1, key, keylen);\n+    ngx_md5_update(&ctx1, salt, saltlen);\n+    ngx_md5_update(&ctx1, key, keylen);\n+    ngx_md5_final(final, &ctx1);\n+\n+    for (n = keylen; n > 0; n -= 16) {\n+        ngx_md5_update(&md5, final, n > 16 ? 16 : n);\n+    }\n+\n+    ngx_memzero(final, sizeof(final));\n+\n+    for (i = keylen; i; i >>= 1) {\n+        if (i & 1) {\n+            ngx_md5_update(&md5, final, 1);\n+\n+        } else {\n+            ngx_md5_update(&md5, key, 1);\n+        }\n+    }\n+\n+    ngx_md5_final(final, &md5);\n+\n+    for (i = 0; i < 1000; i++) {\n+        ngx_md5_init(&ctx1);\n+\n+        if (i & 1) {\n+            ngx_md5_update(&ctx1, key, keylen);\n+\n+        } else {\n+            ngx_md5_update(&ctx1, final, 16);\n+        }\n+\n+        if (i % 3) {\n+            ngx_md5_update(&ctx1, salt, saltlen);\n+        }\n+\n+        if (i % 7) {\n+            ngx_md5_update(&ctx1, key, keylen);\n+        }\n+\n+        if (i & 1) {\n+            ngx_md5_update(&ctx1, final, 16);\n+\n+        } else {\n+            ngx_md5_update(&ctx1, key, keylen);\n+        }\n+\n+        ngx_md5_final(final, &ctx1);\n+    }\n+\n+    /* output */\n+\n+    *encrypted = ngx_pnalloc(pool, sizeof(\"$apr1$\") - 1 + saltlen + 1 + 22 + 1);\n+    if (*encrypted == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(*encrypted, \"$apr1$\", sizeof(\"$apr1$\") - 1);\n+    p = ngx_copy(p, salt, saltlen);\n+    *p++ = '$';\n+\n+    p = ngx_crypt_to64(p, (final[ 0]<<16) | (final[ 6]<<8) | final[12], 4);\n+    p = ngx_crypt_to64(p, (final[ 1]<<16) | (final[ 7]<<8) | final[13], 4);\n+    p = ngx_crypt_to64(p, (final[ 2]<<16) | (final[ 8]<<8) | final[14], 4);\n+    p = ngx_crypt_to64(p, (final[ 3]<<16) | (final[ 9]<<8) | final[15], 4);\n+    p = ngx_crypt_to64(p, (final[ 4]<<16) | (final[10]<<8) | final[ 5], 4);\n+    p = ngx_crypt_to64(p, final[11], 2);\n+    *p = '\\0';\n+\n+    return NGX_OK;\n+}\n+\n+\n+static u_char *\n+ngx_crypt_to64(u_char *p, uint32_t v, size_t n)\n+{\n+    static u_char   itoa64[] =\n+        \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n+\n+    while (n--) {\n+        *p++ = itoa64[v & 0x3f];\n+        v >>= 6;\n+    }\n+\n+    return p;\n+}\n+\n+\n+static ngx_int_t\n+ngx_crypt_plain(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    size_t   len;\n+    u_char  *p;\n+\n+    len = ngx_strlen(key);\n+\n+    *encrypted = ngx_pnalloc(pool, sizeof(\"{PLAIN}\") - 1 + len + 1);\n+    if (*encrypted == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(*encrypted, \"{PLAIN}\", sizeof(\"{PLAIN}\") - 1);\n+    ngx_memcpy(p, key, len + 1);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_crypt_ssha(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    size_t       len;\n+    ngx_int_t    rc;\n+    ngx_str_t    encoded, decoded;\n+    ngx_sha1_t   sha1;\n+\n+    /* \"{SSHA}\" base64(SHA1(key salt) salt) */\n+\n+    /* decode base64 salt to find out true salt */\n+\n+    encoded.data = salt + sizeof(\"{SSHA}\") - 1;\n+    encoded.len = ngx_strlen(encoded.data);\n+\n+    len = ngx_max(ngx_base64_decoded_length(encoded.len), 20);\n+\n+    decoded.data = ngx_pnalloc(pool, len);\n+    if (decoded.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    rc = ngx_decode_base64(&decoded, &encoded);\n+\n+    if (rc != NGX_OK || decoded.len < 20) {\n+        decoded.len = 20;\n+    }\n+\n+    /* update SHA1 from key and salt */\n+\n+    ngx_sha1_init(&sha1);\n+    ngx_sha1_update(&sha1, key, ngx_strlen(key));\n+    ngx_sha1_update(&sha1, decoded.data + 20, decoded.len - 20);\n+    ngx_sha1_final(decoded.data, &sha1);\n+\n+    /* encode it back to base64 */\n+\n+    len = sizeof(\"{SSHA}\") - 1 + ngx_base64_encoded_length(decoded.len) + 1;\n+\n+    *encrypted = ngx_pnalloc(pool, len);\n+    if (*encrypted == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    encoded.data = ngx_cpymem(*encrypted, \"{SSHA}\", sizeof(\"{SSHA}\") - 1);\n+    ngx_encode_base64(&encoded, &decoded);\n+    encoded.data[encoded.len] = '\\0';\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_crypt_sha(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    size_t      len;\n+    ngx_str_t   encoded, decoded;\n+    ngx_sha1_t  sha1;\n+    u_char      digest[20];\n+\n+    /* \"{SHA}\" base64(SHA1(key)) */\n+\n+    decoded.len = sizeof(digest);\n+    decoded.data = digest;\n+\n+    ngx_sha1_init(&sha1);\n+    ngx_sha1_update(&sha1, key, ngx_strlen(key));\n+    ngx_sha1_final(digest, &sha1);\n+\n+    len = sizeof(\"{SHA}\") - 1 + ngx_base64_encoded_length(decoded.len) + 1;\n+\n+    *encrypted = ngx_pnalloc(pool, len);\n+    if (*encrypted == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    encoded.data = ngx_cpymem(*encrypted, \"{SHA}\", sizeof(\"{SHA}\") - 1);\n+    ngx_encode_base64(&encoded, &decoded);\n+    encoded.data[encoded.len] = '\\0';\n+\n+    return NGX_OK;\n+}\n+\n+#endif /* NGX_CRYPT */\nDiff:\n@@ -0,0 +1,20 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CRYPT_H_INCLUDED_\n+#define _NGX_CRYPT_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_int_t ngx_crypt(ngx_pool_t *pool, u_char *key, u_char *salt,\n+    u_char **encrypted);\n+\n+\n+#endif /* _NGX_CRYPT_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,1457 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+static void ngx_destroy_cycle_pools(ngx_conf_t *conf);\n+static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle,\n+    ngx_shm_zone_t *shm_zone);\n+static ngx_int_t ngx_test_lockfile(u_char *file, ngx_log_t *log);\n+static void ngx_clean_old_cycles(ngx_event_t *ev);\n+static void ngx_shutdown_timer_handler(ngx_event_t *ev);\n+\n+\n+volatile ngx_cycle_t  *ngx_cycle;\n+ngx_array_t            ngx_old_cycles;\n+\n+static ngx_pool_t     *ngx_temp_pool;\n+static ngx_event_t     ngx_cleaner_event;\n+static ngx_event_t     ngx_shutdown_event;\n+\n+ngx_uint_t             ngx_test_config;\n+ngx_uint_t             ngx_dump_config;\n+ngx_uint_t             ngx_quiet_mode;\n+\n+\n+/* STUB NAME */\n+static ngx_connection_t  dumb;\n+/* STUB */\n+\n+\n+ngx_cycle_t *\n+ngx_init_cycle(ngx_cycle_t *old_cycle)\n+{\n+    void                *rv;\n+    char               **senv;\n+    ngx_uint_t           i, n;\n+    ngx_log_t           *log;\n+    ngx_time_t          *tp;\n+    ngx_conf_t           conf;\n+    ngx_pool_t          *pool;\n+    ngx_cycle_t         *cycle, **old;\n+    ngx_shm_zone_t      *shm_zone, *oshm_zone;\n+    ngx_list_part_t     *part, *opart;\n+    ngx_open_file_t     *file;\n+    ngx_listening_t     *ls, *nls;\n+    ngx_core_conf_t     *ccf, *old_ccf;\n+    ngx_core_module_t   *module;\n+    char                 hostname[NGX_MAXHOSTNAMELEN];\n+\n+    ngx_timezone_update();\n+\n+    /* force localtime update with a new timezone */\n+\n+    tp = ngx_timeofday();\n+    tp->sec = 0;\n+\n+    ngx_time_update();\n+\n+\n+    log = old_cycle->log;\n+\n+    pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);\n+    if (pool == NULL) {\n+        return NULL;\n+    }\n+    pool->log = log;\n+\n+    cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));\n+    if (cycle == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    cycle->pool = pool;\n+    cycle->log = log;\n+    cycle->old_cycle = old_cycle;\n+\n+    cycle->conf_prefix.len = old_cycle->conf_prefix.len;\n+    cycle->conf_prefix.data = ngx_pstrdup(pool, &old_cycle->conf_prefix);\n+    if (cycle->conf_prefix.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    cycle->prefix.len = old_cycle->prefix.len;\n+    cycle->prefix.data = ngx_pstrdup(pool, &old_cycle->prefix);\n+    if (cycle->prefix.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    cycle->conf_file.len = old_cycle->conf_file.len;\n+    cycle->conf_file.data = ngx_pnalloc(pool, old_cycle->conf_file.len + 1);\n+    if (cycle->conf_file.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    ngx_cpystrn(cycle->conf_file.data, old_cycle->conf_file.data,\n+                old_cycle->conf_file.len + 1);\n+\n+    cycle->conf_param.len = old_cycle->conf_param.len;\n+    cycle->conf_param.data = ngx_pstrdup(pool, &old_cycle->conf_param);\n+    if (cycle->conf_param.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+\n+    n = old_cycle->paths.nelts ? old_cycle->paths.nelts : 10;\n+\n+    if (ngx_array_init(&cycle->paths, pool, n, sizeof(ngx_path_t *))\n+        != NGX_OK)\n+    {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    ngx_memzero(cycle->paths.elts, n * sizeof(ngx_path_t *));\n+\n+\n+    if (ngx_array_init(&cycle->config_dump, pool, 1, sizeof(ngx_conf_dump_t))\n+        != NGX_OK)\n+    {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    ngx_rbtree_init(&cycle->config_dump_rbtree, &cycle->config_dump_sentinel,\n+                    ngx_str_rbtree_insert_value);\n+\n+    if (old_cycle->open_files.part.nelts) {\n+        n = old_cycle->open_files.part.nelts;\n+        for (part = old_cycle->open_files.part.next; part; part = part->next) {\n+            n += part->nelts;\n+        }\n+\n+    } else {\n+        n = 20;\n+    }\n+\n+    if (ngx_list_init(&cycle->open_files, pool, n, sizeof(ngx_open_file_t))\n+        != NGX_OK)\n+    {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+\n+    if (old_cycle->shared_memory.part.nelts) {\n+        n = old_cycle->shared_memory.part.nelts;\n+        for (part = old_cycle->shared_memory.part.next; part; part = part->next)\n+        {\n+            n += part->nelts;\n+        }\n+\n+    } else {\n+        n = 1;\n+    }\n+\n+    if (ngx_list_init(&cycle->shared_memory, pool, n, sizeof(ngx_shm_zone_t))\n+        != NGX_OK)\n+    {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    n = old_cycle->listening.nelts ? old_cycle->listening.nelts : 10;\n+\n+    if (ngx_array_init(&cycle->listening, pool, n, sizeof(ngx_listening_t))\n+        != NGX_OK)\n+    {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    ngx_memzero(cycle->listening.elts, n * sizeof(ngx_listening_t));\n+\n+\n+    ngx_queue_init(&cycle->reusable_connections_queue);\n+\n+\n+    cycle->conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));\n+    if (cycle->conf_ctx == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+\n+    if (gethostname(hostname, NGX_MAXHOSTNAMELEN) == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"gethostname() failed\");\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    /* on Linux gethostname() silently truncates name that does not fit */\n+\n+    hostname[NGX_MAXHOSTNAMELEN - 1] = '\\0';\n+    cycle->hostname.len = ngx_strlen(hostname);\n+\n+    cycle->hostname.data = ngx_pnalloc(pool, cycle->hostname.len);\n+    if (cycle->hostname.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    ngx_strlow(cycle->hostname.data, (u_char *) hostname, cycle->hostname.len);\n+\n+\n+    if (ngx_cycle_modules(cycle) != NGX_OK) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+\n+    for (i = 0; cycle->modules[i]; i++) {\n+        if (cycle->modules[i]->type != NGX_CORE_MODULE) {\n+            continue;\n+        }\n+\n+        module = cycle->modules[i]->ctx;\n+\n+        if (module->create_conf) {\n+            rv = module->create_conf(cycle);\n+            if (rv == NULL) {\n+                ngx_destroy_pool(pool);\n+                return NULL;\n+            }\n+            cycle->conf_ctx[cycle->modules[i]->index] = rv;\n+        }\n+    }\n+\n+\n+    senv = environ;\n+\n+\n+    ngx_memzero(&conf, sizeof(ngx_conf_t));\n+    /* STUB: init array ? */\n+    conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t));\n+    if (conf.args == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log);\n+    if (conf.temp_pool == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+\n+    conf.ctx = cycle->conf_ctx;\n+    conf.cycle = cycle;\n+    conf.pool = pool;\n+    conf.log = log;\n+    conf.module_type = NGX_CORE_MODULE;\n+    conf.cmd_type = NGX_MAIN_CONF;\n+\n+#if 0\n+    log->log_level = NGX_LOG_DEBUG_ALL;\n+#endif\n+\n+    if (ngx_conf_param(&conf) != NGX_CONF_OK) {\n+        environ = senv;\n+        ngx_destroy_cycle_pools(&conf);\n+        return NULL;\n+    }\n+\n+    if (ngx_conf_parse(&conf, &cycle->conf_file) != NGX_CONF_OK) {\n+        environ = senv;\n+        ngx_destroy_cycle_pools(&conf);\n+        return NULL;\n+    }\n+\n+    if (ngx_test_config && !ngx_quiet_mode) {\n+        ngx_log_stderr(0, \"the configuration file %s syntax is ok\",\n+                       cycle->conf_file.data);\n+    }\n+\n+    for (i = 0; cycle->modules[i]; i++) {\n+        if (cycle->modules[i]->type != NGX_CORE_MODULE) {\n+            continue;\n+        }\n+\n+        module = cycle->modules[i]->ctx;\n+\n+        if (module->init_conf) {\n+            if (module->init_conf(cycle,\n+                                  cycle->conf_ctx[cycle->modules[i]->index])\n+                == NGX_CONF_ERROR)\n+            {\n+                environ = senv;\n+                ngx_destroy_cycle_pools(&conf);\n+                return NULL;\n+            }\n+        }\n+    }\n+\n+    if (ngx_process == NGX_PROCESS_SIGNALLER) {\n+        return cycle;\n+    }\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (ngx_test_config) {\n+\n+        if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\n+            goto failed;\n+        }\n+\n+    } else if (!ngx_is_init_cycle(old_cycle)) {\n+\n+        /*\n+         * we do not create the pid file in the first ngx_init_cycle() call\n+         * because we need to write the demonized process pid\n+         */\n+\n+        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle->conf_ctx,\n+                                                   ngx_core_module);\n+        if (ccf->pid.len != old_ccf->pid.len\n+            || ngx_strcmp(ccf->pid.data, old_ccf->pid.data) != 0)\n+        {\n+            /* new pid file name */\n+\n+            if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\n+                goto failed;\n+            }\n+\n+            ngx_delete_pidfile(old_cycle);\n+        }\n+    }\n+\n+\n+    if (ngx_test_lockfile(cycle->lock_file.data, log) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+\n+    if (ngx_create_paths(cycle, ccf->user) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+\n+    if (ngx_log_open_default(cycle) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    /* open the new files */\n+\n+    part = &cycle->open_files.part;\n+    file = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            file = part->elts;\n+            i = 0;\n+        }\n+\n+        if (file[i].name.len == 0) {\n+            continue;\n+        }\n+\n+        file[i].fd = ngx_open_file(file[i].name.data,\n+                                   NGX_FILE_APPEND,\n+                                   NGX_FILE_CREATE_OR_OPEN,\n+                                   NGX_FILE_DEFAULT_ACCESS);\n+\n+        ngx_log_debug3(NGX_LOG_DEBUG_CORE, log, 0,\n+                       \"log: %p %d \\\"%s\\\"\",\n+                       &file[i], file[i].fd, file[i].name.data);\n+\n+        if (file[i].fd == NGX_INVALID_FILE) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                          ngx_open_file_n \" \\\"%s\\\" failed\",\n+                          file[i].name.data);\n+            goto failed;\n+        }\n+\n+#if !(NGX_WIN32)\n+        if (fcntl(file[i].fd, F_SETFD, FD_CLOEXEC) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                          \"fcntl(FD_CLOEXEC) \\\"%s\\\" failed\",\n+                          file[i].name.data);\n+            goto failed;\n+        }\n+#endif\n+    }\n+\n+    cycle->log = &cycle->new_log;\n+    pool->log = &cycle->new_log;\n+\n+\n+    /* create shared memory */\n+\n+    part = &cycle->shared_memory.part;\n+    shm_zone = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            shm_zone = part->elts;\n+            i = 0;\n+        }\n+\n+        if (shm_zone[i].shm.size == 0) {\n+            ngx_log_error(NGX_LOG_EMERG, log, 0,\n+                          \"zero size shared memory zone \\\"%V\\\"\",\n+                          &shm_zone[i].shm.name);\n+            goto failed;\n+        }\n+\n+        shm_zone[i].shm.log = cycle->log;\n+\n+        opart = &old_cycle->shared_memory.part;\n+        oshm_zone = opart->elts;\n+\n+        for (n = 0; /* void */ ; n++) {\n+\n+            if (n >= opart->nelts) {\n+                if (opart->next == NULL) {\n+                    break;\n+                }\n+                opart = opart->next;\n+                oshm_zone = opart->elts;\n+                n = 0;\n+            }\n+\n+            if (shm_zone[i].shm.name.len != oshm_zone[n].shm.name.len) {\n+                continue;\n+            }\n+\n+            if (ngx_strncmp(shm_zone[i].shm.name.data,\n+                            oshm_zone[n].shm.name.data,\n+                            shm_zone[i].shm.name.len)\n+                != 0)\n+            {\n+                continue;\n+            }\n+\n+            if (shm_zone[i].tag == oshm_zone[n].tag\n+                && shm_zone[i].shm.size == oshm_zone[n].shm.size\n+                && !shm_zone[i].noreuse)\n+            {\n+                shm_zone[i].shm.addr = oshm_zone[n].shm.addr;\n+#if (NGX_WIN32)\n+                shm_zone[i].shm.handle = oshm_zone[n].shm.handle;\n+#endif\n+\n+                if (shm_zone[i].init(&shm_zone[i], oshm_zone[n].data)\n+                    != NGX_OK)\n+                {\n+                    goto failed;\n+                }\n+\n+                goto shm_zone_found;\n+            }\n+\n+            break;\n+        }\n+\n+        if (ngx_shm_alloc(&shm_zone[i].shm) != NGX_OK) {\n+            goto failed;\n+        }\n+\n+        if (ngx_init_zone_pool(cycle, &shm_zone[i]) != NGX_OK) {\n+            goto failed;\n+        }\n+\n+        if (shm_zone[i].init(&shm_zone[i], NULL) != NGX_OK) {\n+            goto failed;\n+        }\n+\n+    shm_zone_found:\n+\n+        continue;\n+    }\n+\n+\n+    /* handle the listening sockets */\n+\n+    if (old_cycle->listening.nelts) {\n+        ls = old_cycle->listening.elts;\n+        for (i = 0; i < old_cycle->listening.nelts; i++) {\n+            ls[i].remain = 0;\n+        }\n+\n+        nls = cycle->listening.elts;\n+        for (n = 0; n < cycle->listening.nelts; n++) {\n+\n+            for (i = 0; i < old_cycle->listening.nelts; i++) {\n+                if (ls[i].ignore) {\n+                    continue;\n+                }\n+\n+                if (ls[i].remain) {\n+                    continue;\n+                }\n+\n+                if (ls[i].type != nls[n].type) {\n+                    continue;\n+                }\n+\n+                if (ngx_cmp_sockaddr(nls[n].sockaddr, nls[n].socklen,\n+                                     ls[i].sockaddr, ls[i].socklen, 1)\n+                    == NGX_OK)\n+                {\n+                    nls[n].fd = ls[i].fd;\n+                    nls[n].previous = &ls[i];\n+                    ls[i].remain = 1;\n+\n+                    if (ls[i].backlog != nls[n].backlog) {\n+                        nls[n].listen = 1;\n+                    }\n+\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+\n+                    /*\n+                     * FreeBSD, except the most recent versions,\n+                     * could not remove accept filter\n+                     */\n+                    nls[n].deferred_accept = ls[i].deferred_accept;\n+\n+                    if (ls[i].accept_filter && nls[n].accept_filter) {\n+                        if (ngx_strcmp(ls[i].accept_filter,\n+                                       nls[n].accept_filter)\n+                            != 0)\n+                        {\n+                            nls[n].delete_deferred = 1;\n+                            nls[n].add_deferred = 1;\n+                        }\n+\n+                    } else if (ls[i].accept_filter) {\n+                        nls[n].delete_deferred = 1;\n+\n+                    } else if (nls[n].accept_filter) {\n+                        nls[n].add_deferred = 1;\n+                    }\n+#endif\n+\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n+\n+                    if (ls[i].deferred_accept && !nls[n].deferred_accept) {\n+                        nls[n].delete_deferred = 1;\n+\n+                    } else if (ls[i].deferred_accept != nls[n].deferred_accept)\n+                    {\n+                        nls[n].add_deferred = 1;\n+                    }\n+#endif\n+\n+#if (NGX_HAVE_REUSEPORT)\n+                    if (nls[n].reuseport && !ls[i].reuseport) {\n+                        nls[n].add_reuseport = 1;\n+                    }\n+#endif\n+\n+                    break;\n+                }\n+            }\n+\n+            if (nls[n].fd == (ngx_socket_t) -1) {\n+                nls[n].open = 1;\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+                if (nls[n].accept_filter) {\n+                    nls[n].add_deferred = 1;\n+                }\n+#endif\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n+                if (nls[n].deferred_accept) {\n+                    nls[n].add_deferred = 1;\n+                }\n+#endif\n+            }\n+        }\n+\n+    } else {\n+        ls = cycle->listening.elts;\n+        for (i = 0; i < cycle->listening.nelts; i++) {\n+            ls[i].open = 1;\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n+            if (ls[i].accept_filter) {\n+                ls[i].add_deferred = 1;\n+            }\n+#endif\n+#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n+            if (ls[i].deferred_accept) {\n+                ls[i].add_deferred = 1;\n+            }\n+#endif\n+        }\n+    }\n+\n+    if (ngx_open_listening_sockets(cycle) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    if (!ngx_test_config) {\n+        ngx_configure_listening_sockets(cycle);\n+    }\n+\n+\n+    /* commit the new cycle configuration */\n+\n+    if (!ngx_use_stderr) {\n+        (void) ngx_log_redirect_stderr(cycle);\n+    }\n+\n+    pool->log = cycle->log;\n+\n+    if (ngx_init_modules(cycle) != NGX_OK) {\n+        /* fatal */\n+        exit(1);\n+    }\n+\n+\n+    /* close and delete stuff that lefts from an old cycle */\n+\n+    /* free the unnecessary shared memory */\n+\n+    opart = &old_cycle->shared_memory.part;\n+    oshm_zone = opart->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= opart->nelts) {\n+            if (opart->next == NULL) {\n+                goto old_shm_zone_done;\n+            }\n+            opart = opart->next;\n+            oshm_zone = opart->elts;\n+            i = 0;\n+        }\n+\n+        part = &cycle->shared_memory.part;\n+        shm_zone = part->elts;\n+\n+        for (n = 0; /* void */ ; n++) {\n+\n+            if (n >= part->nelts) {\n+                if (part->next == NULL) {\n+                    break;\n+                }\n+                part = part->next;\n+                shm_zone = part->elts;\n+                n = 0;\n+            }\n+\n+            if (oshm_zone[i].shm.name.len != shm_zone[n].shm.name.len) {\n+                continue;\n+            }\n+\n+            if (ngx_strncmp(oshm_zone[i].shm.name.data,\n+                            shm_zone[n].shm.name.data,\n+                            oshm_zone[i].shm.name.len)\n+                != 0)\n+            {\n+                continue;\n+            }\n+\n+            if (oshm_zone[i].tag == shm_zone[n].tag\n+                && oshm_zone[i].shm.size == shm_zone[n].shm.size\n+                && !oshm_zone[i].noreuse)\n+            {\n+                goto live_shm_zone;\n+            }\n+\n+            break;\n+        }\n+\n+        ngx_shm_free(&oshm_zone[i].shm);\n+\n+    live_shm_zone:\n+\n+        continue;\n+    }\n+\n+old_shm_zone_done:\n+\n+\n+    /* close the unnecessary listening sockets */\n+\n+    ls = old_cycle->listening.elts;\n+    for (i = 0; i < old_cycle->listening.nelts; i++) {\n+\n+        if (ls[i].remain || ls[i].fd == (ngx_socket_t) -1) {\n+            continue;\n+        }\n+\n+        if (ngx_close_socket(ls[i].fd) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                          ngx_close_socket_n \" listening socket on %V failed\",\n+                          &ls[i].addr_text);\n+        }\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+\n+        if (ls[i].sockaddr->sa_family == AF_UNIX) {\n+            u_char  *name;\n+\n+            name = ls[i].addr_text.data + sizeof(\"unix:\") - 1;\n+\n+            ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n+                          \"deleting socket %s\", name);\n+\n+            if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n+                              ngx_delete_file_n \" %s failed\", name);\n+            }\n+        }\n+\n+#endif\n+    }\n+\n+\n+    /* close the unnecessary open files */\n+\n+    part = &old_cycle->open_files.part;\n+    file = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            file = part->elts;\n+            i = 0;\n+        }\n+\n+        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {\n+            continue;\n+        }\n+\n+        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                          ngx_close_file_n \" \\\"%s\\\" failed\",\n+                          file[i].name.data);\n+        }\n+    }\n+\n+    ngx_destroy_pool(conf.temp_pool);\n+\n+    if (ngx_process == NGX_PROCESS_MASTER || ngx_is_init_cycle(old_cycle)) {\n+\n+        ngx_destroy_pool(old_cycle->pool);\n+        cycle->old_cycle = NULL;\n+\n+        return cycle;\n+    }\n+\n+\n+    if (ngx_temp_pool == NULL) {\n+        ngx_temp_pool = ngx_create_pool(128, cycle->log);\n+        if (ngx_temp_pool == NULL) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n+                          \"could not create ngx_temp_pool\");\n+            exit(1);\n+        }\n+\n+        n = 10;\n+\n+        if (ngx_array_init(&ngx_old_cycles, ngx_temp_pool, n,\n+                           sizeof(ngx_cycle_t *))\n+            != NGX_OK)\n+        {\n+            exit(1);\n+        }\n+\n+        ngx_memzero(ngx_old_cycles.elts, n * sizeof(ngx_cycle_t *));\n+\n+        ngx_cleaner_event.handler = ngx_clean_old_cycles;\n+        ngx_cleaner_event.log = cycle->log;\n+        ngx_cleaner_event.data = &dumb;\n+        dumb.fd = (ngx_socket_t) -1;\n+    }\n+\n+    ngx_temp_pool->log = cycle->log;\n+\n+    old = ngx_array_push(&ngx_old_cycles);\n+    if (old == NULL) {\n+        exit(1);\n+    }\n+    *old = old_cycle;\n+\n+    if (!ngx_cleaner_event.timer_set) {\n+        ngx_add_timer(&ngx_cleaner_event, 30000);\n+        ngx_cleaner_event.timer_set = 1;\n+    }\n+\n+    return cycle;\n+\n+\n+failed:\n+\n+    if (!ngx_is_init_cycle(old_cycle)) {\n+        old_ccf = (ngx_core_conf_t *) ngx_get_conf(old_cycle->conf_ctx,\n+                                                   ngx_core_module);\n+        if (old_ccf->environment) {\n+            environ = old_ccf->environment;\n+        }\n+    }\n+\n+    /* rollback the new cycle configuration */\n+\n+    part = &cycle->open_files.part;\n+    file = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            file = part->elts;\n+            i = 0;\n+        }\n+\n+        if (file[i].fd == NGX_INVALID_FILE || file[i].fd == ngx_stderr) {\n+            continue;\n+        }\n+\n+        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                          ngx_close_file_n \" \\\"%s\\\" failed\",\n+                          file[i].name.data);\n+        }\n+    }\n+\n+    /* free the newly created shared memory */\n+\n+    part = &cycle->shared_memory.part;\n+    shm_zone = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            shm_zone = part->elts;\n+            i = 0;\n+        }\n+\n+        if (shm_zone[i].shm.addr == NULL) {\n+            continue;\n+        }\n+\n+        opart = &old_cycle->shared_memory.part;\n+        oshm_zone = opart->elts;\n+\n+        for (n = 0; /* void */ ; n++) {\n+\n+            if (n >= opart->nelts) {\n+                if (opart->next == NULL) {\n+                    break;\n+                }\n+                opart = opart->next;\n+                oshm_zone = opart->elts;\n+                n = 0;\n+            }\n+\n+            if (shm_zone[i].shm.name.len != oshm_zone[n].shm.name.len) {\n+                continue;\n+            }\n+\n+            if (ngx_strncmp(shm_zone[i].shm.name.data,\n+                            oshm_zone[n].shm.name.data,\n+                            shm_zone[i].shm.name.len)\n+                != 0)\n+            {\n+                continue;\n+            }\n+\n+            if (shm_zone[i].tag == oshm_zone[n].tag\n+                && shm_zone[i].shm.size == oshm_zone[n].shm.size\n+                && !shm_zone[i].noreuse)\n+            {\n+                goto old_shm_zone_found;\n+            }\n+\n+            break;\n+        }\n+\n+        ngx_shm_free(&shm_zone[i].shm);\n+\n+    old_shm_zone_found:\n+\n+        continue;\n+    }\n+\n+    if (ngx_test_config) {\n+        ngx_destroy_cycle_pools(&conf);\n+        return NULL;\n+    }\n+\n+    ls = cycle->listening.elts;\n+    for (i = 0; i < cycle->listening.nelts; i++) {\n+        if (ls[i].fd == (ngx_socket_t) -1 || !ls[i].open) {\n+            continue;\n+        }\n+\n+        if (ngx_close_socket(ls[i].fd) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                          ngx_close_socket_n \" %V failed\",\n+                          &ls[i].addr_text);\n+        }\n+    }\n+\n+    ngx_destroy_cycle_pools(&conf);\n+\n+    return NULL;\n+}\n+\n+\n+static void\n+ngx_destroy_cycle_pools(ngx_conf_t *conf)\n+{\n+    ngx_destroy_pool(conf->temp_pool);\n+    ngx_destroy_pool(conf->pool);\n+}\n+\n+\n+static ngx_int_t\n+ngx_init_zone_pool(ngx_cycle_t *cycle, ngx_shm_zone_t *zn)\n+{\n+    u_char           *file;\n+    ngx_slab_pool_t  *sp;\n+\n+    sp = (ngx_slab_pool_t *) zn->shm.addr;\n+\n+    if (zn->shm.exists) {\n+\n+        if (sp == sp->addr) {\n+            return NGX_OK;\n+        }\n+\n+#if (NGX_WIN32)\n+\n+        /* remap at the required address */\n+\n+        if (ngx_shm_remap(&zn->shm, sp->addr) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        sp = (ngx_slab_pool_t *) zn->shm.addr;\n+\n+        if (sp == sp->addr) {\n+            return NGX_OK;\n+        }\n+\n+#endif\n+\n+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n+                      \"shared zone \\\"%V\\\" has no equal addresses: %p vs %p\",\n+                      &zn->shm.name, sp->addr, sp);\n+        return NGX_ERROR;\n+    }\n+\n+    sp->end = zn->shm.addr + zn->shm.size;\n+    sp->min_shift = 3;\n+    sp->addr = zn->shm.addr;\n+\n+#if (NGX_HAVE_ATOMIC_OPS)\n+\n+    file = NULL;\n+\n+#else\n+\n+    file = ngx_pnalloc(cycle->pool,\n+                       cycle->lock_file.len + zn->shm.name.len + 1);\n+    if (file == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    (void) ngx_sprintf(file, \"%V%V%Z\", &cycle->lock_file, &zn->shm.name);\n+\n+#endif\n+\n+    if (ngx_shmtx_create(&sp->mutex, &sp->lock, file) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_slab_init(sp);\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n+{\n+    size_t      len;\n+    ngx_uint_t  create;\n+    ngx_file_t  file;\n+    u_char      pid[NGX_INT64_LEN + 2];\n+\n+    if (ngx_process > NGX_PROCESS_MASTER) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_memzero(&file, sizeof(ngx_file_t));\n+\n+    file.name = *name;\n+    file.log = log;\n+\n+    create = ngx_test_config ? NGX_FILE_CREATE_OR_OPEN : NGX_FILE_TRUNCATE;\n+\n+    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDWR,\n+                            create, NGX_FILE_DEFAULT_ACCESS);\n+\n+    if (file.fd == NGX_INVALID_FILE) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                      ngx_open_file_n \" \\\"%s\\\" failed\", file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    if (!ngx_test_config) {\n+        len = ngx_snprintf(pid, NGX_INT64_LEN + 2, \"%P%N\", ngx_pid) - pid;\n+\n+        if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", file.name.data);\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_delete_pidfile(ngx_cycle_t *cycle)\n+{\n+    u_char           *name;\n+    ngx_core_conf_t  *ccf;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    name = ngx_new_binary ? ccf->oldpid.data : ccf->pid.data;\n+\n+    if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      ngx_delete_file_n \" \\\"%s\\\" failed\", name);\n+    }\n+}\n+\n+\n+ngx_int_t\n+ngx_signal_process(ngx_cycle_t *cycle, char *sig)\n+{\n+    ssize_t           n;\n+    ngx_pid_t         pid;\n+    ngx_file_t        file;\n+    ngx_core_conf_t  *ccf;\n+    u_char            buf[NGX_INT64_LEN + 2];\n+\n+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"signal process started\");\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    ngx_memzero(&file, sizeof(ngx_file_t));\n+\n+    file.name = ccf->pid;\n+    file.log = cycle->log;\n+\n+    file.fd = ngx_open_file(file.name.data, NGX_FILE_RDONLY,\n+                            NGX_FILE_OPEN, NGX_FILE_DEFAULT_ACCESS);\n+\n+    if (file.fd == NGX_INVALID_FILE) {\n+        ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_errno,\n+                      ngx_open_file_n \" \\\"%s\\\" failed\", file.name.data);\n+        return 1;\n+    }\n+\n+    n = ngx_read_file(&file, buf, NGX_INT64_LEN + 2, 0);\n+\n+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", file.name.data);\n+    }\n+\n+    if (n == NGX_ERROR) {\n+        return 1;\n+    }\n+\n+    while (n-- && (buf[n] == CR || buf[n] == LF)) { /* void */ }\n+\n+    pid = ngx_atoi(buf, ++n);\n+\n+    if (pid == (ngx_pid_t) NGX_ERROR) {\n+        ngx_log_error(NGX_LOG_ERR, cycle->log, 0,\n+                      \"invalid PID number \\\"%*s\\\" in \\\"%s\\\"\",\n+                      n, buf, file.name.data);\n+        return 1;\n+    }\n+\n+    return ngx_os_signal_process(cycle, sig, pid);\n+\n+}\n+\n+\n+static ngx_int_t\n+ngx_test_lockfile(u_char *file, ngx_log_t *log)\n+{\n+#if !(NGX_HAVE_ATOMIC_OPS)\n+    ngx_fd_t  fd;\n+\n+    fd = ngx_open_file(file, NGX_FILE_RDWR, NGX_FILE_CREATE_OR_OPEN,\n+                       NGX_FILE_DEFAULT_ACCESS);\n+\n+    if (fd == NGX_INVALID_FILE) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                      ngx_open_file_n \" \\\"%s\\\" failed\", file);\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", file);\n+    }\n+\n+    if (ngx_delete_file(file) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      ngx_delete_file_n \" \\\"%s\\\" failed\", file);\n+    }\n+\n+#endif\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user)\n+{\n+    ngx_fd_t          fd;\n+    ngx_uint_t        i;\n+    ngx_list_part_t  *part;\n+    ngx_open_file_t  *file;\n+\n+    part = &cycle->open_files.part;\n+    file = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            file = part->elts;\n+            i = 0;\n+        }\n+\n+        if (file[i].name.len == 0) {\n+            continue;\n+        }\n+\n+        if (file[i].flush) {\n+            file[i].flush(&file[i], cycle->log);\n+        }\n+\n+        fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND,\n+                           NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS);\n+\n+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                       \"reopen file \\\"%s\\\", old:%d new:%d\",\n+                       file[i].name.data, file[i].fd, fd);\n+\n+        if (fd == NGX_INVALID_FILE) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          ngx_open_file_n \" \\\"%s\\\" failed\", file[i].name.data);\n+            continue;\n+        }\n+\n+#if !(NGX_WIN32)\n+        if (user != (ngx_uid_t) NGX_CONF_UNSET_UINT) {\n+            ngx_file_info_t  fi;\n+\n+            if (ngx_file_info(file[i].name.data, &fi) == NGX_FILE_ERROR) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                              ngx_file_info_n \" \\\"%s\\\" failed\",\n+                              file[i].name.data);\n+\n+                if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                  ngx_close_file_n \" \\\"%s\\\" failed\",\n+                                  file[i].name.data);\n+                }\n+\n+                continue;\n+            }\n+\n+            if (fi.st_uid != user) {\n+                if (chown((const char *) file[i].name.data, user, -1) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                  \"chown(\\\"%s\\\", %d) failed\",\n+                                  file[i].name.data, user);\n+\n+                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n+                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                      ngx_close_file_n \" \\\"%s\\\" failed\",\n+                                      file[i].name.data);\n+                    }\n+\n+                    continue;\n+                }\n+            }\n+\n+            if ((fi.st_mode & (S_IRUSR|S_IWUSR)) != (S_IRUSR|S_IWUSR)) {\n+\n+                fi.st_mode |= (S_IRUSR|S_IWUSR);\n+\n+                if (chmod((const char *) file[i].name.data, fi.st_mode) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                  \"chmod() \\\"%s\\\" failed\", file[i].name.data);\n+\n+                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n+                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                                      ngx_close_file_n \" \\\"%s\\\" failed\",\n+                                      file[i].name.data);\n+                    }\n+\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          \"fcntl(FD_CLOEXEC) \\\"%s\\\" failed\",\n+                          file[i].name.data);\n+\n+            if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                              ngx_close_file_n \" \\\"%s\\\" failed\",\n+                              file[i].name.data);\n+            }\n+\n+            continue;\n+        }\n+#endif\n+\n+        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          ngx_close_file_n \" \\\"%s\\\" failed\",\n+                          file[i].name.data);\n+        }\n+\n+        file[i].fd = fd;\n+    }\n+\n+    (void) ngx_log_redirect_stderr(cycle);\n+}\n+\n+\n+ngx_shm_zone_t *\n+ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name, size_t size, void *tag)\n+{\n+    ngx_uint_t        i;\n+    ngx_shm_zone_t   *shm_zone;\n+    ngx_list_part_t  *part;\n+\n+    part = &cf->cycle->shared_memory.part;\n+    shm_zone = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            shm_zone = part->elts;\n+            i = 0;\n+        }\n+\n+        if (name->len != shm_zone[i].shm.name.len) {\n+            continue;\n+        }\n+\n+        if (ngx_strncmp(name->data, shm_zone[i].shm.name.data, name->len)\n+            != 0)\n+        {\n+            continue;\n+        }\n+\n+        if (tag != shm_zone[i].tag) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                            \"the shared memory zone \\\"%V\\\" is \"\n+                            \"already declared for a different use\",\n+                            &shm_zone[i].shm.name);\n+            return NULL;\n+        }\n+\n+        if (shm_zone[i].shm.size == 0) {\n+            shm_zone[i].shm.size = size;\n+        }\n+\n+        if (size && size != shm_zone[i].shm.size) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                            \"the size %uz of shared memory zone \\\"%V\\\" \"\n+                            \"conflicts with already declared size %uz\",\n+                            size, &shm_zone[i].shm.name, shm_zone[i].shm.size);\n+            return NULL;\n+        }\n+\n+        return &shm_zone[i];\n+    }\n+\n+    shm_zone = ngx_list_push(&cf->cycle->shared_memory);\n+\n+    if (shm_zone == NULL) {\n+        return NULL;\n+    }\n+\n+    shm_zone->data = NULL;\n+    shm_zone->shm.log = cf->cycle->log;\n+    shm_zone->shm.addr = NULL;\n+    shm_zone->shm.size = size;\n+    shm_zone->shm.name = *name;\n+    shm_zone->shm.exists = 0;\n+    shm_zone->init = NULL;\n+    shm_zone->tag = tag;\n+    shm_zone->noreuse = 0;\n+\n+    return shm_zone;\n+}\n+\n+\n+static void\n+ngx_clean_old_cycles(ngx_event_t *ev)\n+{\n+    ngx_uint_t     i, n, found, live;\n+    ngx_log_t     *log;\n+    ngx_cycle_t  **cycle;\n+\n+    log = ngx_cycle->log;\n+    ngx_temp_pool->log = log;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, \"clean old cycles\");\n+\n+    live = 0;\n+\n+    cycle = ngx_old_cycles.elts;\n+    for (i = 0; i < ngx_old_cycles.nelts; i++) {\n+\n+        if (cycle[i] == NULL) {\n+            continue;\n+        }\n+\n+        found = 0;\n+\n+        for (n = 0; n < cycle[i]->connection_n; n++) {\n+            if (cycle[i]->connections[n].fd != (ngx_socket_t) -1) {\n+                found = 1;\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, \"live fd:%ui\", n);\n+\n+                break;\n+            }\n+        }\n+\n+        if (found) {\n+            live = 1;\n+            continue;\n+        }\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, \"clean old cycle: %ui\", i);\n+\n+        ngx_destroy_pool(cycle[i]->pool);\n+        cycle[i] = NULL;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, log, 0, \"old cycles status: %ui\", live);\n+\n+    if (live) {\n+        ngx_add_timer(ev, 30000);\n+\n+    } else {\n+        ngx_destroy_pool(ngx_temp_pool);\n+        ngx_temp_pool = NULL;\n+        ngx_old_cycles.nelts = 0;\n+    }\n+}\n+\n+\n+void\n+ngx_set_shutdown_timer(ngx_cycle_t *cycle)\n+{\n+    ngx_core_conf_t  *ccf;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (ccf->shutdown_timeout) {\n+        ngx_shutdown_event.handler = ngx_shutdown_timer_handler;\n+        ngx_shutdown_event.data = cycle;\n+        ngx_shutdown_event.log = cycle->log;\n+        ngx_shutdown_event.cancelable = 1;\n+\n+        ngx_add_timer(&ngx_shutdown_event, ccf->shutdown_timeout);\n+    }\n+}\n+\n+\n+static void\n+ngx_shutdown_timer_handler(ngx_event_t *ev)\n+{\n+    ngx_uint_t         i;\n+    ngx_cycle_t       *cycle;\n+    ngx_connection_t  *c;\n+\n+    cycle = ev->data;\n+\n+    c = cycle->connections;\n+\n+    for (i = 0; i < cycle->connection_n; i++) {\n+\n+        if (c[i].fd == (ngx_socket_t) -1\n+            || c[i].read == NULL\n+            || c[i].read->accept\n+            || c[i].read->channel\n+            || c[i].read->resolver)\n+        {\n+            continue;\n+        }\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,\n+                       \"*%uA shutdown timeout\", c[i].number);\n+\n+        c[i].close = 1;\n+        c[i].error = 1;\n+\n+        c[i].read->handler(c[i].read);\n+    }\n+}\nDiff:\n@@ -0,0 +1,149 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CYCLE_H_INCLUDED_\n+#define _NGX_CYCLE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#ifndef NGX_CYCLE_POOL_SIZE\n+#define NGX_CYCLE_POOL_SIZE     NGX_DEFAULT_POOL_SIZE\n+#endif\n+\n+\n+#define NGX_DEBUG_POINTS_STOP   1\n+#define NGX_DEBUG_POINTS_ABORT  2\n+\n+\n+typedef struct ngx_shm_zone_s  ngx_shm_zone_t;\n+\n+typedef ngx_int_t (*ngx_shm_zone_init_pt) (ngx_shm_zone_t *zone, void *data);\n+\n+struct ngx_shm_zone_s {\n+    void                     *data;\n+    ngx_shm_t                 shm;\n+    ngx_shm_zone_init_pt      init;\n+    void                     *tag;\n+    void                     *sync;\n+    ngx_uint_t                noreuse;  /* unsigned  noreuse:1; */\n+};\n+\n+\n+struct ngx_cycle_s {\n+    void                  ****conf_ctx;\n+    ngx_pool_t               *pool;\n+\n+    ngx_log_t                *log;\n+    ngx_log_t                 new_log;\n+\n+    ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */\n+\n+    ngx_connection_t        **files;\n+    ngx_connection_t         *free_connections;\n+    ngx_uint_t                free_connection_n;\n+\n+    ngx_module_t            **modules;\n+    ngx_uint_t                modules_n;\n+    ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */\n+\n+    ngx_queue_t               reusable_connections_queue;\n+    ngx_uint_t                reusable_connections_n;\n+\n+    ngx_array_t               listening;\n+    ngx_array_t               paths;\n+\n+    ngx_array_t               config_dump;\n+    ngx_rbtree_t              config_dump_rbtree;\n+    ngx_rbtree_node_t         config_dump_sentinel;\n+\n+    ngx_list_t                open_files;\n+    ngx_list_t                shared_memory;\n+\n+    ngx_uint_t                connection_n;\n+    ngx_uint_t                files_n;\n+\n+    ngx_connection_t         *connections;\n+    ngx_event_t              *read_events;\n+    ngx_event_t              *write_events;\n+\n+    ngx_cycle_t              *old_cycle;\n+\n+    ngx_str_t                 conf_file;\n+    ngx_str_t                 conf_param;\n+    ngx_str_t                 conf_prefix;\n+    ngx_str_t                 prefix;\n+    ngx_str_t                 lock_file;\n+    ngx_str_t                 hostname;\n+};\n+\n+\n+typedef struct {\n+    ngx_flag_t                daemon;\n+    ngx_flag_t                master;\n+    ngx_flag_t                remote_admin;\n+    ngx_flag_t                trace_enable;\n+\n+    ngx_msec_t                timer_resolution;\n+    ngx_msec_t                shutdown_timeout;\n+\n+    ngx_int_t                 worker_processes;\n+    ngx_int_t                 debug_points;\n+\n+    ngx_int_t                 rlimit_nofile;\n+    off_t                     rlimit_core;\n+\n+    int                       priority;\n+\n+    ngx_uint_t                cpu_affinity_auto;\n+    ngx_uint_t                cpu_affinity_n;\n+    ngx_cpuset_t             *cpu_affinity;\n+\n+    char                     *username;\n+    ngx_uid_t                 user;\n+    ngx_gid_t                 group;\n+\n+    ngx_str_t                 working_directory;\n+    ngx_str_t                 lock_file;\n+\n+    ngx_str_t                 pid;\n+    ngx_str_t                 oldpid;\n+\n+    ngx_array_t               env;\n+    char                    **environment;\n+\n+    ngx_uint_t                transparent;  /* unsigned  transparent:1; */\n+} ngx_core_conf_t;\n+\n+\n+#define ngx_is_init_cycle(cycle)  (cycle->conf_ctx == NULL)\n+\n+\n+ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);\n+ngx_int_t ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log);\n+void ngx_delete_pidfile(ngx_cycle_t *cycle);\n+ngx_int_t ngx_signal_process(ngx_cycle_t *cycle, char *sig);\n+void ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user);\n+char **ngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last);\n+ngx_pid_t ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv);\n+ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n+ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n+    size_t size, void *tag);\n+void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+\n+\n+extern volatile ngx_cycle_t  *ngx_cycle;\n+extern ngx_array_t            ngx_old_cycles;\n+extern ngx_module_t           ngx_core_module;\n+extern ngx_uint_t             ngx_test_config;\n+extern ngx_uint_t             ngx_dump_config;\n+extern ngx_uint_t             ngx_quiet_mode;\n+\n+\n+#endif /* _NGX_CYCLE_H_INCLUDED_ */\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\n@@ -0,0 +1,1574 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_event_connect.h>\n+#include <ngx_mail.h>\n+\n+\n+typedef struct {\n+    ngx_addr_t                     *peer;\n+\n+    ngx_msec_t                      timeout;\n+    ngx_flag_t                      pass_client_cert;\n+\n+    ngx_str_t                       host_header;\n+    ngx_str_t                       uri;\n+    ngx_str_t                       header;\n+\n+    ngx_array_t                    *headers;\n+\n+    u_char                         *file;\n+    ngx_uint_t                      line;\n+} ngx_mail_auth_http_conf_t;\n+\n+\n+typedef struct ngx_mail_auth_http_ctx_s  ngx_mail_auth_http_ctx_t;\n+\n+typedef void (*ngx_mail_auth_http_handler_pt)(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx);\n+\n+struct ngx_mail_auth_http_ctx_s {\n+    ngx_buf_t                      *request;\n+    ngx_buf_t                      *response;\n+    ngx_peer_connection_t           peer;\n+\n+    ngx_mail_auth_http_handler_pt   handler;\n+\n+    ngx_uint_t                      state;\n+\n+    u_char                         *header_name_start;\n+    u_char                         *header_name_end;\n+    u_char                         *header_start;\n+    u_char                         *header_end;\n+\n+    ngx_str_t                       addr;\n+    ngx_str_t                       port;\n+    ngx_str_t                       err;\n+    ngx_str_t                       errmsg;\n+    ngx_str_t                       errcode;\n+\n+    time_t                          sleep;\n+\n+    ngx_pool_t                     *pool;\n+};\n+\n+\n+static void ngx_mail_auth_http_write_handler(ngx_event_t *wev);\n+static void ngx_mail_auth_http_read_handler(ngx_event_t *rev);\n+static void ngx_mail_auth_http_ignore_status_line(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx);\n+static void ngx_mail_auth_http_process_headers(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx);\n+static void ngx_mail_auth_sleep_handler(ngx_event_t *rev);\n+static ngx_int_t ngx_mail_auth_http_parse_header_line(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx);\n+static void ngx_mail_auth_http_block_read(ngx_event_t *rev);\n+static void ngx_mail_auth_http_dummy_handler(ngx_event_t *ev);\n+static ngx_buf_t *ngx_mail_auth_http_create_request(ngx_mail_session_t *s,\n+    ngx_pool_t *pool, ngx_mail_auth_http_conf_t *ahcf);\n+static ngx_int_t ngx_mail_auth_http_escape(ngx_pool_t *pool, ngx_str_t *text,\n+    ngx_str_t *escaped);\n+\n+static void *ngx_mail_auth_http_create_conf(ngx_conf_t *cf);\n+static char *ngx_mail_auth_http_merge_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+static char *ngx_mail_auth_http(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+static char *ngx_mail_auth_http_header(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+\n+\n+static ngx_command_t  ngx_mail_auth_http_commands[] = {\n+\n+    { ngx_string(\"auth_http\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_mail_auth_http,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"auth_http_timeout\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_auth_http_conf_t, timeout),\n+      NULL },\n+\n+    { ngx_string(\"auth_http_header\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_mail_auth_http_header,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"auth_http_pass_client_cert\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_auth_http_conf_t, pass_client_cert),\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_auth_http_module_ctx = {\n+    NULL,                                  /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_auth_http_create_conf,        /* create server configuration */\n+    ngx_mail_auth_http_merge_conf          /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_auth_http_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_auth_http_module_ctx,        /* module context */\n+    ngx_mail_auth_http_commands,           /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static ngx_str_t   ngx_mail_auth_http_method[] = {\n+    ngx_string(\"plain\"),\n+    ngx_string(\"plain\"),\n+    ngx_string(\"plain\"),\n+    ngx_string(\"apop\"),\n+    ngx_string(\"cram-md5\"),\n+    ngx_string(\"external\"),\n+    ngx_string(\"none\")\n+};\n+\n+static ngx_str_t   ngx_mail_smtp_errcode = ngx_string(\"535 5.7.0\");\n+\n+\n+void\n+ngx_mail_auth_http_init(ngx_mail_session_t *s)\n+{\n+    ngx_int_t                   rc;\n+    ngx_pool_t                 *pool;\n+    ngx_mail_auth_http_ctx_t   *ctx;\n+    ngx_mail_auth_http_conf_t  *ahcf;\n+\n+    s->connection->log->action = \"in http auth state\";\n+\n+    pool = ngx_create_pool(2048, s->connection->log);\n+    if (pool == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    ctx = ngx_pcalloc(pool, sizeof(ngx_mail_auth_http_ctx_t));\n+    if (ctx == NULL) {\n+        ngx_destroy_pool(pool);\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    ctx->pool = pool;\n+\n+    ahcf = ngx_mail_get_module_srv_conf(s, ngx_mail_auth_http_module);\n+\n+    ctx->request = ngx_mail_auth_http_create_request(s, pool, ahcf);\n+    if (ctx->request == NULL) {\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    ngx_mail_set_ctx(s, ctx, ngx_mail_auth_http_module);\n+\n+    ctx->peer.sockaddr = ahcf->peer->sockaddr;\n+    ctx->peer.socklen = ahcf->peer->socklen;\n+    ctx->peer.name = &ahcf->peer->name;\n+    ctx->peer.get = ngx_event_get_peer;\n+    ctx->peer.log = s->connection->log;\n+    ctx->peer.log_error = NGX_ERROR_ERR;\n+\n+    rc = ngx_event_connect_peer(&ctx->peer);\n+\n+    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {\n+        if (ctx->peer.connection) {\n+            ngx_close_connection(ctx->peer.connection);\n+        }\n+\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    ctx->peer.connection->data = s;\n+    ctx->peer.connection->pool = s->connection->pool;\n+\n+    s->connection->read->handler = ngx_mail_auth_http_block_read;\n+    ctx->peer.connection->read->handler = ngx_mail_auth_http_read_handler;\n+    ctx->peer.connection->write->handler = ngx_mail_auth_http_write_handler;\n+\n+    ctx->handler = ngx_mail_auth_http_ignore_status_line;\n+\n+    ngx_add_timer(ctx->peer.connection->read, ahcf->timeout);\n+    ngx_add_timer(ctx->peer.connection->write, ahcf->timeout);\n+\n+    if (rc == NGX_OK) {\n+        ngx_mail_auth_http_write_handler(ctx->peer.connection->write);\n+        return;\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_auth_http_write_handler(ngx_event_t *wev)\n+{\n+    ssize_t                     n, size;\n+    ngx_connection_t           *c;\n+    ngx_mail_session_t         *s;\n+    ngx_mail_auth_http_ctx_t   *ctx;\n+    ngx_mail_auth_http_conf_t  *ahcf;\n+\n+    c = wev->data;\n+    s = c->data;\n+\n+    ctx = ngx_mail_get_module_ctx(s, ngx_mail_auth_http_module);\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0,\n+                   \"mail auth http write handler\");\n+\n+    if (wev->timedout) {\n+        ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,\n+                      \"auth http server %V timed out\", ctx->peer.name);\n+        ngx_close_connection(c);\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    size = ctx->request->last - ctx->request->pos;\n+\n+    n = ngx_send(c, ctx->request->pos, size);\n+\n+    if (n == NGX_ERROR) {\n+        ngx_close_connection(c);\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    if (n > 0) {\n+        ctx->request->pos += n;\n+\n+        if (n == size) {\n+            wev->handler = ngx_mail_auth_http_dummy_handler;\n+\n+            if (wev->timer_set) {\n+                ngx_del_timer(wev);\n+            }\n+\n+            if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n+                ngx_close_connection(c);\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+            }\n+\n+            return;\n+        }\n+    }\n+\n+    if (!wev->timer_set) {\n+        ahcf = ngx_mail_get_module_srv_conf(s, ngx_mail_auth_http_module);\n+        ngx_add_timer(wev, ahcf->timeout);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_auth_http_read_handler(ngx_event_t *rev)\n+{\n+    ssize_t                     n, size;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_auth_http_ctx_t  *ctx;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                   \"mail auth http read handler\");\n+\n+    ctx = ngx_mail_get_module_ctx(s, ngx_mail_auth_http_module);\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_ERR, rev->log, NGX_ETIMEDOUT,\n+                      \"auth http server %V timed out\", ctx->peer.name);\n+        ngx_close_connection(c);\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    if (ctx->response == NULL) {\n+        ctx->response = ngx_create_temp_buf(ctx->pool, 1024);\n+        if (ctx->response == NULL) {\n+            ngx_close_connection(c);\n+            ngx_destroy_pool(ctx->pool);\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+    }\n+\n+    size = ctx->response->end - ctx->response->last;\n+\n+    n = ngx_recv(c, ctx->response->pos, size);\n+\n+    if (n > 0) {\n+        ctx->response->last += n;\n+\n+        ctx->handler(s, ctx);\n+        return;\n+    }\n+\n+    if (n == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    ngx_close_connection(c);\n+    ngx_destroy_pool(ctx->pool);\n+    ngx_mail_session_internal_server_error(s);\n+}\n+\n+\n+static void\n+ngx_mail_auth_http_ignore_status_line(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx)\n+{\n+    u_char  *p, ch;\n+    enum  {\n+        sw_start = 0,\n+        sw_H,\n+        sw_HT,\n+        sw_HTT,\n+        sw_HTTP,\n+        sw_skip,\n+        sw_almost_done\n+    } state;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                   \"mail auth http process status line\");\n+\n+    state = ctx->state;\n+\n+    for (p = ctx->response->pos; p < ctx->response->last; p++) {\n+        ch = *p;\n+\n+        switch (state) {\n+\n+        /* \"HTTP/\" */\n+        case sw_start:\n+            if (ch == 'H') {\n+                state = sw_H;\n+                break;\n+            }\n+            goto next;\n+\n+        case sw_H:\n+            if (ch == 'T') {\n+                state = sw_HT;\n+                break;\n+            }\n+            goto next;\n+\n+        case sw_HT:\n+            if (ch == 'T') {\n+                state = sw_HTT;\n+                break;\n+            }\n+            goto next;\n+\n+        case sw_HTT:\n+            if (ch == 'P') {\n+                state = sw_HTTP;\n+                break;\n+            }\n+            goto next;\n+\n+        case sw_HTTP:\n+            if (ch == '/') {\n+                state = sw_skip;\n+                break;\n+            }\n+            goto next;\n+\n+        /* any text until end of line */\n+        case sw_skip:\n+            switch (ch) {\n+            case CR:\n+                state = sw_almost_done;\n+\n+                break;\n+            case LF:\n+                goto done;\n+            }\n+            break;\n+\n+        /* end of status line */\n+        case sw_almost_done:\n+            if (ch == LF) {\n+                goto done;\n+            }\n+\n+            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                          \"auth http server %V sent invalid response\",\n+                          ctx->peer.name);\n+            ngx_close_connection(ctx->peer.connection);\n+            ngx_destroy_pool(ctx->pool);\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+    }\n+\n+    ctx->response->pos = p;\n+    ctx->state = state;\n+\n+    return;\n+\n+next:\n+\n+    p = ctx->response->start - 1;\n+\n+done:\n+\n+    ctx->response->pos = p + 1;\n+    ctx->state = 0;\n+    ctx->handler = ngx_mail_auth_http_process_headers;\n+    ctx->handler(s, ctx);\n+}\n+\n+\n+static void\n+ngx_mail_auth_http_process_headers(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx)\n+{\n+    u_char      *p;\n+    time_t       timer;\n+    size_t       len, size;\n+    ngx_int_t    rc, port, n;\n+    ngx_addr_t  *peer;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                   \"mail auth http process headers\");\n+\n+    for ( ;; ) {\n+        rc = ngx_mail_auth_http_parse_header_line(s, ctx);\n+\n+        if (rc == NGX_OK) {\n+\n+#if (NGX_DEBUG)\n+            {\n+            ngx_str_t  key, value;\n+\n+            key.len = ctx->header_name_end - ctx->header_name_start;\n+            key.data = ctx->header_name_start;\n+            value.len = ctx->header_end - ctx->header_start;\n+            value.data = ctx->header_start;\n+\n+            ngx_log_debug2(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                           \"mail auth http header: \\\"%V: %V\\\"\",\n+                           &key, &value);\n+            }\n+#endif\n+\n+            len = ctx->header_name_end - ctx->header_name_start;\n+\n+            if (len == sizeof(\"Auth-Status\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-Status\",\n+                                   sizeof(\"Auth-Status\") - 1)\n+                   == 0)\n+            {\n+                len = ctx->header_end - ctx->header_start;\n+\n+                if (len == 2\n+                    && ctx->header_start[0] == 'O'\n+                    && ctx->header_start[1] == 'K')\n+                {\n+                    continue;\n+                }\n+\n+                if (len == 4\n+                    && ctx->header_start[0] == 'W'\n+                    && ctx->header_start[1] == 'A'\n+                    && ctx->header_start[2] == 'I'\n+                    && ctx->header_start[3] == 'T')\n+                {\n+                    s->auth_wait = 1;\n+                    continue;\n+                }\n+\n+                ctx->errmsg.len = len;\n+                ctx->errmsg.data = ctx->header_start;\n+\n+                switch (s->protocol) {\n+\n+                case NGX_MAIL_POP3_PROTOCOL:\n+                    size = sizeof(\"-ERR \") - 1 + len + sizeof(CRLF) - 1;\n+                    break;\n+\n+                case NGX_MAIL_IMAP_PROTOCOL:\n+                    size = s->tag.len + sizeof(\"NO \") - 1 + len\n+                           + sizeof(CRLF) - 1;\n+                    break;\n+\n+                default: /* NGX_MAIL_SMTP_PROTOCOL */\n+                    ctx->err = ctx->errmsg;\n+                    continue;\n+                }\n+\n+                p = ngx_pnalloc(s->connection->pool, size);\n+                if (p == NULL) {\n+                    ngx_close_connection(ctx->peer.connection);\n+                    ngx_destroy_pool(ctx->pool);\n+                    ngx_mail_session_internal_server_error(s);\n+                    return;\n+                }\n+\n+                ctx->err.data = p;\n+\n+                switch (s->protocol) {\n+\n+                case NGX_MAIL_POP3_PROTOCOL:\n+                    *p++ = '-'; *p++ = 'E'; *p++ = 'R'; *p++ = 'R'; *p++ = ' ';\n+                    break;\n+\n+                case NGX_MAIL_IMAP_PROTOCOL:\n+                    p = ngx_cpymem(p, s->tag.data, s->tag.len);\n+                    *p++ = 'N'; *p++ = 'O'; *p++ = ' ';\n+                    break;\n+\n+                default: /* NGX_MAIL_SMTP_PROTOCOL */\n+                    break;\n+                }\n+\n+                p = ngx_cpymem(p, ctx->header_start, len);\n+                *p++ = CR; *p++ = LF;\n+\n+                ctx->err.len = p - ctx->err.data;\n+\n+                continue;\n+            }\n+\n+            if (len == sizeof(\"Auth-Server\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-Server\",\n+                                   sizeof(\"Auth-Server\") - 1)\n+                    == 0)\n+            {\n+                ctx->addr.len = ctx->header_end - ctx->header_start;\n+                ctx->addr.data = ctx->header_start;\n+\n+                continue;\n+            }\n+\n+            if (len == sizeof(\"Auth-Port\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-Port\",\n+                                   sizeof(\"Auth-Port\") - 1)\n+                   == 0)\n+            {\n+                ctx->port.len = ctx->header_end - ctx->header_start;\n+                ctx->port.data = ctx->header_start;\n+\n+                continue;\n+            }\n+\n+            if (len == sizeof(\"Auth-User\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-User\",\n+                                   sizeof(\"Auth-User\") - 1)\n+                   == 0)\n+            {\n+                s->login.len = ctx->header_end - ctx->header_start;\n+\n+                s->login.data = ngx_pnalloc(s->connection->pool, s->login.len);\n+                if (s->login.data == NULL) {\n+                    ngx_close_connection(ctx->peer.connection);\n+                    ngx_destroy_pool(ctx->pool);\n+                    ngx_mail_session_internal_server_error(s);\n+                    return;\n+                }\n+\n+                ngx_memcpy(s->login.data, ctx->header_start, s->login.len);\n+\n+                continue;\n+            }\n+\n+            if (len == sizeof(\"Auth-Pass\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-Pass\",\n+                                   sizeof(\"Auth-Pass\") - 1)\n+                   == 0)\n+            {\n+                s->passwd.len = ctx->header_end - ctx->header_start;\n+\n+                s->passwd.data = ngx_pnalloc(s->connection->pool,\n+                                             s->passwd.len);\n+                if (s->passwd.data == NULL) {\n+                    ngx_close_connection(ctx->peer.connection);\n+                    ngx_destroy_pool(ctx->pool);\n+                    ngx_mail_session_internal_server_error(s);\n+                    return;\n+                }\n+\n+                ngx_memcpy(s->passwd.data, ctx->header_start, s->passwd.len);\n+\n+                continue;\n+            }\n+\n+            if (len == sizeof(\"Auth-Wait\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-Wait\",\n+                                   sizeof(\"Auth-Wait\") - 1)\n+                   == 0)\n+            {\n+                n = ngx_atoi(ctx->header_start,\n+                             ctx->header_end - ctx->header_start);\n+\n+                if (n != NGX_ERROR) {\n+                    ctx->sleep = n;\n+                }\n+\n+                continue;\n+            }\n+\n+            if (len == sizeof(\"Auth-Error-Code\") - 1\n+                && ngx_strncasecmp(ctx->header_name_start,\n+                                   (u_char *) \"Auth-Error-Code\",\n+                                   sizeof(\"Auth-Error-Code\") - 1)\n+                   == 0)\n+            {\n+                ctx->errcode.len = ctx->header_end - ctx->header_start;\n+\n+                ctx->errcode.data = ngx_pnalloc(s->connection->pool,\n+                                                ctx->errcode.len);\n+                if (ctx->errcode.data == NULL) {\n+                    ngx_close_connection(ctx->peer.connection);\n+                    ngx_destroy_pool(ctx->pool);\n+                    ngx_mail_session_internal_server_error(s);\n+                    return;\n+                }\n+\n+                ngx_memcpy(ctx->errcode.data, ctx->header_start,\n+                           ctx->errcode.len);\n+\n+                continue;\n+            }\n+\n+            /* ignore other headers */\n+\n+            continue;\n+        }\n+\n+        if (rc == NGX_DONE) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                           \"mail auth http header done\");\n+\n+            ngx_close_connection(ctx->peer.connection);\n+\n+            if (ctx->err.len) {\n+\n+                ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n+                              \"client login failed: \\\"%V\\\"\", &ctx->errmsg);\n+\n+                if (s->protocol == NGX_MAIL_SMTP_PROTOCOL) {\n+\n+                    if (ctx->errcode.len == 0) {\n+                        ctx->errcode = ngx_mail_smtp_errcode;\n+                    }\n+\n+                    ctx->err.len = ctx->errcode.len + ctx->errmsg.len\n+                                   + sizeof(\" \" CRLF) - 1;\n+\n+                    p = ngx_pnalloc(s->connection->pool, ctx->err.len);\n+                    if (p == NULL) {\n+                        ngx_destroy_pool(ctx->pool);\n+                        ngx_mail_session_internal_server_error(s);\n+                        return;\n+                    }\n+\n+                    ctx->err.data = p;\n+\n+                    p = ngx_cpymem(p, ctx->errcode.data, ctx->errcode.len);\n+                    *p++ = ' ';\n+                    p = ngx_cpymem(p, ctx->errmsg.data, ctx->errmsg.len);\n+                    *p++ = CR; *p = LF;\n+                }\n+\n+                s->out = ctx->err;\n+                timer = ctx->sleep;\n+\n+                ngx_destroy_pool(ctx->pool);\n+\n+                if (timer == 0) {\n+                    s->quit = 1;\n+                    ngx_mail_send(s->connection->write);\n+                    return;\n+                }\n+\n+                ngx_add_timer(s->connection->read, (ngx_msec_t) (timer * 1000));\n+\n+                s->connection->read->handler = ngx_mail_auth_sleep_handler;\n+\n+                return;\n+            }\n+\n+            if (s->auth_wait) {\n+                timer = ctx->sleep;\n+\n+                ngx_destroy_pool(ctx->pool);\n+\n+                if (timer == 0) {\n+                    ngx_mail_auth_http_init(s);\n+                    return;\n+                }\n+\n+                ngx_add_timer(s->connection->read, (ngx_msec_t) (timer * 1000));\n+\n+                s->connection->read->handler = ngx_mail_auth_sleep_handler;\n+\n+                return;\n+            }\n+\n+            if (ctx->addr.len == 0 || ctx->port.len == 0) {\n+                ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                              \"auth http server %V did not send server or port\",\n+                              ctx->peer.name);\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+                return;\n+            }\n+\n+            if (s->passwd.data == NULL\n+                && s->protocol != NGX_MAIL_SMTP_PROTOCOL)\n+            {\n+                ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                              \"auth http server %V did not send password\",\n+                              ctx->peer.name);\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+                return;\n+            }\n+\n+            peer = ngx_pcalloc(s->connection->pool, sizeof(ngx_addr_t));\n+            if (peer == NULL) {\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+                return;\n+            }\n+\n+            rc = ngx_parse_addr(s->connection->pool, peer,\n+                                ctx->addr.data, ctx->addr.len);\n+\n+            switch (rc) {\n+            case NGX_OK:\n+                break;\n+\n+            case NGX_DECLINED:\n+                ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                              \"auth http server %V sent invalid server \"\n+                              \"address:\\\"%V\\\"\",\n+                              ctx->peer.name, &ctx->addr);\n+                /* fall through */\n+\n+            default:\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+                return;\n+            }\n+\n+            port = ngx_atoi(ctx->port.data, ctx->port.len);\n+            if (port == NGX_ERROR || port < 1 || port > 65535) {\n+                ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                              \"auth http server %V sent invalid server \"\n+                              \"port:\\\"%V\\\"\",\n+                              ctx->peer.name, &ctx->port);\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+                return;\n+            }\n+\n+            ngx_inet_set_port(peer->sockaddr, (in_port_t) port);\n+\n+            len = ctx->addr.len + 1 + ctx->port.len;\n+\n+            peer->name.len = len;\n+\n+            peer->name.data = ngx_pnalloc(s->connection->pool, len);\n+            if (peer->name.data == NULL) {\n+                ngx_destroy_pool(ctx->pool);\n+                ngx_mail_session_internal_server_error(s);\n+                return;\n+            }\n+\n+            len = ctx->addr.len;\n+\n+            ngx_memcpy(peer->name.data, ctx->addr.data, len);\n+\n+            peer->name.data[len++] = ':';\n+\n+            ngx_memcpy(peer->name.data + len, ctx->port.data, ctx->port.len);\n+\n+            ngx_destroy_pool(ctx->pool);\n+            ngx_mail_proxy_init(s, peer);\n+\n+            return;\n+        }\n+\n+        if (rc == NGX_AGAIN ) {\n+            return;\n+        }\n+\n+        /* rc == NGX_ERROR */\n+\n+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                      \"auth http server %V sent invalid header in response\",\n+                      ctx->peer.name);\n+        ngx_close_connection(ctx->peer.connection);\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+\n+        return;\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_auth_sleep_handler(ngx_event_t *rev)\n+{\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, \"mail auth sleep handler\");\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    if (rev->timedout) {\n+\n+        rev->timedout = 0;\n+\n+        if (s->auth_wait) {\n+            s->auth_wait = 0;\n+            ngx_mail_auth_http_init(s);\n+            return;\n+        }\n+\n+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+        rev->handler = cscf->protocol->auth_state;\n+\n+        s->mail_state = 0;\n+        s->auth_method = NGX_MAIL_AUTH_PLAIN;\n+\n+        c->log->action = \"in auth state\";\n+\n+        ngx_mail_send(c->write);\n+\n+        if (c->destroyed) {\n+            return;\n+        }\n+\n+        ngx_add_timer(rev, cscf->timeout);\n+\n+        if (rev->ready) {\n+            rev->handler(rev);\n+            return;\n+        }\n+\n+        if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+        }\n+\n+        return;\n+    }\n+\n+    if (rev->active) {\n+        if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+        }\n+    }\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_auth_http_parse_header_line(ngx_mail_session_t *s,\n+    ngx_mail_auth_http_ctx_t *ctx)\n+{\n+    u_char      c, ch, *p;\n+    enum {\n+        sw_start = 0,\n+        sw_name,\n+        sw_space_before_value,\n+        sw_value,\n+        sw_space_after_value,\n+        sw_almost_done,\n+        sw_header_almost_done\n+    } state;\n+\n+    state = ctx->state;\n+\n+    for (p = ctx->response->pos; p < ctx->response->last; p++) {\n+        ch = *p;\n+\n+        switch (state) {\n+\n+        /* first char */\n+        case sw_start:\n+\n+            switch (ch) {\n+            case CR:\n+                ctx->header_end = p;\n+                state = sw_header_almost_done;\n+                break;\n+            case LF:\n+                ctx->header_end = p;\n+                goto header_done;\n+            default:\n+                state = sw_name;\n+                ctx->header_name_start = p;\n+\n+                c = (u_char) (ch | 0x20);\n+                if (c >= 'a' && c <= 'z') {\n+                    break;\n+                }\n+\n+                if (ch >= '0' && ch <= '9') {\n+                    break;\n+                }\n+\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        /* header name */\n+        case sw_name:\n+            c = (u_char) (ch | 0x20);\n+            if (c >= 'a' && c <= 'z') {\n+                break;\n+            }\n+\n+            if (ch == ':') {\n+                ctx->header_name_end = p;\n+                state = sw_space_before_value;\n+                break;\n+            }\n+\n+            if (ch == '-') {\n+                break;\n+            }\n+\n+            if (ch >= '0' && ch <= '9') {\n+                break;\n+            }\n+\n+            if (ch == CR) {\n+                ctx->header_name_end = p;\n+                ctx->header_start = p;\n+                ctx->header_end = p;\n+                state = sw_almost_done;\n+                break;\n+            }\n+\n+            if (ch == LF) {\n+                ctx->header_name_end = p;\n+                ctx->header_start = p;\n+                ctx->header_end = p;\n+                goto done;\n+            }\n+\n+            return NGX_ERROR;\n+\n+        /* space* before header value */\n+        case sw_space_before_value:\n+            switch (ch) {\n+            case ' ':\n+                break;\n+            case CR:\n+                ctx->header_start = p;\n+                ctx->header_end = p;\n+                state = sw_almost_done;\n+                break;\n+            case LF:\n+                ctx->header_start = p;\n+                ctx->header_end = p;\n+                goto done;\n+            default:\n+                ctx->header_start = p;\n+                state = sw_value;\n+                break;\n+            }\n+            break;\n+\n+        /* header value */\n+        case sw_value:\n+            switch (ch) {\n+            case ' ':\n+                ctx->header_end = p;\n+                state = sw_space_after_value;\n+                break;\n+            case CR:\n+                ctx->header_end = p;\n+                state = sw_almost_done;\n+                break;\n+            case LF:\n+                ctx->header_end = p;\n+                goto done;\n+            }\n+            break;\n+\n+        /* space* before end of header line */\n+        case sw_space_after_value:\n+            switch (ch) {\n+            case ' ':\n+                break;\n+            case CR:\n+                state = sw_almost_done;\n+                break;\n+            case LF:\n+                goto done;\n+            default:\n+                state = sw_value;\n+                break;\n+            }\n+            break;\n+\n+        /* end of header line */\n+        case sw_almost_done:\n+            switch (ch) {\n+            case LF:\n+                goto done;\n+            default:\n+                return NGX_ERROR;\n+            }\n+\n+        /* end of header */\n+        case sw_header_almost_done:\n+            switch (ch) {\n+            case LF:\n+                goto header_done;\n+            default:\n+                return NGX_ERROR;\n+            }\n+        }\n+    }\n+\n+    ctx->response->pos = p;\n+    ctx->state = state;\n+\n+    return NGX_AGAIN;\n+\n+done:\n+\n+    ctx->response->pos = p + 1;\n+    ctx->state = sw_start;\n+\n+    return NGX_OK;\n+\n+header_done:\n+\n+    ctx->response->pos = p + 1;\n+    ctx->state = sw_start;\n+\n+    return NGX_DONE;\n+}\n+\n+\n+static void\n+ngx_mail_auth_http_block_read(ngx_event_t *rev)\n+{\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_auth_http_ctx_t  *ctx;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                   \"mail auth http block read\");\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        c = rev->data;\n+        s = c->data;\n+\n+        ctx = ngx_mail_get_module_ctx(s, ngx_mail_auth_http_module);\n+\n+        ngx_close_connection(ctx->peer.connection);\n+        ngx_destroy_pool(ctx->pool);\n+        ngx_mail_session_internal_server_error(s);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_auth_http_dummy_handler(ngx_event_t *ev)\n+{\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, ev->log, 0,\n+                   \"mail auth http dummy handler\");\n+}\n+\n+\n+static ngx_buf_t *\n+ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n+    ngx_mail_auth_http_conf_t *ahcf)\n+{\n+    size_t                     len;\n+    ngx_buf_t                 *b;\n+    ngx_str_t                  login, passwd;\n+#if (NGX_MAIL_SSL)\n+    ngx_str_t                  verify, subject, issuer, serial, fingerprint,\n+                               raw_cert, cert;\n+    ngx_connection_t          *c;\n+    ngx_mail_ssl_conf_t       *sslcf;\n+#endif\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    if (ngx_mail_auth_http_escape(pool, &s->login, &login) != NGX_OK) {\n+        return NULL;\n+    }\n+\n+    if (ngx_mail_auth_http_escape(pool, &s->passwd, &passwd) != NGX_OK) {\n+        return NULL;\n+    }\n+\n+#if (NGX_MAIL_SSL)\n+\n+    c = s->connection;\n+    sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+    if (c->ssl && sslcf->verify) {\n+\n+        /* certificate details */\n+\n+        if (ngx_ssl_get_client_verify(c, pool, &verify) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        if (ngx_ssl_get_subject_dn(c, pool, &subject) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        if (ngx_ssl_get_issuer_dn(c, pool, &issuer) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        if (ngx_ssl_get_serial_number(c, pool, &serial) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        if (ngx_ssl_get_fingerprint(c, pool, &fingerprint) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        if (ahcf->pass_client_cert) {\n+\n+            /* certificate itself, if configured */\n+\n+            if (ngx_ssl_get_raw_certificate(c, pool, &raw_cert) != NGX_OK) {\n+                return NULL;\n+            }\n+\n+            if (ngx_mail_auth_http_escape(pool, &raw_cert, &cert) != NGX_OK) {\n+                return NULL;\n+            }\n+\n+        } else {\n+            ngx_str_null(&cert);\n+        }\n+\n+    } else {\n+        ngx_str_null(&verify);\n+        ngx_str_null(&subject);\n+        ngx_str_null(&issuer);\n+        ngx_str_null(&serial);\n+        ngx_str_null(&fingerprint);\n+        ngx_str_null(&cert);\n+    }\n+\n+#endif\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    len = sizeof(\"GET \") - 1 + ahcf->uri.len + sizeof(\" HTTP/1.0\" CRLF) - 1\n+          + sizeof(\"Host: \") - 1 + ahcf->host_header.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-Method: \") - 1\n+                + ngx_mail_auth_http_method[s->auth_method].len\n+                + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-User: \") - 1 + login.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-Pass: \") - 1 + passwd.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-Salt: \") - 1 + s->salt.len\n+          + sizeof(\"Auth-Protocol: \") - 1 + cscf->protocol->name.len\n+                + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-Login-Attempt: \") - 1 + NGX_INT_T_LEN\n+                + sizeof(CRLF) - 1\n+          + sizeof(\"Client-IP: \") - 1 + s->connection->addr_text.len\n+                + sizeof(CRLF) - 1\n+          + sizeof(\"Client-Host: \") - 1 + s->host.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SMTP-From: \") - 1 + s->smtp_from.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SMTP-To: \") - 1 + s->smtp_to.len + sizeof(CRLF) - 1\n+#if (NGX_MAIL_SSL)\n+          + sizeof(\"Auth-SSL: on\" CRLF) - 1\n+          + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SSL-Issuer: \") - 1 + issuer.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SSL-Serial: \") - 1 + serial.len + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SSL-Fingerprint: \") - 1 + fingerprint.len\n+              + sizeof(CRLF) - 1\n+          + sizeof(\"Auth-SSL-Cert: \") - 1 + cert.len + sizeof(CRLF) - 1\n+#endif\n+          + ahcf->header.len\n+          + sizeof(CRLF) - 1;\n+\n+    b = ngx_create_temp_buf(pool, len);\n+    if (b == NULL) {\n+        return NULL;\n+    }\n+\n+    b->last = ngx_cpymem(b->last, \"GET \", sizeof(\"GET \") - 1);\n+    b->last = ngx_copy(b->last, ahcf->uri.data, ahcf->uri.len);\n+    b->last = ngx_cpymem(b->last, \" HTTP/1.0\" CRLF,\n+                         sizeof(\" HTTP/1.0\" CRLF) - 1);\n+\n+    b->last = ngx_cpymem(b->last, \"Host: \", sizeof(\"Host: \") - 1);\n+    b->last = ngx_copy(b->last, ahcf->host_header.data,\n+                         ahcf->host_header.len);\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+    b->last = ngx_cpymem(b->last, \"Auth-Method: \",\n+                         sizeof(\"Auth-Method: \") - 1);\n+    b->last = ngx_cpymem(b->last,\n+                         ngx_mail_auth_http_method[s->auth_method].data,\n+                         ngx_mail_auth_http_method[s->auth_method].len);\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+    b->last = ngx_cpymem(b->last, \"Auth-User: \", sizeof(\"Auth-User: \") - 1);\n+    b->last = ngx_copy(b->last, login.data, login.len);\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+    b->last = ngx_cpymem(b->last, \"Auth-Pass: \", sizeof(\"Auth-Pass: \") - 1);\n+    b->last = ngx_copy(b->last, passwd.data, passwd.len);\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+    if (s->auth_method != NGX_MAIL_AUTH_PLAIN && s->salt.len) {\n+        b->last = ngx_cpymem(b->last, \"Auth-Salt: \", sizeof(\"Auth-Salt: \") - 1);\n+        b->last = ngx_copy(b->last, s->salt.data, s->salt.len);\n+\n+        s->passwd.data = NULL;\n+    }\n+\n+    b->last = ngx_cpymem(b->last, \"Auth-Protocol: \",\n+                         sizeof(\"Auth-Protocol: \") - 1);\n+    b->last = ngx_cpymem(b->last, cscf->protocol->name.data,\n+                         cscf->protocol->name.len);\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+    b->last = ngx_sprintf(b->last, \"Auth-Login-Attempt: %ui\" CRLF,\n+                          s->login_attempt);\n+\n+    b->last = ngx_cpymem(b->last, \"Client-IP: \", sizeof(\"Client-IP: \") - 1);\n+    b->last = ngx_copy(b->last, s->connection->addr_text.data,\n+                       s->connection->addr_text.len);\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+    if (s->host.len) {\n+        b->last = ngx_cpymem(b->last, \"Client-Host: \",\n+                             sizeof(\"Client-Host: \") - 1);\n+        b->last = ngx_copy(b->last, s->host.data, s->host.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+    }\n+\n+    if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+\n+        /* HELO, MAIL FROM, and RCPT TO can't contain CRLF, no need to escape */\n+\n+        b->last = ngx_cpymem(b->last, \"Auth-SMTP-Helo: \",\n+                             sizeof(\"Auth-SMTP-Helo: \") - 1);\n+        b->last = ngx_copy(b->last, s->smtp_helo.data, s->smtp_helo.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+        b->last = ngx_cpymem(b->last, \"Auth-SMTP-From: \",\n+                             sizeof(\"Auth-SMTP-From: \") - 1);\n+        b->last = ngx_copy(b->last, s->smtp_from.data, s->smtp_from.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+        b->last = ngx_cpymem(b->last, \"Auth-SMTP-To: \",\n+                             sizeof(\"Auth-SMTP-To: \") - 1);\n+        b->last = ngx_copy(b->last, s->smtp_to.data, s->smtp_to.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+    }\n+\n+#if (NGX_MAIL_SSL)\n+\n+    if (c->ssl) {\n+        b->last = ngx_cpymem(b->last, \"Auth-SSL: on\" CRLF,\n+                             sizeof(\"Auth-SSL: on\" CRLF) - 1);\n+\n+        if (verify.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Verify: \",\n+                                 sizeof(\"Auth-SSL-Verify: \") - 1);\n+            b->last = ngx_copy(b->last, verify.data, verify.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (subject.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Subject: \",\n+                                 sizeof(\"Auth-SSL-Subject: \") - 1);\n+            b->last = ngx_copy(b->last, subject.data, subject.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (issuer.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Issuer: \",\n+                                 sizeof(\"Auth-SSL-Issuer: \") - 1);\n+            b->last = ngx_copy(b->last, issuer.data, issuer.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (serial.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Serial: \",\n+                                 sizeof(\"Auth-SSL-Serial: \") - 1);\n+            b->last = ngx_copy(b->last, serial.data, serial.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (fingerprint.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Fingerprint: \",\n+                                 sizeof(\"Auth-SSL-Fingerprint: \") - 1);\n+            b->last = ngx_copy(b->last, fingerprint.data, fingerprint.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (cert.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Cert: \",\n+                                 sizeof(\"Auth-SSL-Cert: \") - 1);\n+            b->last = ngx_copy(b->last, cert.data, cert.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+    }\n+\n+#endif\n+\n+    if (ahcf->header.len) {\n+        b->last = ngx_copy(b->last, ahcf->header.data, ahcf->header.len);\n+    }\n+\n+    /* add \"\\r\\n\" at the header end */\n+    *b->last++ = CR; *b->last++ = LF;\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                   \"mail auth http header:%N\\\"%*s\\\"\",\n+                   (size_t) (b->last - b->pos), b->pos);\n+#endif\n+\n+    return b;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_auth_http_escape(ngx_pool_t *pool, ngx_str_t *text, ngx_str_t *escaped)\n+{\n+    u_char     *p;\n+    uintptr_t   n;\n+\n+    n = ngx_escape_uri(NULL, text->data, text->len, NGX_ESCAPE_MAIL_AUTH);\n+\n+    if (n == 0) {\n+        *escaped = *text;\n+        return NGX_OK;\n+    }\n+\n+    escaped->len = text->len + n * 2;\n+\n+    p = ngx_pnalloc(pool, escaped->len);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    (void) ngx_escape_uri(p, text->data, text->len, NGX_ESCAPE_MAIL_AUTH);\n+\n+    escaped->data = p;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void *\n+ngx_mail_auth_http_create_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_auth_http_conf_t  *ahcf;\n+\n+    ahcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_auth_http_conf_t));\n+    if (ahcf == NULL) {\n+        return NULL;\n+    }\n+\n+    ahcf->timeout = NGX_CONF_UNSET_MSEC;\n+    ahcf->pass_client_cert = NGX_CONF_UNSET;\n+\n+    ahcf->file = cf->conf_file->file.name.data;\n+    ahcf->line = cf->conf_file->line;\n+\n+    return ahcf;\n+}\n+\n+\n+static char *\n+ngx_mail_auth_http_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_auth_http_conf_t *prev = parent;\n+    ngx_mail_auth_http_conf_t *conf = child;\n+\n+    u_char           *p;\n+    size_t            len;\n+    ngx_uint_t        i;\n+    ngx_table_elt_t  *header;\n+\n+    if (conf->peer == NULL) {\n+        conf->peer = prev->peer;\n+        conf->host_header = prev->host_header;\n+        conf->uri = prev->uri;\n+\n+        if (conf->peer == NULL) {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                          \"no \\\"auth_http\\\" is defined for server in %s:%ui\",\n+                          conf->file, conf->line);\n+\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n+\n+    ngx_conf_merge_value(conf->pass_client_cert, prev->pass_client_cert, 0);\n+\n+    if (conf->headers == NULL) {\n+        conf->headers = prev->headers;\n+        conf->header = prev->header;\n+    }\n+\n+    if (conf->headers && conf->header.len == 0) {\n+        len = 0;\n+        header = conf->headers->elts;\n+        for (i = 0; i < conf->headers->nelts; i++) {\n+            len += header[i].key.len + 2 + header[i].value.len + 2;\n+        }\n+\n+        p = ngx_pnalloc(cf->pool, len);\n+        if (p == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        conf->header.len = len;\n+        conf->header.data = p;\n+\n+        for (i = 0; i < conf->headers->nelts; i++) {\n+            p = ngx_cpymem(p, header[i].key.data, header[i].key.len);\n+            *p++ = ':'; *p++ = ' ';\n+            p = ngx_cpymem(p, header[i].value.data, header[i].value.len);\n+            *p++ = CR; *p++ = LF;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_auth_http(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_auth_http_conf_t *ahcf = conf;\n+\n+    ngx_str_t  *value;\n+    ngx_url_t   u;\n+\n+    value = cf->args->elts;\n+\n+    ngx_memzero(&u, sizeof(ngx_url_t));\n+\n+    u.url = value[1];\n+    u.default_port = 80;\n+    u.uri_part = 1;\n+\n+    if (ngx_strncmp(u.url.data, \"http://\", 7) == 0) {\n+        u.url.len -= 7;\n+        u.url.data += 7;\n+    }\n+\n+    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n+        if (u.err) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"%s in auth_http \\\"%V\\\"\", u.err, &u.url);\n+        }\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ahcf->peer = u.addrs;\n+\n+    if (u.family != AF_UNIX) {\n+        ahcf->host_header = u.host;\n+\n+    } else {\n+        ngx_str_set(&ahcf->host_header, \"localhost\");\n+    }\n+\n+    ahcf->uri = u.uri;\n+\n+    if (ahcf->uri.len == 0) {\n+        ngx_str_set(&ahcf->uri, \"/\");\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_auth_http_header(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_auth_http_conf_t *ahcf = conf;\n+\n+    ngx_str_t        *value;\n+    ngx_table_elt_t  *header;\n+\n+    if (ahcf->headers == NULL) {\n+        ahcf->headers = ngx_array_create(cf->pool, 1, sizeof(ngx_table_elt_t));\n+        if (ahcf->headers == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    header = ngx_array_push(ahcf->headers);\n+    if (header == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    header->key = value[1];\n+    header->value = value[2];\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -0,0 +1,678 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+\n+\n+static void *ngx_mail_core_create_main_conf(ngx_conf_t *cf);\n+static void *ngx_mail_core_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+static char *ngx_mail_core_server(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+\n+\n+static ngx_command_t  ngx_mail_core_commands[] = {\n+\n+    { ngx_string(\"server\"),\n+      NGX_MAIL_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,\n+      ngx_mail_core_server,\n+      0,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"listen\"),\n+      NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_mail_core_listen,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"protocol\"),\n+      NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_mail_core_protocol,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"timeout\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_core_srv_conf_t, timeout),\n+      NULL },\n+\n+    { ngx_string(\"server_name\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_core_srv_conf_t, server_name),\n+      NULL },\n+\n+    { ngx_string(\"error_log\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_mail_core_error_log,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"resolver\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_mail_core_resolver,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"resolver_timeout\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_core_srv_conf_t, resolver_timeout),\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_core_module_ctx = {\n+    NULL,                                  /* protocol */\n+\n+    ngx_mail_core_create_main_conf,        /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_core_create_srv_conf,         /* create server configuration */\n+    ngx_mail_core_merge_srv_conf           /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_core_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_core_module_ctx,             /* module context */\n+    ngx_mail_core_commands,                /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static void *\n+ngx_mail_core_create_main_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_core_main_conf_t  *cmcf;\n+\n+    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_core_main_conf_t));\n+    if (cmcf == NULL) {\n+        return NULL;\n+    }\n+\n+    if (ngx_array_init(&cmcf->servers, cf->pool, 4,\n+                       sizeof(ngx_mail_core_srv_conf_t *))\n+        != NGX_OK)\n+    {\n+        return NULL;\n+    }\n+\n+    if (ngx_array_init(&cmcf->listen, cf->pool, 4, sizeof(ngx_mail_listen_t))\n+        != NGX_OK)\n+    {\n+        return NULL;\n+    }\n+\n+    return cmcf;\n+}\n+\n+\n+static void *\n+ngx_mail_core_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_core_srv_conf_t));\n+    if (cscf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc():\n+     *\n+     *     cscf->protocol = NULL;\n+     *     cscf->error_log = NULL;\n+     */\n+\n+    cscf->timeout = NGX_CONF_UNSET_MSEC;\n+    cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;\n+\n+    cscf->resolver = NGX_CONF_UNSET_PTR;\n+\n+    cscf->file_name = cf->conf_file->file.name.data;\n+    cscf->line = cf->conf_file->line;\n+\n+    return cscf;\n+}\n+\n+\n+static char *\n+ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_core_srv_conf_t *prev = parent;\n+    ngx_mail_core_srv_conf_t *conf = child;\n+\n+    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n+    ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n+                              30000);\n+\n+\n+    ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n+\n+    if (conf->server_name.len == 0) {\n+        conf->server_name = cf->cycle->hostname;\n+    }\n+\n+    if (conf->protocol == NULL) {\n+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                      \"unknown mail protocol for server in %s:%ui\",\n+                      conf->file_name, conf->line);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (conf->error_log == NULL) {\n+        if (prev->error_log) {\n+            conf->error_log = prev->error_log;\n+        } else {\n+            conf->error_log = &cf->cycle->new_log;\n+        }\n+    }\n+\n+    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char                       *rv;\n+    void                       *mconf;\n+    ngx_uint_t                  m;\n+    ngx_conf_t                  pcf;\n+    ngx_mail_module_t          *module;\n+    ngx_mail_conf_ctx_t        *ctx, *mail_ctx;\n+    ngx_mail_core_srv_conf_t   *cscf, **cscfp;\n+    ngx_mail_core_main_conf_t  *cmcf;\n+\n+    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_mail_conf_ctx_t));\n+    if (ctx == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    mail_ctx = cf->ctx;\n+    ctx->main_conf = mail_ctx->main_conf;\n+\n+    /* the server{}'s srv_conf */\n+\n+    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_mail_max_module);\n+    if (ctx->srv_conf == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    for (m = 0; cf->cycle->modules[m]; m++) {\n+        if (cf->cycle->modules[m]->type != NGX_MAIL_MODULE) {\n+            continue;\n+        }\n+\n+        module = cf->cycle->modules[m]->ctx;\n+\n+        if (module->create_srv_conf) {\n+            mconf = module->create_srv_conf(cf);\n+            if (mconf == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            ctx->srv_conf[cf->cycle->modules[m]->ctx_index] = mconf;\n+        }\n+    }\n+\n+    /* the server configuration context */\n+\n+    cscf = ctx->srv_conf[ngx_mail_core_module.ctx_index];\n+    cscf->ctx = ctx;\n+\n+    cmcf = ctx->main_conf[ngx_mail_core_module.ctx_index];\n+\n+    cscfp = ngx_array_push(&cmcf->servers);\n+    if (cscfp == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    *cscfp = cscf;\n+\n+\n+    /* parse inside server{} */\n+\n+    pcf = *cf;\n+    cf->ctx = ctx;\n+    cf->cmd_type = NGX_MAIL_SRV_CONF;\n+\n+    rv = ngx_conf_parse(cf, NULL);\n+\n+    *cf = pcf;\n+\n+    if (rv == NGX_CONF_OK && !cscf->listen) {\n+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                      \"no \\\"listen\\\" is defined for server in %s:%ui\",\n+                      cscf->file_name, cscf->line);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return rv;\n+}\n+\n+\n+static char *\n+ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf = conf;\n+\n+    ngx_str_t                  *value, size;\n+    ngx_url_t                   u;\n+    ngx_uint_t                  i, n, m;\n+    ngx_mail_listen_t          *ls, *als;\n+    ngx_mail_module_t          *module;\n+    ngx_mail_core_main_conf_t  *cmcf;\n+\n+    cscf->listen = 1;\n+\n+    value = cf->args->elts;\n+\n+    ngx_memzero(&u, sizeof(ngx_url_t));\n+\n+    u.url = value[1];\n+    u.listen = 1;\n+\n+    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n+        if (u.err) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"%s in \\\"%V\\\" of the \\\"listen\\\" directive\",\n+                               u.err, &u.url);\n+        }\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cmcf = ngx_mail_conf_get_module_main_conf(cf, ngx_mail_core_module);\n+\n+    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);\n+    if (ls == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ngx_memzero(ls, sizeof(ngx_mail_listen_t));\n+\n+    ls->backlog = NGX_LISTEN_BACKLOG;\n+    ls->rcvbuf = -1;\n+    ls->sndbuf = -1;\n+    ls->ctx = cf->ctx;\n+\n+#if (NGX_HAVE_INET6)\n+    ls->ipv6only = 1;\n+#endif\n+\n+    if (cscf->protocol == NULL) {\n+        for (m = 0; cf->cycle->modules[m]; m++) {\n+            if (cf->cycle->modules[m]->type != NGX_MAIL_MODULE) {\n+                continue;\n+            }\n+\n+            module = cf->cycle->modules[m]->ctx;\n+\n+            if (module->protocol == NULL) {\n+                continue;\n+            }\n+\n+            for (i = 0; module->protocol->port[i]; i++) {\n+                if (module->protocol->port[i] == u.port) {\n+                    cscf->protocol = module->protocol;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    for (i = 2; i < cf->args->nelts; i++) {\n+\n+        if (ngx_strcmp(value[i].data, \"bind\") == 0) {\n+            ls->bind = 1;\n+            continue;\n+        }\n+\n+        if (ngx_strncmp(value[i].data, \"backlog=\", 8) == 0) {\n+            ls->backlog = ngx_atoi(value[i].data + 8, value[i].len - 8);\n+            ls->bind = 1;\n+\n+            if (ls->backlog == NGX_ERROR || ls->backlog == 0) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid backlog \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (ngx_strncmp(value[i].data, \"rcvbuf=\", 7) == 0) {\n+            size.len = value[i].len - 7;\n+            size.data = value[i].data + 7;\n+\n+            ls->rcvbuf = ngx_parse_size(&size);\n+            ls->bind = 1;\n+\n+            if (ls->rcvbuf == NGX_ERROR) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid rcvbuf \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (ngx_strncmp(value[i].data, \"sndbuf=\", 7) == 0) {\n+            size.len = value[i].len - 7;\n+            size.data = value[i].data + 7;\n+\n+            ls->sndbuf = ngx_parse_size(&size);\n+            ls->bind = 1;\n+\n+            if (ls->sndbuf == NGX_ERROR) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid sndbuf \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (ngx_strncmp(value[i].data, \"ipv6only=o\", 10) == 0) {\n+#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n+            if (ngx_strcmp(&value[i].data[10], \"n\") == 0) {\n+                ls->ipv6only = 1;\n+\n+            } else if (ngx_strcmp(&value[i].data[10], \"ff\") == 0) {\n+                ls->ipv6only = 0;\n+\n+            } else {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid ipv6only flags \\\"%s\\\"\",\n+                                   &value[i].data[9]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            ls->bind = 1;\n+            continue;\n+#else\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"bind ipv6only is not supported \"\n+                               \"on this platform\");\n+            return NGX_CONF_ERROR;\n+#endif\n+        }\n+\n+        if (ngx_strcmp(value[i].data, \"ssl\") == 0) {\n+#if (NGX_MAIL_SSL)\n+            ngx_mail_ssl_conf_t  *sslcf;\n+\n+            sslcf = ngx_mail_conf_get_module_srv_conf(cf, ngx_mail_ssl_module);\n+\n+            sslcf->listen = 1;\n+            sslcf->file = cf->conf_file->file.name.data;\n+            sslcf->line = cf->conf_file->line;\n+\n+            ls->ssl = 1;\n+\n+            continue;\n+#else\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"the \\\"ssl\\\" parameter requires \"\n+                               \"ngx_mail_ssl_module\");\n+            return NGX_CONF_ERROR;\n+#endif\n+        }\n+\n+        if (ngx_strncmp(value[i].data, \"so_keepalive=\", 13) == 0) {\n+\n+            if (ngx_strcmp(&value[i].data[13], \"on\") == 0) {\n+                ls->so_keepalive = 1;\n+\n+            } else if (ngx_strcmp(&value[i].data[13], \"off\") == 0) {\n+                ls->so_keepalive = 2;\n+\n+            } else {\n+\n+#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n+                u_char     *p, *end;\n+                ngx_str_t   s;\n+\n+                end = value[i].data + value[i].len;\n+                s.data = value[i].data + 13;\n+\n+                p = ngx_strlchr(s.data, end, ':');\n+                if (p == NULL) {\n+                    p = end;\n+                }\n+\n+                if (p > s.data) {\n+                    s.len = p - s.data;\n+\n+                    ls->tcp_keepidle = ngx_parse_time(&s, 1);\n+                    if (ls->tcp_keepidle == (time_t) NGX_ERROR) {\n+                        goto invalid_so_keepalive;\n+                    }\n+                }\n+\n+                s.data = (p < end) ? (p + 1) : end;\n+\n+                p = ngx_strlchr(s.data, end, ':');\n+                if (p == NULL) {\n+                    p = end;\n+                }\n+\n+                if (p > s.data) {\n+                    s.len = p - s.data;\n+\n+                    ls->tcp_keepintvl = ngx_parse_time(&s, 1);\n+                    if (ls->tcp_keepintvl == (time_t) NGX_ERROR) {\n+                        goto invalid_so_keepalive;\n+                    }\n+                }\n+\n+                s.data = (p < end) ? (p + 1) : end;\n+\n+                if (s.data < end) {\n+                    s.len = end - s.data;\n+\n+                    ls->tcp_keepcnt = ngx_atoi(s.data, s.len);\n+                    if (ls->tcp_keepcnt == NGX_ERROR) {\n+                        goto invalid_so_keepalive;\n+                    }\n+                }\n+\n+                if (ls->tcp_keepidle == 0 && ls->tcp_keepintvl == 0\n+                    && ls->tcp_keepcnt == 0)\n+                {\n+                    goto invalid_so_keepalive;\n+                }\n+\n+                ls->so_keepalive = 1;\n+\n+#else\n+\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"the \\\"so_keepalive\\\" parameter accepts \"\n+                                   \"only \\\"on\\\" or \\\"off\\\" on this platform\");\n+                return NGX_CONF_ERROR;\n+\n+#endif\n+            }\n+\n+            ls->bind = 1;\n+\n+            continue;\n+\n+#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n+        invalid_so_keepalive:\n+\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"invalid so_keepalive value: \\\"%s\\\"\",\n+                               &value[i].data[13]);\n+            return NGX_CONF_ERROR;\n+#endif\n+        }\n+\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"the invalid \\\"%V\\\" parameter\", &value[i]);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    als = cmcf->listen.elts;\n+\n+    for (n = 0; n < u.naddrs; n++) {\n+        ls[n] = ls[0];\n+\n+        ls[n].sockaddr = u.addrs[n].sockaddr;\n+        ls[n].socklen = u.addrs[n].socklen;\n+        ls[n].addr_text = u.addrs[n].name;\n+        ls[n].wildcard = ngx_inet_wildcard(ls[n].sockaddr);\n+\n+        for (i = 0; i < cmcf->listen.nelts - u.naddrs + n; i++) {\n+\n+            if (ngx_cmp_sockaddr(als[i].sockaddr, als[i].socklen,\n+                                 ls[n].sockaddr, ls[n].socklen, 1)\n+                != NGX_OK)\n+            {\n+                continue;\n+            }\n+\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"duplicate \\\"%V\\\" address and port pair\",\n+                               &ls[n].addr_text);\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf = conf;\n+\n+    ngx_str_t          *value;\n+    ngx_uint_t          m;\n+    ngx_mail_module_t  *module;\n+\n+    value = cf->args->elts;\n+\n+    for (m = 0; cf->cycle->modules[m]; m++) {\n+        if (cf->cycle->modules[m]->type != NGX_MAIL_MODULE) {\n+            continue;\n+        }\n+\n+        module = cf->cycle->modules[m]->ctx;\n+\n+        if (module->protocol\n+            && ngx_strcmp(module->protocol->name.data, value[1].data) == 0)\n+        {\n+            cscf->protocol = module->protocol;\n+\n+            return NGX_CONF_OK;\n+        }\n+    }\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"unknown protocol \\\"%V\\\"\", &value[1]);\n+    return NGX_CONF_ERROR;\n+}\n+\n+\n+static char *\n+ngx_mail_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf = conf;\n+\n+    return ngx_log_set_log(cf, &cscf->error_log);\n+}\n+\n+\n+static char *\n+ngx_mail_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf = conf;\n+\n+    ngx_str_t  *value;\n+\n+    value = cf->args->elts;\n+\n+    if (cscf->resolver != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+        cscf->resolver = NULL;\n+        return NGX_CONF_OK;\n+    }\n+\n+    cscf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);\n+    if (cscf->resolver == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+char *\n+ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t    *c, *value;\n+    ngx_uint_t    i;\n+    ngx_array_t  *a;\n+\n+    a = (ngx_array_t *) (p + cmd->offset);\n+\n+    value = cf->args->elts;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+        c = ngx_array_push(a);\n+        if (c == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        *c = value[i];\n+    }\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -0,0 +1,884 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+\n+\n+static void ngx_mail_init_session(ngx_connection_t *c);\n+\n+#if (NGX_MAIL_SSL)\n+static void ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);\n+static void ngx_mail_ssl_handshake_handler(ngx_connection_t *c);\n+static ngx_int_t ngx_mail_verify_cert(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+#endif\n+\n+\n+void\n+ngx_mail_init_connection(ngx_connection_t *c)\n+{\n+    size_t                     len;\n+    ngx_uint_t                 i;\n+    ngx_mail_port_t           *port;\n+    struct sockaddr           *sa;\n+    struct sockaddr_in        *sin;\n+    ngx_mail_log_ctx_t        *ctx;\n+    ngx_mail_in_addr_t        *addr;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_addr_conf_t      *addr_conf;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+    u_char                     text[NGX_SOCKADDR_STRLEN];\n+#if (NGX_HAVE_INET6)\n+    struct sockaddr_in6       *sin6;\n+    ngx_mail_in6_addr_t       *addr6;\n+#endif\n+\n+\n+    /* find the server configuration for the address:port */\n+\n+    port = c->listening->servers;\n+\n+    if (port->naddrs > 1) {\n+\n+        /*\n+         * There are several addresses on this port and one of them\n+         * is the \"*:port\" wildcard so getsockname() is needed to determine\n+         * the server address.\n+         *\n+         * AcceptEx() already gave this address.\n+         */\n+\n+        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n+        sa = c->local_sockaddr;\n+\n+        switch (sa->sa_family) {\n+\n+#if (NGX_HAVE_INET6)\n+        case AF_INET6:\n+            sin6 = (struct sockaddr_in6 *) sa;\n+\n+            addr6 = port->addrs;\n+\n+            /* the last address is \"*\" */\n+\n+            for (i = 0; i < port->naddrs - 1; i++) {\n+                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {\n+                    break;\n+                }\n+            }\n+\n+            addr_conf = &addr6[i].conf;\n+\n+            break;\n+#endif\n+\n+        default: /* AF_INET */\n+            sin = (struct sockaddr_in *) sa;\n+\n+            addr = port->addrs;\n+\n+            /* the last address is \"*\" */\n+\n+            for (i = 0; i < port->naddrs - 1; i++) {\n+                if (addr[i].addr == sin->sin_addr.s_addr) {\n+                    break;\n+                }\n+            }\n+\n+            addr_conf = &addr[i].conf;\n+\n+            break;\n+        }\n+\n+    } else {\n+        switch (c->local_sockaddr->sa_family) {\n+\n+#if (NGX_HAVE_INET6)\n+        case AF_INET6:\n+            addr6 = port->addrs;\n+            addr_conf = &addr6[0].conf;\n+            break;\n+#endif\n+\n+        default: /* AF_INET */\n+            addr = port->addrs;\n+            addr_conf = &addr[0].conf;\n+            break;\n+        }\n+    }\n+\n+    s = ngx_pcalloc(c->pool, sizeof(ngx_mail_session_t));\n+    if (s == NULL) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    s->signature = NGX_MAIL_MODULE;\n+\n+    s->main_conf = addr_conf->ctx->main_conf;\n+    s->srv_conf = addr_conf->ctx->srv_conf;\n+\n+    s->addr_text = &addr_conf->addr_text;\n+\n+    c->data = s;\n+    s->connection = c;\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    ngx_set_connection_log(c, cscf->error_log);\n+\n+    len = ngx_sock_ntop(c->sockaddr, c->socklen, text, NGX_SOCKADDR_STRLEN, 1);\n+\n+    ngx_log_error(NGX_LOG_INFO, c->log, 0, \"*%uA client %*s connected to %V\",\n+                  c->number, len, text, s->addr_text);\n+\n+    ctx = ngx_palloc(c->pool, sizeof(ngx_mail_log_ctx_t));\n+    if (ctx == NULL) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    ctx->client = &c->addr_text;\n+    ctx->session = s;\n+\n+    c->log->connection = c->number;\n+    c->log->handler = ngx_mail_log_error;\n+    c->log->data = ctx;\n+    c->log->action = \"sending client greeting line\";\n+\n+    c->log_error = NGX_ERROR_INFO;\n+\n+#if (NGX_MAIL_SSL)\n+    {\n+    ngx_mail_ssl_conf_t  *sslcf;\n+\n+    sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+    if (sslcf->enable || addr_conf->ssl) {\n+        c->log->action = \"SSL handshaking\";\n+\n+        ngx_mail_ssl_init_connection(&sslcf->ssl, c);\n+        return;\n+    }\n+\n+    }\n+#endif\n+\n+    ngx_mail_init_session(c);\n+}\n+\n+\n+#if (NGX_MAIL_SSL)\n+\n+void\n+ngx_mail_starttls_handler(ngx_event_t *rev)\n+{\n+    ngx_connection_t     *c;\n+    ngx_mail_session_t   *s;\n+    ngx_mail_ssl_conf_t  *sslcf;\n+\n+    c = rev->data;\n+    s = c->data;\n+    s->starttls = 1;\n+\n+    c->log->action = \"in starttls state\";\n+\n+    sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+    ngx_mail_ssl_init_connection(&sslcf->ssl, c);\n+}\n+\n+\n+static void\n+ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)\n+{\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    if (ngx_ssl_create_connection(ssl, c, 0) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (ngx_ssl_handshake(c) == NGX_AGAIN) {\n+\n+        s = c->data;\n+\n+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+        ngx_add_timer(c->read, cscf->timeout);\n+\n+        c->ssl->handler = ngx_mail_ssl_handshake_handler;\n+\n+        return;\n+    }\n+\n+    ngx_mail_ssl_handshake_handler(c);\n+}\n+\n+\n+static void\n+ngx_mail_ssl_handshake_handler(ngx_connection_t *c)\n+{\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    if (c->ssl->handshaked) {\n+\n+        s = c->data;\n+\n+        if (ngx_mail_verify_cert(s, c) != NGX_OK) {\n+            return;\n+        }\n+\n+        if (s->starttls) {\n+            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+            c->read->handler = cscf->protocol->init_protocol;\n+            c->write->handler = ngx_mail_send;\n+\n+            cscf->protocol->init_protocol(c->read);\n+\n+            return;\n+        }\n+\n+        c->read->ready = 0;\n+\n+        ngx_mail_init_session(c);\n+        return;\n+    }\n+\n+    ngx_mail_close_connection(c);\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_verify_cert(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    long                       rc;\n+    X509                      *cert;\n+    ngx_mail_ssl_conf_t       *sslcf;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+    if (!sslcf->verify) {\n+        return NGX_OK;\n+    }\n+\n+    rc = SSL_get_verify_result(c->ssl->connection);\n+\n+    if (rc != X509_V_OK\n+        && (sslcf->verify != 3 || !ngx_ssl_verify_error_optional(rc)))\n+    {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                      \"client SSL certificate verify error: (%l:%s)\",\n+                      rc, X509_verify_cert_error_string(rc));\n+\n+        ngx_ssl_remove_cached_session(c->ssl->session_ctx,\n+                                      (SSL_get0_session(c->ssl->connection)));\n+\n+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+        s->out = cscf->protocol->cert_error;\n+        s->quit = 1;\n+\n+        c->write->handler = ngx_mail_send;\n+\n+        ngx_mail_send(s->connection->write);\n+        return NGX_ERROR;\n+    }\n+\n+    if (sslcf->verify == 1) {\n+        cert = SSL_get_peer_certificate(c->ssl->connection);\n+\n+        if (cert == NULL) {\n+            ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                          \"client sent no required SSL certificate\");\n+\n+            ngx_ssl_remove_cached_session(c->ssl->session_ctx,\n+                                       (SSL_get0_session(c->ssl->connection)));\n+\n+            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+            s->out = cscf->protocol->no_cert;\n+            s->quit = 1;\n+\n+            c->write->handler = ngx_mail_send;\n+\n+            ngx_mail_send(s->connection->write);\n+            return NGX_ERROR;\n+        }\n+\n+        X509_free(cert);\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+#endif\n+\n+\n+static void\n+ngx_mail_init_session(ngx_connection_t *c)\n+{\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    s = c->data;\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    s->protocol = cscf->protocol->type;\n+\n+    s->ctx = ngx_pcalloc(c->pool, sizeof(void *) * ngx_mail_max_module);\n+    if (s->ctx == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    c->write->handler = ngx_mail_send;\n+\n+    cscf->protocol->init_session(s, c);\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_salt(ngx_mail_session_t *s, ngx_connection_t *c,\n+    ngx_mail_core_srv_conf_t *cscf)\n+{\n+    s->salt.data = ngx_pnalloc(c->pool,\n+                               sizeof(\" <18446744073709551616.@>\" CRLF) - 1\n+                               + NGX_TIME_T_LEN\n+                               + cscf->server_name.len);\n+    if (s->salt.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    s->salt.len = ngx_sprintf(s->salt.data, \"<%ul.%T@%V>\" CRLF,\n+                              ngx_random(), ngx_time(), &cscf->server_name)\n+                  - s->salt.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n+#if (NGX_MAIL_SSL)\n+\n+ngx_int_t\n+ngx_mail_starttls_only(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_mail_ssl_conf_t  *sslcf;\n+\n+    if (c->ssl) {\n+        return 0;\n+    }\n+\n+    sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+    if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n+\n+#endif\n+\n+\n+ngx_int_t\n+ngx_mail_auth_plain(ngx_mail_session_t *s, ngx_connection_t *c, ngx_uint_t n)\n+{\n+    u_char     *p, *last;\n+    ngx_str_t  *arg, plain;\n+\n+    arg = s->args.elts;\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth plain: \\\"%V\\\"\", &arg[n]);\n+#endif\n+\n+    plain.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));\n+    if (plain.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_decode_base64(&plain, &arg[n]) != NGX_OK) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+            \"client sent invalid base64 encoding in AUTH PLAIN command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    p = plain.data;\n+    last = p + plain.len;\n+\n+    while (p < last && *p++) { /* void */ }\n+\n+    if (p == last) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                      \"client sent invalid login in AUTH PLAIN command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    s->login.data = p;\n+\n+    while (p < last && *p) { p++; }\n+\n+    if (p == last) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                      \"client sent invalid password in AUTH PLAIN command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    s->login.len = p++ - s->login.data;\n+\n+    s->passwd.len = last - p;\n+    s->passwd.data = p;\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth plain: \\\"%V\\\" \\\"%V\\\"\", &s->login, &s->passwd);\n+#endif\n+\n+    return NGX_DONE;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_auth_login_username(ngx_mail_session_t *s, ngx_connection_t *c,\n+    ngx_uint_t n)\n+{\n+    ngx_str_t  *arg;\n+\n+    arg = s->args.elts;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth login username: \\\"%V\\\"\", &arg[n]);\n+\n+    s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));\n+    if (s->login.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_decode_base64(&s->login, &arg[n]) != NGX_OK) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+            \"client sent invalid base64 encoding in AUTH LOGIN command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth login username: \\\"%V\\\"\", &s->login);\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_auth_login_password(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t  *arg;\n+\n+    arg = s->args.elts;\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth login password: \\\"%V\\\"\", &arg[0]);\n+#endif\n+\n+    s->passwd.data = ngx_pnalloc(c->pool,\n+                                 ngx_base64_decoded_length(arg[0].len));\n+    if (s->passwd.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_decode_base64(&s->passwd, &arg[0]) != NGX_OK) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+            \"client sent invalid base64 encoding in AUTH LOGIN command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth login password: \\\"%V\\\"\", &s->passwd);\n+#endif\n+\n+    return NGX_DONE;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_auth_cram_md5_salt(ngx_mail_session_t *s, ngx_connection_t *c,\n+    char *prefix, size_t len)\n+{\n+    u_char      *p;\n+    ngx_str_t    salt;\n+    ngx_uint_t   n;\n+\n+    p = ngx_pnalloc(c->pool, len + ngx_base64_encoded_length(s->salt.len) + 2);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    salt.data = ngx_cpymem(p, prefix, len);\n+    s->salt.len -= 2;\n+\n+    ngx_encode_base64(&salt, &s->salt);\n+\n+    s->salt.len += 2;\n+    n = len + salt.len;\n+    p[n++] = CR; p[n++] = LF;\n+\n+    s->out.len = n;\n+    s->out.data = p;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_auth_cram_md5(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    u_char     *p, *last;\n+    ngx_str_t  *arg;\n+\n+    arg = s->args.elts;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth cram-md5: \\\"%V\\\"\", &arg[0]);\n+\n+    s->login.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[0].len));\n+    if (s->login.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_decode_base64(&s->login, &arg[0]) != NGX_OK) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+            \"client sent invalid base64 encoding in AUTH CRAM-MD5 command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    p = s->login.data;\n+    last = p + s->login.len;\n+\n+    while (p < last) {\n+        if (*p++ == ' ') {\n+            s->login.len = p - s->login.data - 1;\n+            s->passwd.len = last - p;\n+            s->passwd.data = p;\n+            break;\n+        }\n+    }\n+\n+    if (s->passwd.len != 32) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+            \"client sent invalid CRAM-MD5 hash in AUTH CRAM-MD5 command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth cram-md5: \\\"%V\\\" \\\"%V\\\"\", &s->login, &s->passwd);\n+\n+    s->auth_method = NGX_MAIL_AUTH_CRAM_MD5;\n+\n+    return NGX_DONE;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_auth_external(ngx_mail_session_t *s, ngx_connection_t *c,\n+    ngx_uint_t n)\n+{\n+    ngx_str_t  *arg, external;\n+\n+    arg = s->args.elts;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth external: \\\"%V\\\"\", &arg[n]);\n+\n+    external.data = ngx_pnalloc(c->pool, ngx_base64_decoded_length(arg[n].len));\n+    if (external.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_decode_base64(&external, &arg[n]) != NGX_OK) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+            \"client sent invalid base64 encoding in AUTH EXTERNAL command\");\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    s->login.len = external.len;\n+    s->login.data = external.data;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail auth external: \\\"%V\\\"\", &s->login);\n+\n+    s->auth_method = NGX_MAIL_AUTH_EXTERNAL;\n+\n+    return NGX_DONE;\n+}\n+\n+\n+void\n+ngx_mail_send(ngx_event_t *wev)\n+{\n+    ngx_int_t                  n;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    c = wev->data;\n+    s = c->data;\n+\n+    if (wev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (s->out.len == 0) {\n+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+        }\n+\n+        return;\n+    }\n+\n+    n = c->send(c, s->out.data, s->out.len);\n+\n+    if (n > 0) {\n+        s->out.data += n;\n+        s->out.len -= n;\n+\n+        if (s->out.len != 0) {\n+            goto again;\n+        }\n+\n+        if (wev->timer_set) {\n+            ngx_del_timer(wev);\n+        }\n+\n+        if (s->quit) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n+        if (s->blocked) {\n+            c->read->handler(c->read);\n+        }\n+\n+        return;\n+    }\n+\n+    if (n == NGX_ERROR) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    /* n == NGX_AGAIN */\n+\n+again:\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    ngx_add_timer(c->write, cscf->timeout);\n+\n+    if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ssize_t                    n;\n+    ngx_int_t                  rc;\n+    ngx_str_t                  l;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);\n+\n+    if (n == NGX_ERROR || n == 0) {\n+        ngx_mail_close_connection(c);\n+        return NGX_ERROR;\n+    }\n+\n+    if (n > 0) {\n+        s->buffer->last += n;\n+    }\n+\n+    if (n == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return NGX_ERROR;\n+        }\n+\n+        if (s->buffer->pos == s->buffer->last) {\n+            return NGX_AGAIN;\n+        }\n+    }\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    rc = cscf->protocol->parse_command(s);\n+\n+    if (rc == NGX_AGAIN) {\n+\n+        if (s->buffer->last < s->buffer->end) {\n+            return rc;\n+        }\n+\n+        l.len = s->buffer->last - s->buffer->start;\n+        l.data = s->buffer->start;\n+\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                      \"client sent too long command \\\"%V\\\"\", &l);\n+\n+        s->quit = 1;\n+\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    if (rc == NGX_IMAP_NEXT || rc == NGX_MAIL_PARSE_INVALID_COMMAND) {\n+        return rc;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n+        ngx_mail_close_connection(c);\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_mail_auth(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    s->args.nelts = 0;\n+\n+    if (s->buffer->pos == s->buffer->last) {\n+        s->buffer->pos = s->buffer->start;\n+        s->buffer->last = s->buffer->start;\n+    }\n+\n+    s->state = 0;\n+\n+    if (c->read->timer_set) {\n+        ngx_del_timer(c->read);\n+    }\n+\n+    s->login_attempt++;\n+\n+    ngx_mail_auth_http_init(s);\n+}\n+\n+\n+void\n+ngx_mail_session_internal_server_error(ngx_mail_session_t *s)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    s->out = cscf->protocol->internal_server_error;\n+    s->quit = 1;\n+\n+    ngx_mail_send(s->connection->write);\n+}\n+\n+\n+void\n+ngx_mail_close_connection(ngx_connection_t *c)\n+{\n+    ngx_pool_t  *pool;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"close mail connection: %d\", c->fd);\n+\n+#if (NGX_MAIL_SSL)\n+\n+    if (c->ssl) {\n+        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {\n+            c->ssl->handler = ngx_mail_close_connection;\n+            return;\n+        }\n+    }\n+\n+#endif\n+\n+#if (NGX_STAT_STUB)\n+    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);\n+#endif\n+\n+    c->destroyed = 1;\n+\n+    pool = c->pool;\n+\n+    ngx_close_connection(c);\n+\n+    ngx_destroy_pool(pool);\n+}\n+\n+\n+u_char *\n+ngx_mail_log_error(ngx_log_t *log, u_char *buf, size_t len)\n+{\n+    u_char              *p;\n+    ngx_mail_session_t  *s;\n+    ngx_mail_log_ctx_t  *ctx;\n+\n+    if (log->action) {\n+        p = ngx_snprintf(buf, len, \" while %s\", log->action);\n+        len -= p - buf;\n+        buf = p;\n+    }\n+\n+    ctx = log->data;\n+\n+    p = ngx_snprintf(buf, len, \", client: %V\", ctx->client);\n+    len -= p - buf;\n+    buf = p;\n+\n+    s = ctx->session;\n+\n+    if (s == NULL) {\n+        return p;\n+    }\n+\n+    p = ngx_snprintf(buf, len, \"%s, server: %V\",\n+                     s->starttls ? \" using starttls\" : \"\",\n+                     s->addr_text);\n+    len -= p - buf;\n+    buf = p;\n+\n+    if (s->login.len == 0) {\n+        return p;\n+    }\n+\n+    p = ngx_snprintf(buf, len, \", login: \\\"%V\\\"\", &s->login);\n+    len -= p - buf;\n+    buf = p;\n+\n+    if (s->proxy == NULL) {\n+        return p;\n+    }\n+\n+    p = ngx_snprintf(buf, len, \", upstream: %V\", s->proxy->upstream.name);\n+\n+    return p;\n+}\nDiff:\n@@ -0,0 +1,472 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_imap_module.h>\n+\n+\n+static ngx_int_t ngx_mail_imap_login(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+static ngx_int_t ngx_mail_imap_authenticate(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+static ngx_int_t ngx_mail_imap_capability(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+static ngx_int_t ngx_mail_imap_starttls(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+\n+\n+static u_char  imap_greeting[] = \"* OK IMAP4 ready\" CRLF;\n+static u_char  imap_star[] = \"* \";\n+static u_char  imap_ok[] = \"OK completed\" CRLF;\n+static u_char  imap_next[] = \"+ OK\" CRLF;\n+static u_char  imap_plain_next[] = \"+ \" CRLF;\n+static u_char  imap_username[] = \"+ VXNlcm5hbWU6\" CRLF;\n+static u_char  imap_password[] = \"+ UGFzc3dvcmQ6\" CRLF;\n+static u_char  imap_bye[] = \"* BYE\" CRLF;\n+static u_char  imap_invalid_command[] = \"BAD invalid command\" CRLF;\n+\n+\n+void\n+ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    ngx_str_set(&s->out, imap_greeting);\n+\n+    c->read->handler = ngx_mail_imap_init_protocol;\n+\n+    ngx_add_timer(c->read, cscf->timeout);\n+\n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+    }\n+\n+    ngx_mail_send(c->write);\n+}\n+\n+\n+void\n+ngx_mail_imap_init_protocol(ngx_event_t *rev)\n+{\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_imap_srv_conf_t  *iscf;\n+\n+    c = rev->data;\n+\n+    c->log->action = \"in auth state\";\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    s = c->data;\n+\n+    if (s->buffer == NULL) {\n+        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))\n+            == NGX_ERROR)\n+        {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);\n+\n+        s->buffer = ngx_create_temp_buf(c->pool, iscf->client_buffer_size);\n+        if (s->buffer == NULL) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+    }\n+\n+    s->mail_state = ngx_imap_start;\n+    c->read->handler = ngx_mail_imap_auth_state;\n+\n+    ngx_mail_imap_auth_state(rev);\n+}\n+\n+\n+void\n+ngx_mail_imap_auth_state(ngx_event_t *rev)\n+{\n+    u_char              *p, *dst, *src, *end;\n+    ngx_str_t           *arg;\n+    ngx_int_t            rc;\n+    ngx_uint_t           tag, i;\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap auth state\");\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (s->out.len) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap send handler busy\");\n+        s->blocked = 1;\n+        return;\n+    }\n+\n+    s->blocked = 0;\n+\n+    rc = ngx_mail_read_command(s, c);\n+\n+    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+        return;\n+    }\n+\n+    tag = 1;\n+    s->text.len = 0;\n+    ngx_str_set(&s->out, imap_ok);\n+\n+    if (rc == NGX_OK) {\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap auth command: %i\",\n+                       s->command);\n+\n+        if (s->backslash) {\n+\n+            arg = s->args.elts;\n+\n+            for (i = 0; i < s->args.nelts; i++) {\n+                dst = arg[i].data;\n+                end = dst + arg[i].len;\n+\n+                for (src = dst; src < end; dst++) {\n+                    *dst = *src;\n+                    if (*src++ == '\\\\') {\n+                        *dst = *src++;\n+                    }\n+                }\n+\n+                arg[i].len = dst - arg[i].data;\n+            }\n+\n+            s->backslash = 0;\n+        }\n+\n+        switch (s->mail_state) {\n+\n+        case ngx_imap_start:\n+\n+            switch (s->command) {\n+\n+            case NGX_IMAP_LOGIN:\n+                rc = ngx_mail_imap_login(s, c);\n+                break;\n+\n+            case NGX_IMAP_AUTHENTICATE:\n+                rc = ngx_mail_imap_authenticate(s, c);\n+                tag = (rc != NGX_OK);\n+                break;\n+\n+            case NGX_IMAP_CAPABILITY:\n+                rc = ngx_mail_imap_capability(s, c);\n+                break;\n+\n+            case NGX_IMAP_LOGOUT:\n+                s->quit = 1;\n+                ngx_str_set(&s->text, imap_bye);\n+                break;\n+\n+            case NGX_IMAP_NOOP:\n+                break;\n+\n+            case NGX_IMAP_STARTTLS:\n+                rc = ngx_mail_imap_starttls(s, c);\n+                break;\n+\n+            default:\n+                rc = NGX_MAIL_PARSE_INVALID_COMMAND;\n+                break;\n+            }\n+\n+            break;\n+\n+        case ngx_imap_auth_login_username:\n+            rc = ngx_mail_auth_login_username(s, c, 0);\n+\n+            tag = 0;\n+            ngx_str_set(&s->out, imap_password);\n+            s->mail_state = ngx_imap_auth_login_password;\n+\n+            break;\n+\n+        case ngx_imap_auth_login_password:\n+            rc = ngx_mail_auth_login_password(s, c);\n+            break;\n+\n+        case ngx_imap_auth_plain:\n+            rc = ngx_mail_auth_plain(s, c, 0);\n+            break;\n+\n+        case ngx_imap_auth_cram_md5:\n+            rc = ngx_mail_auth_cram_md5(s, c);\n+            break;\n+\n+        case ngx_imap_auth_external:\n+            rc = ngx_mail_auth_external(s, c, 0);\n+            break;\n+        }\n+\n+    } else if (rc == NGX_IMAP_NEXT) {\n+        tag = 0;\n+        ngx_str_set(&s->out, imap_next);\n+    }\n+\n+    switch (rc) {\n+\n+    case NGX_DONE:\n+        ngx_mail_auth(s, c);\n+        return;\n+\n+    case NGX_ERROR:\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+\n+    case NGX_MAIL_PARSE_INVALID_COMMAND:\n+        s->state = 0;\n+        ngx_str_set(&s->out, imap_invalid_command);\n+        s->mail_state = ngx_imap_start;\n+        break;\n+    }\n+\n+    if (tag) {\n+        if (s->tag.len == 0) {\n+            ngx_str_set(&s->tag, imap_star);\n+        }\n+\n+        if (s->tagged_line.len < s->tag.len + s->text.len + s->out.len) {\n+            s->tagged_line.len = s->tag.len + s->text.len + s->out.len;\n+            s->tagged_line.data = ngx_pnalloc(c->pool, s->tagged_line.len);\n+            if (s->tagged_line.data == NULL) {\n+                ngx_mail_close_connection(c);\n+                return;\n+            }\n+        }\n+\n+        p = s->tagged_line.data;\n+\n+        if (s->text.len) {\n+            p = ngx_cpymem(p, s->text.data, s->text.len);\n+        }\n+\n+        p = ngx_cpymem(p, s->tag.data, s->tag.len);\n+        ngx_memcpy(p, s->out.data, s->out.len);\n+\n+        s->out.len = s->text.len + s->tag.len + s->out.len;\n+        s->out.data = s->tagged_line.data;\n+    }\n+\n+    if (rc != NGX_IMAP_NEXT) {\n+        s->args.nelts = 0;\n+\n+        if (s->state) {\n+            /* preserve tag */\n+            s->arg_start = s->buffer->start + s->tag.len;\n+            s->buffer->pos = s->arg_start;\n+            s->buffer->last = s->arg_start;\n+\n+        } else {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n+            s->tag.len = 0;\n+        }\n+    }\n+\n+    ngx_mail_send(c->write);\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_imap_login(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t  *arg;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    arg = s->args.elts;\n+\n+    if (s->args.nelts != 2 || arg[0].len == 0) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    s->login.len = arg[0].len;\n+    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n+    if (s->login.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->login.data, arg[0].data, s->login.len);\n+\n+    s->passwd.len = arg[1].len;\n+    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);\n+    if (s->passwd.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->passwd.data, arg[1].data, s->passwd.len);\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"imap login:\\\"%V\\\" passwd:\\\"%V\\\"\",\n+                   &s->login, &s->passwd);\n+#else\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"imap login:\\\"%V\\\"\", &s->login);\n+#endif\n+\n+    return NGX_DONE;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_imap_authenticate(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_int_t                  rc;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+    ngx_mail_imap_srv_conf_t  *iscf;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);\n+\n+    rc = ngx_mail_auth_parse(s, c);\n+\n+    switch (rc) {\n+\n+    case NGX_MAIL_AUTH_LOGIN:\n+\n+        ngx_str_set(&s->out, imap_username);\n+        s->mail_state = ngx_imap_auth_login_username;\n+\n+        return NGX_OK;\n+\n+    case NGX_MAIL_AUTH_LOGIN_USERNAME:\n+\n+        ngx_str_set(&s->out, imap_password);\n+        s->mail_state = ngx_imap_auth_login_password;\n+\n+        return ngx_mail_auth_login_username(s, c, 1);\n+\n+    case NGX_MAIL_AUTH_PLAIN:\n+\n+        ngx_str_set(&s->out, imap_plain_next);\n+        s->mail_state = ngx_imap_auth_plain;\n+\n+        return NGX_OK;\n+\n+    case NGX_MAIL_AUTH_CRAM_MD5:\n+\n+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        if (s->salt.data == NULL) {\n+            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+            if (ngx_mail_salt(s, c, cscf) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        if (ngx_mail_auth_cram_md5_salt(s, c, \"+ \", 2) == NGX_OK) {\n+            s->mail_state = ngx_imap_auth_cram_md5;\n+            return NGX_OK;\n+        }\n+\n+        return NGX_ERROR;\n+\n+    case NGX_MAIL_AUTH_EXTERNAL:\n+\n+        if (!(iscf->auth_methods & NGX_MAIL_AUTH_EXTERNAL_ENABLED)) {\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        ngx_str_set(&s->out, imap_username);\n+        s->mail_state = ngx_imap_auth_external;\n+\n+        return NGX_OK;\n+    }\n+\n+    return rc;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_imap_capability(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_mail_imap_srv_conf_t  *iscf;\n+\n+    iscf = ngx_mail_get_module_srv_conf(s, ngx_mail_imap_module);\n+\n+#if (NGX_MAIL_SSL)\n+\n+    if (c->ssl == NULL) {\n+        ngx_mail_ssl_conf_t  *sslcf;\n+\n+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {\n+            s->text = iscf->starttls_capability;\n+            return NGX_OK;\n+        }\n+\n+        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {\n+            s->text = iscf->starttls_only_capability;\n+            return NGX_OK;\n+        }\n+    }\n+#endif\n+\n+    s->text = iscf->capability;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_imap_starttls(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+#if (NGX_MAIL_SSL)\n+    ngx_mail_ssl_conf_t  *sslcf;\n+\n+    if (c->ssl == NULL) {\n+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+        if (sslcf->starttls) {\n+            c->read->handler = ngx_mail_starttls_handler;\n+            return NGX_OK;\n+        }\n+    }\n+\n+#endif\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\nDiff:\n@@ -0,0 +1,257 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_imap_module.h>\n+\n+\n+static void *ngx_mail_imap_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+\n+\n+static ngx_str_t  ngx_mail_imap_default_capabilities[] = {\n+    ngx_string(\"IMAP4\"),\n+    ngx_string(\"IMAP4rev1\"),\n+    ngx_string(\"UIDPLUS\"),\n+    ngx_null_string\n+};\n+\n+\n+static ngx_conf_bitmask_t  ngx_mail_imap_auth_methods[] = {\n+    { ngx_string(\"plain\"), NGX_MAIL_AUTH_PLAIN_ENABLED },\n+    { ngx_string(\"login\"), NGX_MAIL_AUTH_LOGIN_ENABLED },\n+    { ngx_string(\"cram-md5\"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },\n+    { ngx_string(\"external\"), NGX_MAIL_AUTH_EXTERNAL_ENABLED },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+static ngx_str_t  ngx_mail_imap_auth_methods_names[] = {\n+    ngx_string(\"AUTH=PLAIN\"),\n+    ngx_string(\"AUTH=LOGIN\"),\n+    ngx_null_string,  /* APOP */\n+    ngx_string(\"AUTH=CRAM-MD5\"),\n+    ngx_string(\"AUTH=EXTERNAL\"),\n+    ngx_null_string   /* NONE */\n+};\n+\n+\n+static ngx_mail_protocol_t  ngx_mail_imap_protocol = {\n+    ngx_string(\"imap\"),\n+    { 143, 993, 0, 0 },\n+    NGX_MAIL_IMAP_PROTOCOL,\n+\n+    ngx_mail_imap_init_session,\n+    ngx_mail_imap_init_protocol,\n+    ngx_mail_imap_parse_command,\n+    ngx_mail_imap_auth_state,\n+\n+    ngx_string(\"* BAD internal server error\" CRLF),\n+    ngx_string(\"* BYE SSL certificate error\" CRLF),\n+    ngx_string(\"* BYE No required SSL certificate\" CRLF)\n+};\n+\n+\n+static ngx_command_t  ngx_mail_imap_commands[] = {\n+\n+    { ngx_string(\"imap_client_buffer\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_size_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_imap_srv_conf_t, client_buffer_size),\n+      NULL },\n+\n+    { ngx_string(\"imap_capabilities\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_mail_capabilities,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_imap_srv_conf_t, capabilities),\n+      NULL },\n+\n+    { ngx_string(\"imap_auth\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_conf_set_bitmask_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_imap_srv_conf_t, auth_methods),\n+      &ngx_mail_imap_auth_methods },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_imap_module_ctx = {\n+    &ngx_mail_imap_protocol,               /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_imap_create_srv_conf,         /* create server configuration */\n+    ngx_mail_imap_merge_srv_conf           /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_imap_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_imap_module_ctx,             /* module context */\n+    ngx_mail_imap_commands,                /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static void *\n+ngx_mail_imap_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_imap_srv_conf_t  *iscf;\n+\n+    iscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_imap_srv_conf_t));\n+    if (iscf == NULL) {\n+        return NULL;\n+    }\n+\n+    iscf->client_buffer_size = NGX_CONF_UNSET_SIZE;\n+\n+    if (ngx_array_init(&iscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))\n+        != NGX_OK)\n+    {\n+        return NULL;\n+    }\n+\n+    return iscf;\n+}\n+\n+\n+static char *\n+ngx_mail_imap_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_imap_srv_conf_t *prev = parent;\n+    ngx_mail_imap_srv_conf_t *conf = child;\n+\n+    u_char      *p, *auth;\n+    size_t       size;\n+    ngx_str_t   *c, *d;\n+    ngx_uint_t   i, m;\n+\n+    ngx_conf_merge_size_value(conf->client_buffer_size,\n+                              prev->client_buffer_size,\n+                              (size_t) ngx_pagesize);\n+\n+    ngx_conf_merge_bitmask_value(conf->auth_methods,\n+                              prev->auth_methods,\n+                              (NGX_CONF_BITMASK_SET\n+                               |NGX_MAIL_AUTH_PLAIN_ENABLED));\n+\n+\n+    if (conf->capabilities.nelts == 0) {\n+        conf->capabilities = prev->capabilities;\n+    }\n+\n+    if (conf->capabilities.nelts == 0) {\n+\n+        for (d = ngx_mail_imap_default_capabilities; d->len; d++) {\n+            c = ngx_array_push(&conf->capabilities);\n+            if (c == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            *c = *d;\n+        }\n+    }\n+\n+    size = sizeof(\"* CAPABILITY\" CRLF) - 1;\n+\n+    c = conf->capabilities.elts;\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        size += 1 + c[i].len;\n+    }\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (m & conf->auth_methods) {\n+            size += 1 + ngx_mail_imap_auth_methods_names[i].len;\n+        }\n+    }\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->capability.len = size;\n+    conf->capability.data = p;\n+\n+    p = ngx_cpymem(p, \"* CAPABILITY\", sizeof(\"* CAPABILITY\") - 1);\n+\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        *p++ = ' ';\n+        p = ngx_cpymem(p, c[i].data, c[i].len);\n+    }\n+\n+    auth = p;\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (m & conf->auth_methods) {\n+            *p++ = ' ';\n+            p = ngx_cpymem(p, ngx_mail_imap_auth_methods_names[i].data,\n+                           ngx_mail_imap_auth_methods_names[i].len);\n+        }\n+    }\n+\n+    *p++ = CR; *p = LF;\n+\n+\n+    size += sizeof(\" STARTTLS\") - 1;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->starttls_capability.len = size;\n+    conf->starttls_capability.data = p;\n+\n+    p = ngx_cpymem(p, conf->capability.data,\n+                   conf->capability.len - (sizeof(CRLF) - 1));\n+    p = ngx_cpymem(p, \" STARTTLS\", sizeof(\" STARTTLS\") - 1);\n+    *p++ = CR; *p = LF;\n+\n+\n+    size = (auth - conf->capability.data) + sizeof(CRLF) - 1\n+            + sizeof(\" STARTTLS LOGINDISABLED\") - 1;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->starttls_only_capability.len = size;\n+    conf->starttls_only_capability.data = p;\n+\n+    p = ngx_cpymem(p, conf->capability.data,\n+                   auth - conf->capability.data);\n+    p = ngx_cpymem(p, \" STARTTLS LOGINDISABLED\",\n+                   sizeof(\" STARTTLS LOGINDISABLED\") - 1);\n+    *p++ = CR; *p = LF;\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -0,0 +1,39 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_MAIL_IMAP_MODULE_H_INCLUDED_\n+#define _NGX_MAIL_IMAP_MODULE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+\n+\n+typedef struct {\n+    size_t       client_buffer_size;\n+\n+    ngx_str_t    capability;\n+    ngx_str_t    starttls_capability;\n+    ngx_str_t    starttls_only_capability;\n+\n+    ngx_uint_t   auth_methods;\n+\n+    ngx_array_t  capabilities;\n+} ngx_mail_imap_srv_conf_t;\n+\n+\n+void ngx_mail_imap_init_session(ngx_mail_session_t *s, ngx_connection_t *c);\n+void ngx_mail_imap_init_protocol(ngx_event_t *rev);\n+void ngx_mail_imap_auth_state(ngx_event_t *rev);\n+ngx_int_t ngx_mail_imap_parse_command(ngx_mail_session_t *s);\n+\n+\n+extern ngx_module_t  ngx_mail_imap_module;\n+\n+\n+#endif /* _NGX_MAIL_IMAP_MODULE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,932 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_pop3_module.h>\n+#include <ngx_mail_imap_module.h>\n+#include <ngx_mail_smtp_module.h>\n+\n+\n+ngx_int_t\n+ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n+{\n+    u_char      ch, *p, *c, c0, c1, c2, c3;\n+    ngx_str_t  *arg;\n+    enum {\n+        sw_start = 0,\n+        sw_spaces_before_argument,\n+        sw_argument,\n+        sw_almost_done\n+    } state;\n+\n+    state = s->state;\n+\n+    for (p = s->buffer->pos; p < s->buffer->last; p++) {\n+        ch = *p;\n+\n+        switch (state) {\n+\n+        /* POP3 command */\n+        case sw_start:\n+            if (ch == ' ' || ch == CR || ch == LF) {\n+                c = s->buffer->start;\n+\n+                if (p - c == 4) {\n+\n+                    c0 = ngx_toupper(c[0]);\n+                    c1 = ngx_toupper(c[1]);\n+                    c2 = ngx_toupper(c[2]);\n+                    c3 = ngx_toupper(c[3]);\n+\n+                    if (c0 == 'U' && c1 == 'S' && c2 == 'E' && c3 == 'R')\n+                    {\n+                        s->command = NGX_POP3_USER;\n+\n+                    } else if (c0 == 'P' && c1 == 'A' && c2 == 'S' && c3 == 'S')\n+                    {\n+                        s->command = NGX_POP3_PASS;\n+\n+                    } else if (c0 == 'A' && c1 == 'P' && c2 == 'O' && c3 == 'P')\n+                    {\n+                        s->command = NGX_POP3_APOP;\n+\n+                    } else if (c0 == 'Q' && c1 == 'U' && c2 == 'I' && c3 == 'T')\n+                    {\n+                        s->command = NGX_POP3_QUIT;\n+\n+                    } else if (c0 == 'C' && c1 == 'A' && c2 == 'P' && c3 == 'A')\n+                    {\n+                        s->command = NGX_POP3_CAPA;\n+\n+                    } else if (c0 == 'A' && c1 == 'U' && c2 == 'T' && c3 == 'H')\n+                    {\n+                        s->command = NGX_POP3_AUTH;\n+\n+                    } else if (c0 == 'N' && c1 == 'O' && c2 == 'O' && c3 == 'P')\n+                    {\n+                        s->command = NGX_POP3_NOOP;\n+#if (NGX_MAIL_SSL)\n+                    } else if (c0 == 'S' && c1 == 'T' && c2 == 'L' && c3 == 'S')\n+                    {\n+                        s->command = NGX_POP3_STLS;\n+#endif\n+                    } else {\n+                        goto invalid;\n+                    }\n+\n+                } else {\n+                    goto invalid;\n+                }\n+\n+                switch (ch) {\n+                case ' ':\n+                    state = sw_spaces_before_argument;\n+                    break;\n+                case CR:\n+                    state = sw_almost_done;\n+                    break;\n+                case LF:\n+                    goto done;\n+                }\n+                break;\n+            }\n+\n+            if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')) {\n+                goto invalid;\n+            }\n+\n+            break;\n+\n+        case sw_spaces_before_argument:\n+            switch (ch) {\n+            case ' ':\n+                break;\n+            case CR:\n+                state = sw_almost_done;\n+                s->arg_end = p;\n+                break;\n+            case LF:\n+                s->arg_end = p;\n+                goto done;\n+            default:\n+                if (s->args.nelts <= 2) {\n+                    state = sw_argument;\n+                    s->arg_start = p;\n+                    break;\n+                }\n+                goto invalid;\n+            }\n+            break;\n+\n+        case sw_argument:\n+            switch (ch) {\n+\n+            case ' ':\n+\n+                /*\n+                 * the space should be considered as part of the at username\n+                 * or password, but not of argument in other commands\n+                 */\n+\n+                if (s->command == NGX_POP3_USER\n+                    || s->command == NGX_POP3_PASS)\n+                {\n+                    break;\n+                }\n+\n+                /* fall through */\n+\n+            case CR:\n+            case LF:\n+                arg = ngx_array_push(&s->args);\n+                if (arg == NULL) {\n+                    return NGX_ERROR;\n+                }\n+                arg->len = p - s->arg_start;\n+                arg->data = s->arg_start;\n+                s->arg_start = NULL;\n+\n+                switch (ch) {\n+                case ' ':\n+                    state = sw_spaces_before_argument;\n+                    break;\n+                case CR:\n+                    state = sw_almost_done;\n+                    break;\n+                case LF:\n+                    goto done;\n+                }\n+                break;\n+\n+            default:\n+                break;\n+            }\n+            break;\n+\n+        case sw_almost_done:\n+            switch (ch) {\n+            case LF:\n+                goto done;\n+            default:\n+                goto invalid;\n+            }\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+    s->state = state;\n+\n+    return NGX_AGAIN;\n+\n+done:\n+\n+    s->buffer->pos = p + 1;\n+\n+    if (s->arg_start) {\n+        arg = ngx_array_push(&s->args);\n+        if (arg == NULL) {\n+            return NGX_ERROR;\n+        }\n+        arg->len = s->arg_end - s->arg_start;\n+        arg->data = s->arg_start;\n+        s->arg_start = NULL;\n+    }\n+\n+    s->state = (s->command != NGX_POP3_AUTH) ? sw_start : sw_argument;\n+\n+    return NGX_OK;\n+\n+invalid:\n+\n+    s->state = sw_start;\n+    s->arg_start = NULL;\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n+{\n+    u_char      ch, *p, *c;\n+    ngx_str_t  *arg;\n+    enum {\n+        sw_start = 0,\n+        sw_spaces_before_command,\n+        sw_command,\n+        sw_spaces_before_argument,\n+        sw_argument,\n+        sw_backslash,\n+        sw_literal,\n+        sw_no_sync_literal_argument,\n+        sw_start_literal_argument,\n+        sw_literal_argument,\n+        sw_end_literal_argument,\n+        sw_almost_done\n+    } state;\n+\n+    state = s->state;\n+\n+    for (p = s->buffer->pos; p < s->buffer->last; p++) {\n+        ch = *p;\n+\n+        switch (state) {\n+\n+        /* IMAP tag */\n+        case sw_start:\n+            switch (ch) {\n+            case ' ':\n+                s->tag.len = p - s->buffer->start + 1;\n+                s->tag.data = s->buffer->start;\n+                state = sw_spaces_before_command;\n+                break;\n+            case CR:\n+                s->state = sw_start;\n+                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            case LF:\n+                s->state = sw_start;\n+                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            }\n+            break;\n+\n+        case sw_spaces_before_command:\n+            switch (ch) {\n+            case ' ':\n+                break;\n+            case CR:\n+                s->state = sw_start;\n+                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            case LF:\n+                s->state = sw_start;\n+                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            default:\n+                s->cmd_start = p;\n+                state = sw_command;\n+                break;\n+            }\n+            break;\n+\n+        case sw_command:\n+            if (ch == ' ' || ch == CR || ch == LF) {\n+\n+                c = s->cmd_start;\n+\n+                switch (p - c) {\n+\n+                case 4:\n+                    if ((c[0] == 'N' || c[0] == 'n')\n+                        && (c[1] == 'O'|| c[1] == 'o')\n+                        && (c[2] == 'O'|| c[2] == 'o')\n+                        && (c[3] == 'P'|| c[3] == 'p'))\n+                    {\n+                        s->command = NGX_IMAP_NOOP;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+                    break;\n+\n+                case 5:\n+                    if ((c[0] == 'L'|| c[0] == 'l')\n+                        && (c[1] == 'O'|| c[1] == 'o')\n+                        && (c[2] == 'G'|| c[2] == 'g')\n+                        && (c[3] == 'I'|| c[3] == 'i')\n+                        && (c[4] == 'N'|| c[4] == 'n'))\n+                    {\n+                        s->command = NGX_IMAP_LOGIN;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+                    break;\n+\n+                case 6:\n+                    if ((c[0] == 'L'|| c[0] == 'l')\n+                        && (c[1] == 'O'|| c[1] == 'o')\n+                        && (c[2] == 'G'|| c[2] == 'g')\n+                        && (c[3] == 'O'|| c[3] == 'o')\n+                        && (c[4] == 'U'|| c[4] == 'u')\n+                        && (c[5] == 'T'|| c[5] == 't'))\n+                    {\n+                        s->command = NGX_IMAP_LOGOUT;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+                    break;\n+\n+#if (NGX_MAIL_SSL)\n+                case 8:\n+                    if ((c[0] == 'S'|| c[0] == 's')\n+                        && (c[1] == 'T'|| c[1] == 't')\n+                        && (c[2] == 'A'|| c[2] == 'a')\n+                        && (c[3] == 'R'|| c[3] == 'r')\n+                        && (c[4] == 'T'|| c[4] == 't')\n+                        && (c[5] == 'T'|| c[5] == 't')\n+                        && (c[6] == 'L'|| c[6] == 'l')\n+                        && (c[7] == 'S'|| c[7] == 's'))\n+                    {\n+                        s->command = NGX_IMAP_STARTTLS;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+                    break;\n+#endif\n+\n+                case 10:\n+                    if ((c[0] == 'C'|| c[0] == 'c')\n+                        && (c[1] == 'A'|| c[1] == 'a')\n+                        && (c[2] == 'P'|| c[2] == 'p')\n+                        && (c[3] == 'A'|| c[3] == 'a')\n+                        && (c[4] == 'B'|| c[4] == 'b')\n+                        && (c[5] == 'I'|| c[5] == 'i')\n+                        && (c[6] == 'L'|| c[6] == 'l')\n+                        && (c[7] == 'I'|| c[7] == 'i')\n+                        && (c[8] == 'T'|| c[8] == 't')\n+                        && (c[9] == 'Y'|| c[9] == 'y'))\n+                    {\n+                        s->command = NGX_IMAP_CAPABILITY;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+                    break;\n+\n+                case 12:\n+                    if ((c[0] == 'A'|| c[0] == 'a')\n+                        && (c[1] == 'U'|| c[1] == 'u')\n+                        && (c[2] == 'T'|| c[2] == 't')\n+                        && (c[3] == 'H'|| c[3] == 'h')\n+                        && (c[4] == 'E'|| c[4] == 'e')\n+                        && (c[5] == 'N'|| c[5] == 'n')\n+                        && (c[6] == 'T'|| c[6] == 't')\n+                        && (c[7] == 'I'|| c[7] == 'i')\n+                        && (c[8] == 'C'|| c[8] == 'c')\n+                        && (c[9] == 'A'|| c[9] == 'a')\n+                        && (c[10] == 'T'|| c[10] == 't')\n+                        && (c[11] == 'E'|| c[11] == 'e'))\n+                    {\n+                        s->command = NGX_IMAP_AUTHENTICATE;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+                    break;\n+\n+                default:\n+                    goto invalid;\n+                }\n+\n+                switch (ch) {\n+                case ' ':\n+                    state = sw_spaces_before_argument;\n+                    break;\n+                case CR:\n+                    state = sw_almost_done;\n+                    break;\n+                case LF:\n+                    goto done;\n+                }\n+                break;\n+            }\n+\n+            if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')) {\n+                goto invalid;\n+            }\n+\n+            break;\n+\n+        case sw_spaces_before_argument:\n+            switch (ch) {\n+            case ' ':\n+                break;\n+            case CR:\n+                state = sw_almost_done;\n+                s->arg_end = p;\n+                break;\n+            case LF:\n+                s->arg_end = p;\n+                goto done;\n+            case '\"':\n+                if (s->args.nelts <= 2) {\n+                    s->quoted = 1;\n+                    s->arg_start = p + 1;\n+                    state = sw_argument;\n+                    break;\n+                }\n+                goto invalid;\n+            case '{':\n+                if (s->args.nelts <= 2) {\n+                    state = sw_literal;\n+                    break;\n+                }\n+                goto invalid;\n+            default:\n+                if (s->args.nelts <= 2) {\n+                    s->arg_start = p;\n+                    state = sw_argument;\n+                    break;\n+                }\n+                goto invalid;\n+            }\n+            break;\n+\n+        case sw_argument:\n+            if (ch == ' ' && s->quoted) {\n+                break;\n+            }\n+\n+            switch (ch) {\n+            case '\"':\n+                if (!s->quoted) {\n+                    break;\n+                }\n+                s->quoted = 0;\n+                /* fall through */\n+            case ' ':\n+            case CR:\n+            case LF:\n+                arg = ngx_array_push(&s->args);\n+                if (arg == NULL) {\n+                    return NGX_ERROR;\n+                }\n+                arg->len = p - s->arg_start;\n+                arg->data = s->arg_start;\n+                s->arg_start = NULL;\n+\n+                switch (ch) {\n+                case '\"':\n+                case ' ':\n+                    state = sw_spaces_before_argument;\n+                    break;\n+                case CR:\n+                    state = sw_almost_done;\n+                    break;\n+                case LF:\n+                    goto done;\n+                }\n+                break;\n+            case '\\\\':\n+                if (s->quoted) {\n+                    s->backslash = 1;\n+                    state = sw_backslash;\n+                }\n+                break;\n+            }\n+            break;\n+\n+        case sw_backslash:\n+            switch (ch) {\n+            case CR:\n+            case LF:\n+                goto invalid;\n+            default:\n+                state = sw_argument;\n+            }\n+            break;\n+\n+        case sw_literal:\n+            if (ch >= '0' && ch <= '9') {\n+                s->literal_len = s->literal_len * 10 + (ch - '0');\n+                break;\n+            }\n+            if (ch == '}') {\n+                state = sw_start_literal_argument;\n+                break;\n+            }\n+            if (ch == '+') {\n+                state = sw_no_sync_literal_argument;\n+                break;\n+            }\n+            goto invalid;\n+\n+        case sw_no_sync_literal_argument:\n+            if (ch == '}') {\n+                s->no_sync_literal = 1;\n+                state = sw_start_literal_argument;\n+                break;\n+            }\n+            goto invalid;\n+\n+        case sw_start_literal_argument:\n+            switch (ch) {\n+            case CR:\n+                break;\n+            case LF:\n+                s->buffer->pos = p + 1;\n+                s->arg_start = p + 1;\n+                if (s->no_sync_literal == 0) {\n+                    s->state = sw_literal_argument;\n+                    return NGX_IMAP_NEXT;\n+                }\n+                state = sw_literal_argument;\n+                s->no_sync_literal = 0;\n+                break;\n+            default:\n+                goto invalid;\n+            }\n+            break;\n+\n+        case sw_literal_argument:\n+            if (s->literal_len && --s->literal_len) {\n+                break;\n+            }\n+\n+            arg = ngx_array_push(&s->args);\n+            if (arg == NULL) {\n+                return NGX_ERROR;\n+            }\n+            arg->len = p + 1 - s->arg_start;\n+            arg->data = s->arg_start;\n+            s->arg_start = NULL;\n+            state = sw_end_literal_argument;\n+\n+            break;\n+\n+        case sw_end_literal_argument:\n+            switch (ch) {\n+            case '{':\n+                if (s->args.nelts <= 2) {\n+                    state = sw_literal;\n+                    break;\n+                }\n+                goto invalid;\n+            case CR:\n+                state = sw_almost_done;\n+                break;\n+            case LF:\n+                goto done;\n+            default:\n+                state = sw_spaces_before_argument;\n+                break;\n+            }\n+            break;\n+\n+        case sw_almost_done:\n+            switch (ch) {\n+            case LF:\n+                goto done;\n+            default:\n+                goto invalid;\n+            }\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+    s->state = state;\n+\n+    return NGX_AGAIN;\n+\n+done:\n+\n+    s->buffer->pos = p + 1;\n+\n+    if (s->arg_start) {\n+        arg = ngx_array_push(&s->args);\n+        if (arg == NULL) {\n+            return NGX_ERROR;\n+        }\n+        arg->len = s->arg_end - s->arg_start;\n+        arg->data = s->arg_start;\n+\n+        s->arg_start = NULL;\n+        s->cmd_start = NULL;\n+        s->quoted = 0;\n+        s->no_sync_literal = 0;\n+        s->literal_len = 0;\n+    }\n+\n+    s->state = (s->command != NGX_IMAP_AUTHENTICATE) ? sw_start : sw_argument;\n+\n+    return NGX_OK;\n+\n+invalid:\n+\n+    s->state = sw_start;\n+    s->quoted = 0;\n+    s->no_sync_literal = 0;\n+    s->literal_len = 0;\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n+{\n+    u_char      ch, *p, *c, c0, c1, c2, c3;\n+    ngx_str_t  *arg;\n+    enum {\n+        sw_start = 0,\n+        sw_command,\n+        sw_invalid,\n+        sw_spaces_before_argument,\n+        sw_argument,\n+        sw_almost_done\n+    } state;\n+\n+    state = s->state;\n+\n+    for (p = s->buffer->pos; p < s->buffer->last; p++) {\n+        ch = *p;\n+\n+        switch (state) {\n+\n+        /* SMTP command */\n+        case sw_start:\n+            s->cmd_start = p;\n+            state = sw_command;\n+\n+            /* fall through */\n+\n+        case sw_command:\n+            if (ch == ' ' || ch == CR || ch == LF) {\n+                c = s->cmd_start;\n+\n+                if (p - c == 4) {\n+\n+                    c0 = ngx_toupper(c[0]);\n+                    c1 = ngx_toupper(c[1]);\n+                    c2 = ngx_toupper(c[2]);\n+                    c3 = ngx_toupper(c[3]);\n+\n+                    if (c0 == 'H' && c1 == 'E' && c2 == 'L' && c3 == 'O')\n+                    {\n+                        s->command = NGX_SMTP_HELO;\n+\n+                    } else if (c0 == 'E' && c1 == 'H' && c2 == 'L' && c3 == 'O')\n+                    {\n+                        s->command = NGX_SMTP_EHLO;\n+\n+                    } else if (c0 == 'Q' && c1 == 'U' && c2 == 'I' && c3 == 'T')\n+                    {\n+                        s->command = NGX_SMTP_QUIT;\n+\n+                    } else if (c0 == 'A' && c1 == 'U' && c2 == 'T' && c3 == 'H')\n+                    {\n+                        s->command = NGX_SMTP_AUTH;\n+\n+                    } else if (c0 == 'N' && c1 == 'O' && c2 == 'O' && c3 == 'P')\n+                    {\n+                        s->command = NGX_SMTP_NOOP;\n+\n+                    } else if (c0 == 'M' && c1 == 'A' && c2 == 'I' && c3 == 'L')\n+                    {\n+                        s->command = NGX_SMTP_MAIL;\n+\n+                    } else if (c0 == 'R' && c1 == 'S' && c2 == 'E' && c3 == 'T')\n+                    {\n+                        s->command = NGX_SMTP_RSET;\n+\n+                    } else if (c0 == 'R' && c1 == 'C' && c2 == 'P' && c3 == 'T')\n+                    {\n+                        s->command = NGX_SMTP_RCPT;\n+\n+                    } else if (c0 == 'V' && c1 == 'R' && c2 == 'F' && c3 == 'Y')\n+                    {\n+                        s->command = NGX_SMTP_VRFY;\n+\n+                    } else if (c0 == 'E' && c1 == 'X' && c2 == 'P' && c3 == 'N')\n+                    {\n+                        s->command = NGX_SMTP_EXPN;\n+\n+                    } else if (c0 == 'H' && c1 == 'E' && c2 == 'L' && c3 == 'P')\n+                    {\n+                        s->command = NGX_SMTP_HELP;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+#if (NGX_MAIL_SSL)\n+                } else if (p - c == 8) {\n+\n+                    if ((c[0] == 'S'|| c[0] == 's')\n+                        && (c[1] == 'T'|| c[1] == 't')\n+                        && (c[2] == 'A'|| c[2] == 'a')\n+                        && (c[3] == 'R'|| c[3] == 'r')\n+                        && (c[4] == 'T'|| c[4] == 't')\n+                        && (c[5] == 'T'|| c[5] == 't')\n+                        && (c[6] == 'L'|| c[6] == 'l')\n+                        && (c[7] == 'S'|| c[7] == 's'))\n+                    {\n+                        s->command = NGX_SMTP_STARTTLS;\n+\n+                    } else {\n+                        goto invalid;\n+                    }\n+#endif\n+                } else {\n+                    goto invalid;\n+                }\n+\n+                s->cmd.data = s->cmd_start;\n+                s->cmd.len = p - s->cmd_start;\n+\n+                switch (ch) {\n+                case ' ':\n+                    state = sw_spaces_before_argument;\n+                    break;\n+                case CR:\n+                    state = sw_almost_done;\n+                    break;\n+                case LF:\n+                    goto done;\n+                }\n+                break;\n+            }\n+\n+            if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')) {\n+                goto invalid;\n+            }\n+\n+            break;\n+\n+        case sw_invalid:\n+            goto invalid;\n+\n+        case sw_spaces_before_argument:\n+            switch (ch) {\n+            case ' ':\n+                break;\n+            case CR:\n+                state = sw_almost_done;\n+                s->arg_end = p;\n+                break;\n+            case LF:\n+                s->arg_end = p;\n+                goto done;\n+            default:\n+                if (s->args.nelts <= 10) {\n+                    state = sw_argument;\n+                    s->arg_start = p;\n+                    break;\n+                }\n+                goto invalid;\n+            }\n+            break;\n+\n+        case sw_argument:\n+            switch (ch) {\n+            case ' ':\n+            case CR:\n+            case LF:\n+                arg = ngx_array_push(&s->args);\n+                if (arg == NULL) {\n+                    return NGX_ERROR;\n+                }\n+                arg->len = p - s->arg_start;\n+                arg->data = s->arg_start;\n+                s->arg_start = NULL;\n+\n+                switch (ch) {\n+                case ' ':\n+                    state = sw_spaces_before_argument;\n+                    break;\n+                case CR:\n+                    state = sw_almost_done;\n+                    break;\n+                case LF:\n+                    goto done;\n+                }\n+                break;\n+\n+            default:\n+                break;\n+            }\n+            break;\n+\n+        case sw_almost_done:\n+            switch (ch) {\n+            case LF:\n+                goto done;\n+            default:\n+                goto invalid;\n+            }\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+    s->state = state;\n+\n+    return NGX_AGAIN;\n+\n+done:\n+\n+    s->buffer->pos = p + 1;\n+\n+    if (s->arg_start) {\n+        arg = ngx_array_push(&s->args);\n+        if (arg == NULL) {\n+            return NGX_ERROR;\n+        }\n+        arg->len = s->arg_end - s->arg_start;\n+        arg->data = s->arg_start;\n+        s->arg_start = NULL;\n+    }\n+\n+    s->state = (s->command != NGX_SMTP_AUTH) ? sw_start : sw_argument;\n+\n+    return NGX_OK;\n+\n+invalid:\n+\n+    s->state = sw_invalid;\n+    s->arg_start = NULL;\n+\n+    /* skip invalid command till LF */\n+\n+    for (p = s->buffer->pos; p < s->buffer->last; p++) {\n+        if (*p == LF) {\n+            s->state = sw_start;\n+            p++;\n+            break;\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\n+\n+\n+ngx_int_t\n+ngx_mail_auth_parse(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t                 *arg;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    if (s->args.nelts == 0) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    arg = s->args.elts;\n+\n+    if (arg[0].len == 5) {\n+\n+        if (ngx_strncasecmp(arg[0].data, (u_char *) \"LOGIN\", 5) == 0) {\n+\n+            if (s->args.nelts == 1) {\n+                return NGX_MAIL_AUTH_LOGIN;\n+            }\n+\n+            if (s->args.nelts == 2) {\n+                return NGX_MAIL_AUTH_LOGIN_USERNAME;\n+            }\n+\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        if (ngx_strncasecmp(arg[0].data, (u_char *) \"PLAIN\", 5) == 0) {\n+\n+            if (s->args.nelts == 1) {\n+                return NGX_MAIL_AUTH_PLAIN;\n+            }\n+\n+            if (s->args.nelts == 2) {\n+                return ngx_mail_auth_plain(s, c, 1);\n+            }\n+        }\n+\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    if (arg[0].len == 8) {\n+\n+        if (ngx_strncasecmp(arg[0].data, (u_char *) \"CRAM-MD5\", 8) == 0) {\n+\n+            if (s->args.nelts != 1) {\n+                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            }\n+\n+            return NGX_MAIL_AUTH_CRAM_MD5;\n+        }\n+\n+        if (ngx_strncasecmp(arg[0].data, (u_char *) \"EXTERNAL\", 8) == 0) {\n+\n+            if (s->args.nelts == 1) {\n+                return NGX_MAIL_AUTH_EXTERNAL;\n+            }\n+\n+            if (s->args.nelts == 2) {\n+                return ngx_mail_auth_external(s, c, 1);\n+            }\n+        }\n+\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\nDiff:\n@@ -0,0 +1,515 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_pop3_module.h>\n+\n+\n+static ngx_int_t ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c,\n+    ngx_int_t stls);\n+static ngx_int_t ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);\n+\n+\n+static u_char  pop3_greeting[] = \"+OK POP3 ready\" CRLF;\n+static u_char  pop3_ok[] = \"+OK\" CRLF;\n+static u_char  pop3_next[] = \"+ \" CRLF;\n+static u_char  pop3_username[] = \"+ VXNlcm5hbWU6\" CRLF;\n+static u_char  pop3_password[] = \"+ UGFzc3dvcmQ6\" CRLF;\n+static u_char  pop3_invalid_command[] = \"-ERR invalid command\" CRLF;\n+\n+\n+void\n+ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    u_char                    *p;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+    ngx_mail_pop3_srv_conf_t  *pscf;\n+\n+    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    if (pscf->auth_methods\n+        & (NGX_MAIL_AUTH_APOP_ENABLED|NGX_MAIL_AUTH_CRAM_MD5_ENABLED))\n+    {\n+        if (ngx_mail_salt(s, c, cscf) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_greeting) + s->salt.len);\n+        if (s->out.data == NULL) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(s->out.data, pop3_greeting, sizeof(pop3_greeting) - 3);\n+        *p++ = ' ';\n+        p = ngx_cpymem(p, s->salt.data, s->salt.len);\n+\n+        s->out.len = p - s->out.data;\n+\n+    } else {\n+        ngx_str_set(&s->out, pop3_greeting);\n+    }\n+\n+    c->read->handler = ngx_mail_pop3_init_protocol;\n+\n+    ngx_add_timer(c->read, cscf->timeout);\n+\n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+    }\n+\n+    ngx_mail_send(c->write);\n+}\n+\n+\n+void\n+ngx_mail_pop3_init_protocol(ngx_event_t *rev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+\n+    c->log->action = \"in auth state\";\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    s = c->data;\n+\n+    if (s->buffer == NULL) {\n+        if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t))\n+            == NGX_ERROR)\n+        {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        s->buffer = ngx_create_temp_buf(c->pool, 128);\n+        if (s->buffer == NULL) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+    }\n+\n+    s->mail_state = ngx_pop3_start;\n+    c->read->handler = ngx_mail_pop3_auth_state;\n+\n+    ngx_mail_pop3_auth_state(rev);\n+}\n+\n+\n+void\n+ngx_mail_pop3_auth_state(ngx_event_t *rev)\n+{\n+    ngx_int_t            rc;\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"pop3 auth state\");\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (s->out.len) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"pop3 send handler busy\");\n+        s->blocked = 1;\n+        return;\n+    }\n+\n+    s->blocked = 0;\n+\n+    rc = ngx_mail_read_command(s, c);\n+\n+    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+        return;\n+    }\n+\n+    ngx_str_set(&s->out, pop3_ok);\n+\n+    if (rc == NGX_OK) {\n+        switch (s->mail_state) {\n+\n+        case ngx_pop3_start:\n+\n+            switch (s->command) {\n+\n+            case NGX_POP3_USER:\n+                rc = ngx_mail_pop3_user(s, c);\n+                break;\n+\n+            case NGX_POP3_CAPA:\n+                rc = ngx_mail_pop3_capa(s, c, 1);\n+                break;\n+\n+            case NGX_POP3_APOP:\n+                rc = ngx_mail_pop3_apop(s, c);\n+                break;\n+\n+            case NGX_POP3_AUTH:\n+                rc = ngx_mail_pop3_auth(s, c);\n+                break;\n+\n+            case NGX_POP3_QUIT:\n+                s->quit = 1;\n+                break;\n+\n+            case NGX_POP3_NOOP:\n+                break;\n+\n+            case NGX_POP3_STLS:\n+                rc = ngx_mail_pop3_stls(s, c);\n+                break;\n+\n+            default:\n+                rc = NGX_MAIL_PARSE_INVALID_COMMAND;\n+                break;\n+            }\n+\n+            break;\n+\n+        case ngx_pop3_user:\n+\n+            switch (s->command) {\n+\n+            case NGX_POP3_PASS:\n+                rc = ngx_mail_pop3_pass(s, c);\n+                break;\n+\n+            case NGX_POP3_CAPA:\n+                rc = ngx_mail_pop3_capa(s, c, 0);\n+                break;\n+\n+            case NGX_POP3_QUIT:\n+                s->quit = 1;\n+                break;\n+\n+            case NGX_POP3_NOOP:\n+                break;\n+\n+            default:\n+                rc = NGX_MAIL_PARSE_INVALID_COMMAND;\n+                break;\n+            }\n+\n+            break;\n+\n+        /* suppress warnings */\n+        case ngx_pop3_passwd:\n+            break;\n+\n+        case ngx_pop3_auth_login_username:\n+            rc = ngx_mail_auth_login_username(s, c, 0);\n+\n+            ngx_str_set(&s->out, pop3_password);\n+            s->mail_state = ngx_pop3_auth_login_password;\n+            break;\n+\n+        case ngx_pop3_auth_login_password:\n+            rc = ngx_mail_auth_login_password(s, c);\n+            break;\n+\n+        case ngx_pop3_auth_plain:\n+            rc = ngx_mail_auth_plain(s, c, 0);\n+            break;\n+\n+        case ngx_pop3_auth_cram_md5:\n+            rc = ngx_mail_auth_cram_md5(s, c);\n+            break;\n+\n+        case ngx_pop3_auth_external:\n+            rc = ngx_mail_auth_external(s, c, 0);\n+            break;\n+        }\n+    }\n+\n+    switch (rc) {\n+\n+    case NGX_DONE:\n+        ngx_mail_auth(s, c);\n+        return;\n+\n+    case NGX_ERROR:\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+\n+    case NGX_MAIL_PARSE_INVALID_COMMAND:\n+        s->mail_state = ngx_pop3_start;\n+        s->state = 0;\n+\n+        ngx_str_set(&s->out, pop3_invalid_command);\n+\n+        /* fall through */\n+\n+    case NGX_OK:\n+\n+        s->args.nelts = 0;\n+        s->buffer->pos = s->buffer->start;\n+        s->buffer->last = s->buffer->start;\n+\n+        if (s->state) {\n+            s->arg_start = s->buffer->start;\n+        }\n+\n+        ngx_mail_send(c->write);\n+    }\n+}\n+\n+static ngx_int_t\n+ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t  *arg;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    if (s->args.nelts != 1) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    arg = s->args.elts;\n+    s->login.len = arg[0].len;\n+    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n+    if (s->login.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->login.data, arg[0].data, s->login.len);\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"pop3 login: \\\"%V\\\"\", &s->login);\n+\n+    s->mail_state = ngx_pop3_user;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t  *arg;\n+\n+    if (s->args.nelts != 1) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    arg = s->args.elts;\n+    s->passwd.len = arg[0].len;\n+    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);\n+    if (s->passwd.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->passwd.data, arg[0].data, s->passwd.len);\n+\n+#if (NGX_DEBUG_MAIL_PASSWD)\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"pop3 passwd: \\\"%V\\\"\", &s->passwd);\n+#endif\n+\n+    return NGX_DONE;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c, ngx_int_t stls)\n+{\n+    ngx_mail_pop3_srv_conf_t  *pscf;\n+\n+    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);\n+\n+#if (NGX_MAIL_SSL)\n+\n+    if (stls && c->ssl == NULL) {\n+        ngx_mail_ssl_conf_t  *sslcf;\n+\n+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+        if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {\n+            s->out = pscf->starttls_capability;\n+            return NGX_OK;\n+        }\n+\n+        if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {\n+            s->out = pscf->starttls_only_capability;\n+            return NGX_OK;\n+        }\n+    }\n+\n+#endif\n+\n+    s->out = pscf->capability;\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+#if (NGX_MAIL_SSL)\n+    ngx_mail_ssl_conf_t  *sslcf;\n+\n+    if (c->ssl == NULL) {\n+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+        if (sslcf->starttls) {\n+            c->read->handler = ngx_mail_starttls_handler;\n+            return NGX_OK;\n+        }\n+    }\n+\n+#endif\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t                 *arg;\n+    ngx_mail_pop3_srv_conf_t  *pscf;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    if (s->args.nelts != 2) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);\n+\n+    if (!(pscf->auth_methods & NGX_MAIL_AUTH_APOP_ENABLED)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+\n+    arg = s->args.elts;\n+\n+    s->login.len = arg[0].len;\n+    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n+    if (s->login.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->login.data, arg[0].data, s->login.len);\n+\n+    s->passwd.len = arg[1].len;\n+    s->passwd.data = ngx_pnalloc(c->pool, s->passwd.len);\n+    if (s->passwd.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->passwd.data, arg[1].data, s->passwd.len);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"pop3 apop: \\\"%V\\\" \\\"%V\\\"\", &s->login, &s->passwd);\n+\n+    s->auth_method = NGX_MAIL_AUTH_APOP;\n+\n+    return NGX_DONE;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_int_t                  rc;\n+    ngx_mail_pop3_srv_conf_t  *pscf;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    pscf = ngx_mail_get_module_srv_conf(s, ngx_mail_pop3_module);\n+\n+    if (s->args.nelts == 0) {\n+        s->out = pscf->auth_capability;\n+        s->state = 0;\n+\n+        return NGX_OK;\n+    }\n+\n+    rc = ngx_mail_auth_parse(s, c);\n+\n+    switch (rc) {\n+\n+    case NGX_MAIL_AUTH_LOGIN:\n+\n+        ngx_str_set(&s->out, pop3_username);\n+        s->mail_state = ngx_pop3_auth_login_username;\n+\n+        return NGX_OK;\n+\n+    case NGX_MAIL_AUTH_LOGIN_USERNAME:\n+\n+        ngx_str_set(&s->out, pop3_password);\n+        s->mail_state = ngx_pop3_auth_login_password;\n+\n+        return ngx_mail_auth_login_username(s, c, 1);\n+\n+    case NGX_MAIL_AUTH_PLAIN:\n+\n+        ngx_str_set(&s->out, pop3_next);\n+        s->mail_state = ngx_pop3_auth_plain;\n+\n+        return NGX_OK;\n+\n+    case NGX_MAIL_AUTH_CRAM_MD5:\n+\n+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        if (ngx_mail_auth_cram_md5_salt(s, c, \"+ \", 2) == NGX_OK) {\n+            s->mail_state = ngx_pop3_auth_cram_md5;\n+            return NGX_OK;\n+        }\n+\n+        return NGX_ERROR;\n+\n+    case NGX_MAIL_AUTH_EXTERNAL:\n+\n+        if (!(pscf->auth_methods & NGX_MAIL_AUTH_EXTERNAL_ENABLED)) {\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        ngx_str_set(&s->out, pop3_username);\n+        s->mail_state = ngx_pop3_auth_external;\n+\n+        return NGX_OK;\n+    }\n+\n+    return rc;\n+}\nDiff:\n@@ -0,0 +1,322 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_pop3_module.h>\n+\n+\n+static void *ngx_mail_pop3_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+\n+\n+static ngx_str_t  ngx_mail_pop3_default_capabilities[] = {\n+    ngx_string(\"TOP\"),\n+    ngx_string(\"USER\"),\n+    ngx_string(\"UIDL\"),\n+    ngx_null_string\n+};\n+\n+\n+static ngx_conf_bitmask_t  ngx_mail_pop3_auth_methods[] = {\n+    { ngx_string(\"plain\"), NGX_MAIL_AUTH_PLAIN_ENABLED },\n+    { ngx_string(\"apop\"), NGX_MAIL_AUTH_APOP_ENABLED },\n+    { ngx_string(\"cram-md5\"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },\n+    { ngx_string(\"external\"), NGX_MAIL_AUTH_EXTERNAL_ENABLED },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+static ngx_str_t  ngx_mail_pop3_auth_methods_names[] = {\n+    ngx_string(\"PLAIN\"),\n+    ngx_string(\"LOGIN\"),\n+    ngx_null_string,  /* APOP */\n+    ngx_string(\"CRAM-MD5\"),\n+    ngx_string(\"EXTERNAL\"),\n+    ngx_null_string   /* NONE */\n+};\n+\n+\n+static ngx_mail_protocol_t  ngx_mail_pop3_protocol = {\n+    ngx_string(\"pop3\"),\n+    { 110, 995, 0, 0 },\n+    NGX_MAIL_POP3_PROTOCOL,\n+\n+    ngx_mail_pop3_init_session,\n+    ngx_mail_pop3_init_protocol,\n+    ngx_mail_pop3_parse_command,\n+    ngx_mail_pop3_auth_state,\n+\n+    ngx_string(\"-ERR internal server error\" CRLF),\n+    ngx_string(\"-ERR SSL certificate error\" CRLF),\n+    ngx_string(\"-ERR No required SSL certificate\" CRLF)\n+};\n+\n+\n+static ngx_command_t  ngx_mail_pop3_commands[] = {\n+\n+    { ngx_string(\"pop3_capabilities\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_mail_capabilities,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_pop3_srv_conf_t, capabilities),\n+      NULL },\n+\n+    { ngx_string(\"pop3_auth\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_conf_set_bitmask_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_pop3_srv_conf_t, auth_methods),\n+      &ngx_mail_pop3_auth_methods },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_pop3_module_ctx = {\n+    &ngx_mail_pop3_protocol,               /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_pop3_create_srv_conf,         /* create server configuration */\n+    ngx_mail_pop3_merge_srv_conf           /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_pop3_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_pop3_module_ctx,             /* module context */\n+    ngx_mail_pop3_commands,                /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static void *\n+ngx_mail_pop3_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_pop3_srv_conf_t  *pscf;\n+\n+    pscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_pop3_srv_conf_t));\n+    if (pscf == NULL) {\n+        return NULL;\n+    }\n+\n+    if (ngx_array_init(&pscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))\n+        != NGX_OK)\n+    {\n+        return NULL;\n+    }\n+\n+    return pscf;\n+}\n+\n+\n+static char *\n+ngx_mail_pop3_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_pop3_srv_conf_t *prev = parent;\n+    ngx_mail_pop3_srv_conf_t *conf = child;\n+\n+    u_char      *p;\n+    size_t       size, stls_only_size;\n+    ngx_str_t   *c, *d;\n+    ngx_uint_t   i, m;\n+\n+    ngx_conf_merge_bitmask_value(conf->auth_methods,\n+                                 prev->auth_methods,\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_MAIL_AUTH_PLAIN_ENABLED));\n+\n+    if (conf->auth_methods & NGX_MAIL_AUTH_PLAIN_ENABLED) {\n+        conf->auth_methods |= NGX_MAIL_AUTH_LOGIN_ENABLED;\n+    }\n+\n+    if (conf->capabilities.nelts == 0) {\n+        conf->capabilities = prev->capabilities;\n+    }\n+\n+    if (conf->capabilities.nelts == 0) {\n+\n+        for (d = ngx_mail_pop3_default_capabilities; d->len; d++) {\n+            c = ngx_array_push(&conf->capabilities);\n+            if (c == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            *c = *d;\n+        }\n+    }\n+\n+    size = sizeof(\"+OK Capability list follows\" CRLF) - 1\n+           + sizeof(\".\" CRLF) - 1;\n+\n+    stls_only_size = size + sizeof(\"STLS\" CRLF) - 1;\n+\n+    c = conf->capabilities.elts;\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        size += c[i].len + sizeof(CRLF) - 1;\n+\n+        if (ngx_strcasecmp(c[i].data, (u_char *) \"USER\") == 0) {\n+            continue;\n+        }\n+\n+        stls_only_size += c[i].len + sizeof(CRLF) - 1;\n+    }\n+\n+    size += sizeof(\"SASL\") - 1 + sizeof(CRLF) - 1;\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (ngx_mail_pop3_auth_methods_names[i].len == 0) {\n+            continue;\n+        }\n+\n+        if (m & conf->auth_methods) {\n+            size += 1 + ngx_mail_pop3_auth_methods_names[i].len;\n+        }\n+    }\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->capability.len = size;\n+    conf->capability.data = p;\n+\n+    p = ngx_cpymem(p, \"+OK Capability list follows\" CRLF,\n+                   sizeof(\"+OK Capability list follows\" CRLF) - 1);\n+\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        p = ngx_cpymem(p, c[i].data, c[i].len);\n+        *p++ = CR; *p++ = LF;\n+    }\n+\n+    p = ngx_cpymem(p, \"SASL\", sizeof(\"SASL\") - 1);\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (ngx_mail_pop3_auth_methods_names[i].len == 0) {\n+            continue;\n+        }\n+\n+        if (m & conf->auth_methods) {\n+            *p++ = ' ';\n+            p = ngx_cpymem(p, ngx_mail_pop3_auth_methods_names[i].data,\n+                           ngx_mail_pop3_auth_methods_names[i].len);\n+        }\n+    }\n+\n+    *p++ = CR; *p++ = LF;\n+\n+    *p++ = '.'; *p++ = CR; *p = LF;\n+\n+\n+    size += sizeof(\"STLS\" CRLF) - 1;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->starttls_capability.len = size;\n+    conf->starttls_capability.data = p;\n+\n+    p = ngx_cpymem(p, conf->capability.data,\n+                   conf->capability.len - (sizeof(\".\" CRLF) - 1));\n+\n+    p = ngx_cpymem(p, \"STLS\" CRLF, sizeof(\"STLS\" CRLF) - 1);\n+    *p++ = '.'; *p++ = CR; *p = LF;\n+\n+\n+    size = sizeof(\"+OK methods supported:\" CRLF) - 1\n+           + sizeof(\".\" CRLF) - 1;\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (ngx_mail_pop3_auth_methods_names[i].len == 0) {\n+            continue;\n+        }\n+\n+        if (m & conf->auth_methods) {\n+            size += ngx_mail_pop3_auth_methods_names[i].len\n+                    + sizeof(CRLF) - 1;\n+        }\n+    }\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->auth_capability.data = p;\n+    conf->auth_capability.len = size;\n+\n+    p = ngx_cpymem(p, \"+OK methods supported:\" CRLF,\n+                   sizeof(\"+OK methods supported:\" CRLF) - 1);\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (ngx_mail_pop3_auth_methods_names[i].len == 0) {\n+            continue;\n+        }\n+\n+        if (m & conf->auth_methods) {\n+            p = ngx_cpymem(p, ngx_mail_pop3_auth_methods_names[i].data,\n+                           ngx_mail_pop3_auth_methods_names[i].len);\n+            *p++ = CR; *p++ = LF;\n+        }\n+    }\n+\n+    *p++ = '.'; *p++ = CR; *p = LF;\n+\n+\n+    p = ngx_pnalloc(cf->pool, stls_only_size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->starttls_only_capability.len = stls_only_size;\n+    conf->starttls_only_capability.data = p;\n+\n+    p = ngx_cpymem(p, \"+OK Capability list follows\" CRLF,\n+                   sizeof(\"+OK Capability list follows\" CRLF) - 1);\n+\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        if (ngx_strcasecmp(c[i].data, (u_char *) \"USER\") == 0) {\n+            continue;\n+        }\n+\n+        p = ngx_cpymem(p, c[i].data, c[i].len);\n+        *p++ = CR; *p++ = LF;\n+    }\n+\n+    p = ngx_cpymem(p, \"STLS\" CRLF, sizeof(\"STLS\" CRLF) - 1);\n+    *p++ = '.'; *p++ = CR; *p = LF;\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -0,0 +1,38 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_MAIL_POP3_MODULE_H_INCLUDED_\n+#define _NGX_MAIL_POP3_MODULE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+\n+\n+typedef struct {\n+    ngx_str_t    capability;\n+    ngx_str_t    starttls_capability;\n+    ngx_str_t    starttls_only_capability;\n+    ngx_str_t    auth_capability;\n+\n+    ngx_uint_t   auth_methods;\n+\n+    ngx_array_t  capabilities;\n+} ngx_mail_pop3_srv_conf_t;\n+\n+\n+void ngx_mail_pop3_init_session(ngx_mail_session_t *s, ngx_connection_t *c);\n+void ngx_mail_pop3_init_protocol(ngx_event_t *rev);\n+void ngx_mail_pop3_auth_state(ngx_event_t *rev);\n+ngx_int_t ngx_mail_pop3_parse_command(ngx_mail_session_t *s);\n+\n+\n+extern ngx_module_t  ngx_mail_pop3_module;\n+\n+\n+#endif /* _NGX_MAIL_POP3_MODULE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,1126 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_event_connect.h>\n+#include <ngx_mail.h>\n+\n+\n+typedef struct {\n+    ngx_flag_t  enable;\n+    ngx_flag_t  pass_error_message;\n+    ngx_flag_t  xclient;\n+    size_t      buffer_size;\n+    ngx_msec_t  timeout;\n+} ngx_mail_proxy_conf_t;\n+\n+\n+static void ngx_mail_proxy_block_read(ngx_event_t *rev);\n+static void ngx_mail_proxy_pop3_handler(ngx_event_t *rev);\n+static void ngx_mail_proxy_imap_handler(ngx_event_t *rev);\n+static void ngx_mail_proxy_smtp_handler(ngx_event_t *rev);\n+static void ngx_mail_proxy_dummy_handler(ngx_event_t *ev);\n+static ngx_int_t ngx_mail_proxy_read_response(ngx_mail_session_t *s,\n+    ngx_uint_t state);\n+static void ngx_mail_proxy_handler(ngx_event_t *ev);\n+static void ngx_mail_proxy_upstream_error(ngx_mail_session_t *s);\n+static void ngx_mail_proxy_internal_server_error(ngx_mail_session_t *s);\n+static void ngx_mail_proxy_close_session(ngx_mail_session_t *s);\n+static void *ngx_mail_proxy_create_conf(ngx_conf_t *cf);\n+static char *ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+\n+\n+static ngx_command_t  ngx_mail_proxy_commands[] = {\n+\n+    { ngx_string(\"proxy\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, enable),\n+      NULL },\n+\n+    { ngx_string(\"proxy_buffer\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_size_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, buffer_size),\n+      NULL },\n+\n+    { ngx_string(\"proxy_timeout\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, timeout),\n+      NULL },\n+\n+    { ngx_string(\"proxy_pass_error_message\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, pass_error_message),\n+      NULL },\n+\n+    { ngx_string(\"xclient\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, xclient),\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_proxy_module_ctx = {\n+    NULL,                                  /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_proxy_create_conf,            /* create server configuration */\n+    ngx_mail_proxy_merge_conf              /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_proxy_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_proxy_module_ctx,            /* module context */\n+    ngx_mail_proxy_commands,               /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static u_char  smtp_auth_ok[] = \"235 2.0.0 OK\" CRLF;\n+\n+\n+void\n+ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n+{\n+    ngx_int_t                  rc;\n+    ngx_mail_proxy_ctx_t      *p;\n+    ngx_mail_proxy_conf_t     *pcf;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    s->connection->log->action = \"connecting to upstream\";\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    p = ngx_pcalloc(s->connection->pool, sizeof(ngx_mail_proxy_ctx_t));\n+    if (p == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    s->proxy = p;\n+\n+    p->upstream.sockaddr = peer->sockaddr;\n+    p->upstream.socklen = peer->socklen;\n+    p->upstream.name = &peer->name;\n+    p->upstream.get = ngx_event_get_peer;\n+    p->upstream.log = s->connection->log;\n+    p->upstream.log_error = NGX_ERROR_ERR;\n+\n+    rc = ngx_event_connect_peer(&p->upstream);\n+\n+    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    ngx_add_timer(p->upstream.connection->read, cscf->timeout);\n+\n+    p->upstream.connection->data = s;\n+    p->upstream.connection->pool = s->connection->pool;\n+\n+    s->connection->read->handler = ngx_mail_proxy_block_read;\n+    p->upstream.connection->write->handler = ngx_mail_proxy_dummy_handler;\n+\n+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+    s->proxy->buffer = ngx_create_temp_buf(s->connection->pool,\n+                                           pcf->buffer_size);\n+    if (s->proxy->buffer == NULL) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    s->out.len = 0;\n+\n+    switch (s->protocol) {\n+\n+    case NGX_MAIL_POP3_PROTOCOL:\n+        p->upstream.connection->read->handler = ngx_mail_proxy_pop3_handler;\n+        s->mail_state = ngx_pop3_start;\n+        break;\n+\n+    case NGX_MAIL_IMAP_PROTOCOL:\n+        p->upstream.connection->read->handler = ngx_mail_proxy_imap_handler;\n+        s->mail_state = ngx_imap_start;\n+        break;\n+\n+    default: /* NGX_MAIL_SMTP_PROTOCOL */\n+        p->upstream.connection->read->handler = ngx_mail_proxy_smtp_handler;\n+        s->mail_state = ngx_smtp_start;\n+        break;\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_proxy_block_read(ngx_event_t *rev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, \"mail proxy block read\");\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        c = rev->data;\n+        s = c->data;\n+\n+        ngx_mail_proxy_close_session(s);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n+{\n+    u_char                 *p;\n+    ngx_int_t               rc;\n+    ngx_str_t               line;\n+    ngx_connection_t       *c;\n+    ngx_mail_session_t     *s;\n+    ngx_mail_proxy_conf_t  *pcf;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                   \"mail proxy pop3 auth handler\");\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n+                      \"upstream timed out\");\n+        c->timedout = 1;\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    rc = ngx_mail_proxy_read_response(s, 0);\n+\n+    if (rc == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n+        ngx_mail_proxy_upstream_error(s);\n+        return;\n+    }\n+\n+    switch (s->mail_state) {\n+\n+    case ngx_pop3_start:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, \"mail proxy send user\");\n+\n+        s->connection->log->action = \"sending user name to upstream\";\n+\n+        line.len = sizeof(\"USER \")  - 1 + s->login.len + 2;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(line.data, \"USER \", sizeof(\"USER \") - 1);\n+        p = ngx_cpymem(p, s->login.data, s->login.len);\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_pop3_user;\n+        break;\n+\n+    case ngx_pop3_user:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, \"mail proxy send pass\");\n+\n+        s->connection->log->action = \"sending password to upstream\";\n+\n+        line.len = sizeof(\"PASS \")  - 1 + s->passwd.len + 2;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(line.data, \"PASS \", sizeof(\"PASS \") - 1);\n+        p = ngx_cpymem(p, s->passwd.data, s->passwd.len);\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_pop3_passwd;\n+        break;\n+\n+    case ngx_pop3_passwd:\n+        s->connection->read->handler = ngx_mail_proxy_handler;\n+        s->connection->write->handler = ngx_mail_proxy_handler;\n+        rev->handler = ngx_mail_proxy_handler;\n+        c->write->handler = ngx_mail_proxy_handler;\n+\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+        ngx_add_timer(s->connection->read, pcf->timeout);\n+        ngx_del_timer(c->read);\n+\n+        c->log->action = NULL;\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n+\n+        ngx_mail_proxy_handler(s->connection->write);\n+\n+        return;\n+\n+    default:\n+#if (NGX_SUPPRESS_WARN)\n+        ngx_str_null(&line);\n+#endif\n+        break;\n+    }\n+\n+    if (c->send(c, line.data, line.len) < (ssize_t) line.len) {\n+        /*\n+         * we treat the incomplete sending as NGX_ERROR\n+         * because it is very strange here\n+         */\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    s->proxy->buffer->pos = s->proxy->buffer->start;\n+    s->proxy->buffer->last = s->proxy->buffer->start;\n+}\n+\n+\n+static void\n+ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n+{\n+    u_char                 *p;\n+    ngx_int_t               rc;\n+    ngx_str_t               line;\n+    ngx_connection_t       *c;\n+    ngx_mail_session_t     *s;\n+    ngx_mail_proxy_conf_t  *pcf;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                   \"mail proxy imap auth handler\");\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n+                      \"upstream timed out\");\n+        c->timedout = 1;\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    rc = ngx_mail_proxy_read_response(s, s->mail_state);\n+\n+    if (rc == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n+        ngx_mail_proxy_upstream_error(s);\n+        return;\n+    }\n+\n+    switch (s->mail_state) {\n+\n+    case ngx_imap_start:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send login\");\n+\n+        s->connection->log->action = \"sending LOGIN command to upstream\";\n+\n+        line.len = s->tag.len + sizeof(\"LOGIN \") - 1\n+                   + 1 + NGX_SIZE_T_LEN + 1 + 2;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        line.len = ngx_sprintf(line.data, \"%VLOGIN {%uz}\" CRLF,\n+                               &s->tag, s->login.len)\n+                   - line.data;\n+\n+        s->mail_state = ngx_imap_login;\n+        break;\n+\n+    case ngx_imap_login:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, \"mail proxy send user\");\n+\n+        s->connection->log->action = \"sending user name to upstream\";\n+\n+        line.len = s->login.len + 1 + 1 + NGX_SIZE_T_LEN + 1 + 2;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        line.len = ngx_sprintf(line.data, \"%V {%uz}\" CRLF,\n+                               &s->login, s->passwd.len)\n+                   - line.data;\n+\n+        s->mail_state = ngx_imap_user;\n+        break;\n+\n+    case ngx_imap_user:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send passwd\");\n+\n+        s->connection->log->action = \"sending password to upstream\";\n+\n+        line.len = s->passwd.len + 2;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(line.data, s->passwd.data, s->passwd.len);\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_imap_passwd;\n+        break;\n+\n+    case ngx_imap_passwd:\n+        s->connection->read->handler = ngx_mail_proxy_handler;\n+        s->connection->write->handler = ngx_mail_proxy_handler;\n+        rev->handler = ngx_mail_proxy_handler;\n+        c->write->handler = ngx_mail_proxy_handler;\n+\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+        ngx_add_timer(s->connection->read, pcf->timeout);\n+        ngx_del_timer(c->read);\n+\n+        c->log->action = NULL;\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n+\n+        ngx_mail_proxy_handler(s->connection->write);\n+\n+        return;\n+\n+    default:\n+#if (NGX_SUPPRESS_WARN)\n+        ngx_str_null(&line);\n+#endif\n+        break;\n+    }\n+\n+    if (c->send(c, line.data, line.len) < (ssize_t) line.len) {\n+        /*\n+         * we treat the incomplete sending as NGX_ERROR\n+         * because it is very strange here\n+         */\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    s->proxy->buffer->pos = s->proxy->buffer->start;\n+    s->proxy->buffer->last = s->proxy->buffer->start;\n+}\n+\n+\n+static void\n+ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n+{\n+    u_char                    *p;\n+    ngx_int_t                  rc;\n+    ngx_str_t                  line;\n+    ngx_buf_t                 *b;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_proxy_conf_t     *pcf;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                   \"mail proxy smtp auth handler\");\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n+                      \"upstream timed out\");\n+        c->timedout = 1;\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    rc = ngx_mail_proxy_read_response(s, s->mail_state);\n+\n+    if (rc == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n+        ngx_mail_proxy_upstream_error(s);\n+        return;\n+    }\n+\n+    switch (s->mail_state) {\n+\n+    case ngx_smtp_start:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0, \"mail proxy send ehlo\");\n+\n+        s->connection->log->action = \"sending HELO/EHLO to upstream\";\n+\n+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+        line.len = sizeof(\"HELO \")  - 1 + cscf->server_name.len + 2;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+        p = ngx_cpymem(line.data,\n+                       ((s->esmtp || pcf->xclient) ? \"EHLO \" : \"HELO \"),\n+                       sizeof(\"HELO \") - 1);\n+\n+        p = ngx_cpymem(p, cscf->server_name.data, cscf->server_name.len);\n+        *p++ = CR; *p = LF;\n+\n+        if (pcf->xclient) {\n+            s->mail_state = ngx_smtp_helo_xclient;\n+\n+        } else if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+            s->mail_state = ngx_smtp_helo_from;\n+\n+        } else {\n+            s->mail_state = ngx_smtp_helo;\n+        }\n+\n+        break;\n+\n+    case ngx_smtp_helo_xclient:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send xclient\");\n+\n+        s->connection->log->action = \"sending XCLIENT to upstream\";\n+\n+        line.len = sizeof(\"XCLIENT ADDR= LOGIN= NAME=\"\n+                          CRLF) - 1\n+                   + s->connection->addr_text.len + s->login.len + s->host.len;\n+\n+#if (NGX_HAVE_INET6)\n+        if (s->connection->sockaddr->sa_family == AF_INET6) {\n+            line.len += sizeof(\"IPV6:\") - 1;\n+        }\n+#endif\n+\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(line.data, \"XCLIENT ADDR=\", sizeof(\"XCLIENT ADDR=\") - 1);\n+\n+#if (NGX_HAVE_INET6)\n+        if (s->connection->sockaddr->sa_family == AF_INET6) {\n+            p = ngx_cpymem(p, \"IPV6:\", sizeof(\"IPV6:\") - 1);\n+        }\n+#endif\n+\n+        p = ngx_copy(p, s->connection->addr_text.data,\n+                     s->connection->addr_text.len);\n+\n+        if (s->login.len) {\n+            p = ngx_cpymem(p, \" LOGIN=\", sizeof(\" LOGIN=\") - 1);\n+            p = ngx_copy(p, s->login.data, s->login.len);\n+        }\n+\n+        p = ngx_cpymem(p, \" NAME=\", sizeof(\" NAME=\") - 1);\n+        p = ngx_copy(p, s->host.data, s->host.len);\n+\n+        *p++ = CR; *p++ = LF;\n+\n+        line.len = p - line.data;\n+\n+        if (s->smtp_helo.len) {\n+            s->mail_state = ngx_smtp_xclient_helo;\n+\n+        } else if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+            s->mail_state = ngx_smtp_xclient_from;\n+\n+        } else {\n+            s->mail_state = ngx_smtp_xclient;\n+        }\n+\n+        break;\n+\n+    case ngx_smtp_xclient_helo:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send client ehlo\");\n+\n+        s->connection->log->action = \"sending client HELO/EHLO to upstream\";\n+\n+        line.len = sizeof(\"HELO \" CRLF) - 1 + s->smtp_helo.len;\n+\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        line.len = ngx_sprintf(line.data,\n+                       ((s->esmtp) ? \"EHLO %V\" CRLF : \"HELO %V\" CRLF),\n+                       &s->smtp_helo)\n+                   - line.data;\n+\n+        s->mail_state = (s->auth_method == NGX_MAIL_AUTH_NONE) ?\n+                            ngx_smtp_helo_from : ngx_smtp_helo;\n+\n+        break;\n+\n+    case ngx_smtp_helo_from:\n+    case ngx_smtp_xclient_from:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send mail from\");\n+\n+        s->connection->log->action = \"sending MAIL FROM to upstream\";\n+\n+        line.len = s->smtp_from.len + sizeof(CRLF) - 1;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(line.data, s->smtp_from.data, s->smtp_from.len);\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_smtp_from;\n+\n+        break;\n+\n+    case ngx_smtp_from:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send rcpt to\");\n+\n+        s->connection->log->action = \"sending RCPT TO to upstream\";\n+\n+        line.len = s->smtp_to.len + sizeof(CRLF) - 1;\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        p = ngx_cpymem(line.data, s->smtp_to.data, s->smtp_to.len);\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_smtp_to;\n+\n+        break;\n+\n+    case ngx_smtp_helo:\n+    case ngx_smtp_xclient:\n+    case ngx_smtp_to:\n+\n+        b = s->proxy->buffer;\n+\n+        if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+            b->pos = b->start;\n+\n+        } else {\n+            ngx_memcpy(b->start, smtp_auth_ok, sizeof(smtp_auth_ok) - 1);\n+            b->last = b->start + sizeof(smtp_auth_ok) - 1;\n+        }\n+\n+        s->connection->read->handler = ngx_mail_proxy_handler;\n+        s->connection->write->handler = ngx_mail_proxy_handler;\n+        rev->handler = ngx_mail_proxy_handler;\n+        c->write->handler = ngx_mail_proxy_handler;\n+\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+        ngx_add_timer(s->connection->read, pcf->timeout);\n+        ngx_del_timer(c->read);\n+\n+        c->log->action = NULL;\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n+\n+        if (s->buffer->pos == s->buffer->last) {\n+            ngx_mail_proxy_handler(s->connection->write);\n+\n+        } else {\n+            ngx_mail_proxy_handler(c->write);\n+        }\n+\n+        return;\n+\n+    default:\n+#if (NGX_SUPPRESS_WARN)\n+        ngx_str_null(&line);\n+#endif\n+        break;\n+    }\n+\n+    if (c->send(c, line.data, line.len) < (ssize_t) line.len) {\n+        /*\n+         * we treat the incomplete sending as NGX_ERROR\n+         * because it is very strange here\n+         */\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n+    s->proxy->buffer->pos = s->proxy->buffer->start;\n+    s->proxy->buffer->last = s->proxy->buffer->start;\n+}\n+\n+\n+static void\n+ngx_mail_proxy_dummy_handler(ngx_event_t *wev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0, \"mail proxy dummy handler\");\n+\n+    if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n+        c = wev->data;\n+        s = c->data;\n+\n+        ngx_mail_proxy_close_session(s);\n+    }\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)\n+{\n+    u_char                 *p, *m;\n+    ssize_t                 n;\n+    ngx_buf_t              *b;\n+    ngx_mail_proxy_conf_t  *pcf;\n+\n+    s->connection->log->action = \"reading response from upstream\";\n+\n+    b = s->proxy->buffer;\n+\n+    n = s->proxy->upstream.connection->recv(s->proxy->upstream.connection,\n+                                            b->last, b->end - b->last);\n+\n+    if (n == NGX_ERROR || n == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (n == NGX_AGAIN) {\n+        return NGX_AGAIN;\n+    }\n+\n+    b->last += n;\n+\n+    if (b->last - b->pos < 4) {\n+        return NGX_AGAIN;\n+    }\n+\n+    if (*(b->last - 2) != CR || *(b->last - 1) != LF) {\n+        if (b->last == b->end) {\n+            *(b->last - 1) = '\\0';\n+            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                          \"upstream sent too long response line: \\\"%s\\\"\",\n+                          b->pos);\n+            return NGX_ERROR;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    p = b->pos;\n+\n+    switch (s->protocol) {\n+\n+    case NGX_MAIL_POP3_PROTOCOL:\n+        if (p[0] == '+' && p[1] == 'O' && p[2] == 'K') {\n+            return NGX_OK;\n+        }\n+        break;\n+\n+    case NGX_MAIL_IMAP_PROTOCOL:\n+        switch (state) {\n+\n+        case ngx_imap_start:\n+            if (p[0] == '*' && p[1] == ' ' && p[2] == 'O' && p[3] == 'K') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n+        case ngx_imap_login:\n+        case ngx_imap_user:\n+            if (p[0] == '+') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n+        case ngx_imap_passwd:\n+            if (ngx_strncmp(p, s->tag.data, s->tag.len) == 0) {\n+                p += s->tag.len;\n+                if (p[0] == 'O' && p[1] == 'K') {\n+                    return NGX_OK;\n+                }\n+            }\n+            break;\n+        }\n+\n+        break;\n+\n+    default: /* NGX_MAIL_SMTP_PROTOCOL */\n+\n+        if (p[3] == '-') {\n+            /* multiline reply, check if we got last line */\n+\n+            m = b->last - (sizeof(CRLF \"200\" CRLF) - 1);\n+\n+            while (m > p) {\n+                if (m[0] == CR && m[1] == LF) {\n+                    break;\n+                }\n+\n+                m--;\n+            }\n+\n+            if (m <= p || m[5] == '-') {\n+                return NGX_AGAIN;\n+            }\n+        }\n+\n+        switch (state) {\n+\n+        case ngx_smtp_start:\n+            if (p[0] == '2' && p[1] == '2' && p[2] == '0') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n+        case ngx_smtp_helo:\n+        case ngx_smtp_helo_xclient:\n+        case ngx_smtp_helo_from:\n+        case ngx_smtp_from:\n+            if (p[0] == '2' && p[1] == '5' && p[2] == '0') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n+        case ngx_smtp_xclient:\n+        case ngx_smtp_xclient_from:\n+        case ngx_smtp_xclient_helo:\n+            if (p[0] == '2' && (p[1] == '2' || p[1] == '5') && p[2] == '0') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n+        case ngx_smtp_to:\n+            return NGX_OK;\n+        }\n+\n+        break;\n+    }\n+\n+    pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+    if (pcf->pass_error_message == 0) {\n+        *(b->last - 2) = '\\0';\n+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                      \"upstream sent invalid response: \\\"%s\\\"\", p);\n+        return NGX_ERROR;\n+    }\n+\n+    s->out.len = b->last - p - 2;\n+    s->out.data = p;\n+\n+    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n+                  \"upstream sent invalid response: \\\"%V\\\"\", &s->out);\n+\n+    s->out.len = b->last - b->pos;\n+    s->out.data = b->pos;\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+static void\n+ngx_mail_proxy_handler(ngx_event_t *ev)\n+{\n+    char                   *action, *recv_action, *send_action;\n+    size_t                  size;\n+    ssize_t                 n;\n+    ngx_buf_t              *b;\n+    ngx_uint_t              do_write;\n+    ngx_connection_t       *c, *src, *dst;\n+    ngx_mail_session_t     *s;\n+    ngx_mail_proxy_conf_t  *pcf;\n+\n+    c = ev->data;\n+    s = c->data;\n+\n+    if (ev->timedout || c->close) {\n+        c->log->action = \"proxying\";\n+\n+        if (c->close) {\n+            ngx_log_error(NGX_LOG_INFO, c->log, 0, \"shutdown timeout\");\n+\n+        } else if (c == s->connection) {\n+            ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n+                          \"client timed out\");\n+            c->timedout = 1;\n+\n+        } else {\n+            ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n+                          \"upstream timed out\");\n+        }\n+\n+        ngx_mail_proxy_close_session(s);\n+        return;\n+    }\n+\n+    if (c == s->connection) {\n+        if (ev->write) {\n+            recv_action = \"proxying and reading from upstream\";\n+            send_action = \"proxying and sending to client\";\n+            src = s->proxy->upstream.connection;\n+            dst = c;\n+            b = s->proxy->buffer;\n+\n+        } else {\n+            recv_action = \"proxying and reading from client\";\n+            send_action = \"proxying and sending to upstream\";\n+            src = c;\n+            dst = s->proxy->upstream.connection;\n+            b = s->buffer;\n+        }\n+\n+    } else {\n+        if (ev->write) {\n+            recv_action = \"proxying and reading from client\";\n+            send_action = \"proxying and sending to upstream\";\n+            src = s->connection;\n+            dst = c;\n+            b = s->buffer;\n+\n+        } else {\n+            recv_action = \"proxying and reading from upstream\";\n+            send_action = \"proxying and sending to client\";\n+            src = c;\n+            dst = s->connection;\n+            b = s->proxy->buffer;\n+        }\n+    }\n+\n+    do_write = ev->write ? 1 : 0;\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_MAIL, ev->log, 0,\n+                   \"mail proxy handler: %ui, #%d > #%d\",\n+                   do_write, src->fd, dst->fd);\n+\n+    for ( ;; ) {\n+\n+        if (do_write) {\n+\n+            size = b->last - b->pos;\n+\n+            if (size && dst->write->ready) {\n+                c->log->action = send_action;\n+\n+                n = dst->send(dst, b->pos, size);\n+\n+                if (n == NGX_ERROR) {\n+                    ngx_mail_proxy_close_session(s);\n+                    return;\n+                }\n+\n+                if (n > 0) {\n+                    b->pos += n;\n+\n+                    if (b->pos == b->last) {\n+                        b->pos = b->start;\n+                        b->last = b->start;\n+                    }\n+                }\n+            }\n+        }\n+\n+        size = b->end - b->last;\n+\n+        if (size && src->read->ready) {\n+            c->log->action = recv_action;\n+\n+            n = src->recv(src, b->last, size);\n+\n+            if (n == NGX_AGAIN || n == 0) {\n+                break;\n+            }\n+\n+            if (n > 0) {\n+                do_write = 1;\n+                b->last += n;\n+\n+                continue;\n+            }\n+\n+            if (n == NGX_ERROR) {\n+                src->read->eof = 1;\n+            }\n+        }\n+\n+        break;\n+    }\n+\n+    c->log->action = \"proxying\";\n+\n+    if ((s->connection->read->eof && s->buffer->pos == s->buffer->last)\n+        || (s->proxy->upstream.connection->read->eof\n+            && s->proxy->buffer->pos == s->proxy->buffer->last)\n+        || (s->connection->read->eof\n+            && s->proxy->upstream.connection->read->eof))\n+    {\n+        action = c->log->action;\n+        c->log->action = NULL;\n+        ngx_log_error(NGX_LOG_INFO, c->log, 0, \"proxied session done\");\n+        c->log->action = action;\n+\n+        ngx_mail_proxy_close_session(s);\n+        return;\n+    }\n+\n+    if (ngx_handle_write_event(dst->write, 0) != NGX_OK) {\n+        ngx_mail_proxy_close_session(s);\n+        return;\n+    }\n+\n+    if (ngx_handle_read_event(dst->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_close_session(s);\n+        return;\n+    }\n+\n+    if (ngx_handle_write_event(src->write, 0) != NGX_OK) {\n+        ngx_mail_proxy_close_session(s);\n+        return;\n+    }\n+\n+    if (ngx_handle_read_event(src->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_close_session(s);\n+        return;\n+    }\n+\n+    if (c == s->connection) {\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+        ngx_add_timer(c->read, pcf->timeout);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_proxy_upstream_error(ngx_mail_session_t *s)\n+{\n+    if (s->proxy->upstream.connection) {\n+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                       \"close mail proxy connection: %d\",\n+                       s->proxy->upstream.connection->fd);\n+\n+        ngx_close_connection(s->proxy->upstream.connection);\n+    }\n+\n+    if (s->out.len == 0) {\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n+    s->quit = 1;\n+    ngx_mail_send(s->connection->write);\n+}\n+\n+\n+static void\n+ngx_mail_proxy_internal_server_error(ngx_mail_session_t *s)\n+{\n+    if (s->proxy->upstream.connection) {\n+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                       \"close mail proxy connection: %d\",\n+                       s->proxy->upstream.connection->fd);\n+\n+        ngx_close_connection(s->proxy->upstream.connection);\n+    }\n+\n+    ngx_mail_session_internal_server_error(s);\n+}\n+\n+\n+static void\n+ngx_mail_proxy_close_session(ngx_mail_session_t *s)\n+{\n+    if (s->proxy->upstream.connection) {\n+        ngx_log_debug1(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                       \"close mail proxy connection: %d\",\n+                       s->proxy->upstream.connection->fd);\n+\n+        ngx_close_connection(s->proxy->upstream.connection);\n+    }\n+\n+    ngx_mail_close_connection(s->connection);\n+}\n+\n+\n+static void *\n+ngx_mail_proxy_create_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_proxy_conf_t  *pcf;\n+\n+    pcf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_proxy_conf_t));\n+    if (pcf == NULL) {\n+        return NULL;\n+    }\n+\n+    pcf->enable = NGX_CONF_UNSET;\n+    pcf->pass_error_message = NGX_CONF_UNSET;\n+    pcf->xclient = NGX_CONF_UNSET;\n+    pcf->buffer_size = NGX_CONF_UNSET_SIZE;\n+    pcf->timeout = NGX_CONF_UNSET_MSEC;\n+\n+    return pcf;\n+}\n+\n+\n+static char *\n+ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_proxy_conf_t *prev = parent;\n+    ngx_mail_proxy_conf_t *conf = child;\n+\n+    ngx_conf_merge_value(conf->enable, prev->enable, 0);\n+    ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);\n+    ngx_conf_merge_value(conf->xclient, prev->xclient, 1);\n+    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n+                              (size_t) ngx_pagesize);\n+    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -0,0 +1,915 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_smtp_module.h>\n+\n+\n+static void ngx_mail_smtp_resolve_addr_handler(ngx_resolver_ctx_t *ctx);\n+static void ngx_mail_smtp_resolve_name(ngx_event_t *rev);\n+static void ngx_mail_smtp_resolve_name_handler(ngx_resolver_ctx_t *ctx);\n+static void ngx_mail_smtp_block_reading(ngx_event_t *rev);\n+static void ngx_mail_smtp_greeting(ngx_mail_session_t *s, ngx_connection_t *c);\n+static void ngx_mail_smtp_invalid_pipelining(ngx_event_t *rev);\n+static ngx_int_t ngx_mail_smtp_create_buffer(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+\n+static ngx_int_t ngx_mail_smtp_helo(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_auth(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_mail(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_starttls(ngx_mail_session_t *s,\n+    ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c);\n+\n+static ngx_int_t ngx_mail_smtp_discard_command(ngx_mail_session_t *s,\n+    ngx_connection_t *c, char *err);\n+static void ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s,\n+    ngx_connection_t *c, char *err);\n+\n+\n+static u_char  smtp_ok[] = \"250 2.0.0 OK\" CRLF;\n+static u_char  smtp_bye[] = \"221 2.0.0 Bye\" CRLF;\n+static u_char  smtp_starttls[] = \"220 2.0.0 Start TLS\" CRLF;\n+static u_char  smtp_next[] = \"334 \" CRLF;\n+static u_char  smtp_username[] = \"334 VXNlcm5hbWU6\" CRLF;\n+static u_char  smtp_password[] = \"334 UGFzc3dvcmQ6\" CRLF;\n+static u_char  smtp_invalid_command[] = \"500 5.5.1 Invalid command\" CRLF;\n+static u_char  smtp_invalid_pipelining[] =\n+    \"503 5.5.0 Improper use of SMTP command pipelining\" CRLF;\n+static u_char  smtp_invalid_argument[] = \"501 5.5.4 Invalid argument\" CRLF;\n+static u_char  smtp_auth_required[] = \"530 5.7.1 Authentication required\" CRLF;\n+static u_char  smtp_bad_sequence[] = \"503 5.5.1 Bad sequence of commands\" CRLF;\n+\n+\n+static ngx_str_t  smtp_unavailable = ngx_string(\"[UNAVAILABLE]\");\n+static ngx_str_t  smtp_tempunavail = ngx_string(\"[TEMPUNAVAIL]\");\n+\n+\n+void\n+ngx_mail_smtp_init_session(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_resolver_ctx_t        *ctx;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    if (cscf->resolver == NULL) {\n+        s->host = smtp_unavailable;\n+        ngx_mail_smtp_greeting(s, c);\n+        return;\n+    }\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+    if (c->sockaddr->sa_family == AF_UNIX) {\n+        s->host = smtp_tempunavail;\n+        ngx_mail_smtp_greeting(s, c);\n+        return;\n+    }\n+#endif\n+\n+    c->log->action = \"in resolving client address\";\n+\n+    ctx = ngx_resolve_start(cscf->resolver, NULL);\n+    if (ctx == NULL) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    ctx->addr.sockaddr = c->sockaddr;\n+    ctx->addr.socklen = c->socklen;\n+    ctx->handler = ngx_mail_smtp_resolve_addr_handler;\n+    ctx->data = s;\n+    ctx->timeout = cscf->resolver_timeout;\n+\n+    s->resolver_ctx = ctx;\n+    c->read->handler = ngx_mail_smtp_block_reading;\n+\n+    if (ngx_resolve_addr(ctx) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_smtp_resolve_addr_handler(ngx_resolver_ctx_t *ctx)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    s = ctx->data;\n+    c = s->connection;\n+\n+    if (ctx->state) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"%V could not be resolved (%i: %s)\",\n+                      &c->addr_text, ctx->state,\n+                      ngx_resolver_strerror(ctx->state));\n+\n+        if (ctx->state == NGX_RESOLVE_NXDOMAIN) {\n+            s->host = smtp_unavailable;\n+\n+        } else {\n+            s->host = smtp_tempunavail;\n+        }\n+\n+        ngx_resolve_addr_done(ctx);\n+\n+        ngx_mail_smtp_greeting(s, s->connection);\n+\n+        return;\n+    }\n+\n+    c->log->action = \"in resolving client hostname\";\n+\n+    s->host.data = ngx_pstrdup(c->pool, &ctx->name);\n+    if (s->host.data == NULL) {\n+        ngx_resolve_addr_done(ctx);\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    s->host.len = ctx->name.len;\n+\n+    ngx_resolve_addr_done(ctx);\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"address resolved: %V\", &s->host);\n+\n+    c->read->handler = ngx_mail_smtp_resolve_name;\n+\n+    ngx_post_event(c->read, &ngx_posted_events);\n+}\n+\n+\n+static void\n+ngx_mail_smtp_resolve_name(ngx_event_t *rev)\n+{\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_resolver_ctx_t        *ctx;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    ctx = ngx_resolve_start(cscf->resolver, NULL);\n+    if (ctx == NULL) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    ctx->name = s->host;\n+    ctx->handler = ngx_mail_smtp_resolve_name_handler;\n+    ctx->data = s;\n+    ctx->timeout = cscf->resolver_timeout;\n+\n+    s->resolver_ctx = ctx;\n+    c->read->handler = ngx_mail_smtp_block_reading;\n+\n+    if (ngx_resolve_name(ctx) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_smtp_resolve_name_handler(ngx_resolver_ctx_t *ctx)\n+{\n+    ngx_uint_t           i;\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    s = ctx->data;\n+    c = s->connection;\n+\n+    if (ctx->state) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"\\\"%V\\\" could not be resolved (%i: %s)\",\n+                      &ctx->name, ctx->state,\n+                      ngx_resolver_strerror(ctx->state));\n+\n+        if (ctx->state == NGX_RESOLVE_NXDOMAIN) {\n+            s->host = smtp_unavailable;\n+\n+        } else {\n+            s->host = smtp_tempunavail;\n+        }\n+\n+    } else {\n+\n+#if (NGX_DEBUG)\n+        {\n+        u_char     text[NGX_SOCKADDR_STRLEN];\n+        ngx_str_t  addr;\n+\n+        addr.data = text;\n+\n+        for (i = 0; i < ctx->naddrs; i++) {\n+            addr.len = ngx_sock_ntop(ctx->addrs[i].sockaddr,\n+                                     ctx->addrs[i].socklen,\n+                                     text, NGX_SOCKADDR_STRLEN, 0);\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                           \"name was resolved to %V\", &addr);\n+        }\n+        }\n+#endif\n+\n+        for (i = 0; i < ctx->naddrs; i++) {\n+            if (ngx_cmp_sockaddr(ctx->addrs[i].sockaddr, ctx->addrs[i].socklen,\n+                                 c->sockaddr, c->socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto found;\n+            }\n+        }\n+\n+        s->host = smtp_unavailable;\n+    }\n+\n+found:\n+\n+    ngx_resolve_name_done(ctx);\n+\n+    ngx_mail_smtp_greeting(s, c);\n+}\n+\n+\n+static void\n+ngx_mail_smtp_block_reading(ngx_event_t *rev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+    ngx_resolver_ctx_t  *ctx;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"smtp reading blocked\");\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+\n+        if (s->resolver_ctx) {\n+            ctx = s->resolver_ctx;\n+\n+            if (ctx->handler == ngx_mail_smtp_resolve_addr_handler) {\n+                ngx_resolve_addr_done(ctx);\n+\n+            } else if (ctx->handler == ngx_mail_smtp_resolve_name_handler) {\n+                ngx_resolve_name_done(ctx);\n+            }\n+\n+            s->resolver_ctx = NULL;\n+        }\n+\n+        ngx_mail_close_connection(c);\n+    }\n+}\n+\n+\n+static void\n+ngx_mail_smtp_greeting(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_msec_t                 timeout;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"smtp greeting for \\\"%V\\\"\", &s->host);\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);\n+\n+    timeout = sscf->greeting_delay ? sscf->greeting_delay : cscf->timeout;\n+    ngx_add_timer(c->read, timeout);\n+\n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+    }\n+\n+    if (c->read->ready) {\n+        ngx_post_event(c->read, &ngx_posted_events);\n+    }\n+\n+    if (sscf->greeting_delay) {\n+         c->read->handler = ngx_mail_smtp_invalid_pipelining;\n+         return;\n+    }\n+\n+    c->read->handler = ngx_mail_smtp_init_protocol;\n+\n+    s->out = sscf->greeting;\n+\n+    ngx_mail_send(c->write);\n+}\n+\n+\n+static void\n+ngx_mail_smtp_invalid_pipelining(ngx_event_t *rev)\n+{\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    c->log->action = \"in delay pipelining state\";\n+\n+    if (rev->timedout) {\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"delay greeting\");\n+\n+        rev->timedout = 0;\n+\n+        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+        c->read->handler = ngx_mail_smtp_init_protocol;\n+\n+        ngx_add_timer(c->read, cscf->timeout);\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n+        sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);\n+\n+        s->out = sscf->greeting;\n+\n+    } else {\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"invalid pipelining\");\n+\n+        if (s->buffer == NULL) {\n+            if (ngx_mail_smtp_create_buffer(s, c) != NGX_OK) {\n+                return;\n+            }\n+        }\n+\n+        if (ngx_mail_smtp_discard_command(s, c,\n+                                \"client was rejected before greeting: \\\"%V\\\"\")\n+            != NGX_OK)\n+        {\n+            return;\n+        }\n+\n+        ngx_str_set(&s->out, smtp_invalid_pipelining);\n+        s->quit = 1;\n+    }\n+\n+    ngx_mail_send(c->write);\n+}\n+\n+\n+void\n+ngx_mail_smtp_init_protocol(ngx_event_t *rev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+\n+    c->log->action = \"in auth state\";\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    s = c->data;\n+\n+    if (s->buffer == NULL) {\n+        if (ngx_mail_smtp_create_buffer(s, c) != NGX_OK) {\n+            return;\n+        }\n+    }\n+\n+    s->mail_state = ngx_smtp_start;\n+    c->read->handler = ngx_mail_smtp_auth_state;\n+\n+    ngx_mail_smtp_auth_state(rev);\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_create_buffer(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+    if (ngx_array_init(&s->args, c->pool, 2, sizeof(ngx_str_t)) == NGX_ERROR) {\n+        ngx_mail_session_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);\n+\n+    s->buffer = ngx_create_temp_buf(c->pool, sscf->client_buffer_size);\n+    if (s->buffer == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_mail_smtp_auth_state(ngx_event_t *rev)\n+{\n+    ngx_int_t            rc;\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"smtp auth state\");\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (s->out.len) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"smtp send handler busy\");\n+        s->blocked = 1;\n+        return;\n+    }\n+\n+    s->blocked = 0;\n+\n+    rc = ngx_mail_read_command(s, c);\n+\n+    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+        return;\n+    }\n+\n+    ngx_str_set(&s->out, smtp_ok);\n+\n+    if (rc == NGX_OK) {\n+        switch (s->mail_state) {\n+\n+        case ngx_smtp_start:\n+\n+            switch (s->command) {\n+\n+            case NGX_SMTP_HELO:\n+            case NGX_SMTP_EHLO:\n+                rc = ngx_mail_smtp_helo(s, c);\n+                break;\n+\n+            case NGX_SMTP_AUTH:\n+                rc = ngx_mail_smtp_auth(s, c);\n+                break;\n+\n+            case NGX_SMTP_QUIT:\n+                s->quit = 1;\n+                ngx_str_set(&s->out, smtp_bye);\n+                break;\n+\n+            case NGX_SMTP_MAIL:\n+                rc = ngx_mail_smtp_mail(s, c);\n+                break;\n+\n+            case NGX_SMTP_RCPT:\n+                rc = ngx_mail_smtp_rcpt(s, c);\n+                break;\n+\n+            case NGX_SMTP_RSET:\n+                rc = ngx_mail_smtp_rset(s, c);\n+                break;\n+\n+            case NGX_SMTP_NOOP:\n+                break;\n+\n+            case NGX_SMTP_STARTTLS:\n+                rc = ngx_mail_smtp_starttls(s, c);\n+                ngx_str_set(&s->out, smtp_starttls);\n+                break;\n+\n+            default:\n+                rc = NGX_MAIL_PARSE_INVALID_COMMAND;\n+                break;\n+            }\n+\n+            break;\n+\n+        case ngx_smtp_auth_login_username:\n+            rc = ngx_mail_auth_login_username(s, c, 0);\n+\n+            ngx_str_set(&s->out, smtp_password);\n+            s->mail_state = ngx_smtp_auth_login_password;\n+            break;\n+\n+        case ngx_smtp_auth_login_password:\n+            rc = ngx_mail_auth_login_password(s, c);\n+            break;\n+\n+        case ngx_smtp_auth_plain:\n+            rc = ngx_mail_auth_plain(s, c, 0);\n+            break;\n+\n+        case ngx_smtp_auth_cram_md5:\n+            rc = ngx_mail_auth_cram_md5(s, c);\n+            break;\n+\n+        case ngx_smtp_auth_external:\n+            rc = ngx_mail_auth_external(s, c, 0);\n+            break;\n+        }\n+    }\n+\n+    if (s->buffer->pos < s->buffer->last) {\n+        s->blocked = 1;\n+    }\n+\n+    switch (rc) {\n+\n+    case NGX_DONE:\n+        ngx_mail_auth(s, c);\n+        return;\n+\n+    case NGX_ERROR:\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+\n+    case NGX_MAIL_PARSE_INVALID_COMMAND:\n+        s->mail_state = ngx_smtp_start;\n+        s->state = 0;\n+        ngx_str_set(&s->out, smtp_invalid_command);\n+\n+        /* fall through */\n+\n+    case NGX_OK:\n+        s->args.nelts = 0;\n+\n+        if (s->buffer->pos == s->buffer->last) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n+        }\n+\n+        if (s->state) {\n+            s->arg_start = s->buffer->pos;\n+        }\n+\n+        ngx_mail_send(c->write);\n+    }\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_helo(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t                 *arg;\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+    if (s->args.nelts != 1) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        s->state = 0;\n+        return NGX_OK;\n+    }\n+\n+    arg = s->args.elts;\n+\n+    s->smtp_helo.len = arg[0].len;\n+\n+    s->smtp_helo.data = ngx_pnalloc(c->pool, arg[0].len);\n+    if (s->smtp_helo.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->smtp_helo.data, arg[0].data, arg[0].len);\n+\n+    ngx_str_null(&s->smtp_from);\n+    ngx_str_null(&s->smtp_to);\n+\n+    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);\n+\n+    if (s->command == NGX_SMTP_HELO) {\n+        s->out = sscf->server_name;\n+\n+    } else {\n+        s->esmtp = 1;\n+\n+#if (NGX_MAIL_SSL)\n+\n+        if (c->ssl == NULL) {\n+            ngx_mail_ssl_conf_t  *sslcf;\n+\n+            sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+\n+            if (sslcf->starttls == NGX_MAIL_STARTTLS_ON) {\n+                s->out = sscf->starttls_capability;\n+                return NGX_OK;\n+            }\n+\n+            if (sslcf->starttls == NGX_MAIL_STARTTLS_ONLY) {\n+                s->out = sscf->starttls_only_capability;\n+                return NGX_OK;\n+            }\n+        }\n+#endif\n+\n+        s->out = sscf->capability;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_auth(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_int_t                  rc;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+#if (NGX_MAIL_SSL)\n+    if (ngx_mail_starttls_only(s, c)) {\n+        return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    }\n+#endif\n+\n+    if (s->args.nelts == 0) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        s->state = 0;\n+        return NGX_OK;\n+    }\n+\n+    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);\n+\n+    rc = ngx_mail_auth_parse(s, c);\n+\n+    switch (rc) {\n+\n+    case NGX_MAIL_AUTH_LOGIN:\n+\n+        ngx_str_set(&s->out, smtp_username);\n+        s->mail_state = ngx_smtp_auth_login_username;\n+\n+        return NGX_OK;\n+\n+    case NGX_MAIL_AUTH_LOGIN_USERNAME:\n+\n+        ngx_str_set(&s->out, smtp_password);\n+        s->mail_state = ngx_smtp_auth_login_password;\n+\n+        return ngx_mail_auth_login_username(s, c, 1);\n+\n+    case NGX_MAIL_AUTH_PLAIN:\n+\n+        ngx_str_set(&s->out, smtp_next);\n+        s->mail_state = ngx_smtp_auth_plain;\n+\n+        return NGX_OK;\n+\n+    case NGX_MAIL_AUTH_CRAM_MD5:\n+\n+        if (!(sscf->auth_methods & NGX_MAIL_AUTH_CRAM_MD5_ENABLED)) {\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        if (s->salt.data == NULL) {\n+            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+            if (ngx_mail_salt(s, c, cscf) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        if (ngx_mail_auth_cram_md5_salt(s, c, \"334 \", 4) == NGX_OK) {\n+            s->mail_state = ngx_smtp_auth_cram_md5;\n+            return NGX_OK;\n+        }\n+\n+        return NGX_ERROR;\n+\n+    case NGX_MAIL_AUTH_EXTERNAL:\n+\n+        if (!(sscf->auth_methods & NGX_MAIL_AUTH_EXTERNAL_ENABLED)) {\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+\n+        ngx_str_set(&s->out, smtp_username);\n+        s->mail_state = ngx_smtp_auth_external;\n+\n+        return NGX_OK;\n+    }\n+\n+    return rc;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_mail(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t                 *arg, cmd;\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+    sscf = ngx_mail_get_module_srv_conf(s, ngx_mail_smtp_module);\n+\n+    if (!(sscf->auth_methods & NGX_MAIL_AUTH_NONE_ENABLED)) {\n+        ngx_mail_smtp_log_rejected_command(s, c, \"client was rejected: \\\"%V\\\"\");\n+        ngx_str_set(&s->out, smtp_auth_required);\n+        return NGX_OK;\n+    }\n+\n+    /* auth none */\n+\n+    if (s->smtp_from.len) {\n+        ngx_str_set(&s->out, smtp_bad_sequence);\n+        return NGX_OK;\n+    }\n+\n+    if (s->args.nelts == 0) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        return NGX_OK;\n+    }\n+\n+    arg = s->args.elts;\n+    arg += s->args.nelts - 1;\n+\n+    cmd.len = arg->data + arg->len - s->cmd.data;\n+    cmd.data = s->cmd.data;\n+\n+    s->smtp_from.len = cmd.len;\n+\n+    s->smtp_from.data = ngx_pnalloc(c->pool, cmd.len);\n+    if (s->smtp_from.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->smtp_from.data, cmd.data, cmd.len);\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"smtp mail from:\\\"%V\\\"\", &s->smtp_from);\n+\n+    ngx_str_set(&s->out, smtp_ok);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_t  *arg, cmd;\n+\n+    if (s->smtp_from.len == 0) {\n+        ngx_str_set(&s->out, smtp_bad_sequence);\n+        return NGX_OK;\n+    }\n+\n+    if (s->args.nelts == 0) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        return NGX_OK;\n+    }\n+\n+    arg = s->args.elts;\n+    arg += s->args.nelts - 1;\n+\n+    cmd.len = arg->data + arg->len - s->cmd.data;\n+    cmd.data = s->cmd.data;\n+\n+    s->smtp_to.len = cmd.len;\n+\n+    s->smtp_to.data = ngx_pnalloc(c->pool, cmd.len);\n+    if (s->smtp_to.data == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(s->smtp_to.data, cmd.data, cmd.len);\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"smtp rcpt to:\\\"%V\\\"\", &s->smtp_to);\n+\n+    s->auth_method = NGX_MAIL_AUTH_NONE;\n+\n+    return NGX_DONE;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    ngx_str_null(&s->smtp_from);\n+    ngx_str_null(&s->smtp_to);\n+    ngx_str_set(&s->out, smtp_ok);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_starttls(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+#if (NGX_MAIL_SSL)\n+    ngx_mail_ssl_conf_t  *sslcf;\n+\n+    if (c->ssl == NULL) {\n+        sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n+        if (sslcf->starttls) {\n+\n+            /*\n+             * RFC3207 requires us to discard any knowledge\n+             * obtained from client before STARTTLS.\n+             */\n+\n+            ngx_str_null(&s->smtp_helo);\n+            ngx_str_null(&s->smtp_from);\n+            ngx_str_null(&s->smtp_to);\n+\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n+\n+            c->read->handler = ngx_mail_starttls_handler;\n+            return NGX_OK;\n+        }\n+    }\n+\n+#endif\n+\n+    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_smtp_discard_command(ngx_mail_session_t *s, ngx_connection_t *c,\n+    char *err)\n+{\n+    ssize_t    n;\n+\n+    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);\n+\n+    if (n == NGX_ERROR || n == 0) {\n+        ngx_mail_close_connection(c);\n+        return NGX_ERROR;\n+    }\n+\n+    if (n > 0) {\n+        s->buffer->last += n;\n+    }\n+\n+    if (n == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return NGX_ERROR;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    ngx_mail_smtp_log_rejected_command(s, c, err);\n+\n+    s->buffer->pos = s->buffer->start;\n+    s->buffer->last = s->buffer->start;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void\n+ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s, ngx_connection_t *c,\n+    char *err)\n+{\n+    u_char      ch;\n+    ngx_str_t   cmd;\n+    ngx_uint_t  i;\n+\n+    if (c->log->log_level < NGX_LOG_INFO) {\n+        return;\n+    }\n+\n+    cmd.len = s->buffer->last - s->buffer->start;\n+    cmd.data = s->buffer->start;\n+\n+    for (i = 0; i < cmd.len; i++) {\n+        ch = cmd.data[i];\n+\n+        if (ch != CR && ch != LF) {\n+            continue;\n+        }\n+\n+        cmd.data[i] = '_';\n+    }\n+\n+    cmd.len = i;\n+\n+    ngx_log_error(NGX_LOG_INFO, c->log, 0, err, &cmd);\n+}\nDiff:\n@@ -0,0 +1,311 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_smtp_module.h>\n+\n+\n+static void *ngx_mail_smtp_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_mail_smtp_merge_srv_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+\n+\n+static ngx_conf_bitmask_t  ngx_mail_smtp_auth_methods[] = {\n+    { ngx_string(\"plain\"), NGX_MAIL_AUTH_PLAIN_ENABLED },\n+    { ngx_string(\"login\"), NGX_MAIL_AUTH_LOGIN_ENABLED },\n+    { ngx_string(\"cram-md5\"), NGX_MAIL_AUTH_CRAM_MD5_ENABLED },\n+    { ngx_string(\"external\"), NGX_MAIL_AUTH_EXTERNAL_ENABLED },\n+    { ngx_string(\"none\"), NGX_MAIL_AUTH_NONE_ENABLED },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+static ngx_str_t  ngx_mail_smtp_auth_methods_names[] = {\n+    ngx_string(\"PLAIN\"),\n+    ngx_string(\"LOGIN\"),\n+    ngx_null_string,  /* APOP */\n+    ngx_string(\"CRAM-MD5\"),\n+    ngx_string(\"EXTERNAL\"),\n+    ngx_null_string   /* NONE */\n+};\n+\n+\n+static ngx_mail_protocol_t  ngx_mail_smtp_protocol = {\n+    ngx_string(\"smtp\"),\n+    { 25, 465, 587, 0 },\n+    NGX_MAIL_SMTP_PROTOCOL,\n+\n+    ngx_mail_smtp_init_session,\n+    ngx_mail_smtp_init_protocol,\n+    ngx_mail_smtp_parse_command,\n+    ngx_mail_smtp_auth_state,\n+\n+    ngx_string(\"451 4.3.2 Internal server error\" CRLF),\n+    ngx_string(\"421 4.7.1 SSL certificate error\" CRLF),\n+    ngx_string(\"421 4.7.1 No required SSL certificate\" CRLF)\n+};\n+\n+\n+static ngx_command_t  ngx_mail_smtp_commands[] = {\n+\n+    { ngx_string(\"smtp_client_buffer\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_size_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_smtp_srv_conf_t, client_buffer_size),\n+      NULL },\n+\n+    { ngx_string(\"smtp_greeting_delay\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_smtp_srv_conf_t, greeting_delay),\n+      NULL },\n+\n+    { ngx_string(\"smtp_capabilities\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_mail_capabilities,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_smtp_srv_conf_t, capabilities),\n+      NULL },\n+\n+    { ngx_string(\"smtp_auth\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_conf_set_bitmask_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_smtp_srv_conf_t, auth_methods),\n+      &ngx_mail_smtp_auth_methods },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_smtp_module_ctx = {\n+    &ngx_mail_smtp_protocol,               /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_smtp_create_srv_conf,         /* create server configuration */\n+    ngx_mail_smtp_merge_srv_conf           /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_smtp_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_smtp_module_ctx,             /* module context */\n+    ngx_mail_smtp_commands,                /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static void *\n+ngx_mail_smtp_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_smtp_srv_conf_t  *sscf;\n+\n+    sscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_smtp_srv_conf_t));\n+    if (sscf == NULL) {\n+        return NULL;\n+    }\n+\n+    sscf->client_buffer_size = NGX_CONF_UNSET_SIZE;\n+    sscf->greeting_delay = NGX_CONF_UNSET_MSEC;\n+\n+    if (ngx_array_init(&sscf->capabilities, cf->pool, 4, sizeof(ngx_str_t))\n+        != NGX_OK)\n+    {\n+        return NULL;\n+    }\n+\n+    return sscf;\n+}\n+\n+\n+static char *\n+ngx_mail_smtp_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_smtp_srv_conf_t *prev = parent;\n+    ngx_mail_smtp_srv_conf_t *conf = child;\n+\n+    u_char                    *p, *auth, *last;\n+    size_t                     size;\n+    ngx_str_t                 *c;\n+    ngx_uint_t                 i, m, auth_enabled;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+\n+    ngx_conf_merge_size_value(conf->client_buffer_size,\n+                              prev->client_buffer_size,\n+                              (size_t) ngx_pagesize);\n+\n+    ngx_conf_merge_msec_value(conf->greeting_delay,\n+                              prev->greeting_delay, 0);\n+\n+    ngx_conf_merge_bitmask_value(conf->auth_methods,\n+                              prev->auth_methods,\n+                              (NGX_CONF_BITMASK_SET\n+                               |NGX_MAIL_AUTH_PLAIN_ENABLED\n+                               |NGX_MAIL_AUTH_LOGIN_ENABLED));\n+\n+\n+    cscf = ngx_mail_conf_get_module_srv_conf(cf, ngx_mail_core_module);\n+\n+    size = sizeof(\"220  ESMTP ready\" CRLF) - 1 + cscf->server_name.len;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->greeting.len = size;\n+    conf->greeting.data = p;\n+\n+    *p++ = '2'; *p++ = '2'; *p++ = '0'; *p++ = ' ';\n+    p = ngx_cpymem(p, cscf->server_name.data, cscf->server_name.len);\n+    ngx_memcpy(p, \" ESMTP ready\" CRLF, sizeof(\" ESMTP ready\" CRLF) - 1);\n+\n+\n+    size = sizeof(\"250 \" CRLF) - 1 + cscf->server_name.len;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->server_name.len = size;\n+    conf->server_name.data = p;\n+\n+    *p++ = '2'; *p++ = '5'; *p++ = '0'; *p++ = ' ';\n+    p = ngx_cpymem(p, cscf->server_name.data, cscf->server_name.len);\n+    *p++ = CR; *p = LF;\n+\n+\n+    if (conf->capabilities.nelts == 0) {\n+        conf->capabilities = prev->capabilities;\n+    }\n+\n+    size = sizeof(\"250-\") - 1 + cscf->server_name.len + sizeof(CRLF) - 1;\n+\n+    c = conf->capabilities.elts;\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        size += sizeof(\"250 \") - 1 + c[i].len + sizeof(CRLF) - 1;\n+    }\n+\n+    auth_enabled = 0;\n+\n+    for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+         m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+         m <<= 1, i++)\n+    {\n+        if (m & conf->auth_methods) {\n+            size += 1 + ngx_mail_smtp_auth_methods_names[i].len;\n+            auth_enabled = 1;\n+        }\n+    }\n+\n+    if (auth_enabled) {\n+        size += sizeof(\"250 AUTH\") - 1 + sizeof(CRLF) - 1;\n+    }\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->capability.len = size;\n+    conf->capability.data = p;\n+\n+    last = p;\n+\n+    *p++ = '2'; *p++ = '5'; *p++ = '0'; *p++ = '-';\n+    p = ngx_cpymem(p, cscf->server_name.data, cscf->server_name.len);\n+    *p++ = CR; *p++ = LF;\n+\n+    for (i = 0; i < conf->capabilities.nelts; i++) {\n+        last = p;\n+        *p++ = '2'; *p++ = '5'; *p++ = '0'; *p++ = '-';\n+        p = ngx_cpymem(p, c[i].data, c[i].len);\n+        *p++ = CR; *p++ = LF;\n+    }\n+\n+    auth = p;\n+\n+    if (auth_enabled) {\n+        last = p;\n+\n+        *p++ = '2'; *p++ = '5'; *p++ = '0'; *p++ = ' ';\n+        *p++ = 'A'; *p++ = 'U'; *p++ = 'T'; *p++ = 'H';\n+\n+        for (m = NGX_MAIL_AUTH_PLAIN_ENABLED, i = 0;\n+             m <= NGX_MAIL_AUTH_EXTERNAL_ENABLED;\n+             m <<= 1, i++)\n+        {\n+            if (m & conf->auth_methods) {\n+                *p++ = ' ';\n+                p = ngx_cpymem(p, ngx_mail_smtp_auth_methods_names[i].data,\n+                               ngx_mail_smtp_auth_methods_names[i].len);\n+            }\n+        }\n+\n+        *p++ = CR; *p = LF;\n+\n+    } else {\n+        last[3] = ' ';\n+    }\n+\n+    size += sizeof(\"250 STARTTLS\" CRLF) - 1;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->starttls_capability.len = size;\n+    conf->starttls_capability.data = p;\n+\n+    p = ngx_cpymem(p, conf->capability.data, conf->capability.len);\n+\n+    ngx_memcpy(p, \"250 STARTTLS\" CRLF, sizeof(\"250 STARTTLS\" CRLF) - 1);\n+\n+    p = conf->starttls_capability.data\n+        + (last - conf->capability.data) + 3;\n+    *p = '-';\n+\n+    size = (auth - conf->capability.data)\n+            + sizeof(\"250 STARTTLS\" CRLF) - 1;\n+\n+    p = ngx_pnalloc(cf->pool, size);\n+    if (p == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    conf->starttls_only_capability.len = size;\n+    conf->starttls_only_capability.data = p;\n+\n+    p = ngx_cpymem(p, conf->capability.data, auth - conf->capability.data);\n+\n+    ngx_memcpy(p, \"250 STARTTLS\" CRLF, sizeof(\"250 STARTTLS\" CRLF) - 1);\n+\n+    if (last < auth) {\n+        p = conf->starttls_only_capability.data\n+            + (last - conf->capability.data) + 3;\n+        *p = '-';\n+    }\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -0,0 +1,45 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_MAIL_SMTP_MODULE_H_INCLUDED_\n+#define _NGX_MAIL_SMTP_MODULE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+#include <ngx_mail_smtp_module.h>\n+\n+\n+typedef struct {\n+    ngx_msec_t   greeting_delay;\n+\n+    size_t       client_buffer_size;\n+\n+    ngx_str_t    capability;\n+    ngx_str_t    starttls_capability;\n+    ngx_str_t    starttls_only_capability;\n+\n+    ngx_str_t    server_name;\n+    ngx_str_t    greeting;\n+\n+    ngx_uint_t   auth_methods;\n+\n+    ngx_array_t  capabilities;\n+} ngx_mail_smtp_srv_conf_t;\n+\n+\n+void ngx_mail_smtp_init_session(ngx_mail_session_t *s, ngx_connection_t *c);\n+void ngx_mail_smtp_init_protocol(ngx_event_t *rev);\n+void ngx_mail_smtp_auth_state(ngx_event_t *rev);\n+ngx_int_t ngx_mail_smtp_parse_command(ngx_mail_session_t *s);\n+\n+\n+extern ngx_module_t  ngx_mail_smtp_module;\n+\n+\n+#endif /* _NGX_MAIL_SMTP_MODULE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,656 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+\n+\n+#define NGX_DEFAULT_CIPHERS     \"HIGH:!aNULL:!MD5\"\n+#define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n+\n+\n+static void *ngx_mail_ssl_create_conf(ngx_conf_t *cf);\n+static char *ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child);\n+\n+static char *ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static char *ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+\n+\n+static ngx_conf_enum_t  ngx_mail_starttls_state[] = {\n+    { ngx_string(\"off\"), NGX_MAIL_STARTTLS_OFF },\n+    { ngx_string(\"on\"), NGX_MAIL_STARTTLS_ON },\n+    { ngx_string(\"only\"), NGX_MAIL_STARTTLS_ONLY },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+\n+static ngx_conf_bitmask_t  ngx_mail_ssl_protocols[] = {\n+    { ngx_string(\"SSLv2\"), NGX_SSL_SSLv2 },\n+    { ngx_string(\"SSLv3\"), NGX_SSL_SSLv3 },\n+    { ngx_string(\"TLSv1\"), NGX_SSL_TLSv1 },\n+    { ngx_string(\"TLSv1.1\"), NGX_SSL_TLSv1_1 },\n+    { ngx_string(\"TLSv1.2\"), NGX_SSL_TLSv1_2 },\n+    { ngx_string(\"TLSv1.3\"), NGX_SSL_TLSv1_3 },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+static ngx_conf_enum_t  ngx_mail_ssl_verify[] = {\n+    { ngx_string(\"off\"), 0 },\n+    { ngx_string(\"on\"), 1 },\n+    { ngx_string(\"optional\"), 2 },\n+    { ngx_string(\"optional_no_ca\"), 3 },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n+static ngx_conf_deprecated_t  ngx_mail_ssl_deprecated = {\n+    ngx_conf_deprecated, \"ssl\", \"listen ... ssl\"\n+};\n+\n+\n+static ngx_command_t  ngx_mail_ssl_commands[] = {\n+\n+    { ngx_string(\"ssl\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_mail_ssl_enable,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, enable),\n+      &ngx_mail_ssl_deprecated },\n+\n+    { ngx_string(\"starttls\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_mail_ssl_starttls,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, starttls),\n+      ngx_mail_starttls_state },\n+\n+    { ngx_string(\"ssl_certificate\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_array_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, certificates),\n+      NULL },\n+\n+    { ngx_string(\"ssl_certificate_key\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_array_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, certificate_keys),\n+      NULL },\n+\n+    { ngx_string(\"ssl_password_file\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_mail_ssl_password_file,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"ssl_dhparam\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, dhparam),\n+      NULL },\n+\n+    { ngx_string(\"ssl_ecdh_curve\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, ecdh_curve),\n+      NULL },\n+\n+    { ngx_string(\"ssl_protocols\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_conf_set_bitmask_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, protocols),\n+      &ngx_mail_ssl_protocols },\n+\n+    { ngx_string(\"ssl_ciphers\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, ciphers),\n+      NULL },\n+\n+    { ngx_string(\"ssl_prefer_server_ciphers\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, prefer_server_ciphers),\n+      NULL },\n+\n+    { ngx_string(\"ssl_session_cache\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE12,\n+      ngx_mail_ssl_session_cache,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+    { ngx_string(\"ssl_session_tickets\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, session_tickets),\n+      NULL },\n+\n+    { ngx_string(\"ssl_session_ticket_key\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_array_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, session_ticket_keys),\n+      NULL },\n+\n+    { ngx_string(\"ssl_session_timeout\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_sec_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, session_timeout),\n+      NULL },\n+\n+    { ngx_string(\"ssl_verify_client\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_enum_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, verify),\n+      &ngx_mail_ssl_verify },\n+\n+    { ngx_string(\"ssl_verify_depth\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_num_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, verify_depth),\n+      NULL },\n+\n+    { ngx_string(\"ssl_client_certificate\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, client_certificate),\n+      NULL },\n+\n+    { ngx_string(\"ssl_trusted_certificate\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, trusted_certificate),\n+      NULL },\n+\n+    { ngx_string(\"ssl_crl\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, crl),\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_ssl_module_ctx = {\n+    NULL,                                  /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_ssl_create_conf,              /* create server configuration */\n+    ngx_mail_ssl_merge_conf                /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_ssl_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_ssl_module_ctx,              /* module context */\n+    ngx_mail_ssl_commands,                 /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static ngx_str_t ngx_mail_ssl_sess_id_ctx = ngx_string(\"MAIL\");\n+\n+\n+static void *\n+ngx_mail_ssl_create_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_ssl_conf_t  *scf;\n+\n+    scf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_ssl_conf_t));\n+    if (scf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc():\n+     *\n+     *     scf->listen = 0;\n+     *     scf->protocols = 0;\n+     *     scf->dhparam = { 0, NULL };\n+     *     scf->ecdh_curve = { 0, NULL };\n+     *     scf->client_certificate = { 0, NULL };\n+     *     scf->trusted_certificate = { 0, NULL };\n+     *     scf->crl = { 0, NULL };\n+     *     scf->ciphers = { 0, NULL };\n+     *     scf->shm_zone = NULL;\n+     */\n+\n+    scf->enable = NGX_CONF_UNSET;\n+    scf->starttls = NGX_CONF_UNSET_UINT;\n+    scf->certificates = NGX_CONF_UNSET_PTR;\n+    scf->certificate_keys = NGX_CONF_UNSET_PTR;\n+    scf->passwords = NGX_CONF_UNSET_PTR;\n+    scf->prefer_server_ciphers = NGX_CONF_UNSET;\n+    scf->verify = NGX_CONF_UNSET_UINT;\n+    scf->verify_depth = NGX_CONF_UNSET_UINT;\n+    scf->builtin_session_cache = NGX_CONF_UNSET;\n+    scf->session_timeout = NGX_CONF_UNSET;\n+    scf->session_tickets = NGX_CONF_UNSET;\n+    scf->session_ticket_keys = NGX_CONF_UNSET_PTR;\n+\n+    return scf;\n+}\n+\n+\n+static char *\n+ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_ssl_conf_t *prev = parent;\n+    ngx_mail_ssl_conf_t *conf = child;\n+\n+    char                *mode;\n+    ngx_pool_cleanup_t  *cln;\n+\n+    ngx_conf_merge_value(conf->enable, prev->enable, 0);\n+    ngx_conf_merge_uint_value(conf->starttls, prev->starttls,\n+                         NGX_MAIL_STARTTLS_OFF);\n+\n+    ngx_conf_merge_value(conf->session_timeout,\n+                         prev->session_timeout, 300);\n+\n+    ngx_conf_merge_value(conf->prefer_server_ciphers,\n+                         prev->prefer_server_ciphers, 0);\n+\n+    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n+                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n+                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+\n+    ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);\n+    ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);\n+\n+    ngx_conf_merge_ptr_value(conf->certificates, prev->certificates, NULL);\n+    ngx_conf_merge_ptr_value(conf->certificate_keys, prev->certificate_keys,\n+                         NULL);\n+\n+    ngx_conf_merge_ptr_value(conf->passwords, prev->passwords, NULL);\n+\n+    ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, \"\");\n+\n+    ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,\n+                         NGX_DEFAULT_ECDH_CURVE);\n+\n+    ngx_conf_merge_str_value(conf->client_certificate,\n+                         prev->client_certificate, \"\");\n+    ngx_conf_merge_str_value(conf->trusted_certificate,\n+                         prev->trusted_certificate, \"\");\n+    ngx_conf_merge_str_value(conf->crl, prev->crl, \"\");\n+\n+    ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n+\n+\n+    conf->ssl.log = cf->log;\n+\n+    if (conf->listen) {\n+        mode = \"listen ... ssl\";\n+\n+    } else if (conf->enable) {\n+        mode = \"ssl\";\n+\n+    } else if (conf->starttls != NGX_MAIL_STARTTLS_OFF) {\n+        mode = \"starttls\";\n+\n+    } else {\n+        return NGX_CONF_OK;\n+    }\n+\n+    if (conf->file == NULL) {\n+        conf->file = prev->file;\n+        conf->line = prev->line;\n+    }\n+\n+    if (conf->certificates == NULL) {\n+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                      \"no \\\"ssl_certificate\\\" is defined for \"\n+                      \"the \\\"%s\\\" directive in %s:%ui\",\n+                      mode, conf->file, conf->line);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (conf->certificate_keys == NULL) {\n+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                      \"no \\\"ssl_certificate_key\\\" is defined for \"\n+                      \"the \\\"%s\\\" directive in %s:%ui\",\n+                      mode, conf->file, conf->line);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (conf->certificate_keys->nelts < conf->certificates->nelts) {\n+        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                      \"no \\\"ssl_certificate_key\\\" is defined \"\n+                      \"for certificate \\\"%V\\\" and \"\n+                      \"the \\\"%s\\\" directive in %s:%ui\",\n+                      ((ngx_str_t *) conf->certificates->elts)\n+                      + conf->certificates->nelts - 1,\n+                      mode, conf->file, conf->line);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (ngx_ssl_create(&conf->ssl, conf->protocols, NULL) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cln = ngx_pool_cleanup_add(cf->pool, 0);\n+    if (cln == NULL) {\n+        ngx_ssl_cleanup_ctx(&conf->ssl);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cln->handler = ngx_ssl_cleanup_ctx;\n+    cln->data = &conf->ssl;\n+\n+    if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,\n+                             conf->certificate_keys, conf->passwords)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (conf->verify) {\n+\n+        if (conf->client_certificate.len == 0 && conf->verify != 3) {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                          \"no ssl_client_certificate for ssl_verify_client\");\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        if (ngx_ssl_client_certificate(cf, &conf->ssl,\n+                                       &conf->client_certificate,\n+                                       conf->verify_depth)\n+            != NGX_OK)\n+        {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        if (ngx_ssl_trusted_certificate(cf, &conf->ssl,\n+                                        &conf->trusted_certificate,\n+                                        conf->verify_depth)\n+            != NGX_OK)\n+        {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        if (ngx_ssl_crl(cf, &conf->ssl, &conf->crl) != NGX_OK) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (ngx_ssl_ecdh_curve(cf, &conf->ssl, &conf->ecdh_curve) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ngx_conf_merge_value(conf->builtin_session_cache,\n+                         prev->builtin_session_cache, NGX_SSL_NONE_SCACHE);\n+\n+    if (conf->shm_zone == NULL) {\n+        conf->shm_zone = prev->shm_zone;\n+    }\n+\n+    if (ngx_ssl_session_cache(&conf->ssl, &ngx_mail_ssl_sess_id_ctx,\n+                              conf->certificates, conf->builtin_session_cache,\n+                              conf->shm_zone, conf->session_timeout)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ngx_conf_merge_value(conf->session_tickets,\n+                         prev->session_tickets, 1);\n+\n+#ifdef SSL_OP_NO_TICKET\n+    if (!conf->session_tickets) {\n+        SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_NO_TICKET);\n+    }\n+#endif\n+\n+    ngx_conf_merge_ptr_value(conf->session_ticket_keys,\n+                         prev->session_ticket_keys, NULL);\n+\n+    if (ngx_ssl_session_ticket_keys(cf, &conf->ssl, conf->session_ticket_keys)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_ssl_conf_t  *scf = conf;\n+\n+    char  *rv;\n+\n+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);\n+\n+    if (rv != NGX_CONF_OK) {\n+        return rv;\n+    }\n+\n+    if (scf->enable && (ngx_int_t) scf->starttls > NGX_MAIL_STARTTLS_OFF) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"\\\"starttls\\\" directive conflicts with \\\"ssl on\\\"\");\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (!scf->listen) {\n+        scf->file = cf->conf_file->file.name.data;\n+        scf->line = cf->conf_file->line;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_ssl_conf_t  *scf = conf;\n+\n+    char  *rv;\n+\n+    rv = ngx_conf_set_enum_slot(cf, cmd, conf);\n+\n+    if (rv != NGX_CONF_OK) {\n+        return rv;\n+    }\n+\n+    if (scf->enable == 1 && (ngx_int_t) scf->starttls > NGX_MAIL_STARTTLS_OFF) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"\\\"ssl\\\" directive conflicts with \\\"starttls\\\"\");\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (!scf->listen) {\n+        scf->file = cf->conf_file->file.name.data;\n+        scf->line = cf->conf_file->line;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_ssl_conf_t  *scf = conf;\n+\n+    ngx_str_t  *value;\n+\n+    if (scf->passwords != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    scf->passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+\n+    if (scf->passwords == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_ssl_conf_t  *scf = conf;\n+\n+    size_t       len;\n+    ngx_str_t   *value, name, size;\n+    ngx_int_t    n;\n+    ngx_uint_t   i, j;\n+\n+    value = cf->args->elts;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+\n+        if (ngx_strcmp(value[i].data, \"off\") == 0) {\n+            scf->builtin_session_cache = NGX_SSL_NO_SCACHE;\n+            continue;\n+        }\n+\n+        if (ngx_strcmp(value[i].data, \"none\") == 0) {\n+            scf->builtin_session_cache = NGX_SSL_NONE_SCACHE;\n+            continue;\n+        }\n+\n+        if (ngx_strcmp(value[i].data, \"builtin\") == 0) {\n+            scf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;\n+            continue;\n+        }\n+\n+        if (value[i].len > sizeof(\"builtin:\") - 1\n+            && ngx_strncmp(value[i].data, \"builtin:\", sizeof(\"builtin:\") - 1)\n+               == 0)\n+        {\n+            n = ngx_atoi(value[i].data + sizeof(\"builtin:\") - 1,\n+                         value[i].len - (sizeof(\"builtin:\") - 1));\n+\n+            if (n == NGX_ERROR) {\n+                goto invalid;\n+            }\n+\n+            scf->builtin_session_cache = n;\n+\n+            continue;\n+        }\n+\n+        if (value[i].len > sizeof(\"shared:\") - 1\n+            && ngx_strncmp(value[i].data, \"shared:\", sizeof(\"shared:\") - 1)\n+               == 0)\n+        {\n+            len = 0;\n+\n+            for (j = sizeof(\"shared:\") - 1; j < value[i].len; j++) {\n+                if (value[i].data[j] == ':') {\n+                    break;\n+                }\n+\n+                len++;\n+            }\n+\n+            if (len == 0) {\n+                goto invalid;\n+            }\n+\n+            name.len = len;\n+            name.data = value[i].data + sizeof(\"shared:\") - 1;\n+\n+            size.len = value[i].len - j - 1;\n+            size.data = name.data + len + 1;\n+\n+            n = ngx_parse_size(&size);\n+\n+            if (n == NGX_ERROR) {\n+                goto invalid;\n+            }\n+\n+            if (n < (ngx_int_t) (8 * ngx_pagesize)) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"session cache \\\"%V\\\" is too small\",\n+                                   &value[i]);\n+\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            scf->shm_zone = ngx_shared_memory_add(cf, &name, n,\n+                                                   &ngx_mail_ssl_module);\n+            if (scf->shm_zone == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            scf->shm_zone->init = ngx_ssl_session_cache_init;\n+\n+            continue;\n+        }\n+\n+        goto invalid;\n+    }\n+\n+    if (scf->shm_zone && scf->builtin_session_cache == NGX_CONF_UNSET) {\n+        scf->builtin_session_cache = NGX_SSL_NO_BUILTIN_SCACHE;\n+    }\n+\n+    return NGX_CONF_OK;\n+\n+invalid:\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"invalid session cache \\\"%V\\\"\", &value[i]);\n+\n+    return NGX_CONF_ERROR;\n+}\nDiff:\n@@ -0,0 +1,65 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_MAIL_SSL_H_INCLUDED_\n+#define _NGX_MAIL_SSL_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+\n+\n+#define NGX_MAIL_STARTTLS_OFF   0\n+#define NGX_MAIL_STARTTLS_ON    1\n+#define NGX_MAIL_STARTTLS_ONLY  2\n+\n+\n+typedef struct {\n+    ngx_flag_t       enable;\n+    ngx_flag_t       prefer_server_ciphers;\n+\n+    ngx_ssl_t        ssl;\n+\n+    ngx_uint_t       starttls;\n+    ngx_uint_t       listen;\n+    ngx_uint_t       protocols;\n+\n+    ngx_uint_t       verify;\n+    ngx_uint_t       verify_depth;\n+\n+    ssize_t          builtin_session_cache;\n+\n+    time_t           session_timeout;\n+\n+    ngx_array_t     *certificates;\n+    ngx_array_t     *certificate_keys;\n+\n+    ngx_str_t        dhparam;\n+    ngx_str_t        ecdh_curve;\n+    ngx_str_t        client_certificate;\n+    ngx_str_t        trusted_certificate;\n+    ngx_str_t        crl;\n+\n+    ngx_str_t        ciphers;\n+\n+    ngx_array_t     *passwords;\n+\n+    ngx_shm_zone_t  *shm_zone;\n+\n+    ngx_flag_t       session_tickets;\n+    ngx_array_t     *session_ticket_keys;\n+\n+    u_char          *file;\n+    ngx_uint_t       line;\n+} ngx_mail_ssl_conf_t;\n+\n+\n+extern ngx_module_t  ngx_mail_ssl_module;\n+\n+\n+#endif /* _NGX_MAIL_SSL_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,29 @@\n+\n+// stub module to test header files' C++ compatibility\n+\n+extern \"C\" {\n+  #include <ngx_config.h>\n+  #include <ngx_core.h>\n+  #include <ngx_event.h>\n+  #include <ngx_event_connect.h>\n+  #include <ngx_event_pipe.h>\n+\n+  #include <ngx_http.h>\n+\n+  #include <ngx_mail.h>\n+  #include <ngx_mail_pop3_module.h>\n+  #include <ngx_mail_imap_module.h>\n+  #include <ngx_mail_smtp_module.h>\n+}\n+\n+// nginx header files should go before other, because they define 64-bit off_t\n+// #include <string>\n+\n+\n+void ngx_cpp_test_handler(void *data);\n+\n+void\n+ngx_cpp_test_handler(void *data)\n+{\n+    return;\n+}\nDiff:\n@@ -0,0 +1,126 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+/*\n+ * declare Profiler interface here because\n+ * <google/profiler.h> is C++ header file\n+ */\n+\n+int ProfilerStart(u_char* fname);\n+void ProfilerStop(void);\n+void ProfilerRegisterThread(void);\n+\n+\n+static void *ngx_google_perftools_create_conf(ngx_cycle_t *cycle);\n+static ngx_int_t ngx_google_perftools_worker(ngx_cycle_t *cycle);\n+\n+\n+typedef struct {\n+    ngx_str_t  profiles;\n+} ngx_google_perftools_conf_t;\n+\n+\n+static ngx_command_t  ngx_google_perftools_commands[] = {\n+\n+    { ngx_string(\"google_perftools_profiles\"),\n+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      0,\n+      offsetof(ngx_google_perftools_conf_t, profiles),\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_core_module_t  ngx_google_perftools_module_ctx = {\n+    ngx_string(\"google_perftools\"),\n+    ngx_google_perftools_create_conf,\n+    NULL\n+};\n+\n+\n+ngx_module_t  ngx_google_perftools_module = {\n+    NGX_MODULE_V1,\n+    &ngx_google_perftools_module_ctx,      /* module context */\n+    ngx_google_perftools_commands,         /* module directives */\n+    NGX_CORE_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    ngx_google_perftools_worker,           /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static void *\n+ngx_google_perftools_create_conf(ngx_cycle_t *cycle)\n+{\n+    ngx_google_perftools_conf_t  *gptcf;\n+\n+    gptcf = ngx_pcalloc(cycle->pool, sizeof(ngx_google_perftools_conf_t));\n+    if (gptcf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc()\n+     *\n+     *     gptcf->profiles = { 0, NULL };\n+     */\n+\n+    return gptcf;\n+}\n+\n+\n+static ngx_int_t\n+ngx_google_perftools_worker(ngx_cycle_t *cycle)\n+{\n+    u_char                       *profile;\n+    ngx_google_perftools_conf_t  *gptcf;\n+\n+    gptcf = (ngx_google_perftools_conf_t *)\n+                ngx_get_conf(cycle->conf_ctx, ngx_google_perftools_module);\n+\n+    if (gptcf->profiles.len == 0) {\n+        return NGX_OK;\n+    }\n+\n+    profile = ngx_alloc(gptcf->profiles.len + NGX_INT_T_LEN + 2, cycle->log);\n+    if (profile == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (getenv(\"CPUPROFILE\")) {\n+        /* disable inherited Profiler enabled in master process */\n+        ProfilerStop();\n+    }\n+\n+    ngx_sprintf(profile, \"%V.%d%Z\", &gptcf->profiles, ngx_pid);\n+\n+    if (ProfilerStart(profile)) {\n+        /* start ITIMER_PROF timer */\n+        ProfilerRegisterThread();\n+\n+    } else {\n+        ngx_log_error(NGX_LOG_CRIT, cycle->log, ngx_errno,\n+                      \"ProfilerStart(%s) failed\", profile);\n+    }\n+\n+    ngx_free(profile);\n+\n+    return NGX_OK;\n+}\n+\n+\n+/* ProfilerStop() is called on Profiler destruction */\nDiff:\n@@ -0,0 +1,90 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_uint_t  ngx_pagesize;\n+ngx_uint_t  ngx_pagesize_shift;\n+ngx_uint_t  ngx_cacheline_size;\n+\n+\n+void *\n+ngx_alloc(size_t size, ngx_log_t *log)\n+{\n+    void  *p;\n+\n+    p = malloc(size);\n+    if (p == NULL) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                      \"malloc(%uz) failed\", size);\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, \"malloc: %p:%uz\", p, size);\n+\n+    return p;\n+}\n+\n+\n+void *\n+ngx_calloc(size_t size, ngx_log_t *log)\n+{\n+    void  *p;\n+\n+    p = ngx_alloc(size, log);\n+\n+    if (p) {\n+        ngx_memzero(p, size);\n+    }\n+\n+    return p;\n+}\n+\n+\n+#if (NGX_HAVE_POSIX_MEMALIGN)\n+\n+void *\n+ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)\n+{\n+    void  *p;\n+    int    err;\n+\n+    err = posix_memalign(&p, alignment, size);\n+\n+    if (err) {\n+        ngx_log_error(NGX_LOG_EMERG, log, err,\n+                      \"posix_memalign(%uz, %uz) failed\", alignment, size);\n+        p = NULL;\n+    }\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, log, 0,\n+                   \"posix_memalign: %p:%uz @%uz\", p, size, alignment);\n+\n+    return p;\n+}\n+\n+#elif (NGX_HAVE_MEMALIGN)\n+\n+void *\n+ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)\n+{\n+    void  *p;\n+\n+    p = memalign(alignment, size);\n+    if (p == NULL) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                      \"memalign(%uz, %uz) failed\", alignment, size);\n+    }\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, log, 0,\n+                   \"memalign: %p:%uz @%uz\", p, size, alignment);\n+\n+    return p;\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,45 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_ALLOC_H_INCLUDED_\n+#define _NGX_ALLOC_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+void *ngx_alloc(size_t size, ngx_log_t *log);\n+void *ngx_calloc(size_t size, ngx_log_t *log);\n+\n+#define ngx_free          free\n+\n+\n+/*\n+ * Linux has memalign() or posix_memalign()\n+ * Solaris has memalign()\n+ * FreeBSD 7.0 has posix_memalign(), besides, early version's malloc()\n+ * aligns allocations bigger than page size at the page boundary\n+ */\n+\n+#if (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)\n+\n+void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);\n+\n+#else\n+\n+#define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)\n+\n+#endif\n+\n+\n+extern ngx_uint_t  ngx_pagesize;\n+extern ngx_uint_t  ngx_pagesize_shift;\n+extern ngx_uint_t  ngx_cacheline_size;\n+\n+\n+#endif /* _NGX_ALLOC_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,313 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_ATOMIC_H_INCLUDED_\n+#define _NGX_ATOMIC_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_HAVE_LIBATOMIC)\n+\n+#define AO_REQUIRE_CAS\n+#include <atomic_ops.h>\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+typedef long                        ngx_atomic_int_t;\n+typedef AO_t                        ngx_atomic_uint_t;\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+#if (NGX_PTR_SIZE == 8)\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+#else\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+#endif\n+\n+#define ngx_atomic_cmp_set(lock, old, new)                                    \\\n+    AO_compare_and_swap(lock, old, new)\n+#define ngx_atomic_fetch_add(value, add)                                      \\\n+    AO_fetch_and_add(value, add)\n+#define ngx_memory_barrier()        AO_nop()\n+#define ngx_cpu_pause()\n+\n+\n+#elif (NGX_DARWIN_ATOMIC)\n+\n+/*\n+ * use Darwin 8 atomic(3) and barrier(3) operations\n+ * optimized at run-time for UP and SMP\n+ */\n+\n+#include <libkern/OSAtomic.h>\n+\n+/* \"bool\" conflicts with perl's CORE/handy.h */\n+#if 0\n+#undef bool\n+#endif\n+\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+#if (NGX_PTR_SIZE == 8)\n+\n+typedef int64_t                     ngx_atomic_int_t;\n+typedef uint64_t                    ngx_atomic_uint_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+\n+#define ngx_atomic_cmp_set(lock, old, new)                                    \\\n+    OSAtomicCompareAndSwap64Barrier(old, new, (int64_t *) lock)\n+\n+#define ngx_atomic_fetch_add(value, add)                                      \\\n+    (OSAtomicAdd64(add, (int64_t *) value) - add)\n+\n+#else\n+\n+typedef int32_t                     ngx_atomic_int_t;\n+typedef uint32_t                    ngx_atomic_uint_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+\n+#define ngx_atomic_cmp_set(lock, old, new)                                    \\\n+    OSAtomicCompareAndSwap32Barrier(old, new, (int32_t *) lock)\n+\n+#define ngx_atomic_fetch_add(value, add)                                      \\\n+    (OSAtomicAdd32(add, (int32_t *) value) - add)\n+\n+#endif\n+\n+#define ngx_memory_barrier()        OSMemoryBarrier()\n+\n+#define ngx_cpu_pause()\n+\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+\n+#elif (NGX_HAVE_GCC_ATOMIC)\n+\n+/* GCC 4.1 builtin atomic operations */\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+typedef long                        ngx_atomic_int_t;\n+typedef unsigned long               ngx_atomic_uint_t;\n+\n+#if (NGX_PTR_SIZE == 8)\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+#else\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+#endif\n+\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+\n+#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n+    __sync_bool_compare_and_swap(lock, old, set)\n+\n+#define ngx_atomic_fetch_add(value, add)                                      \\\n+    __sync_fetch_and_add(value, add)\n+\n+#define ngx_memory_barrier()        __sync_synchronize()\n+\n+#if ( __i386__ || __i386 || __amd64__ || __amd64 )\n+#define ngx_cpu_pause()             __asm__ (\"pause\")\n+#else\n+#define ngx_cpu_pause()\n+#endif\n+\n+\n+#elif ( __i386__ || __i386 )\n+\n+typedef int32_t                     ngx_atomic_int_t;\n+typedef uint32_t                    ngx_atomic_uint_t;\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+\n+\n+#if ( __SUNPRO_C )\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set);\n+\n+ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add);\n+\n+/*\n+ * Sun Studio 12 exits with segmentation fault on '__asm (\"pause\")',\n+ * so ngx_cpu_pause is declared in src/os/unix/ngx_sunpro_x86.il\n+ */\n+\n+void\n+ngx_cpu_pause(void);\n+\n+/* the code in src/os/unix/ngx_sunpro_x86.il */\n+\n+#define ngx_memory_barrier()        __asm (\".volatile\"); __asm (\".nonvolatile\")\n+\n+\n+#else /* ( __GNUC__ || __INTEL_COMPILER ) */\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+#include \"ngx_gcc_atomic_x86.h\"\n+\n+#endif\n+\n+\n+#elif ( __amd64__ || __amd64 )\n+\n+typedef int64_t                     ngx_atomic_int_t;\n+typedef uint64_t                    ngx_atomic_uint_t;\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+\n+\n+#if ( __SUNPRO_C )\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set);\n+\n+ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add);\n+\n+/*\n+ * Sun Studio 12 exits with segmentation fault on '__asm (\"pause\")',\n+ * so ngx_cpu_pause is declared in src/os/unix/ngx_sunpro_amd64.il\n+ */\n+\n+void\n+ngx_cpu_pause(void);\n+\n+/* the code in src/os/unix/ngx_sunpro_amd64.il */\n+\n+#define ngx_memory_barrier()        __asm (\".volatile\"); __asm (\".nonvolatile\")\n+\n+\n+#else /* ( __GNUC__ || __INTEL_COMPILER ) */\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+#include \"ngx_gcc_atomic_amd64.h\"\n+\n+#endif\n+\n+\n+#elif ( __sparc__ || __sparc || __sparcv9 )\n+\n+#if (NGX_PTR_SIZE == 8)\n+\n+typedef int64_t                     ngx_atomic_int_t;\n+typedef uint64_t                    ngx_atomic_uint_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+\n+#else\n+\n+typedef int32_t                     ngx_atomic_int_t;\n+typedef uint32_t                    ngx_atomic_uint_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+\n+#endif\n+\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+\n+#if ( __SUNPRO_C )\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+#include \"ngx_sunpro_atomic_sparc64.h\"\n+\n+\n+#else /* ( __GNUC__ || __INTEL_COMPILER ) */\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+#include \"ngx_gcc_atomic_sparc64.h\"\n+\n+#endif\n+\n+\n+#elif ( __powerpc__ || __POWERPC__ )\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+#if (NGX_PTR_SIZE == 8)\n+\n+typedef int64_t                     ngx_atomic_int_t;\n+typedef uint64_t                    ngx_atomic_uint_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+\n+#else\n+\n+typedef int32_t                     ngx_atomic_int_t;\n+typedef uint32_t                    ngx_atomic_uint_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+\n+#endif\n+\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+\n+#include \"ngx_gcc_atomic_ppc.h\"\n+\n+#endif\n+\n+\n+#if !(NGX_HAVE_ATOMIC_OPS)\n+\n+#define NGX_HAVE_ATOMIC_OPS  0\n+\n+typedef int32_t                     ngx_atomic_int_t;\n+typedef uint32_t                    ngx_atomic_uint_t;\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    if (*lock == old) {\n+        *lock = set;\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n+\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    ngx_atomic_int_t  old;\n+\n+    old = *value;\n+    *value += add;\n+\n+    return old;\n+}\n+\n+#define ngx_memory_barrier()\n+#define ngx_cpu_pause()\n+\n+#endif\n+\n+\n+void ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin);\n+\n+#define ngx_trylock(lock)  (*(lock) == 0 && ngx_atomic_cmp_set(lock, 0, 1))\n+#define ngx_unlock(lock)    *(lock) = 0\n+\n+\n+#endif /* _NGX_ATOMIC_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,253 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_channel.h>\n+\n+\n+ngx_int_t\n+ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,\n+    ngx_log_t *log)\n+{\n+    ssize_t             n;\n+    ngx_err_t           err;\n+    struct iovec        iov[1];\n+    struct msghdr       msg;\n+\n+#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+\n+    union {\n+        struct cmsghdr  cm;\n+        char            space[CMSG_SPACE(sizeof(int))];\n+    } cmsg;\n+\n+    if (ch->fd == -1) {\n+        msg.msg_control = NULL;\n+        msg.msg_controllen = 0;\n+\n+    } else {\n+        msg.msg_control = (caddr_t) &cmsg;\n+        msg.msg_controllen = sizeof(cmsg);\n+\n+        ngx_memzero(&cmsg, sizeof(cmsg));\n+\n+        cmsg.cm.cmsg_len = CMSG_LEN(sizeof(int));\n+        cmsg.cm.cmsg_level = SOL_SOCKET;\n+        cmsg.cm.cmsg_type = SCM_RIGHTS;\n+\n+        /*\n+         * We have to use ngx_memcpy() instead of simple\n+         *   *(int *) CMSG_DATA(&cmsg.cm) = ch->fd;\n+         * because some gcc 4.4 with -O2/3/s optimization issues the warning:\n+         *   dereferencing type-punned pointer will break strict-aliasing rules\n+         *\n+         * Fortunately, gcc with -O1 compiles this ngx_memcpy()\n+         * in the same simple assignment as in the code above\n+         */\n+\n+        ngx_memcpy(CMSG_DATA(&cmsg.cm), &ch->fd, sizeof(int));\n+    }\n+\n+    msg.msg_flags = 0;\n+\n+#else\n+\n+    if (ch->fd == -1) {\n+        msg.msg_accrights = NULL;\n+        msg.msg_accrightslen = 0;\n+\n+    } else {\n+        msg.msg_accrights = (caddr_t) &ch->fd;\n+        msg.msg_accrightslen = sizeof(int);\n+    }\n+\n+#endif\n+\n+    iov[0].iov_base = (char *) ch;\n+    iov[0].iov_len = size;\n+\n+    msg.msg_name = NULL;\n+    msg.msg_namelen = 0;\n+    msg.msg_iov = iov;\n+    msg.msg_iovlen = 1;\n+\n+    n = sendmsg(s, &msg, 0);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+        if (err == NGX_EAGAIN) {\n+            return NGX_AGAIN;\n+        }\n+\n+        ngx_log_error(NGX_LOG_ALERT, log, err, \"sendmsg() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size, ngx_log_t *log)\n+{\n+    ssize_t             n;\n+    ngx_err_t           err;\n+    struct iovec        iov[1];\n+    struct msghdr       msg;\n+\n+#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+    union {\n+        struct cmsghdr  cm;\n+        char            space[CMSG_SPACE(sizeof(int))];\n+    } cmsg;\n+#else\n+    int                 fd;\n+#endif\n+\n+    iov[0].iov_base = (char *) ch;\n+    iov[0].iov_len = size;\n+\n+    msg.msg_name = NULL;\n+    msg.msg_namelen = 0;\n+    msg.msg_iov = iov;\n+    msg.msg_iovlen = 1;\n+\n+#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+    msg.msg_control = (caddr_t) &cmsg;\n+    msg.msg_controllen = sizeof(cmsg);\n+#else\n+    msg.msg_accrights = (caddr_t) &fd;\n+    msg.msg_accrightslen = sizeof(int);\n+#endif\n+\n+    n = recvmsg(s, &msg, 0);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+        if (err == NGX_EAGAIN) {\n+            return NGX_AGAIN;\n+        }\n+\n+        ngx_log_error(NGX_LOG_ALERT, log, err, \"recvmsg() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (n == 0) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, \"recvmsg() returned zero\");\n+        return NGX_ERROR;\n+    }\n+\n+    if ((size_t) n < sizeof(ngx_channel_t)) {\n+        ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                      \"recvmsg() returned not enough data: %z\", n);\n+        return NGX_ERROR;\n+    }\n+\n+#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+\n+    if (ch->command == NGX_CMD_OPEN_CHANNEL) {\n+\n+        if (cmsg.cm.cmsg_len < (socklen_t) CMSG_LEN(sizeof(int))) {\n+            ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                          \"recvmsg() returned too small ancillary data\");\n+            return NGX_ERROR;\n+        }\n+\n+        if (cmsg.cm.cmsg_level != SOL_SOCKET || cmsg.cm.cmsg_type != SCM_RIGHTS)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                          \"recvmsg() returned invalid ancillary data \"\n+                          \"level %d or type %d\",\n+                          cmsg.cm.cmsg_level, cmsg.cm.cmsg_type);\n+            return NGX_ERROR;\n+        }\n+\n+        /* ch->fd = *(int *) CMSG_DATA(&cmsg.cm); */\n+\n+        ngx_memcpy(&ch->fd, CMSG_DATA(&cmsg.cm), sizeof(int));\n+    }\n+\n+    if (msg.msg_flags & (MSG_TRUNC|MSG_CTRUNC)) {\n+        ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                      \"recvmsg() truncated data\");\n+    }\n+\n+#else\n+\n+    if (ch->command == NGX_CMD_OPEN_CHANNEL) {\n+        if (msg.msg_accrightslen != sizeof(int)) {\n+            ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                          \"recvmsg() returned no ancillary data\");\n+            return NGX_ERROR;\n+        }\n+\n+        ch->fd = fd;\n+    }\n+\n+#endif\n+\n+    return n;\n+}\n+\n+\n+ngx_int_t\n+ngx_add_channel_event(ngx_cycle_t *cycle, ngx_fd_t fd, ngx_int_t event,\n+    ngx_event_handler_pt handler)\n+{\n+    ngx_event_t       *ev, *rev, *wev;\n+    ngx_connection_t  *c;\n+\n+    c = ngx_get_connection(fd, cycle->log);\n+\n+    if (c == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    c->pool = cycle->pool;\n+\n+    rev = c->read;\n+    wev = c->write;\n+\n+    rev->log = cycle->log;\n+    wev->log = cycle->log;\n+\n+    rev->channel = 1;\n+    wev->channel = 1;\n+\n+    ev = (event == NGX_READ_EVENT) ? rev : wev;\n+\n+    ev->handler = handler;\n+\n+    if (ngx_add_conn && (ngx_event_flags & NGX_USE_EPOLL_EVENT) == 0) {\n+        if (ngx_add_conn(c) == NGX_ERROR) {\n+            ngx_free_connection(c);\n+            return NGX_ERROR;\n+        }\n+\n+    } else {\n+        if (ngx_add_event(ev, event, 0) == NGX_ERROR) {\n+            ngx_free_connection(c);\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_close_channel(ngx_fd_t *fd, ngx_log_t *log)\n+{\n+    if (close(fd[0]) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, \"close() channel failed\");\n+    }\n+\n+    if (close(fd[1]) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, \"close() channel failed\");\n+    }\n+}\nDiff:\n@@ -0,0 +1,34 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_CHANNEL_H_INCLUDED_\n+#define _NGX_CHANNEL_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+typedef struct {\n+    ngx_uint_t  command;\n+    ngx_pid_t   pid;\n+    ngx_int_t   slot;\n+    ngx_fd_t    fd;\n+} ngx_channel_t;\n+\n+\n+ngx_int_t ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,\n+    ngx_log_t *log);\n+ngx_int_t ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,\n+    ngx_log_t *log);\n+ngx_int_t ngx_add_channel_event(ngx_cycle_t *cycle, ngx_fd_t fd,\n+    ngx_int_t event, ngx_event_handler_pt handler);\n+void ngx_close_channel(ngx_fd_t *fd, ngx_log_t *log);\n+\n+\n+#endif /* _NGX_CHANNEL_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,71 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_int_t\n+ngx_daemon(ngx_log_t *log)\n+{\n+    int  fd;\n+\n+    switch (fork()) {\n+    case -1:\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"fork() failed\");\n+        return NGX_ERROR;\n+\n+    case 0:\n+        break;\n+\n+    default:\n+        exit(0);\n+    }\n+\n+    ngx_parent = ngx_pid;\n+    ngx_pid = ngx_getpid();\n+\n+    if (setsid() == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"setsid() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    umask(0);\n+\n+    fd = open(\"/dev/null\", O_RDWR);\n+    if (fd == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                      \"open(\\\"/dev/null\\\") failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (dup2(fd, STDIN_FILENO) == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"dup2(STDIN) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (dup2(fd, STDOUT_FILENO) == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"dup2(STDOUT) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+#if 0\n+    if (dup2(fd, STDERR_FILENO) == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"dup2(STDERR) failed\");\n+        return NGX_ERROR;\n+    }\n+#endif\n+\n+    if (fd > STDERR_FILENO) {\n+        if (close(fd) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"close() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -0,0 +1,23 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_DARWIN_H_INCLUDED_\n+#define _NGX_DARWIN_H_INCLUDED_\n+\n+\n+void ngx_debug_init(void);\n+ngx_chain_t *ngx_darwin_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+extern int       ngx_darwin_kern_osreldate;\n+extern int       ngx_darwin_hw_ncpu;\n+extern u_long    ngx_darwin_net_inet_tcp_sendspace;\n+\n+extern ngx_uint_t  ngx_debug_malloc;\n+\n+\n+#endif /* _NGX_DARWIN_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,100 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_DARWIN_CONFIG_H_INCLUDED_\n+#define _NGX_DARWIN_CONFIG_H_INCLUDED_\n+\n+\n+#define __APPLE_USE_RFC_3542    /* IPV6_PKTINFO */\n+\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <unistd.h>\n+#include <inttypes.h>\n+#include <stdarg.h>\n+#include <stddef.h>             /* offsetof() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <signal.h>\n+#include <pwd.h>\n+#include <grp.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <sys/mount.h>          /* statfs() */\n+\n+#include <sys/filio.h>          /* FIONBIO */\n+#include <sys/ioctl.h>\n+#include <sys/uio.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+#include <sys/wait.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sched.h>\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>        /* TCP_NODELAY */\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <sys/un.h>\n+\n+#include <sys/sysctl.h>\n+#include <xlocale.h>\n+\n+#include <dlfcn.h>\n+\n+\n+#ifndef IOV_MAX\n+#define IOV_MAX   64\n+#endif\n+\n+\n+#include <ngx_auto_config.h>\n+\n+\n+#if (NGX_HAVE_POSIX_SEM)\n+#include <semaphore.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_POLL)\n+#include <poll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_KQUEUE)\n+#include <sys/event.h>\n+#endif\n+\n+\n+#define NGX_LISTEN_BACKLOG  -1\n+\n+\n+#ifndef NGX_HAVE_INHERITED_NONBLOCK\n+#define NGX_HAVE_INHERITED_NONBLOCK  1\n+#endif\n+\n+\n+#ifndef NGX_HAVE_CASELESS_FILESYSTEM\n+#define NGX_HAVE_CASELESS_FILESYSTEM  1\n+#endif\n+\n+\n+#define NGX_HAVE_OS_SPECIFIC_INIT    1\n+#define NGX_HAVE_DEBUG_MALLOC        1\n+\n+\n+extern char **environ;\n+\n+\n+#endif /* _NGX_DARWIN_CONFIG_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,198 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+char    ngx_darwin_kern_ostype[16];\n+char    ngx_darwin_kern_osrelease[128];\n+int     ngx_darwin_hw_ncpu;\n+int     ngx_darwin_kern_ipc_somaxconn;\n+u_long  ngx_darwin_net_inet_tcp_sendspace;\n+\n+ngx_uint_t  ngx_debug_malloc;\n+\n+\n+static ngx_os_io_t ngx_darwin_io = {\n+    ngx_unix_recv,\n+    ngx_readv_chain,\n+    ngx_udp_unix_recv,\n+    ngx_unix_send,\n+    ngx_udp_unix_send,\n+    ngx_udp_unix_sendmsg_chain,\n+#if (NGX_HAVE_SENDFILE)\n+    ngx_darwin_sendfile_chain,\n+    NGX_IO_SENDFILE\n+#else\n+    ngx_writev_chain,\n+    0\n+#endif\n+};\n+\n+\n+typedef struct {\n+    char        *name;\n+    void        *value;\n+    size_t       size;\n+    ngx_uint_t   exists;\n+} sysctl_t;\n+\n+\n+sysctl_t sysctls[] = {\n+    { \"hw.ncpu\",\n+      &ngx_darwin_hw_ncpu,\n+      sizeof(ngx_darwin_hw_ncpu), 0 },\n+\n+    { \"net.inet.tcp.sendspace\",\n+      &ngx_darwin_net_inet_tcp_sendspace,\n+      sizeof(ngx_darwin_net_inet_tcp_sendspace), 0 },\n+\n+    { \"kern.ipc.somaxconn\",\n+      &ngx_darwin_kern_ipc_somaxconn,\n+      sizeof(ngx_darwin_kern_ipc_somaxconn), 0 },\n+\n+    { NULL, NULL, 0, 0 }\n+};\n+\n+\n+void\n+ngx_debug_init(void)\n+{\n+#if (NGX_DEBUG_MALLOC)\n+\n+    /*\n+     * MacOSX 10.6, 10.7:  MallocScribble fills freed memory with 0x55\n+     *                     and fills allocated memory with 0xAA.\n+     * MacOSX 10.4, 10.5:  MallocScribble fills freed memory with 0x55,\n+     *                     MallocPreScribble fills allocated memory with 0xAA.\n+     * MacOSX 10.3:        MallocScribble fills freed memory with 0x55,\n+     *                     and no way to fill allocated memory.\n+     */\n+\n+    setenv(\"MallocScribble\", \"1\", 0);\n+\n+    ngx_debug_malloc = 1;\n+\n+#else\n+\n+    if (getenv(\"MallocScribble\")) {\n+        ngx_debug_malloc = 1;\n+    }\n+\n+#endif\n+}\n+\n+\n+ngx_int_t\n+ngx_os_specific_init(ngx_log_t *log)\n+{\n+    size_t      size;\n+    ngx_err_t   err;\n+    ngx_uint_t  i;\n+\n+    size = sizeof(ngx_darwin_kern_ostype);\n+    if (sysctlbyname(\"kern.ostype\", ngx_darwin_kern_ostype, &size, NULL, 0)\n+        == -1)\n+    {\n+        err = ngx_errno;\n+\n+        if (err != NGX_ENOENT) {\n+\n+            ngx_log_error(NGX_LOG_ALERT, log, err,\n+                          \"sysctlbyname(kern.ostype) failed\");\n+\n+            if (err != NGX_ENOMEM) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_darwin_kern_ostype[size - 1] = '\\0';\n+        }\n+    }\n+\n+    size = sizeof(ngx_darwin_kern_osrelease);\n+    if (sysctlbyname(\"kern.osrelease\", ngx_darwin_kern_osrelease, &size,\n+                     NULL, 0)\n+        == -1)\n+    {\n+        err = ngx_errno;\n+\n+        if (err != NGX_ENOENT) {\n+\n+            ngx_log_error(NGX_LOG_ALERT, log, err,\n+                          \"sysctlbyname(kern.osrelease) failed\");\n+\n+            if (err != NGX_ENOMEM) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_darwin_kern_osrelease[size - 1] = '\\0';\n+        }\n+    }\n+\n+    for (i = 0; sysctls[i].name; i++) {\n+        size = sysctls[i].size;\n+\n+        if (sysctlbyname(sysctls[i].name, sysctls[i].value, &size, NULL, 0)\n+            == 0)\n+        {\n+            sysctls[i].exists = 1;\n+            continue;\n+        }\n+\n+        err = ngx_errno;\n+\n+        if (err == NGX_ENOENT) {\n+            continue;\n+        }\n+\n+        ngx_log_error(NGX_LOG_ALERT, log, err,\n+                      \"sysctlbyname(%s) failed\", sysctls[i].name);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_ncpu = ngx_darwin_hw_ncpu;\n+\n+    if (ngx_darwin_kern_ipc_somaxconn > 32767) {\n+        ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                      \"sysctl kern.ipc.somaxconn must be less than 32768\");\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_tcp_nodelay_and_tcp_nopush = 1;\n+\n+    ngx_os_io = ngx_darwin_io;\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_os_specific_status(ngx_log_t *log)\n+{\n+    u_long      value;\n+    ngx_uint_t  i;\n+\n+    if (ngx_darwin_kern_ostype[0]) {\n+        ngx_log_error(NGX_LOG_NOTICE, log, 0, \"OS: %s %s\",\n+                      ngx_darwin_kern_ostype, ngx_darwin_kern_osrelease);\n+    }\n+\n+    for (i = 0; sysctls[i].name; i++) {\n+        if (sysctls[i].exists) {\n+            if (sysctls[i].size == sizeof(long)) {\n+                value = *(long *) sysctls[i].value;\n+\n+            } else {\n+                value = *(int *) sysctls[i].value;\n+            }\n+\n+            ngx_log_error(NGX_LOG_NOTICE, log, 0, \"%s: %l\",\n+                          sysctls[i].name, value);\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,206 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+/*\n+ * It seems that Darwin 9.4 (Mac OS X 1.5) sendfile() has the same\n+ * old bug as early FreeBSD sendfile() syscall:\n+ * http://bugs.freebsd.org/33771\n+ *\n+ * Besides sendfile() has another bug: if one calls sendfile()\n+ * with both a header and a trailer, then sendfile() ignores a file part\n+ * at all and sends only the header and the trailer together.\n+ * For this reason we send a trailer only if there is no a header.\n+ *\n+ * Although sendfile() allows to pass a header or a trailer,\n+ * it may send the header or the trailer and a part of the file\n+ * in different packets.  And FreeBSD workaround (TCP_NOPUSH option)\n+ * does not help.\n+ */\n+\n+\n+ngx_chain_t *\n+ngx_darwin_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n+{\n+    int              rc;\n+    off_t            send, prev_send, sent;\n+    off_t            file_size;\n+    ssize_t          n;\n+    ngx_uint_t       eintr;\n+    ngx_err_t        err;\n+    ngx_buf_t       *file;\n+    ngx_event_t     *wev;\n+    ngx_chain_t     *cl;\n+    ngx_iovec_t      header, trailer;\n+    struct sf_hdtr   hdtr;\n+    struct iovec     headers[NGX_IOVS_PREALLOCATE];\n+    struct iovec     trailers[NGX_IOVS_PREALLOCATE];\n+\n+    wev = c->write;\n+\n+    if (!wev->ready) {\n+        return in;\n+    }\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n+        (void) ngx_connection_error(c, wev->kq_errno,\n+                               \"kevent() reported about an closed connection\");\n+        wev->error = 1;\n+        return NGX_CHAIN_ERROR;\n+    }\n+\n+#endif\n+\n+    /* the maximum limit size is the maximum size_t value - the page size */\n+\n+    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n+        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n+    }\n+\n+    send = 0;\n+\n+    header.iovs = headers;\n+    header.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    trailer.iovs = trailers;\n+    trailer.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    for ( ;; ) {\n+        eintr = 0;\n+        prev_send = send;\n+\n+        /* create the header iovec and coalesce the neighbouring bufs */\n+\n+        cl = ngx_output_chain_to_iovec(&header, in, limit - send, c->log);\n+\n+        if (cl == NGX_CHAIN_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        send += header.size;\n+\n+        if (cl && cl->buf->in_file && send < limit) {\n+            file = cl->buf;\n+\n+            /* coalesce the neighbouring file bufs */\n+\n+            file_size = ngx_chain_coalesce_file(&cl, limit - send);\n+\n+            send += file_size;\n+\n+            if (header.count == 0 && send < limit) {\n+\n+                /*\n+                 * create the trailer iovec and coalesce the neighbouring bufs\n+                 */\n+\n+                cl = ngx_output_chain_to_iovec(&trailer, cl, limit - send,\n+                                               c->log);\n+                if (cl == NGX_CHAIN_ERROR) {\n+                    return NGX_CHAIN_ERROR;\n+                }\n+\n+                send += trailer.size;\n+\n+            } else {\n+                trailer.count = 0;\n+            }\n+\n+            /*\n+             * sendfile() returns EINVAL if sf_hdtr's count is 0,\n+             * but corresponding pointer is not NULL\n+             */\n+\n+            hdtr.headers = header.count ? header.iovs : NULL;\n+            hdtr.hdr_cnt = header.count;\n+            hdtr.trailers = trailer.count ? trailer.iovs : NULL;\n+            hdtr.trl_cnt = trailer.count;\n+\n+            sent = header.size + file_size;\n+\n+            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"sendfile: @%O %O h:%uz\",\n+                           file->file_pos, sent, header.size);\n+\n+            rc = sendfile(file->file->fd, c->fd, file->file_pos,\n+                          &sent, &hdtr, 0);\n+\n+            if (rc == -1) {\n+                err = ngx_errno;\n+\n+                switch (err) {\n+                case NGX_EAGAIN:\n+                    break;\n+\n+                case NGX_EINTR:\n+                    eintr = 1;\n+                    break;\n+\n+                default:\n+                    wev->error = 1;\n+                    (void) ngx_connection_error(c, err, \"sendfile() failed\");\n+                    return NGX_CHAIN_ERROR;\n+                }\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                               \"sendfile() sent only %O bytes\", sent);\n+            }\n+\n+            if (rc == 0 && sent == 0) {\n+\n+                /*\n+                 * if rc and sent equal to zero, then someone\n+                 * has truncated the file, so the offset became beyond\n+                 * the end of the file\n+                 */\n+\n+                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                              \"sendfile() reported that \\\"%s\\\" was truncated\",\n+                              file->file->name.data);\n+\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"sendfile: %d, @%O %O:%O\",\n+                           rc, file->file_pos, sent, file_size + header.size);\n+\n+        } else {\n+            n = ngx_writev(c, &header);\n+\n+            if (n == NGX_ERROR) {\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            sent = (n == NGX_AGAIN) ? 0 : n;\n+        }\n+\n+        c->sent += sent;\n+\n+        in = ngx_chain_update_sent(in, sent);\n+\n+        if (eintr) {\n+            send = prev_send + sent;\n+            continue;\n+        }\n+\n+        if (send - prev_send != sent) {\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        if (send >= limit || in == NULL) {\n+            return in;\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,28 @@\n+\n+/*\n+ * Copyright (C) Maxim Dounin\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_HAVE_DLOPEN)\n+\n+char *\n+ngx_dlerror(void)\n+{\n+    char  *err;\n+\n+    err = (char *) dlerror();\n+\n+    if (err == NULL) {\n+        return \"\";\n+    }\n+\n+    return err;\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,31 @@\n+\n+/*\n+ * Copyright (C) Maxim Dounin\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_DLOPEN_H_INCLUDED_\n+#define _NGX_DLOPEN_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#define ngx_dlopen(path)           dlopen((char *) path, RTLD_NOW | RTLD_GLOBAL)\n+#define ngx_dlopen_n               \"dlopen()\"\n+\n+#define ngx_dlsym(handle, symbol)  dlsym(handle, symbol)\n+#define ngx_dlsym_n                \"dlsym()\"\n+\n+#define ngx_dlclose(handle)        dlclose(handle)\n+#define ngx_dlclose_n              \"dlclose()\"\n+\n+\n+#if (NGX_HAVE_DLOPEN)\n+char *ngx_dlerror(void);\n+#endif\n+\n+\n+#endif /* _NGX_DLOPEN_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,87 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/*\n+ * The strerror() messages are copied because:\n+ *\n+ * 1) strerror() and strerror_r() functions are not Async-Signal-Safe,\n+ *    therefore, they cannot be used in signal handlers;\n+ *\n+ * 2) a direct sys_errlist[] array may be used instead of these functions,\n+ *    but Linux linker warns about its usage:\n+ *\n+ * warning: `sys_errlist' is deprecated; use `strerror' or `strerror_r' instead\n+ * warning: `sys_nerr' is deprecated; use `strerror' or `strerror_r' instead\n+ *\n+ *    causing false bug reports.\n+ */\n+\n+\n+static ngx_str_t  *ngx_sys_errlist;\n+static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n+\n+\n+u_char *\n+ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n+{\n+    ngx_str_t  *msg;\n+\n+    msg = ((ngx_uint_t) err < NGX_SYS_NERR) ? &ngx_sys_errlist[err]:\n+                                              &ngx_unknown_error;\n+    size = ngx_min(size, msg->len);\n+\n+    return ngx_cpymem(errstr, msg->data, size);\n+}\n+\n+\n+ngx_int_t\n+ngx_strerror_init(void)\n+{\n+    char       *msg;\n+    u_char     *p;\n+    size_t      len;\n+    ngx_err_t   err;\n+\n+    /*\n+     * ngx_strerror() is not ready to work at this stage, therefore,\n+     * malloc() is used and possible errors are logged using strerror().\n+     */\n+\n+    len = NGX_SYS_NERR * sizeof(ngx_str_t);\n+\n+    ngx_sys_errlist = malloc(len);\n+    if (ngx_sys_errlist == NULL) {\n+        goto failed;\n+    }\n+\n+    for (err = 0; err < NGX_SYS_NERR; err++) {\n+        msg = strerror(err);\n+        len = ngx_strlen(msg);\n+\n+        p = malloc(len);\n+        if (p == NULL) {\n+            goto failed;\n+        }\n+\n+        ngx_memcpy(p, msg, len);\n+        ngx_sys_errlist[err].len = len;\n+        ngx_sys_errlist[err].data = p;\n+    }\n+\n+    return NGX_OK;\n+\n+failed:\n+\n+    err = errno;\n+    ngx_log_stderr(0, \"malloc(%uz) failed (%d: %s)\", len, err, strerror(err));\n+\n+    return NGX_ERROR;\n+}\nDiff:\n@@ -0,0 +1,79 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_ERRNO_H_INCLUDED_\n+#define _NGX_ERRNO_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef int               ngx_err_t;\n+\n+#define NGX_EPERM         EPERM\n+#define NGX_ENOENT        ENOENT\n+#define NGX_ENOPATH       ENOENT\n+#define NGX_ESRCH         ESRCH\n+#define NGX_EINTR         EINTR\n+#define NGX_ECHILD        ECHILD\n+#define NGX_ENOMEM        ENOMEM\n+#define NGX_EACCES        EACCES\n+#define NGX_EBUSY         EBUSY\n+#define NGX_EEXIST        EEXIST\n+#define NGX_EEXIST_FILE   EEXIST\n+#define NGX_EXDEV         EXDEV\n+#define NGX_ENOTDIR       ENOTDIR\n+#define NGX_EISDIR        EISDIR\n+#define NGX_EINVAL        EINVAL\n+#define NGX_ENFILE        ENFILE\n+#define NGX_EMFILE        EMFILE\n+#define NGX_ENOSPC        ENOSPC\n+#define NGX_EPIPE         EPIPE\n+#define NGX_EINPROGRESS   EINPROGRESS\n+#define NGX_ENOPROTOOPT   ENOPROTOOPT\n+#define NGX_EOPNOTSUPP    EOPNOTSUPP\n+#define NGX_EADDRINUSE    EADDRINUSE\n+#define NGX_ECONNABORTED  ECONNABORTED\n+#define NGX_ECONNRESET    ECONNRESET\n+#define NGX_ENOTCONN      ENOTCONN\n+#define NGX_ETIMEDOUT     ETIMEDOUT\n+#define NGX_ECONNREFUSED  ECONNREFUSED\n+#define NGX_ENAMETOOLONG  ENAMETOOLONG\n+#define NGX_ENETDOWN      ENETDOWN\n+#define NGX_ENETUNREACH   ENETUNREACH\n+#define NGX_EHOSTDOWN     EHOSTDOWN\n+#define NGX_EHOSTUNREACH  EHOSTUNREACH\n+#define NGX_ENOSYS        ENOSYS\n+#define NGX_ECANCELED     ECANCELED\n+#define NGX_EILSEQ        EILSEQ\n+#define NGX_ENOMOREFILES  0\n+#define NGX_ELOOP         ELOOP\n+#define NGX_EBADF         EBADF\n+\n+#if (NGX_HAVE_OPENAT)\n+#define NGX_EMLINK        EMLINK\n+#endif\n+\n+#if (__hpux__)\n+#define NGX_EAGAIN        EWOULDBLOCK\n+#else\n+#define NGX_EAGAIN        EAGAIN\n+#endif\n+\n+\n+#define ngx_errno                  errno\n+#define ngx_socket_errno           errno\n+#define ngx_set_errno(err)         errno = err\n+#define ngx_set_socket_errno(err)  errno = err\n+\n+\n+u_char *ngx_strerror(ngx_err_t err, u_char *errstr, size_t size);\n+ngx_int_t ngx_strerror_init(void);\n+\n+\n+#endif /* _NGX_ERRNO_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,216 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+/*\n+ * FreeBSD file AIO features and quirks:\n+ *\n+ *    if an asked data are already in VM cache, then aio_error() returns 0,\n+ *    and the data are already copied in buffer;\n+ *\n+ *    aio_read() preread in VM cache as minimum 16K (probably BKVASIZE);\n+ *    the first AIO preload may be up to 128K;\n+ *\n+ *    aio_read/aio_error() may return EINPROGRESS for just written data;\n+ *\n+ *    kqueue EVFILT_AIO filter is level triggered only: an event repeats\n+ *    until aio_return() will be called;\n+ *\n+ *    aio_cancel() cannot cancel file AIO: it returns AIO_NOTCANCELED always.\n+ */\n+\n+\n+extern int  ngx_kqueue;\n+\n+\n+static ssize_t ngx_file_aio_result(ngx_file_t *file, ngx_event_aio_t *aio,\n+    ngx_event_t *ev);\n+static void ngx_file_aio_event_handler(ngx_event_t *ev);\n+\n+\n+ngx_int_t\n+ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool)\n+{\n+    ngx_event_aio_t  *aio;\n+\n+    aio = ngx_pcalloc(pool, sizeof(ngx_event_aio_t));\n+    if (aio == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    aio->file = file;\n+    aio->fd = file->fd;\n+    aio->event.data = aio;\n+    aio->event.ready = 1;\n+    aio->event.log = file->log;\n+\n+    file->aio = aio;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ssize_t\n+ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,\n+    ngx_pool_t *pool)\n+{\n+    int               n;\n+    ngx_event_t      *ev;\n+    ngx_event_aio_t  *aio;\n+\n+    if (!ngx_file_aio) {\n+        return ngx_read_file(file, buf, size, offset);\n+    }\n+\n+    if (file->aio == NULL && ngx_file_aio_init(file, pool) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    aio = file->aio;\n+    ev = &aio->event;\n+\n+    if (!ev->ready) {\n+        ngx_log_error(NGX_LOG_ALERT, file->log, 0,\n+                      \"second aio post for \\\"%V\\\"\", &file->name);\n+        return NGX_AGAIN;\n+    }\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"aio complete:%d @%O:%uz %V\",\n+                   ev->complete, offset, size, &file->name);\n+\n+    if (ev->complete) {\n+        ev->complete = 0;\n+        ngx_set_errno(aio->err);\n+\n+        if (aio->err == 0) {\n+            return aio->nbytes;\n+        }\n+\n+        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                      \"aio read \\\"%s\\\" failed\", file->name.data);\n+\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memzero(&aio->aiocb, sizeof(struct aiocb));\n+\n+    aio->aiocb.aio_fildes = file->fd;\n+    aio->aiocb.aio_offset = offset;\n+    aio->aiocb.aio_buf = buf;\n+    aio->aiocb.aio_nbytes = size;\n+#if (NGX_HAVE_KQUEUE)\n+    aio->aiocb.aio_sigevent.sigev_notify_kqueue = ngx_kqueue;\n+    aio->aiocb.aio_sigevent.sigev_notify = SIGEV_KEVENT;\n+    aio->aiocb.aio_sigevent.sigev_value.sival_ptr = ev;\n+#endif\n+    ev->handler = ngx_file_aio_event_handler;\n+\n+    n = aio_read(&aio->aiocb);\n+\n+    if (n == -1) {\n+        n = ngx_errno;\n+\n+        if (n == NGX_EAGAIN) {\n+            return ngx_read_file(file, buf, size, offset);\n+        }\n+\n+        ngx_log_error(NGX_LOG_CRIT, file->log, n,\n+                      \"aio_read(\\\"%V\\\") failed\", &file->name);\n+\n+        if (n == NGX_ENOSYS) {\n+            ngx_file_aio = 0;\n+            return ngx_read_file(file, buf, size, offset);\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"aio_read: fd:%d %d\", file->fd, n);\n+\n+    ev->active = 1;\n+    ev->ready = 0;\n+    ev->complete = 0;\n+\n+    return ngx_file_aio_result(aio->file, aio, ev);\n+}\n+\n+\n+static ssize_t\n+ngx_file_aio_result(ngx_file_t *file, ngx_event_aio_t *aio, ngx_event_t *ev)\n+{\n+    int        n;\n+    ngx_err_t  err;\n+\n+    n = aio_error(&aio->aiocb);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"aio_error: fd:%d %d\", file->fd, n);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+        aio->err = err;\n+\n+        ngx_log_error(NGX_LOG_ALERT, file->log, err,\n+                      \"aio_error(\\\"%V\\\") failed\", &file->name);\n+        return NGX_ERROR;\n+    }\n+\n+    if (n == NGX_EINPROGRESS) {\n+        if (ev->ready) {\n+            ev->ready = 0;\n+            ngx_log_error(NGX_LOG_ALERT, file->log, n,\n+                          \"aio_read(\\\"%V\\\") still in progress\",\n+                          &file->name);\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    n = aio_return(&aio->aiocb);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+        aio->err = err;\n+        ev->ready = 1;\n+\n+        ngx_log_error(NGX_LOG_CRIT, file->log, err,\n+                      \"aio_return(\\\"%V\\\") failed\", &file->name);\n+        return NGX_ERROR;\n+    }\n+\n+    aio->err = 0;\n+    aio->nbytes = n;\n+    ev->ready = 1;\n+    ev->active = 0;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"aio_return: fd:%d %d\", file->fd, n);\n+\n+    return n;\n+}\n+\n+\n+static void\n+ngx_file_aio_event_handler(ngx_event_t *ev)\n+{\n+    ngx_event_aio_t  *aio;\n+\n+    aio = ev->data;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_CORE, ev->log, 0,\n+                   \"aio event handler fd:%d %V\", aio->fd, &aio->file->name);\n+\n+    if (ngx_file_aio_result(aio->file, aio, ev) != NGX_AGAIN) {\n+        aio->handler(ev);\n+    }\n+}\nDiff:\n@@ -0,0 +1,907 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_THREADS)\n+#include <ngx_thread_pool.h>\n+static void ngx_thread_read_handler(void *data, ngx_log_t *log);\n+static void ngx_thread_write_chain_to_file_handler(void *data, ngx_log_t *log);\n+#endif\n+\n+static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl);\n+static ssize_t ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec,\n+    off_t offset);\n+\n+\n+#if (NGX_HAVE_FILE_AIO)\n+\n+ngx_uint_t  ngx_file_aio = 1;\n+\n+#endif\n+\n+\n+ssize_t\n+ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)\n+{\n+    ssize_t  n;\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"read: %d, %p, %uz, %O\", file->fd, buf, size, offset);\n+\n+#if (NGX_HAVE_PREAD)\n+\n+    n = pread(file->fd, buf, size, offset);\n+\n+    if (n == -1) {\n+        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                      \"pread() \\\"%s\\\" failed\", file->name.data);\n+        return NGX_ERROR;\n+    }\n+\n+#else\n+\n+    if (file->sys_offset != offset) {\n+        if (lseek(file->fd, offset, SEEK_SET) == -1) {\n+            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                          \"lseek() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        file->sys_offset = offset;\n+    }\n+\n+    n = read(file->fd, buf, size);\n+\n+    if (n == -1) {\n+        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                      \"read() \\\"%s\\\" failed\", file->name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    file->sys_offset += n;\n+\n+#endif\n+\n+    file->offset += n;\n+\n+    return n;\n+}\n+\n+\n+#if (NGX_THREADS)\n+\n+typedef struct {\n+    ngx_fd_t       fd;\n+    ngx_uint_t     write;   /* unsigned  write:1; */\n+\n+    u_char        *buf;\n+    size_t         size;\n+    ngx_chain_t   *chain;\n+    off_t          offset;\n+\n+    size_t         nbytes;\n+    ngx_err_t      err;\n+} ngx_thread_file_ctx_t;\n+\n+\n+ssize_t\n+ngx_thread_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,\n+    ngx_pool_t *pool)\n+{\n+    ngx_thread_task_t      *task;\n+    ngx_thread_file_ctx_t  *ctx;\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"thread read: %d, %p, %uz, %O\",\n+                   file->fd, buf, size, offset);\n+\n+    task = file->thread_task;\n+\n+    if (task == NULL) {\n+        task = ngx_thread_task_alloc(pool, sizeof(ngx_thread_file_ctx_t));\n+        if (task == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        file->thread_task = task;\n+    }\n+\n+    ctx = task->ctx;\n+\n+    if (task->event.complete) {\n+        task->event.complete = 0;\n+\n+        if (ctx->write) {\n+            ngx_log_error(NGX_LOG_ALERT, file->log, 0,\n+                          \"invalid thread call, read instead of write\");\n+            return NGX_ERROR;\n+        }\n+\n+        if (ctx->err) {\n+            ngx_log_error(NGX_LOG_CRIT, file->log, ctx->err,\n+                          \"pread() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        return ctx->nbytes;\n+    }\n+\n+    task->handler = ngx_thread_read_handler;\n+\n+    ctx->write = 0;\n+\n+    ctx->fd = file->fd;\n+    ctx->buf = buf;\n+    ctx->size = size;\n+    ctx->offset = offset;\n+\n+    if (file->thread_handler(task, file) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_AGAIN;\n+}\n+\n+\n+#if (NGX_HAVE_PREAD)\n+\n+static void\n+ngx_thread_read_handler(void *data, ngx_log_t *log)\n+{\n+    ngx_thread_file_ctx_t *ctx = data;\n+\n+    ssize_t  n;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, \"thread read handler\");\n+\n+    n = pread(ctx->fd, ctx->buf, ctx->size, ctx->offset);\n+\n+    if (n == -1) {\n+        ctx->err = ngx_errno;\n+\n+    } else {\n+        ctx->nbytes = n;\n+        ctx->err = 0;\n+    }\n+\n+#if 0\n+    ngx_time_update();\n+#endif\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, log, 0,\n+                   \"pread: %z (err: %d) of %uz @%O\",\n+                   n, ctx->err, ctx->size, ctx->offset);\n+}\n+\n+#else\n+\n+#error pread() is required!\n+\n+#endif\n+\n+#endif /* NGX_THREADS */\n+\n+\n+ssize_t\n+ngx_write_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)\n+{\n+    ssize_t    n, written;\n+    ngx_err_t  err;\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"write: %d, %p, %uz, %O\", file->fd, buf, size, offset);\n+\n+    written = 0;\n+\n+#if (NGX_HAVE_PWRITE)\n+\n+    for ( ;; ) {\n+        n = pwrite(file->fd, buf + written, size, offset);\n+\n+        if (n == -1) {\n+            err = ngx_errno;\n+\n+            if (err == NGX_EINTR) {\n+                ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,\n+                               \"pwrite() was interrupted\");\n+                continue;\n+            }\n+\n+            ngx_log_error(NGX_LOG_CRIT, file->log, err,\n+                          \"pwrite() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        file->offset += n;\n+        written += n;\n+\n+        if ((size_t) n == size) {\n+            return written;\n+        }\n+\n+        offset += n;\n+        size -= n;\n+    }\n+\n+#else\n+\n+    if (file->sys_offset != offset) {\n+        if (lseek(file->fd, offset, SEEK_SET) == -1) {\n+            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                          \"lseek() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        file->sys_offset = offset;\n+    }\n+\n+    for ( ;; ) {\n+        n = write(file->fd, buf + written, size);\n+\n+        if (n == -1) {\n+            err = ngx_errno;\n+\n+            if (err == NGX_EINTR) {\n+                ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,\n+                               \"write() was interrupted\");\n+                continue;\n+            }\n+\n+            ngx_log_error(NGX_LOG_CRIT, file->log, err,\n+                          \"write() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        file->sys_offset += n;\n+        file->offset += n;\n+        written += n;\n+\n+        if ((size_t) n == size) {\n+            return written;\n+        }\n+\n+        size -= n;\n+    }\n+#endif\n+}\n+\n+\n+ngx_fd_t\n+ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)\n+{\n+    ngx_fd_t  fd;\n+\n+    fd = open((const char *) name, O_CREAT|O_EXCL|O_RDWR,\n+              access ? access : 0600);\n+\n+    if (fd != -1 && !persistent) {\n+        (void) unlink((const char *) name);\n+    }\n+\n+    return fd;\n+}\n+\n+\n+ssize_t\n+ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,\n+    ngx_pool_t *pool)\n+{\n+    ssize_t        total, n;\n+    ngx_iovec_t    vec;\n+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];\n+\n+    /* use pwrite() if there is the only buf in a chain */\n+\n+    if (cl->next == NULL) {\n+        return ngx_write_file(file, cl->buf->pos,\n+                              (size_t) (cl->buf->last - cl->buf->pos),\n+                              offset);\n+    }\n+\n+    total = 0;\n+\n+    vec.iovs = iovs;\n+    vec.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    do {\n+        /* create the iovec and coalesce the neighbouring bufs */\n+        cl = ngx_chain_to_iovec(&vec, cl);\n+\n+        /* use pwrite() if there is the only iovec buffer */\n+\n+        if (vec.count == 1) {\n+            n = ngx_write_file(file, (u_char *) iovs[0].iov_base,\n+                               iovs[0].iov_len, offset);\n+\n+            if (n == NGX_ERROR) {\n+                return n;\n+            }\n+\n+            return total + n;\n+        }\n+\n+        n = ngx_writev_file(file, &vec, offset);\n+\n+        if (n == NGX_ERROR) {\n+            return n;\n+        }\n+\n+        offset += n;\n+        total += n;\n+\n+    } while (cl);\n+\n+    return total;\n+}\n+\n+\n+static ngx_chain_t *\n+ngx_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *cl)\n+{\n+    size_t         total, size;\n+    u_char        *prev;\n+    ngx_uint_t     n;\n+    struct iovec  *iov;\n+\n+    iov = NULL;\n+    prev = NULL;\n+    total = 0;\n+    n = 0;\n+\n+    for ( /* void */ ; cl; cl = cl->next) {\n+\n+        if (ngx_buf_special(cl->buf)) {\n+            continue;\n+        }\n+\n+        size = cl->buf->last - cl->buf->pos;\n+\n+        if (prev == cl->buf->pos) {\n+            iov->iov_len += size;\n+\n+        } else {\n+            if (n == vec->nalloc) {\n+                break;\n+            }\n+\n+            iov = &vec->iovs[n++];\n+\n+            iov->iov_base = (void *) cl->buf->pos;\n+            iov->iov_len = size;\n+        }\n+\n+        prev = cl->buf->pos + size;\n+        total += size;\n+    }\n+\n+    vec->count = n;\n+    vec->size = total;\n+\n+    return cl;\n+}\n+\n+\n+static ssize_t\n+ngx_writev_file(ngx_file_t *file, ngx_iovec_t *vec, off_t offset)\n+{\n+    ssize_t    n;\n+    ngx_err_t  err;\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"writev: %d, %uz, %O\", file->fd, vec->size, offset);\n+\n+#if (NGX_HAVE_PWRITEV)\n+\n+eintr:\n+\n+    n = pwritev(file->fd, vec->iovs, vec->count, offset);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+\n+        if (err == NGX_EINTR) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,\n+                           \"pwritev() was interrupted\");\n+            goto eintr;\n+        }\n+\n+        ngx_log_error(NGX_LOG_CRIT, file->log, err,\n+                      \"pwritev() \\\"%s\\\" failed\", file->name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    if ((size_t) n != vec->size) {\n+        ngx_log_error(NGX_LOG_CRIT, file->log, 0,\n+                      \"pwritev() \\\"%s\\\" has written only %z of %uz\",\n+                      file->name.data, n, vec->size);\n+        return NGX_ERROR;\n+    }\n+\n+#else\n+\n+    if (file->sys_offset != offset) {\n+        if (lseek(file->fd, offset, SEEK_SET) == -1) {\n+            ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                          \"lseek() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        file->sys_offset = offset;\n+    }\n+\n+eintr:\n+\n+    n = writev(file->fd, vec->iovs, vec->count);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+\n+        if (err == NGX_EINTR) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, file->log, err,\n+                           \"writev() was interrupted\");\n+            goto eintr;\n+        }\n+\n+        ngx_log_error(NGX_LOG_CRIT, file->log, err,\n+                      \"writev() \\\"%s\\\" failed\", file->name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    if ((size_t) n != vec->size) {\n+        ngx_log_error(NGX_LOG_CRIT, file->log, 0,\n+                      \"writev() \\\"%s\\\" has written only %z of %uz\",\n+                      file->name.data, n, vec->size);\n+        return NGX_ERROR;\n+    }\n+\n+    file->sys_offset += n;\n+\n+#endif\n+\n+    file->offset += n;\n+\n+    return n;\n+}\n+\n+\n+#if (NGX_THREADS)\n+\n+ssize_t\n+ngx_thread_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl, off_t offset,\n+    ngx_pool_t *pool)\n+{\n+    ngx_thread_task_t      *task;\n+    ngx_thread_file_ctx_t  *ctx;\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"thread write chain: %d, %p, %O\",\n+                   file->fd, cl, offset);\n+\n+    task = file->thread_task;\n+\n+    if (task == NULL) {\n+        task = ngx_thread_task_alloc(pool,\n+                                     sizeof(ngx_thread_file_ctx_t));\n+        if (task == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        file->thread_task = task;\n+    }\n+\n+    ctx = task->ctx;\n+\n+    if (task->event.complete) {\n+        task->event.complete = 0;\n+\n+        if (!ctx->write) {\n+            ngx_log_error(NGX_LOG_ALERT, file->log, 0,\n+                          \"invalid thread call, write instead of read\");\n+            return NGX_ERROR;\n+        }\n+\n+        if (ctx->err || ctx->nbytes == 0) {\n+            ngx_log_error(NGX_LOG_CRIT, file->log, ctx->err,\n+                          \"pwritev() \\\"%s\\\" failed\", file->name.data);\n+            return NGX_ERROR;\n+        }\n+\n+        file->offset += ctx->nbytes;\n+        return ctx->nbytes;\n+    }\n+\n+    task->handler = ngx_thread_write_chain_to_file_handler;\n+\n+    ctx->write = 1;\n+\n+    ctx->fd = file->fd;\n+    ctx->chain = cl;\n+    ctx->offset = offset;\n+\n+    if (file->thread_handler(task, file) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_AGAIN;\n+}\n+\n+\n+static void\n+ngx_thread_write_chain_to_file_handler(void *data, ngx_log_t *log)\n+{\n+    ngx_thread_file_ctx_t *ctx = data;\n+\n+#if (NGX_HAVE_PWRITEV)\n+\n+    off_t          offset;\n+    ssize_t        n;\n+    ngx_err_t      err;\n+    ngx_chain_t   *cl;\n+    ngx_iovec_t    vec;\n+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];\n+\n+    vec.iovs = iovs;\n+    vec.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    cl = ctx->chain;\n+    offset = ctx->offset;\n+\n+    ctx->nbytes = 0;\n+    ctx->err = 0;\n+\n+    do {\n+        /* create the iovec and coalesce the neighbouring bufs */\n+        cl = ngx_chain_to_iovec(&vec, cl);\n+\n+eintr:\n+\n+        n = pwritev(ctx->fd, iovs, vec.count, offset);\n+\n+        if (n == -1) {\n+            err = ngx_errno;\n+\n+            if (err == NGX_EINTR) {\n+                ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, err,\n+                               \"pwritev() was interrupted\");\n+                goto eintr;\n+            }\n+\n+            ctx->err = err;\n+            return;\n+        }\n+\n+        if ((size_t) n != vec.size) {\n+            ctx->nbytes = 0;\n+            return;\n+        }\n+\n+        ctx->nbytes += n;\n+        offset += n;\n+    } while (cl);\n+\n+#else\n+\n+    ctx->err = NGX_ENOSYS;\n+    return;\n+\n+#endif\n+}\n+\n+#endif /* NGX_THREADS */\n+\n+\n+ngx_int_t\n+ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s)\n+{\n+    struct timeval  tv[2];\n+\n+    tv[0].tv_sec = ngx_time();\n+    tv[0].tv_usec = 0;\n+    tv[1].tv_sec = s;\n+    tv[1].tv_usec = 0;\n+\n+    if (utimes((char *) name, tv) != -1) {\n+        return NGX_OK;\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_create_file_mapping(ngx_file_mapping_t *fm)\n+{\n+    fm->fd = ngx_open_file(fm->name, NGX_FILE_RDWR, NGX_FILE_TRUNCATE,\n+                           NGX_FILE_DEFAULT_ACCESS);\n+\n+    if (fm->fd == NGX_INVALID_FILE) {\n+        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,\n+                      ngx_open_file_n \" \\\"%s\\\" failed\", fm->name);\n+        return NGX_ERROR;\n+    }\n+\n+    if (ftruncate(fm->fd, fm->size) == -1) {\n+        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,\n+                      \"ftruncate() \\\"%s\\\" failed\", fm->name);\n+        goto failed;\n+    }\n+\n+    fm->addr = mmap(NULL, fm->size, PROT_READ|PROT_WRITE, MAP_SHARED,\n+                    fm->fd, 0);\n+    if (fm->addr != MAP_FAILED) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,\n+                  \"mmap(%uz) \\\"%s\\\" failed\", fm->size, fm->name);\n+\n+failed:\n+\n+    if (ngx_close_file(fm->fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", fm->name);\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+void\n+ngx_close_file_mapping(ngx_file_mapping_t *fm)\n+{\n+    if (munmap(fm->addr, fm->size) == -1) {\n+        ngx_log_error(NGX_LOG_CRIT, fm->log, ngx_errno,\n+                      \"munmap(%uz) \\\"%s\\\" failed\", fm->size, fm->name);\n+    }\n+\n+    if (ngx_close_file(fm->fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, fm->log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", fm->name);\n+    }\n+}\n+\n+\n+ngx_int_t\n+ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)\n+{\n+    dir->dir = opendir((const char *) name->data);\n+\n+    if (dir->dir == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    dir->valid_info = 0;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_read_dir(ngx_dir_t *dir)\n+{\n+    dir->de = readdir(dir->dir);\n+\n+    if (dir->de) {\n+#if (NGX_HAVE_D_TYPE)\n+        dir->type = dir->de->d_type;\n+#else\n+        dir->type = 0;\n+#endif\n+        return NGX_OK;\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_open_glob(ngx_glob_t *gl)\n+{\n+    int  n;\n+\n+    n = glob((char *) gl->pattern, 0, NULL, &gl->pglob);\n+\n+    if (n == 0) {\n+        return NGX_OK;\n+    }\n+\n+#ifdef GLOB_NOMATCH\n+\n+    if (n == GLOB_NOMATCH && gl->test) {\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n+{\n+    size_t  count;\n+\n+#ifdef GLOB_NOMATCH\n+    count = (size_t) gl->pglob.gl_pathc;\n+#else\n+    count = (size_t) gl->pglob.gl_matchc;\n+#endif\n+\n+    if (gl->n < count) {\n+\n+        name->len = (size_t) ngx_strlen(gl->pglob.gl_pathv[gl->n]);\n+        name->data = (u_char *) gl->pglob.gl_pathv[gl->n];\n+        gl->n++;\n+\n+        return NGX_OK;\n+    }\n+\n+    return NGX_DONE;\n+}\n+\n+\n+void\n+ngx_close_glob(ngx_glob_t *gl)\n+{\n+    globfree(&gl->pglob);\n+}\n+\n+\n+ngx_err_t\n+ngx_trylock_fd(ngx_fd_t fd)\n+{\n+    struct flock  fl;\n+\n+    ngx_memzero(&fl, sizeof(struct flock));\n+    fl.l_type = F_WRLCK;\n+    fl.l_whence = SEEK_SET;\n+\n+    if (fcntl(fd, F_SETLK, &fl) == -1) {\n+        return ngx_errno;\n+    }\n+\n+    return 0;\n+}\n+\n+\n+ngx_err_t\n+ngx_lock_fd(ngx_fd_t fd)\n+{\n+    struct flock  fl;\n+\n+    ngx_memzero(&fl, sizeof(struct flock));\n+    fl.l_type = F_WRLCK;\n+    fl.l_whence = SEEK_SET;\n+\n+    if (fcntl(fd, F_SETLKW, &fl) == -1) {\n+        return ngx_errno;\n+    }\n+\n+    return 0;\n+}\n+\n+\n+ngx_err_t\n+ngx_unlock_fd(ngx_fd_t fd)\n+{\n+    struct flock  fl;\n+\n+    ngx_memzero(&fl, sizeof(struct flock));\n+    fl.l_type = F_UNLCK;\n+    fl.l_whence = SEEK_SET;\n+\n+    if (fcntl(fd, F_SETLK, &fl) == -1) {\n+        return  ngx_errno;\n+    }\n+\n+    return 0;\n+}\n+\n+\n+#if (NGX_HAVE_POSIX_FADVISE) && !(NGX_HAVE_F_READAHEAD)\n+\n+ngx_int_t\n+ngx_read_ahead(ngx_fd_t fd, size_t n)\n+{\n+    int  err;\n+\n+    err = posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);\n+\n+    if (err == 0) {\n+        return 0;\n+    }\n+\n+    ngx_set_errno(err);\n+    return NGX_FILE_ERROR;\n+}\n+\n+#endif\n+\n+\n+#if (NGX_HAVE_O_DIRECT)\n+\n+ngx_int_t\n+ngx_directio_on(ngx_fd_t fd)\n+{\n+    int  flags;\n+\n+    flags = fcntl(fd, F_GETFL);\n+\n+    if (flags == -1) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    return fcntl(fd, F_SETFL, flags | O_DIRECT);\n+}\n+\n+\n+ngx_int_t\n+ngx_directio_off(ngx_fd_t fd)\n+{\n+    int  flags;\n+\n+    flags = fcntl(fd, F_GETFL);\n+\n+    if (flags == -1) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    return fcntl(fd, F_SETFL, flags & ~O_DIRECT);\n+}\n+\n+#endif\n+\n+\n+#if (NGX_HAVE_STATFS)\n+\n+size_t\n+ngx_fs_bsize(u_char *name)\n+{\n+    struct statfs  fs;\n+\n+    if (statfs((char *) name, &fs) == -1) {\n+        return 512;\n+    }\n+\n+    if ((fs.f_bsize % 512) != 0) {\n+        return 512;\n+    }\n+\n+    return (size_t) fs.f_bsize;\n+}\n+\n+#elif (NGX_HAVE_STATVFS)\n+\n+size_t\n+ngx_fs_bsize(u_char *name)\n+{\n+    struct statvfs  fs;\n+\n+    if (statvfs((char *) name, &fs) == -1) {\n+        return 512;\n+    }\n+\n+    if ((fs.f_frsize % 512) != 0) {\n+        return 512;\n+    }\n+\n+    return (size_t) fs.f_frsize;\n+}\n+\n+#else\n+\n+size_t\n+ngx_fs_bsize(u_char *name)\n+{\n+    return 512;\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,392 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_FILES_H_INCLUDED_\n+#define _NGX_FILES_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef int                      ngx_fd_t;\n+typedef struct stat              ngx_file_info_t;\n+typedef ino_t                    ngx_file_uniq_t;\n+\n+\n+typedef struct {\n+    u_char                      *name;\n+    size_t                       size;\n+    void                        *addr;\n+    ngx_fd_t                     fd;\n+    ngx_log_t                   *log;\n+} ngx_file_mapping_t;\n+\n+\n+typedef struct {\n+    DIR                         *dir;\n+    struct dirent               *de;\n+    struct stat                  info;\n+\n+    unsigned                     type:8;\n+    unsigned                     valid_info:1;\n+} ngx_dir_t;\n+\n+\n+typedef struct {\n+    size_t                       n;\n+    glob_t                       pglob;\n+    u_char                      *pattern;\n+    ngx_log_t                   *log;\n+    ngx_uint_t                   test;\n+} ngx_glob_t;\n+\n+\n+#define NGX_INVALID_FILE         -1\n+#define NGX_FILE_ERROR           -1\n+\n+\n+\n+#ifdef __CYGWIN__\n+\n+#ifndef NGX_HAVE_CASELESS_FILESYSTEM\n+#define NGX_HAVE_CASELESS_FILESYSTEM  1\n+#endif\n+\n+#define ngx_open_file(name, mode, create, access)                            \\\n+    open((const char *) name, mode|create|O_BINARY, access)\n+\n+#else\n+\n+#define ngx_open_file(name, mode, create, access)                            \\\n+    open((const char *) name, mode|create, access)\n+\n+#endif\n+\n+#define ngx_open_file_n          \"open()\"\n+\n+#define NGX_FILE_RDONLY          O_RDONLY\n+#define NGX_FILE_WRONLY          O_WRONLY\n+#define NGX_FILE_RDWR            O_RDWR\n+#define NGX_FILE_CREATE_OR_OPEN  O_CREAT\n+#define NGX_FILE_OPEN            0\n+#define NGX_FILE_TRUNCATE        (O_CREAT|O_TRUNC)\n+#define NGX_FILE_APPEND          (O_WRONLY|O_APPEND)\n+#define NGX_FILE_NONBLOCK        O_NONBLOCK\n+\n+#if (NGX_HAVE_OPENAT)\n+#define NGX_FILE_NOFOLLOW        O_NOFOLLOW\n+\n+#if defined(O_DIRECTORY)\n+#define NGX_FILE_DIRECTORY       O_DIRECTORY\n+#else\n+#define NGX_FILE_DIRECTORY       0\n+#endif\n+\n+#if defined(O_SEARCH)\n+#define NGX_FILE_SEARCH          (O_SEARCH|NGX_FILE_DIRECTORY)\n+\n+#elif defined(O_EXEC)\n+#define NGX_FILE_SEARCH          (O_EXEC|NGX_FILE_DIRECTORY)\n+\n+#elif (NGX_HAVE_O_PATH)\n+#define NGX_FILE_SEARCH          (O_PATH|O_RDONLY|NGX_FILE_DIRECTORY)\n+\n+#else\n+#define NGX_FILE_SEARCH          (O_RDONLY|NGX_FILE_DIRECTORY)\n+#endif\n+\n+#endif /* NGX_HAVE_OPENAT */\n+\n+#define NGX_FILE_DEFAULT_ACCESS  0644\n+#define NGX_FILE_OWNER_ACCESS    0600\n+\n+\n+#define ngx_close_file           close\n+#define ngx_close_file_n         \"close()\"\n+\n+\n+#define ngx_delete_file(name)    unlink((const char *) name)\n+#define ngx_delete_file_n        \"unlink()\"\n+\n+\n+ngx_fd_t ngx_open_tempfile(u_char *name, ngx_uint_t persistent,\n+    ngx_uint_t access);\n+#define ngx_open_tempfile_n      \"open()\"\n+\n+\n+ssize_t ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset);\n+#if (NGX_HAVE_PREAD)\n+#define ngx_read_file_n          \"pread()\"\n+#else\n+#define ngx_read_file_n          \"read()\"\n+#endif\n+\n+ssize_t ngx_write_file(ngx_file_t *file, u_char *buf, size_t size,\n+    off_t offset);\n+\n+ssize_t ngx_write_chain_to_file(ngx_file_t *file, ngx_chain_t *ce,\n+    off_t offset, ngx_pool_t *pool);\n+\n+\n+#define ngx_read_fd              read\n+#define ngx_read_fd_n            \"read()\"\n+\n+/*\n+ * we use inlined function instead of simple #define\n+ * because glibc 2.3 sets warn_unused_result attribute for write()\n+ * and in this case gcc 4.3 ignores (void) cast\n+ */\n+static ngx_inline ssize_t\n+ngx_write_fd(ngx_fd_t fd, void *buf, size_t n)\n+{\n+    return write(fd, buf, n);\n+}\n+\n+#define ngx_write_fd_n           \"write()\"\n+\n+\n+#define ngx_write_console        ngx_write_fd\n+\n+\n+#define ngx_linefeed(p)          *p++ = LF;\n+#define NGX_LINEFEED_SIZE        1\n+#define NGX_LINEFEED             \"\\x0a\"\n+\n+\n+#define ngx_rename_file(o, n)    rename((const char *) o, (const char *) n)\n+#define ngx_rename_file_n        \"rename()\"\n+\n+\n+#define ngx_change_file_access(n, a) chmod((const char *) n, a)\n+#define ngx_change_file_access_n \"chmod()\"\n+\n+\n+ngx_int_t ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s);\n+#define ngx_set_file_time_n      \"utimes()\"\n+\n+\n+#define ngx_file_info(file, sb)  stat((const char *) file, sb)\n+#define ngx_file_info_n          \"stat()\"\n+\n+#define ngx_fd_info(fd, sb)      fstat(fd, sb)\n+#define ngx_fd_info_n            \"fstat()\"\n+\n+#define ngx_link_info(file, sb)  lstat((const char *) file, sb)\n+#define ngx_link_info_n          \"lstat()\"\n+\n+#define ngx_is_dir(sb)           (S_ISDIR((sb)->st_mode))\n+#define ngx_is_file(sb)          (S_ISREG((sb)->st_mode))\n+#define ngx_is_link(sb)          (S_ISLNK((sb)->st_mode))\n+#define ngx_is_exec(sb)          (((sb)->st_mode & S_IXUSR) == S_IXUSR)\n+#define ngx_file_access(sb)      ((sb)->st_mode & 0777)\n+#define ngx_file_size(sb)        (sb)->st_size\n+#define ngx_file_fs_size(sb)     ngx_max((sb)->st_size, (sb)->st_blocks * 512)\n+#define ngx_file_mtime(sb)       (sb)->st_mtime\n+#define ngx_file_uniq(sb)        (sb)->st_ino\n+\n+\n+ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm);\n+void ngx_close_file_mapping(ngx_file_mapping_t *fm);\n+\n+\n+#define ngx_realpath(p, r)       (u_char *) realpath((char *) p, (char *) r)\n+#define ngx_realpath_n           \"realpath()\"\n+#define ngx_getcwd(buf, size)    (getcwd((char *) buf, size) != NULL)\n+#define ngx_getcwd_n             \"getcwd()\"\n+#define ngx_path_separator(c)    ((c) == '/')\n+\n+\n+#if defined(PATH_MAX)\n+\n+#define NGX_HAVE_MAX_PATH        1\n+#define NGX_MAX_PATH             PATH_MAX\n+\n+#else\n+\n+#define NGX_MAX_PATH             4096\n+\n+#endif\n+\n+\n+ngx_int_t ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir);\n+#define ngx_open_dir_n           \"opendir()\"\n+\n+\n+#define ngx_close_dir(d)         closedir((d)->dir)\n+#define ngx_close_dir_n          \"closedir()\"\n+\n+\n+ngx_int_t ngx_read_dir(ngx_dir_t *dir);\n+#define ngx_read_dir_n           \"readdir()\"\n+\n+\n+#define ngx_create_dir(name, access) mkdir((const char *) name, access)\n+#define ngx_create_dir_n         \"mkdir()\"\n+\n+\n+#define ngx_delete_dir(name)     rmdir((const char *) name)\n+#define ngx_delete_dir_n         \"rmdir()\"\n+\n+\n+#define ngx_dir_access(a)        (a | (a & 0444) >> 2)\n+\n+\n+#define ngx_de_name(dir)         ((u_char *) (dir)->de->d_name)\n+#if (NGX_HAVE_D_NAMLEN)\n+#define ngx_de_namelen(dir)      (dir)->de->d_namlen\n+#else\n+#define ngx_de_namelen(dir)      ngx_strlen((dir)->de->d_name)\n+#endif\n+\n+static ngx_inline ngx_int_t\n+ngx_de_info(u_char *name, ngx_dir_t *dir)\n+{\n+    dir->type = 0;\n+    return stat((const char *) name, &dir->info);\n+}\n+\n+#define ngx_de_info_n            \"stat()\"\n+#define ngx_de_link_info(name, dir)  lstat((const char *) name, &(dir)->info)\n+#define ngx_de_link_info_n       \"lstat()\"\n+\n+#if (NGX_HAVE_D_TYPE)\n+\n+/*\n+ * some file systems (e.g. XFS on Linux and CD9660 on FreeBSD)\n+ * do not set dirent.d_type\n+ */\n+\n+#define ngx_de_is_dir(dir)                                                   \\\n+    (((dir)->type) ? ((dir)->type == DT_DIR) : (S_ISDIR((dir)->info.st_mode)))\n+#define ngx_de_is_file(dir)                                                  \\\n+    (((dir)->type) ? ((dir)->type == DT_REG) : (S_ISREG((dir)->info.st_mode)))\n+#define ngx_de_is_link(dir)                                                  \\\n+    (((dir)->type) ? ((dir)->type == DT_LNK) : (S_ISLNK((dir)->info.st_mode)))\n+\n+#else\n+\n+#define ngx_de_is_dir(dir)       (S_ISDIR((dir)->info.st_mode))\n+#define ngx_de_is_file(dir)      (S_ISREG((dir)->info.st_mode))\n+#define ngx_de_is_link(dir)      (S_ISLNK((dir)->info.st_mode))\n+\n+#endif\n+\n+#define ngx_de_access(dir)       (((dir)->info.st_mode) & 0777)\n+#define ngx_de_size(dir)         (dir)->info.st_size\n+#define ngx_de_fs_size(dir)                                                  \\\n+    ngx_max((dir)->info.st_size, (dir)->info.st_blocks * 512)\n+#define ngx_de_mtime(dir)        (dir)->info.st_mtime\n+\n+\n+ngx_int_t ngx_open_glob(ngx_glob_t *gl);\n+#define ngx_open_glob_n          \"glob()\"\n+ngx_int_t ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name);\n+void ngx_close_glob(ngx_glob_t *gl);\n+\n+\n+ngx_err_t ngx_trylock_fd(ngx_fd_t fd);\n+ngx_err_t ngx_lock_fd(ngx_fd_t fd);\n+ngx_err_t ngx_unlock_fd(ngx_fd_t fd);\n+\n+#define ngx_trylock_fd_n         \"fcntl(F_SETLK, F_WRLCK)\"\n+#define ngx_lock_fd_n            \"fcntl(F_SETLKW, F_WRLCK)\"\n+#define ngx_unlock_fd_n          \"fcntl(F_SETLK, F_UNLCK)\"\n+\n+\n+#if (NGX_HAVE_F_READAHEAD)\n+\n+#define NGX_HAVE_READ_AHEAD      1\n+\n+#define ngx_read_ahead(fd, n)    fcntl(fd, F_READAHEAD, (int) n)\n+#define ngx_read_ahead_n         \"fcntl(fd, F_READAHEAD)\"\n+\n+#elif (NGX_HAVE_POSIX_FADVISE)\n+\n+#define NGX_HAVE_READ_AHEAD      1\n+\n+ngx_int_t ngx_read_ahead(ngx_fd_t fd, size_t n);\n+#define ngx_read_ahead_n         \"posix_fadvise(POSIX_FADV_SEQUENTIAL)\"\n+\n+#else\n+\n+#define ngx_read_ahead(fd, n)    0\n+#define ngx_read_ahead_n         \"ngx_read_ahead_n\"\n+\n+#endif\n+\n+\n+#if (NGX_HAVE_O_DIRECT)\n+\n+ngx_int_t ngx_directio_on(ngx_fd_t fd);\n+#define ngx_directio_on_n        \"fcntl(O_DIRECT)\"\n+\n+ngx_int_t ngx_directio_off(ngx_fd_t fd);\n+#define ngx_directio_off_n       \"fcntl(!O_DIRECT)\"\n+\n+#elif (NGX_HAVE_F_NOCACHE)\n+\n+#define ngx_directio_on(fd)      fcntl(fd, F_NOCACHE, 1)\n+#define ngx_directio_on_n        \"fcntl(F_NOCACHE, 1)\"\n+\n+#elif (NGX_HAVE_DIRECTIO)\n+\n+#define ngx_directio_on(fd)      directio(fd, DIRECTIO_ON)\n+#define ngx_directio_on_n        \"directio(DIRECTIO_ON)\"\n+\n+#else\n+\n+#define ngx_directio_on(fd)      0\n+#define ngx_directio_on_n        \"ngx_directio_on_n\"\n+\n+#endif\n+\n+size_t ngx_fs_bsize(u_char *name);\n+\n+\n+#if (NGX_HAVE_OPENAT)\n+\n+#define ngx_openat_file(fd, name, mode, create, access)                      \\\n+    openat(fd, (const char *) name, mode|create, access)\n+\n+#define ngx_openat_file_n        \"openat()\"\n+\n+#define ngx_file_at_info(fd, name, sb, flag)                                 \\\n+    fstatat(fd, (const char *) name, sb, flag)\n+\n+#define ngx_file_at_info_n       \"fstatat()\"\n+\n+#define NGX_AT_FDCWD             (ngx_fd_t) AT_FDCWD\n+\n+#endif\n+\n+\n+#define ngx_stdout               STDOUT_FILENO\n+#define ngx_stderr               STDERR_FILENO\n+#define ngx_set_stderr(fd)       dup2(fd, STDERR_FILENO)\n+#define ngx_set_stderr_n         \"dup2(STDERR_FILENO)\"\n+\n+\n+#if (NGX_HAVE_FILE_AIO)\n+\n+ngx_int_t ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool);\n+ssize_t ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size,\n+    off_t offset, ngx_pool_t *pool);\n+\n+extern ngx_uint_t  ngx_file_aio;\n+\n+#endif\n+\n+#if (NGX_THREADS)\n+ssize_t ngx_thread_read(ngx_file_t *file, u_char *buf, size_t size,\n+    off_t offset, ngx_pool_t *pool);\n+ssize_t ngx_thread_write_chain_to_file(ngx_file_t *file, ngx_chain_t *cl,\n+    off_t offset, ngx_pool_t *pool);\n+#endif\n+\n+\n+#endif /* _NGX_FILES_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,25 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_FREEBSD_H_INCLUDED_\n+#define _NGX_FREEBSD_H_INCLUDED_\n+\n+\n+void ngx_debug_init(void);\n+ngx_chain_t *ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+extern int         ngx_freebsd_kern_osreldate;\n+extern int         ngx_freebsd_hw_ncpu;\n+extern u_long      ngx_freebsd_net_inet_tcp_sendspace;\n+\n+extern ngx_uint_t  ngx_freebsd_sendfile_nbytes_bug;\n+extern ngx_uint_t  ngx_freebsd_use_tcp_nopush;\n+extern ngx_uint_t  ngx_debug_malloc;\n+\n+\n+#endif /* _NGX_FREEBSD_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,129 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_FREEBSD_CONFIG_H_INCLUDED_\n+#define _NGX_FREEBSD_CONFIG_H_INCLUDED_\n+\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <unistd.h>\n+#include <stdarg.h>\n+#include <stddef.h>             /* offsetof() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <signal.h>\n+#include <pwd.h>\n+#include <grp.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <time.h>\n+#include <sys/param.h>          /* ALIGN() */\n+#include <sys/mount.h>          /* statfs() */\n+\n+#include <sys/filio.h>          /* FIONBIO */\n+#include <sys/uio.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+#include <sys/wait.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sched.h>\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>        /* TCP_NODELAY, TCP_NOPUSH */\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <sys/un.h>\n+\n+#include <libutil.h>            /* setproctitle() before 4.1 */\n+#include <osreldate.h>\n+#include <sys/sysctl.h>\n+\n+#include <dlfcn.h>\n+\n+\n+#if __FreeBSD_version < 400017\n+\n+/*\n+ * FreeBSD 3.x has no CMSG_SPACE() and CMSG_LEN() and has the broken CMSG_DATA()\n+ */\n+\n+#undef  CMSG_SPACE\n+#define CMSG_SPACE(l)       (ALIGN(sizeof(struct cmsghdr)) + ALIGN(l))\n+\n+#undef  CMSG_LEN\n+#define CMSG_LEN(l)         (ALIGN(sizeof(struct cmsghdr)) + (l))\n+\n+#undef  CMSG_DATA\n+#define CMSG_DATA(cmsg)     ((u_char *)(cmsg) + ALIGN(sizeof(struct cmsghdr)))\n+\n+#endif\n+\n+\n+#include <ngx_auto_config.h>\n+\n+\n+#if (NGX_HAVE_POSIX_SEM)\n+#include <semaphore.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_POLL)\n+#include <poll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_KQUEUE)\n+#include <sys/event.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_FILE_AIO)\n+\n+#include <aio.h>\n+typedef struct aiocb  ngx_aiocb_t;\n+\n+#if (__FreeBSD_version < 700005 && !defined __DragonFly__)\n+#define sival_ptr     sigval_ptr\n+#endif\n+\n+#endif\n+\n+\n+#define NGX_LISTEN_BACKLOG        -1\n+\n+\n+#ifdef __DragonFly__\n+#define NGX_KEEPALIVE_FACTOR      1000\n+#endif\n+\n+\n+#ifndef IOV_MAX\n+#define IOV_MAX   1024\n+#endif\n+\n+\n+#ifndef NGX_HAVE_INHERITED_NONBLOCK\n+#define NGX_HAVE_INHERITED_NONBLOCK  1\n+#endif\n+\n+\n+#define NGX_HAVE_OS_SPECIFIC_INIT    1\n+#define NGX_HAVE_DEBUG_MALLOC        1\n+\n+\n+extern char **environ;\n+extern char  *malloc_options;\n+\n+\n+#endif /* _NGX_FREEBSD_CONFIG_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,262 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/* FreeBSD 3.0 at least */\n+char    ngx_freebsd_kern_ostype[16];\n+char    ngx_freebsd_kern_osrelease[128];\n+int     ngx_freebsd_kern_osreldate;\n+int     ngx_freebsd_hw_ncpu;\n+int     ngx_freebsd_kern_ipc_somaxconn;\n+u_long  ngx_freebsd_net_inet_tcp_sendspace;\n+\n+/* FreeBSD 4.9 */\n+int     ngx_freebsd_machdep_hlt_logical_cpus;\n+\n+\n+ngx_uint_t  ngx_freebsd_sendfile_nbytes_bug;\n+ngx_uint_t  ngx_freebsd_use_tcp_nopush;\n+\n+ngx_uint_t  ngx_debug_malloc;\n+\n+\n+static ngx_os_io_t ngx_freebsd_io = {\n+    ngx_unix_recv,\n+    ngx_readv_chain,\n+    ngx_udp_unix_recv,\n+    ngx_unix_send,\n+    ngx_udp_unix_send,\n+    ngx_udp_unix_sendmsg_chain,\n+#if (NGX_HAVE_SENDFILE)\n+    ngx_freebsd_sendfile_chain,\n+    NGX_IO_SENDFILE\n+#else\n+    ngx_writev_chain,\n+    0\n+#endif\n+};\n+\n+\n+typedef struct {\n+    char        *name;\n+    void        *value;\n+    size_t       size;\n+    ngx_uint_t   exists;\n+} sysctl_t;\n+\n+\n+sysctl_t sysctls[] = {\n+    { \"hw.ncpu\",\n+      &ngx_freebsd_hw_ncpu,\n+      sizeof(ngx_freebsd_hw_ncpu), 0 },\n+\n+    { \"machdep.hlt_logical_cpus\",\n+      &ngx_freebsd_machdep_hlt_logical_cpus,\n+      sizeof(ngx_freebsd_machdep_hlt_logical_cpus), 0 },\n+\n+    { \"net.inet.tcp.sendspace\",\n+      &ngx_freebsd_net_inet_tcp_sendspace,\n+      sizeof(ngx_freebsd_net_inet_tcp_sendspace), 0 },\n+\n+    { \"kern.ipc.somaxconn\",\n+      &ngx_freebsd_kern_ipc_somaxconn,\n+      sizeof(ngx_freebsd_kern_ipc_somaxconn), 0 },\n+\n+    { NULL, NULL, 0, 0 }\n+};\n+\n+\n+void\n+ngx_debug_init(void)\n+{\n+#if (NGX_DEBUG_MALLOC)\n+\n+#if __FreeBSD_version >= 500014 && __FreeBSD_version < 1000011\n+    _malloc_options = \"J\";\n+#elif __FreeBSD_version < 500014\n+    malloc_options = \"J\";\n+#endif\n+\n+    ngx_debug_malloc = 1;\n+\n+#else\n+    char  *mo;\n+\n+    mo = getenv(\"MALLOC_OPTIONS\");\n+\n+    if (mo && ngx_strchr(mo, 'J')) {\n+        ngx_debug_malloc = 1;\n+    }\n+#endif\n+}\n+\n+\n+ngx_int_t\n+ngx_os_specific_init(ngx_log_t *log)\n+{\n+    int         version;\n+    size_t      size;\n+    ngx_err_t   err;\n+    ngx_uint_t  i;\n+\n+    size = sizeof(ngx_freebsd_kern_ostype);\n+    if (sysctlbyname(\"kern.ostype\",\n+                     ngx_freebsd_kern_ostype, &size, NULL, 0) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sysctlbyname(kern.ostype) failed\");\n+\n+        if (ngx_errno != NGX_ENOMEM) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_freebsd_kern_ostype[size - 1] = '\\0';\n+    }\n+\n+    size = sizeof(ngx_freebsd_kern_osrelease);\n+    if (sysctlbyname(\"kern.osrelease\",\n+                     ngx_freebsd_kern_osrelease, &size, NULL, 0) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sysctlbyname(kern.osrelease) failed\");\n+\n+        if (ngx_errno != NGX_ENOMEM) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_freebsd_kern_osrelease[size - 1] = '\\0';\n+    }\n+\n+\n+    size = sizeof(int);\n+    if (sysctlbyname(\"kern.osreldate\",\n+                     &ngx_freebsd_kern_osreldate, &size, NULL, 0) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sysctlbyname(kern.osreldate) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    version = ngx_freebsd_kern_osreldate;\n+\n+\n+#if (NGX_HAVE_SENDFILE)\n+\n+    /*\n+     * The determination of the sendfile() \"nbytes bug\" is complex enough.\n+     * There are two sendfile() syscalls: a new #393 has no bug while\n+     * an old #336 has the bug in some versions and has not in others.\n+     * Besides libc_r wrapper also emulates the bug in some versions.\n+     * There is no way to say exactly if syscall #336 in FreeBSD circa 4.6\n+     * has the bug.  We use the algorithm that is correct at least for\n+     * RELEASEs and for syscalls only (not libc_r wrapper).\n+     *\n+     * 4.6.1-RELEASE and below have the bug\n+     * 4.6.2-RELEASE and above have the new syscall\n+     *\n+     * We detect the new sendfile() syscall available at the compile time\n+     * to allow an old binary to run correctly on an updated FreeBSD system.\n+     */\n+\n+#if (__FreeBSD__ == 4 && __FreeBSD_version >= 460102) \\\n+    || __FreeBSD_version == 460002 || __FreeBSD_version >= 500039\n+\n+    /* a new syscall without the bug */\n+\n+    ngx_freebsd_sendfile_nbytes_bug = 0;\n+\n+#else\n+\n+    /* an old syscall that may have the bug */\n+\n+    ngx_freebsd_sendfile_nbytes_bug = 1;\n+\n+#endif\n+\n+#endif /* NGX_HAVE_SENDFILE */\n+\n+\n+    if ((version < 500000 && version >= 440003) || version >= 500017) {\n+        ngx_freebsd_use_tcp_nopush = 1;\n+    }\n+\n+\n+    for (i = 0; sysctls[i].name; i++) {\n+        size = sysctls[i].size;\n+\n+        if (sysctlbyname(sysctls[i].name, sysctls[i].value, &size, NULL, 0)\n+            == 0)\n+        {\n+            sysctls[i].exists = 1;\n+            continue;\n+        }\n+\n+        err = ngx_errno;\n+\n+        if (err == NGX_ENOENT) {\n+            continue;\n+        }\n+\n+        ngx_log_error(NGX_LOG_ALERT, log, err,\n+                      \"sysctlbyname(%s) failed\", sysctls[i].name);\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_freebsd_machdep_hlt_logical_cpus) {\n+        ngx_ncpu = ngx_freebsd_hw_ncpu / 2;\n+\n+    } else {\n+        ngx_ncpu = ngx_freebsd_hw_ncpu;\n+    }\n+\n+    if (version < 600008 && ngx_freebsd_kern_ipc_somaxconn > 32767) {\n+        ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                      \"sysctl kern.ipc.somaxconn must be less than 32768\");\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_tcp_nodelay_and_tcp_nopush = 1;\n+\n+    ngx_os_io = ngx_freebsd_io;\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_os_specific_status(ngx_log_t *log)\n+{\n+    u_long      value;\n+    ngx_uint_t  i;\n+\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0, \"OS: %s %s\",\n+                  ngx_freebsd_kern_ostype, ngx_freebsd_kern_osrelease);\n+\n+#ifdef __DragonFly_version\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0,\n+                  \"kern.osreldate: %d, built on %d\",\n+                  ngx_freebsd_kern_osreldate, __DragonFly_version);\n+#else\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0,\n+                  \"kern.osreldate: %d, built on %d\",\n+                  ngx_freebsd_kern_osreldate, __FreeBSD_version);\n+#endif\n+\n+    for (i = 0; sysctls[i].name; i++) {\n+        if (sysctls[i].exists) {\n+            if (sysctls[i].size == sizeof(long)) {\n+                value = *(long *) sysctls[i].value;\n+\n+            } else {\n+                value = *(int *) sysctls[i].value;\n+            }\n+\n+            ngx_log_error(NGX_LOG_NOTICE, log, 0, \"%s: %l\",\n+                          sysctls[i].name, value);\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,333 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+/*\n+ * Although FreeBSD sendfile() allows to pass a header and a trailer,\n+ * it cannot send a header with a part of the file in one packet until\n+ * FreeBSD 5.3.  Besides, over the fast ethernet connection sendfile()\n+ * may send the partially filled packets, i.e. the 8 file pages may be sent\n+ * as the 11 full 1460-bytes packets, then one incomplete 324-bytes packet,\n+ * and then again the 11 full 1460-bytes packets.\n+ *\n+ * Therefore we use the TCP_NOPUSH option (similar to Linux's TCP_CORK)\n+ * to postpone the sending - it not only sends a header and the first part of\n+ * the file in one packet, but also sends the file pages in the full packets.\n+ *\n+ * But until FreeBSD 4.5 turning TCP_NOPUSH off does not flush a pending\n+ * data that less than MSS, so that data may be sent with 5 second delay.\n+ * So we do not use TCP_NOPUSH on FreeBSD prior to 4.5, although it can be used\n+ * for non-keepalive HTTP connections.\n+ */\n+\n+\n+ngx_chain_t *\n+ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n+{\n+    int               rc, flags;\n+    off_t             send, prev_send, sent;\n+    size_t            file_size;\n+    ssize_t           n;\n+    ngx_uint_t        eintr, eagain;\n+    ngx_err_t         err;\n+    ngx_buf_t        *file;\n+    ngx_event_t      *wev;\n+    ngx_chain_t      *cl;\n+    ngx_iovec_t       header, trailer;\n+    struct sf_hdtr    hdtr;\n+    struct iovec      headers[NGX_IOVS_PREALLOCATE];\n+    struct iovec      trailers[NGX_IOVS_PREALLOCATE];\n+#if (NGX_HAVE_AIO_SENDFILE)\n+    ngx_uint_t        ebusy;\n+    ngx_event_aio_t  *aio;\n+#endif\n+\n+    wev = c->write;\n+\n+    if (!wev->ready) {\n+        return in;\n+    }\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n+        (void) ngx_connection_error(c, wev->kq_errno,\n+                               \"kevent() reported about an closed connection\");\n+        wev->error = 1;\n+        return NGX_CHAIN_ERROR;\n+    }\n+\n+#endif\n+\n+    /* the maximum limit size is the maximum size_t value - the page size */\n+\n+    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n+        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n+    }\n+\n+    send = 0;\n+    eagain = 0;\n+    flags = 0;\n+\n+#if (NGX_HAVE_AIO_SENDFILE && NGX_SUPPRESS_WARN)\n+    aio = NULL;\n+    file = NULL;\n+#endif\n+\n+    header.iovs = headers;\n+    header.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    trailer.iovs = trailers;\n+    trailer.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    for ( ;; ) {\n+        eintr = 0;\n+#if (NGX_HAVE_AIO_SENDFILE)\n+        ebusy = 0;\n+#endif\n+        prev_send = send;\n+\n+        /* create the header iovec and coalesce the neighbouring bufs */\n+\n+        cl = ngx_output_chain_to_iovec(&header, in, limit - send, c->log);\n+\n+        if (cl == NGX_CHAIN_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        send += header.size;\n+\n+        if (cl && cl->buf->in_file && send < limit) {\n+            file = cl->buf;\n+\n+            /* coalesce the neighbouring file bufs */\n+\n+            file_size = (size_t) ngx_chain_coalesce_file(&cl, limit - send);\n+\n+            send += file_size;\n+\n+            if (send < limit) {\n+\n+                /*\n+                 * create the trailer iovec and coalesce the neighbouring bufs\n+                 */\n+\n+                cl = ngx_output_chain_to_iovec(&trailer, cl, limit - send,\n+                                               c->log);\n+                if (cl == NGX_CHAIN_ERROR) {\n+                    return NGX_CHAIN_ERROR;\n+                }\n+\n+                send += trailer.size;\n+\n+            } else {\n+                trailer.count = 0;\n+            }\n+\n+            if (ngx_freebsd_use_tcp_nopush\n+                && c->tcp_nopush == NGX_TCP_NOPUSH_UNSET)\n+            {\n+                if (ngx_tcp_nopush(c->fd) == -1) {\n+                    err = ngx_socket_errno;\n+\n+                    /*\n+                     * there is a tiny chance to be interrupted, however,\n+                     * we continue a processing without the TCP_NOPUSH\n+                     */\n+\n+                    if (err != NGX_EINTR) {\n+                        wev->error = 1;\n+                        (void) ngx_connection_error(c, err,\n+                                                    ngx_tcp_nopush_n \" failed\");\n+                        return NGX_CHAIN_ERROR;\n+                    }\n+\n+                } else {\n+                    c->tcp_nopush = NGX_TCP_NOPUSH_SET;\n+\n+                    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                                   \"tcp_nopush\");\n+                }\n+            }\n+\n+            /*\n+             * sendfile() does unneeded work if sf_hdtr's count is 0,\n+             * but corresponding pointer is not NULL\n+             */\n+\n+            hdtr.headers = header.count ? header.iovs : NULL;\n+            hdtr.hdr_cnt = header.count;\n+            hdtr.trailers = trailer.count ? trailer.iovs : NULL;\n+            hdtr.trl_cnt = trailer.count;\n+\n+            /*\n+             * the \"nbytes bug\" of the old sendfile() syscall:\n+             * http://bugs.freebsd.org/33771\n+             */\n+\n+            if (!ngx_freebsd_sendfile_nbytes_bug) {\n+                header.size = 0;\n+            }\n+\n+            sent = 0;\n+\n+#if (NGX_HAVE_AIO_SENDFILE)\n+            aio = file->file->aio;\n+            flags = (aio && aio->preload_handler) ? SF_NODISKIO : 0;\n+#endif\n+\n+            rc = sendfile(file->file->fd, c->fd, file->file_pos,\n+                          file_size + header.size, &hdtr, &sent, flags);\n+\n+            if (rc == -1) {\n+                err = ngx_errno;\n+\n+                switch (err) {\n+                case NGX_EAGAIN:\n+                    eagain = 1;\n+                    break;\n+\n+                case NGX_EINTR:\n+                    eintr = 1;\n+                    break;\n+\n+#if (NGX_HAVE_AIO_SENDFILE)\n+                case NGX_EBUSY:\n+                    ebusy = 1;\n+                    break;\n+#endif\n+\n+                default:\n+                    wev->error = 1;\n+                    (void) ngx_connection_error(c, err, \"sendfile() failed\");\n+                    return NGX_CHAIN_ERROR;\n+                }\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                               \"sendfile() sent only %O bytes\", sent);\n+\n+            /*\n+             * sendfile() in FreeBSD 3.x-4.x may return value >= 0\n+             * on success, although only 0 is documented\n+             */\n+\n+            } else if (rc >= 0 && sent == 0) {\n+\n+                /*\n+                 * if rc is OK and sent equal to zero, then someone\n+                 * has truncated the file, so the offset became beyond\n+                 * the end of the file\n+                 */\n+\n+                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                         \"sendfile() reported that \\\"%s\\\" was truncated at %O\",\n+                         file->file->name.data, file->file_pos);\n+\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"sendfile: %d, @%O %O:%uz\",\n+                           rc, file->file_pos, sent, file_size + header.size);\n+\n+        } else {\n+            n = ngx_writev(c, &header);\n+\n+            if (n == NGX_ERROR) {\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            sent = (n == NGX_AGAIN) ? 0 : n;\n+        }\n+\n+        c->sent += sent;\n+\n+        in = ngx_chain_update_sent(in, sent);\n+\n+#if (NGX_HAVE_AIO_SENDFILE)\n+\n+        if (ebusy) {\n+            if (aio->event.active) {\n+                /*\n+                 * tolerate duplicate calls; they can happen due to subrequests\n+                 * or multiple calls of the next body filter from a filter\n+                 */\n+\n+                if (sent) {\n+                    c->busy_count = 0;\n+                }\n+\n+                return in;\n+            }\n+\n+            if (sent == 0) {\n+                c->busy_count++;\n+\n+                if (c->busy_count > 2) {\n+                    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                                  \"sendfile(%V) returned busy again\",\n+                                  &file->file->name);\n+\n+                    c->busy_count = 0;\n+                    aio->preload_handler = NULL;\n+\n+                    send = prev_send;\n+                    continue;\n+                }\n+\n+            } else {\n+                c->busy_count = 0;\n+            }\n+\n+            n = aio->preload_handler(file);\n+\n+            if (n > 0) {\n+                send = prev_send + sent;\n+                continue;\n+            }\n+\n+            return in;\n+        }\n+\n+        if (flags == SF_NODISKIO) {\n+            c->busy_count = 0;\n+        }\n+\n+#endif\n+\n+        if (eagain) {\n+\n+            /*\n+             * sendfile() may return EAGAIN, even if it has sent a whole file\n+             * part, it indicates that the successive sendfile() call would\n+             * return EAGAIN right away and would not send anything.\n+             * We use it as a hint.\n+             */\n+\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        if (eintr) {\n+            send = prev_send + sent;\n+            continue;\n+        }\n+\n+        if (send - prev_send != sent) {\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        if (send >= limit || in == NULL) {\n+            return in;\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,82 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#if (NGX_SMP)\n+#define NGX_SMP_LOCK  \"lock;\"\n+#else\n+#define NGX_SMP_LOCK\n+#endif\n+\n+\n+/*\n+ * \"cmpxchgq  r, [m]\":\n+ *\n+ *     if (rax == [m]) {\n+ *         zf = 1;\n+ *         [m] = r;\n+ *     } else {\n+ *         zf = 0;\n+ *         rax = [m];\n+ *     }\n+ *\n+ *\n+ * The \"r\" is any register, %rax (%r0) - %r16.\n+ * The \"=a\" and \"a\" are the %rax register.\n+ * Although we can return result in any register, we use \"a\" because it is\n+ * used in cmpxchgq anyway.  The result is actually in %al but not in $rax,\n+ * however as the code is inlined gcc can test %al as well as %rax.\n+ *\n+ * The \"cc\" means that flags were changed.\n+ */\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    u_char  res;\n+\n+    __asm__ volatile (\n+\n+         NGX_SMP_LOCK\n+    \"    cmpxchgq  %3, %1;   \"\n+    \"    sete      %0;       \"\n+\n+    : \"=a\" (res) : \"m\" (*lock), \"a\" (old), \"r\" (set) : \"cc\", \"memory\");\n+\n+    return res;\n+}\n+\n+\n+/*\n+ * \"xaddq  r, [m]\":\n+ *\n+ *     temp = [m];\n+ *     [m] += r;\n+ *     r = temp;\n+ *\n+ *\n+ * The \"+r\" is any register, %rax (%r0) - %r16.\n+ * The \"cc\" means that flags were changed.\n+ */\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    __asm__ volatile (\n+\n+         NGX_SMP_LOCK\n+    \"    xaddq  %0, %1;   \"\n+\n+    : \"+r\" (add) : \"m\" (*value) : \"cc\", \"memory\");\n+\n+    return add;\n+}\n+\n+\n+#define ngx_memory_barrier()    __asm__ volatile (\"\" ::: \"memory\")\n+\n+#define ngx_cpu_pause()         __asm__ (\"pause\")\nDiff:\n@@ -0,0 +1,155 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+/*\n+ * The ppc assembler treats \";\" as comment, so we have to use \"\\n\".\n+ * The minus in \"bne-\" is a hint for the branch prediction unit that\n+ * this branch is unlikely to be taken.\n+ * The \"1b\" means the nearest backward label \"1\" and the \"1f\" means\n+ * the nearest forward label \"1\".\n+ *\n+ * The \"b\" means that the base registers can be used only, i.e.\n+ * any register except r0.  The r0 register always has a zero value and\n+ * could not be used in \"addi  r0, r0, 1\".\n+ * The \"=&b\" means that no input registers can be used.\n+ *\n+ * \"sync\"    read and write barriers\n+ * \"isync\"   read barrier, is faster than \"sync\"\n+ * \"eieio\"   write barrier, is faster than \"sync\"\n+ * \"lwsync\"  write barrier, is faster than \"eieio\" on ppc64\n+ */\n+\n+#if (NGX_PTR_SIZE == 8)\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    ngx_atomic_uint_t  res, temp;\n+\n+    __asm__ volatile (\n+\n+    \"    li      %0, 0       \\n\" /* preset \"0\" to \"res\"                      */\n+    \"    lwsync              \\n\" /* write barrier                            */\n+    \"1:                      \\n\"\n+    \"    ldarx   %1, 0, %2   \\n\" /* load from [lock] into \"temp\"             */\n+                                 /*   and store reservation                  */\n+    \"    cmpd    %1, %3      \\n\" /* compare \"temp\" and \"old\"                 */\n+    \"    bne-    2f          \\n\" /* not equal                                */\n+    \"    stdcx.  %4, 0, %2   \\n\" /* store \"set\" into [lock] if reservation   */\n+                                 /*   is not cleared                         */\n+    \"    bne-    1b          \\n\" /* the reservation was cleared              */\n+    \"    isync               \\n\" /* read barrier                             */\n+    \"    li      %0, 1       \\n\" /* set \"1\" to \"res\"                         */\n+    \"2:                      \\n\"\n+\n+    : \"=&b\" (res), \"=&b\" (temp)\n+    : \"b\" (lock), \"b\" (old), \"b\" (set)\n+    : \"cc\", \"memory\");\n+\n+    return res;\n+}\n+\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    ngx_atomic_uint_t  res, temp;\n+\n+    __asm__ volatile (\n+\n+    \"    lwsync              \\n\" /* write barrier                            */\n+    \"1:  ldarx   %0, 0, %2   \\n\" /* load from [value] into \"res\"             */\n+                                 /*   and store reservation                  */\n+    \"    add     %1, %0, %3  \\n\" /* \"res\" + \"add\" store in \"temp\"            */\n+    \"    stdcx.  %1, 0, %2   \\n\" /* store \"temp\" into [value] if reservation */\n+                                 /*   is not cleared                         */\n+    \"    bne-    1b          \\n\" /* try again if reservation was cleared     */\n+    \"    isync               \\n\" /* read barrier                             */\n+\n+    : \"=&b\" (res), \"=&b\" (temp)\n+    : \"b\" (value), \"b\" (add)\n+    : \"cc\", \"memory\");\n+\n+    return res;\n+}\n+\n+\n+#if (NGX_SMP)\n+#define ngx_memory_barrier()                                                  \\\n+    __asm__ volatile (\"isync  \\n  lwsync  \\n\" ::: \"memory\")\n+#else\n+#define ngx_memory_barrier()   __asm__ volatile (\"\" ::: \"memory\")\n+#endif\n+\n+#else\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    ngx_atomic_uint_t  res, temp;\n+\n+    __asm__ volatile (\n+\n+    \"    li      %0, 0       \\n\" /* preset \"0\" to \"res\"                      */\n+    \"    eieio               \\n\" /* write barrier                            */\n+    \"1:                      \\n\"\n+    \"    lwarx   %1, 0, %2   \\n\" /* load from [lock] into \"temp\"             */\n+                                 /*   and store reservation                  */\n+    \"    cmpw    %1, %3      \\n\" /* compare \"temp\" and \"old\"                 */\n+    \"    bne-    2f          \\n\" /* not equal                                */\n+    \"    stwcx.  %4, 0, %2   \\n\" /* store \"set\" into [lock] if reservation   */\n+                                 /*   is not cleared                         */\n+    \"    bne-    1b          \\n\" /* the reservation was cleared              */\n+    \"    isync               \\n\" /* read barrier                             */\n+    \"    li      %0, 1       \\n\" /* set \"1\" to \"res\"                         */\n+    \"2:                      \\n\"\n+\n+    : \"=&b\" (res), \"=&b\" (temp)\n+    : \"b\" (lock), \"b\" (old), \"b\" (set)\n+    : \"cc\", \"memory\");\n+\n+    return res;\n+}\n+\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    ngx_atomic_uint_t  res, temp;\n+\n+    __asm__ volatile (\n+\n+    \"    eieio               \\n\" /* write barrier                            */\n+    \"1:  lwarx   %0, 0, %2   \\n\" /* load from [value] into \"res\"             */\n+                                 /*   and store reservation                  */\n+    \"    add     %1, %0, %3  \\n\" /* \"res\" + \"add\" store in \"temp\"            */\n+    \"    stwcx.  %1, 0, %2   \\n\" /* store \"temp\" into [value] if reservation */\n+                                 /*   is not cleared                         */\n+    \"    bne-    1b          \\n\" /* try again if reservation was cleared     */\n+    \"    isync               \\n\" /* read barrier                             */\n+\n+    : \"=&b\" (res), \"=&b\" (temp)\n+    : \"b\" (value), \"b\" (add)\n+    : \"cc\", \"memory\");\n+\n+    return res;\n+}\n+\n+\n+#if (NGX_SMP)\n+#define ngx_memory_barrier()                                                  \\\n+    __asm__ volatile (\"isync  \\n  eieio  \\n\" ::: \"memory\")\n+#else\n+#define ngx_memory_barrier()   __asm__ volatile (\"\" ::: \"memory\")\n+#endif\n+\n+#endif\n+\n+\n+#define ngx_cpu_pause()\nDiff:\n@@ -0,0 +1,82 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+/*\n+ * \"casa   [r1] 0x80, r2, r0\"  and\n+ * \"casxa  [r1] 0x80, r2, r0\"  do the following:\n+ *\n+ *     if ([r1] == r2) {\n+ *         swap(r0, [r1]);\n+ *     } else {\n+ *         r0 = [r1];\n+ *     }\n+ *\n+ * so \"r0 == r2\" means that the operation was successful.\n+ *\n+ *\n+ * The \"r\" means the general register.\n+ * The \"+r\" means the general register used for both input and output.\n+ */\n+\n+\n+#if (NGX_PTR_SIZE == 4)\n+#define NGX_CASA  \"casa\"\n+#else\n+#define NGX_CASA  \"casxa\"\n+#endif\n+\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    __asm__ volatile (\n+\n+    NGX_CASA \" [%1] 0x80, %2, %0\"\n+\n+    : \"+r\" (set) : \"r\" (lock), \"r\" (old) : \"memory\");\n+\n+    return (set == old);\n+}\n+\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    ngx_atomic_uint_t  old, res;\n+\n+    old = *value;\n+\n+    for ( ;; ) {\n+\n+        res = old + add;\n+\n+        __asm__ volatile (\n+\n+        NGX_CASA \" [%1] 0x80, %2, %0\"\n+\n+        : \"+r\" (res) : \"r\" (value), \"r\" (old) : \"memory\");\n+\n+        if (res == old) {\n+            return res;\n+        }\n+\n+        old = res;\n+    }\n+}\n+\n+\n+#if (NGX_SMP)\n+#define ngx_memory_barrier()                                                  \\\n+            __asm__ volatile (                                                \\\n+            \"membar #LoadLoad | #LoadStore | #StoreStore | #StoreLoad\"        \\\n+            ::: \"memory\")\n+#else\n+#define ngx_memory_barrier()   __asm__ volatile (\"\" ::: \"memory\")\n+#endif\n+\n+#define ngx_cpu_pause()\nDiff:\n@@ -0,0 +1,127 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#if (NGX_SMP)\n+#define NGX_SMP_LOCK  \"lock;\"\n+#else\n+#define NGX_SMP_LOCK\n+#endif\n+\n+\n+/*\n+ * \"cmpxchgl  r, [m]\":\n+ *\n+ *     if (eax == [m]) {\n+ *         zf = 1;\n+ *         [m] = r;\n+ *     } else {\n+ *         zf = 0;\n+ *         eax = [m];\n+ *     }\n+ *\n+ *\n+ * The \"r\" means the general register.\n+ * The \"=a\" and \"a\" are the %eax register.\n+ * Although we can return result in any register, we use \"a\" because it is\n+ * used in cmpxchgl anyway.  The result is actually in %al but not in %eax,\n+ * however, as the code is inlined gcc can test %al as well as %eax,\n+ * and icc adds \"movzbl %al, %eax\" by itself.\n+ *\n+ * The \"cc\" means that flags were changed.\n+ */\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    u_char  res;\n+\n+    __asm__ volatile (\n+\n+         NGX_SMP_LOCK\n+    \"    cmpxchgl  %3, %1;   \"\n+    \"    sete      %0;       \"\n+\n+    : \"=a\" (res) : \"m\" (*lock), \"a\" (old), \"r\" (set) : \"cc\", \"memory\");\n+\n+    return res;\n+}\n+\n+\n+/*\n+ * \"xaddl  r, [m]\":\n+ *\n+ *     temp = [m];\n+ *     [m] += r;\n+ *     r = temp;\n+ *\n+ *\n+ * The \"+r\" means the general register.\n+ * The \"cc\" means that flags were changed.\n+ */\n+\n+\n+#if !(( __GNUC__ == 2 && __GNUC_MINOR__ <= 7 ) || ( __INTEL_COMPILER >= 800 ))\n+\n+/*\n+ * icc 8.1 and 9.0 compile broken code with -march=pentium4 option:\n+ * ngx_atomic_fetch_add() always return the input \"add\" value,\n+ * so we use the gcc 2.7 version.\n+ *\n+ * icc 8.1 and 9.0 with -march=pentiumpro option or icc 7.1 compile\n+ * correct code.\n+ */\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    __asm__ volatile (\n+\n+         NGX_SMP_LOCK\n+    \"    xaddl  %0, %1;   \"\n+\n+    : \"+r\" (add) : \"m\" (*value) : \"cc\", \"memory\");\n+\n+    return add;\n+}\n+\n+\n+#else\n+\n+/*\n+ * gcc 2.7 does not support \"+r\", so we have to use the fixed\n+ * %eax (\"=a\" and \"a\") and this adds two superfluous instructions in the end\n+ * of code, something like this: \"mov %eax, %edx / mov %edx, %eax\".\n+ */\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    ngx_atomic_uint_t  old;\n+\n+    __asm__ volatile (\n+\n+         NGX_SMP_LOCK\n+    \"    xaddl  %2, %1;   \"\n+\n+    : \"=a\" (old) : \"m\" (*value), \"a\" (add) : \"cc\", \"memory\");\n+\n+    return old;\n+}\n+\n+#endif\n+\n+\n+/*\n+ * on x86 the write operations go in a program order, so we need only\n+ * to disable the gcc reorder optimizations\n+ */\n+\n+#define ngx_memory_barrier()    __asm__ volatile (\"\" ::: \"memory\")\n+\n+/* old \"as\" does not support \"pause\" opcode */\n+#define ngx_cpu_pause()         __asm__ (\".byte 0xf3, 0x90\")\nDiff:\n@@ -0,0 +1,16 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_LINUX_H_INCLUDED_\n+#define _NGX_LINUX_H_INCLUDED_\n+\n+\n+ngx_chain_t *ngx_linux_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+\n+#endif /* _NGX_LINUX_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,148 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+extern int            ngx_eventfd;\n+extern aio_context_t  ngx_aio_ctx;\n+\n+\n+static void ngx_file_aio_event_handler(ngx_event_t *ev);\n+\n+\n+static int\n+io_submit(aio_context_t ctx, long n, struct iocb **paiocb)\n+{\n+    return syscall(SYS_io_submit, ctx, n, paiocb);\n+}\n+\n+\n+ngx_int_t\n+ngx_file_aio_init(ngx_file_t *file, ngx_pool_t *pool)\n+{\n+    ngx_event_aio_t  *aio;\n+\n+    aio = ngx_pcalloc(pool, sizeof(ngx_event_aio_t));\n+    if (aio == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    aio->file = file;\n+    aio->fd = file->fd;\n+    aio->event.data = aio;\n+    aio->event.ready = 1;\n+    aio->event.log = file->log;\n+\n+    file->aio = aio;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ssize_t\n+ngx_file_aio_read(ngx_file_t *file, u_char *buf, size_t size, off_t offset,\n+    ngx_pool_t *pool)\n+{\n+    ngx_err_t         err;\n+    struct iocb      *piocb[1];\n+    ngx_event_t      *ev;\n+    ngx_event_aio_t  *aio;\n+\n+    if (!ngx_file_aio) {\n+        return ngx_read_file(file, buf, size, offset);\n+    }\n+\n+    if (file->aio == NULL && ngx_file_aio_init(file, pool) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    aio = file->aio;\n+    ev = &aio->event;\n+\n+    if (!ev->ready) {\n+        ngx_log_error(NGX_LOG_ALERT, file->log, 0,\n+                      \"second aio post for \\\"%V\\\"\", &file->name);\n+        return NGX_AGAIN;\n+    }\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, file->log, 0,\n+                   \"aio complete:%d @%O:%uz %V\",\n+                   ev->complete, offset, size, &file->name);\n+\n+    if (ev->complete) {\n+        ev->active = 0;\n+        ev->complete = 0;\n+\n+        if (aio->res >= 0) {\n+            ngx_set_errno(0);\n+            return aio->res;\n+        }\n+\n+        ngx_set_errno(-aio->res);\n+\n+        ngx_log_error(NGX_LOG_CRIT, file->log, ngx_errno,\n+                      \"aio read \\\"%s\\\" failed\", file->name.data);\n+\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memzero(&aio->aiocb, sizeof(struct iocb));\n+\n+    aio->aiocb.aio_data = (uint64_t) (uintptr_t) ev;\n+    aio->aiocb.aio_lio_opcode = IOCB_CMD_PREAD;\n+    aio->aiocb.aio_fildes = file->fd;\n+    aio->aiocb.aio_buf = (uint64_t) (uintptr_t) buf;\n+    aio->aiocb.aio_nbytes = size;\n+    aio->aiocb.aio_offset = offset;\n+    aio->aiocb.aio_flags = IOCB_FLAG_RESFD;\n+    aio->aiocb.aio_resfd = ngx_eventfd;\n+\n+    ev->handler = ngx_file_aio_event_handler;\n+\n+    piocb[0] = &aio->aiocb;\n+\n+    if (io_submit(ngx_aio_ctx, 1, piocb) == 1) {\n+        ev->active = 1;\n+        ev->ready = 0;\n+        ev->complete = 0;\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    err = ngx_errno;\n+\n+    if (err == NGX_EAGAIN) {\n+        return ngx_read_file(file, buf, size, offset);\n+    }\n+\n+    ngx_log_error(NGX_LOG_CRIT, file->log, err,\n+                  \"io_submit(\\\"%V\\\") failed\", &file->name);\n+\n+    if (err == NGX_ENOSYS) {\n+        ngx_file_aio = 0;\n+        return ngx_read_file(file, buf, size, offset);\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+static void\n+ngx_file_aio_event_handler(ngx_event_t *ev)\n+{\n+    ngx_event_aio_t  *aio;\n+\n+    aio = ev->data;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_CORE, ev->log, 0,\n+                   \"aio event handler fd:%d %V\", aio->fd, &aio->file->name);\n+\n+    aio->handler(ev);\n+}\nDiff:\n@@ -0,0 +1,128 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_LINUX_CONFIG_H_INCLUDED_\n+#define _NGX_LINUX_CONFIG_H_INCLUDED_\n+\n+\n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE             /* pread(), pwrite(), gethostname() */\n+#endif\n+\n+#define _FILE_OFFSET_BITS  64\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <unistd.h>\n+#include <stdarg.h>\n+#include <stddef.h>             /* offsetof() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <signal.h>\n+#include <pwd.h>\n+#include <grp.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <sys/vfs.h>            /* statfs() */\n+\n+#include <sys/uio.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+#include <sys/wait.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sched.h>\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>        /* TCP_NODELAY, TCP_CORK */\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <sys/un.h>\n+\n+#include <time.h>               /* tzset() */\n+#include <malloc.h>             /* memalign() */\n+#include <limits.h>             /* IOV_MAX */\n+#include <sys/ioctl.h>\n+#include <crypt.h>\n+#include <sys/utsname.h>        /* uname() */\n+\n+#include <dlfcn.h>\n+\n+\n+#include <ngx_auto_config.h>\n+\n+\n+#if (NGX_HAVE_POSIX_SEM)\n+#include <semaphore.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_SYS_PRCTL_H)\n+#include <sys/prctl.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_SENDFILE64)\n+#include <sys/sendfile.h>\n+#else\n+extern ssize_t sendfile(int s, int fd, int32_t *offset, size_t size);\n+#define NGX_SENDFILE_LIMIT  0x80000000\n+#endif\n+\n+\n+#if (NGX_HAVE_POLL)\n+#include <poll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_EPOLL)\n+#include <sys/epoll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_SYS_EVENTFD_H)\n+#include <sys/eventfd.h>\n+#endif\n+#include <sys/syscall.h>\n+#if (NGX_HAVE_FILE_AIO)\n+#include <linux/aio_abi.h>\n+typedef struct iocb  ngx_aiocb_t;\n+#endif\n+\n+\n+#if (NGX_HAVE_CAPABILITIES)\n+#include <linux/capability.h>\n+#endif\n+\n+\n+#define NGX_LISTEN_BACKLOG        511\n+\n+\n+#ifndef NGX_HAVE_SO_SNDLOWAT\n+/* setsockopt(SO_SNDLOWAT) returns ENOPROTOOPT */\n+#define NGX_HAVE_SO_SNDLOWAT         0\n+#endif\n+\n+\n+#ifndef NGX_HAVE_INHERITED_NONBLOCK\n+#define NGX_HAVE_INHERITED_NONBLOCK  0\n+#endif\n+\n+\n+#define NGX_HAVE_OS_SPECIFIC_INIT    1\n+#define ngx_debug_init()\n+\n+\n+extern char **environ;\n+\n+\n+#endif /* _NGX_LINUX_CONFIG_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,60 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+u_char  ngx_linux_kern_ostype[50];\n+u_char  ngx_linux_kern_osrelease[50];\n+\n+\n+static ngx_os_io_t ngx_linux_io = {\n+    ngx_unix_recv,\n+    ngx_readv_chain,\n+    ngx_udp_unix_recv,\n+    ngx_unix_send,\n+    ngx_udp_unix_send,\n+    ngx_udp_unix_sendmsg_chain,\n+#if (NGX_HAVE_SENDFILE)\n+    ngx_linux_sendfile_chain,\n+    NGX_IO_SENDFILE\n+#else\n+    ngx_writev_chain,\n+    0\n+#endif\n+};\n+\n+\n+ngx_int_t\n+ngx_os_specific_init(ngx_log_t *log)\n+{\n+    struct utsname  u;\n+\n+    if (uname(&u) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno, \"uname() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    (void) ngx_cpystrn(ngx_linux_kern_ostype, (u_char *) u.sysname,\n+                       sizeof(ngx_linux_kern_ostype));\n+\n+    (void) ngx_cpystrn(ngx_linux_kern_osrelease, (u_char *) u.release,\n+                       sizeof(ngx_linux_kern_osrelease));\n+\n+    ngx_os_io = ngx_linux_io;\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_os_specific_status(ngx_log_t *log)\n+{\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0, \"OS: %s %s\",\n+                  ngx_linux_kern_ostype, ngx_linux_kern_osrelease);\n+}\nDiff:\n@@ -0,0 +1,442 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+static ssize_t ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file,\n+    size_t size);\n+\n+#if (NGX_THREADS)\n+#include <ngx_thread_pool.h>\n+\n+#if !(NGX_HAVE_SENDFILE64)\n+#error sendfile64() is required!\n+#endif\n+\n+static ssize_t ngx_linux_sendfile_thread(ngx_connection_t *c, ngx_buf_t *file,\n+    size_t size);\n+static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\n+#endif\n+\n+\n+/*\n+ * On Linux up to 2.4.21 sendfile() (syscall #187) works with 32-bit\n+ * offsets only, and the including <sys/sendfile.h> breaks the compiling,\n+ * if off_t is 64 bit wide.  So we use own sendfile() definition, where offset\n+ * parameter is int32_t, and use sendfile() for the file parts below 2G only,\n+ * see src/os/unix/ngx_linux_config.h\n+ *\n+ * Linux 2.4.21 has the new sendfile64() syscall #239.\n+ *\n+ * On Linux up to 2.6.16 sendfile() does not allow to pass the count parameter\n+ * more than 2G-1 bytes even on 64-bit platforms: it returns EINVAL,\n+ * so we limit it to 2G-1 bytes.\n+ */\n+\n+#define NGX_SENDFILE_MAXSIZE  2147483647L\n+\n+\n+ngx_chain_t *\n+ngx_linux_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n+{\n+    int            tcp_nodelay;\n+    off_t          send, prev_send;\n+    size_t         file_size, sent;\n+    ssize_t        n;\n+    ngx_err_t      err;\n+    ngx_buf_t     *file;\n+    ngx_event_t   *wev;\n+    ngx_chain_t   *cl;\n+    ngx_iovec_t    header;\n+    struct iovec   headers[NGX_IOVS_PREALLOCATE];\n+\n+    wev = c->write;\n+\n+    if (!wev->ready) {\n+        return in;\n+    }\n+\n+\n+    /* the maximum limit size is 2G-1 - the page size */\n+\n+    if (limit == 0 || limit > (off_t) (NGX_SENDFILE_MAXSIZE - ngx_pagesize)) {\n+        limit = NGX_SENDFILE_MAXSIZE - ngx_pagesize;\n+    }\n+\n+\n+    send = 0;\n+\n+    header.iovs = headers;\n+    header.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    for ( ;; ) {\n+        prev_send = send;\n+\n+        /* create the iovec and coalesce the neighbouring bufs */\n+\n+        cl = ngx_output_chain_to_iovec(&header, in, limit - send, c->log);\n+\n+        if (cl == NGX_CHAIN_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        send += header.size;\n+\n+        /* set TCP_CORK if there is a header before a file */\n+\n+        if (c->tcp_nopush == NGX_TCP_NOPUSH_UNSET\n+            && header.count != 0\n+            && cl\n+            && cl->buf->in_file)\n+        {\n+            /* the TCP_CORK and TCP_NODELAY are mutually exclusive */\n+\n+            if (c->tcp_nodelay == NGX_TCP_NODELAY_SET) {\n+\n+                tcp_nodelay = 0;\n+\n+                if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,\n+                               (const void *) &tcp_nodelay, sizeof(int)) == -1)\n+                {\n+                    err = ngx_socket_errno;\n+\n+                    /*\n+                     * there is a tiny chance to be interrupted, however,\n+                     * we continue a processing with the TCP_NODELAY\n+                     * and without the TCP_CORK\n+                     */\n+\n+                    if (err != NGX_EINTR) {\n+                        wev->error = 1;\n+                        ngx_connection_error(c, err,\n+                                             \"setsockopt(TCP_NODELAY) failed\");\n+                        return NGX_CHAIN_ERROR;\n+                    }\n+\n+                } else {\n+                    c->tcp_nodelay = NGX_TCP_NODELAY_UNSET;\n+\n+                    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                                   \"no tcp_nodelay\");\n+                }\n+            }\n+\n+            if (c->tcp_nodelay == NGX_TCP_NODELAY_UNSET) {\n+\n+                if (ngx_tcp_nopush(c->fd) == -1) {\n+                    err = ngx_socket_errno;\n+\n+                    /*\n+                     * there is a tiny chance to be interrupted, however,\n+                     * we continue a processing without the TCP_CORK\n+                     */\n+\n+                    if (err != NGX_EINTR) {\n+                        wev->error = 1;\n+                        ngx_connection_error(c, err,\n+                                             ngx_tcp_nopush_n \" failed\");\n+                        return NGX_CHAIN_ERROR;\n+                    }\n+\n+                } else {\n+                    c->tcp_nopush = NGX_TCP_NOPUSH_SET;\n+\n+                    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                                   \"tcp_nopush\");\n+                }\n+            }\n+        }\n+\n+        /* get the file buf */\n+\n+        if (header.count == 0 && cl && cl->buf->in_file && send < limit) {\n+            file = cl->buf;\n+\n+            /* coalesce the neighbouring file bufs */\n+\n+            file_size = (size_t) ngx_chain_coalesce_file(&cl, limit - send);\n+\n+            send += file_size;\n+#if 1\n+            if (file_size == 0) {\n+                ngx_debug_point();\n+                return NGX_CHAIN_ERROR;\n+            }\n+#endif\n+\n+            n = ngx_linux_sendfile(c, file, file_size);\n+\n+            if (n == NGX_ERROR) {\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            if (n == NGX_DONE) {\n+                /* thread task posted */\n+                return in;\n+            }\n+\n+            sent = (n == NGX_AGAIN) ? 0 : n;\n+\n+        } else {\n+            n = ngx_writev(c, &header);\n+\n+            if (n == NGX_ERROR) {\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            sent = (n == NGX_AGAIN) ? 0 : n;\n+        }\n+\n+        c->sent += sent;\n+\n+        in = ngx_chain_update_sent(in, sent);\n+\n+        if (n == NGX_AGAIN) {\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        if ((size_t) (send - prev_send) != sent) {\n+\n+            /*\n+             * sendfile() on Linux 4.3+ might be interrupted at any time,\n+             * and provides no indication if it was interrupted or not,\n+             * so we have to retry till an explicit EAGAIN\n+             *\n+             * sendfile() in threads can also report less bytes written\n+             * than we are prepared to send now, since it was started in\n+             * some point in the past, so we again have to retry\n+             */\n+\n+            send = prev_send + sent;\n+            continue;\n+        }\n+\n+        if (send >= limit || in == NULL) {\n+            return in;\n+        }\n+    }\n+}\n+\n+\n+static ssize_t\n+ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+#if (NGX_HAVE_SENDFILE64)\n+    off_t      offset;\n+#else\n+    int32_t    offset;\n+#endif\n+    ssize_t    n;\n+    ngx_err_t  err;\n+\n+#if (NGX_THREADS)\n+\n+    if (file->file->thread_handler) {\n+        return ngx_linux_sendfile_thread(c, file, size);\n+    }\n+\n+#endif\n+\n+#if (NGX_HAVE_SENDFILE64)\n+    offset = file->file_pos;\n+#else\n+    offset = (int32_t) file->file_pos;\n+#endif\n+\n+eintr:\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"sendfile: @%O %uz\", file->file_pos, size);\n+\n+    n = sendfile(c->fd, file->file->fd, &offset, size);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+\n+        switch (err) {\n+        case NGX_EAGAIN:\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"sendfile() is not ready\");\n+            return NGX_AGAIN;\n+\n+        case NGX_EINTR:\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"sendfile() was interrupted\");\n+            goto eintr;\n+\n+        default:\n+            c->write->error = 1;\n+            ngx_connection_error(c, err, \"sendfile() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    if (n == 0) {\n+        /*\n+         * if sendfile returns zero, then someone has truncated the file,\n+         * so the offset became beyond the end of the file\n+         */\n+\n+        ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                      \"sendfile() reported that \\\"%s\\\" was truncated at %O\",\n+                      file->file->name.data, file->file_pos);\n+\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0, \"sendfile: %z of %uz @%O\",\n+                   n, size, file->file_pos);\n+\n+    return n;\n+}\n+\n+\n+#if (NGX_THREADS)\n+\n+typedef struct {\n+    ngx_buf_t     *file;\n+    ngx_socket_t   socket;\n+    size_t         size;\n+\n+    size_t         sent;\n+    ngx_err_t      err;\n+} ngx_linux_sendfile_ctx_t;\n+\n+\n+static ssize_t\n+ngx_linux_sendfile_thread(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+    ngx_event_t               *wev;\n+    ngx_thread_task_t         *task;\n+    ngx_linux_sendfile_ctx_t  *ctx;\n+\n+    ngx_log_debug3(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"linux sendfile thread: %d, %uz, %O\",\n+                   file->file->fd, size, file->file_pos);\n+\n+    task = c->sendfile_task;\n+\n+    if (task == NULL) {\n+        task = ngx_thread_task_alloc(c->pool, sizeof(ngx_linux_sendfile_ctx_t));\n+        if (task == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        task->handler = ngx_linux_sendfile_thread_handler;\n+\n+        c->sendfile_task = task;\n+    }\n+\n+    ctx = task->ctx;\n+    wev = c->write;\n+\n+    if (task->event.complete) {\n+        task->event.complete = 0;\n+\n+        if (ctx->err == NGX_EAGAIN) {\n+            /*\n+             * if wev->complete is set, this means that a write event\n+             * happened while we were waiting for the thread task, so\n+             * we have to retry sending even on EAGAIN\n+             */\n+\n+            if (wev->complete) {\n+                return 0;\n+            }\n+\n+            return NGX_AGAIN;\n+        }\n+\n+        if (ctx->err) {\n+            wev->error = 1;\n+            ngx_connection_error(c, ctx->err, \"sendfile() failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        if (ctx->sent == 0) {\n+            /*\n+             * if sendfile returns zero, then someone has truncated the file,\n+             * so the offset became beyond the end of the file\n+             */\n+\n+            ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"sendfile() reported that \\\"%s\\\" was truncated at %O\",\n+                          file->file->name.data, file->file_pos);\n+\n+            return NGX_ERROR;\n+        }\n+\n+        return ctx->sent;\n+    }\n+\n+    if (task->event.active && ctx->file == file) {\n+        /*\n+         * tolerate duplicate calls; they can happen due to subrequests\n+         * or multiple calls of the next body filter from a filter\n+         */\n+\n+        return NGX_DONE;\n+    }\n+\n+    ctx->file = file;\n+    ctx->socket = c->fd;\n+    ctx->size = size;\n+\n+    wev->complete = 0;\n+\n+    if (file->file->thread_handler(task, file->file) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_DONE;\n+}\n+\n+\n+static void\n+ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log)\n+{\n+    ngx_linux_sendfile_ctx_t *ctx = data;\n+\n+    off_t       offset;\n+    ssize_t     n;\n+    ngx_buf_t  *file;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, \"linux sendfile thread handler\");\n+\n+    file = ctx->file;\n+    offset = file->file_pos;\n+\n+again:\n+\n+    n = sendfile(ctx->socket, file->file->fd, &offset, ctx->size);\n+\n+    if (n == -1) {\n+        ctx->err = ngx_errno;\n+\n+    } else {\n+        ctx->sent = n;\n+        ctx->err = 0;\n+    }\n+\n+#if 0\n+    ngx_time_update();\n+#endif\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_EVENT, log, 0,\n+                   \"sendfile: %z (err: %d) of %uz @%O\",\n+                   n, ctx->err, ctx->size, file->file_pos);\n+\n+    if (ctx->err == NGX_EINTR) {\n+        goto again;\n+    }\n+}\n+\n+#endif /* NGX_THREADS */\nDiff:\n@@ -0,0 +1,102 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_OS_H_INCLUDED_\n+#define _NGX_OS_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#define NGX_IO_SENDFILE    1\n+\n+\n+typedef ssize_t (*ngx_recv_pt)(ngx_connection_t *c, u_char *buf, size_t size);\n+typedef ssize_t (*ngx_recv_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+typedef ssize_t (*ngx_send_pt)(ngx_connection_t *c, u_char *buf, size_t size);\n+typedef ngx_chain_t *(*ngx_send_chain_pt)(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+typedef struct {\n+    ngx_recv_pt        recv;\n+    ngx_recv_chain_pt  recv_chain;\n+    ngx_recv_pt        udp_recv;\n+    ngx_send_pt        send;\n+    ngx_send_pt        udp_send;\n+    ngx_send_chain_pt  udp_send_chain;\n+    ngx_send_chain_pt  send_chain;\n+    ngx_uint_t         flags;\n+} ngx_os_io_t;\n+\n+\n+ngx_int_t ngx_os_init(ngx_log_t *log);\n+void ngx_os_status(ngx_log_t *log);\n+ngx_int_t ngx_os_specific_init(ngx_log_t *log);\n+void ngx_os_specific_status(ngx_log_t *log);\n+ngx_int_t ngx_daemon(ngx_log_t *log);\n+ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle, char *sig, ngx_pid_t pid);\n+\n+\n+ssize_t ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size);\n+ssize_t ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *entry, off_t limit);\n+ssize_t ngx_udp_unix_recv(ngx_connection_t *c, u_char *buf, size_t size);\n+ssize_t ngx_unix_send(ngx_connection_t *c, u_char *buf, size_t size);\n+ngx_chain_t *ngx_writev_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+ssize_t ngx_udp_unix_send(ngx_connection_t *c, u_char *buf, size_t size);\n+ngx_chain_t *ngx_udp_unix_sendmsg_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+\n+#if (IOV_MAX > 64)\n+#define NGX_IOVS_PREALLOCATE  64\n+#else\n+#define NGX_IOVS_PREALLOCATE  IOV_MAX\n+#endif\n+\n+\n+typedef struct {\n+    struct iovec  *iovs;\n+    ngx_uint_t     count;\n+    size_t         size;\n+    ngx_uint_t     nalloc;\n+} ngx_iovec_t;\n+\n+ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in,\n+    size_t limit, ngx_log_t *log);\n+\n+\n+ssize_t ngx_writev(ngx_connection_t *c, ngx_iovec_t *vec);\n+\n+\n+extern ngx_os_io_t  ngx_os_io;\n+extern ngx_int_t    ngx_ncpu;\n+extern ngx_int_t    ngx_max_sockets;\n+extern ngx_uint_t   ngx_inherited_nonblocking;\n+extern ngx_uint_t   ngx_tcp_nodelay_and_tcp_nopush;\n+\n+\n+#if (NGX_FREEBSD)\n+#include <ngx_freebsd.h>\n+\n+\n+#elif (NGX_LINUX)\n+#include <ngx_linux.h>\n+\n+\n+#elif (NGX_SOLARIS)\n+#include <ngx_solaris.h>\n+\n+\n+#elif (NGX_DARWIN)\n+#include <ngx_darwin.h>\n+#endif\n+\n+\n+#endif /* _NGX_OS_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,151 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_POSIX_CONFIG_H_INCLUDED_\n+#define _NGX_POSIX_CONFIG_H_INCLUDED_\n+\n+\n+#if (NGX_HPUX)\n+#define _XOPEN_SOURCE\n+#define _XOPEN_SOURCE_EXTENDED  1\n+#define _HPUX_ALT_XOPEN_SOCKET_API\n+#endif\n+\n+\n+#if (NGX_TRU64)\n+#define _REENTRANT\n+#endif\n+\n+\n+#if (NGX_GNU_HURD)\n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE             /* accept4() */\n+#endif\n+#define _FILE_OFFSET_BITS       64\n+#endif\n+\n+\n+#ifdef __CYGWIN__\n+#define timezonevar             /* timezone is variable */\n+#define NGX_BROKEN_SCM_RIGHTS   1\n+#endif\n+\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#if (NGX_HAVE_UNISTD_H)\n+#include <unistd.h>\n+#endif\n+#if (NGX_HAVE_INTTYPES_H)\n+#include <inttypes.h>\n+#endif\n+#include <stdarg.h>\n+#include <stddef.h>             /* offsetof() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <signal.h>\n+#include <pwd.h>\n+#include <grp.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <time.h>\n+#if (NGX_HAVE_SYS_PARAM_H)\n+#include <sys/param.h>          /* statfs() */\n+#endif\n+#if (NGX_HAVE_SYS_MOUNT_H)\n+#include <sys/mount.h>          /* statfs() */\n+#endif\n+#if (NGX_HAVE_SYS_STATVFS_H)\n+#include <sys/statvfs.h>        /* statvfs() */\n+#endif\n+\n+#if (NGX_HAVE_SYS_FILIO_H)\n+#include <sys/filio.h>          /* FIONBIO */\n+#endif\n+#include <sys/ioctl.h>          /* FIONBIO */\n+\n+#include <sys/uio.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+#include <sys/wait.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sched.h>\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>        /* TCP_NODELAY */\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <sys/un.h>\n+\n+#if (NGX_HAVE_LIMITS_H)\n+#include <limits.h>             /* IOV_MAX */\n+#endif\n+\n+#ifdef __CYGWIN__\n+#include <malloc.h>             /* memalign() */\n+#endif\n+\n+#if (NGX_HAVE_CRYPT_H)\n+#include <crypt.h>\n+#endif\n+\n+\n+#ifndef IOV_MAX\n+#define IOV_MAX   16\n+#endif\n+\n+\n+#include <ngx_auto_config.h>\n+\n+\n+#if (NGX_HAVE_DLOPEN)\n+#include <dlfcn.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_POSIX_SEM)\n+#include <semaphore.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_POLL)\n+#include <poll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_KQUEUE)\n+#include <sys/event.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_DEVPOLL) && !(NGX_TEST_BUILD_DEVPOLL)\n+#include <sys/ioctl.h>\n+#include <sys/devpoll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_FILE_AIO)\n+#include <aio.h>\n+typedef struct aiocb  ngx_aiocb_t;\n+#endif\n+\n+\n+#define NGX_LISTEN_BACKLOG  511\n+\n+#define ngx_debug_init()\n+\n+\n+extern char **environ;\n+\n+\n+#endif /* _NGX_POSIX_CONFIG_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,144 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <nginx.h>\n+\n+\n+ngx_int_t   ngx_ncpu;\n+ngx_int_t   ngx_max_sockets;\n+ngx_uint_t  ngx_inherited_nonblocking;\n+ngx_uint_t  ngx_tcp_nodelay_and_tcp_nopush;\n+\n+\n+struct rlimit  rlmt;\n+\n+\n+ngx_os_io_t ngx_os_io = {\n+    ngx_unix_recv,\n+    ngx_readv_chain,\n+    ngx_udp_unix_recv,\n+    ngx_unix_send,\n+    ngx_udp_unix_send,\n+    ngx_udp_unix_sendmsg_chain,\n+    ngx_writev_chain,\n+    0\n+};\n+\n+\n+ngx_int_t\n+ngx_os_init(ngx_log_t *log)\n+{\n+    ngx_time_t  *tp;\n+    ngx_uint_t   n;\n+#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n+    long         size;\n+#endif\n+\n+#if (NGX_HAVE_OS_SPECIFIC_INIT)\n+    if (ngx_os_specific_init(log) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+#endif\n+\n+    if (ngx_init_setproctitle(log) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_pagesize = getpagesize();\n+    ngx_cacheline_size = NGX_CPU_CACHE_LINE;\n+\n+    for (n = ngx_pagesize; n >>= 1; ngx_pagesize_shift++) { /* void */ }\n+\n+#if (NGX_HAVE_SC_NPROCESSORS_ONLN)\n+    if (ngx_ncpu == 0) {\n+        ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);\n+    }\n+#endif\n+\n+    if (ngx_ncpu < 1) {\n+        ngx_ncpu = 1;\n+    }\n+\n+#if (NGX_HAVE_LEVEL1_DCACHE_LINESIZE)\n+    size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);\n+    if (size > 0) {\n+        ngx_cacheline_size = size;\n+    }\n+#endif\n+\n+    ngx_cpuinfo();\n+\n+    if (getrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, errno,\n+                      \"getrlimit(RLIMIT_NOFILE) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_max_sockets = (ngx_int_t) rlmt.rlim_cur;\n+\n+#if (NGX_HAVE_INHERITED_NONBLOCK || NGX_HAVE_ACCEPT4)\n+    ngx_inherited_nonblocking = 1;\n+#else\n+    ngx_inherited_nonblocking = 0;\n+#endif\n+\n+    tp = ngx_timeofday();\n+    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_os_status(ngx_log_t *log)\n+{\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0, NGINX_VER_BUILD);\n+\n+#ifdef NGX_COMPILER\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0, \"built by \" NGX_COMPILER);\n+#endif\n+\n+#if (NGX_HAVE_OS_SPECIFIC_INIT)\n+    ngx_os_specific_status(log);\n+#endif\n+\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0,\n+                  \"getrlimit(RLIMIT_NOFILE): %r:%r\",\n+                  rlmt.rlim_cur, rlmt.rlim_max);\n+}\n+\n+\n+#if 0\n+\n+ngx_int_t\n+ngx_posix_post_conf_init(ngx_log_t *log)\n+{\n+    ngx_fd_t  pp[2];\n+\n+    if (pipe(pp) == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, \"pipe() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (dup2(pp[1], STDERR_FILENO) == -1) {\n+        ngx_log_error(NGX_LOG_EMERG, log, errno, \"dup2(STDERR) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (pp[1] > STDERR_FILENO) {\n+        if (close(pp[1]) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, log, errno, \"close() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,648 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_channel.h>\n+\n+\n+typedef struct {\n+    int     signo;\n+    char   *signame;\n+    char   *name;\n+    void  (*handler)(int signo, siginfo_t *siginfo, void *ucontext);\n+} ngx_signal_t;\n+\n+\n+\n+static void ngx_execute_proc(ngx_cycle_t *cycle, void *data);\n+static void ngx_signal_handler(int signo, siginfo_t *siginfo, void *ucontext);\n+static void ngx_process_get_status(void);\n+static void ngx_unlock_mutexes(ngx_pid_t pid);\n+\n+\n+int              ngx_argc;\n+char           **ngx_argv;\n+char           **ngx_os_argv;\n+\n+ngx_int_t        ngx_process_slot;\n+ngx_socket_t     ngx_channel;\n+ngx_int_t        ngx_last_process;\n+ngx_process_t    ngx_processes[NGX_MAX_PROCESSES];\n+\n+\n+ngx_signal_t  signals[] = {\n+    { ngx_signal_value(NGX_RECONFIGURE_SIGNAL),\n+      \"SIG\" ngx_value(NGX_RECONFIGURE_SIGNAL),\n+      \"reload\",\n+      ngx_signal_handler },\n+\n+    { ngx_signal_value(NGX_REOPEN_SIGNAL),\n+      \"SIG\" ngx_value(NGX_REOPEN_SIGNAL),\n+      \"reopen\",\n+      ngx_signal_handler },\n+\n+    { ngx_signal_value(NGX_NOACCEPT_SIGNAL),\n+      \"SIG\" ngx_value(NGX_NOACCEPT_SIGNAL),\n+      \"\",\n+      ngx_signal_handler },\n+\n+    { ngx_signal_value(NGX_TERMINATE_SIGNAL),\n+      \"SIG\" ngx_value(NGX_TERMINATE_SIGNAL),\n+      \"stop\",\n+      ngx_signal_handler },\n+\n+    { ngx_signal_value(NGX_SHUTDOWN_SIGNAL),\n+      \"SIG\" ngx_value(NGX_SHUTDOWN_SIGNAL),\n+      \"quit\",\n+      ngx_signal_handler },\n+\n+    { ngx_signal_value(NGX_CHANGEBIN_SIGNAL),\n+      \"SIG\" ngx_value(NGX_CHANGEBIN_SIGNAL),\n+      \"\",\n+      ngx_signal_handler },\n+\n+    { SIGALRM, \"SIGALRM\", \"\", ngx_signal_handler },\n+\n+    { SIGINT, \"SIGINT\", \"\", ngx_signal_handler },\n+\n+    { SIGIO, \"SIGIO\", \"\", ngx_signal_handler },\n+\n+    { SIGCHLD, \"SIGCHLD\", \"\", ngx_signal_handler },\n+\n+    { SIGSYS, \"SIGSYS, SIG_IGN\", \"\", NULL },\n+\n+    { SIGPIPE, \"SIGPIPE, SIG_IGN\", \"\", NULL },\n+\n+    { 0, NULL, \"\", NULL }\n+};\n+\n+\n+ngx_pid_t\n+ngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,\n+    char *name, ngx_int_t respawn)\n+{\n+    u_long     on;\n+    ngx_pid_t  pid;\n+    ngx_int_t  s;\n+\n+    if (respawn >= 0) {\n+        s = respawn;\n+\n+    } else {\n+        for (s = 0; s < ngx_last_process; s++) {\n+            if (ngx_processes[s].pid == -1) {\n+                break;\n+            }\n+        }\n+\n+        if (s == NGX_MAX_PROCESSES) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n+                          \"no more than %d processes can be spawned\",\n+                          NGX_MAX_PROCESSES);\n+            return NGX_INVALID_PID;\n+        }\n+    }\n+\n+\n+    if (respawn != NGX_PROCESS_DETACHED) {\n+\n+        /* Solaris 9 still has no AF_LOCAL */\n+\n+        if (socketpair(AF_UNIX, SOCK_STREAM, 0, ngx_processes[s].channel) == -1)\n+        {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"socketpair() failed while spawning \\\"%s\\\"\", name);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n+                       \"channel %d:%d\",\n+                       ngx_processes[s].channel[0],\n+                       ngx_processes[s].channel[1]);\n+\n+        if (ngx_nonblocking(ngx_processes[s].channel[0]) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          ngx_nonblocking_n \" failed while spawning \\\"%s\\\"\",\n+                          name);\n+            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        if (ngx_nonblocking(ngx_processes[s].channel[1]) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          ngx_nonblocking_n \" failed while spawning \\\"%s\\\"\",\n+                          name);\n+            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        on = 1;\n+        if (ioctl(ngx_processes[s].channel[0], FIOASYNC, &on) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"ioctl(FIOASYNC) failed while spawning \\\"%s\\\"\", name);\n+            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        if (fcntl(ngx_processes[s].channel[0], F_SETOWN, ngx_pid) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"fcntl(F_SETOWN) failed while spawning \\\"%s\\\"\", name);\n+            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        if (fcntl(ngx_processes[s].channel[0], F_SETFD, FD_CLOEXEC) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"fcntl(FD_CLOEXEC) failed while spawning \\\"%s\\\"\",\n+                           name);\n+            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        if (fcntl(ngx_processes[s].channel[1], F_SETFD, FD_CLOEXEC) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"fcntl(FD_CLOEXEC) failed while spawning \\\"%s\\\"\",\n+                           name);\n+            ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+            return NGX_INVALID_PID;\n+        }\n+\n+        ngx_channel = ngx_processes[s].channel[1];\n+\n+    } else {\n+        ngx_processes[s].channel[0] = -1;\n+        ngx_processes[s].channel[1] = -1;\n+    }\n+\n+    ngx_process_slot = s;\n+\n+\n+    pid = fork();\n+\n+    switch (pid) {\n+\n+    case -1:\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      \"fork() failed while spawning \\\"%s\\\"\", name);\n+        ngx_close_channel(ngx_processes[s].channel, cycle->log);\n+        return NGX_INVALID_PID;\n+\n+    case 0:\n+        ngx_parent = ngx_pid;\n+        ngx_pid = ngx_getpid();\n+        proc(cycle, data);\n+        break;\n+\n+    default:\n+        break;\n+    }\n+\n+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"start %s %P\", name, pid);\n+\n+    ngx_processes[s].pid = pid;\n+    ngx_processes[s].exited = 0;\n+\n+    if (respawn >= 0) {\n+        return pid;\n+    }\n+\n+    ngx_processes[s].proc = proc;\n+    ngx_processes[s].data = data;\n+    ngx_processes[s].name = name;\n+    ngx_processes[s].exiting = 0;\n+\n+    switch (respawn) {\n+\n+    case NGX_PROCESS_NORESPAWN:\n+        ngx_processes[s].respawn = 0;\n+        ngx_processes[s].just_spawn = 0;\n+        ngx_processes[s].detached = 0;\n+        break;\n+\n+    case NGX_PROCESS_JUST_SPAWN:\n+        ngx_processes[s].respawn = 0;\n+        ngx_processes[s].just_spawn = 1;\n+        ngx_processes[s].detached = 0;\n+        break;\n+\n+    case NGX_PROCESS_RESPAWN:\n+        ngx_processes[s].respawn = 1;\n+        ngx_processes[s].just_spawn = 0;\n+        ngx_processes[s].detached = 0;\n+        break;\n+\n+    case NGX_PROCESS_JUST_RESPAWN:\n+        ngx_processes[s].respawn = 1;\n+        ngx_processes[s].just_spawn = 1;\n+        ngx_processes[s].detached = 0;\n+        break;\n+\n+    case NGX_PROCESS_DETACHED:\n+        ngx_processes[s].respawn = 0;\n+        ngx_processes[s].just_spawn = 0;\n+        ngx_processes[s].detached = 1;\n+        break;\n+    }\n+\n+    if (s == ngx_last_process) {\n+        ngx_last_process++;\n+    }\n+\n+    return pid;\n+}\n+\n+\n+ngx_pid_t\n+ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx)\n+{\n+    return ngx_spawn_process(cycle, ngx_execute_proc, ctx, ctx->name,\n+                             NGX_PROCESS_DETACHED);\n+}\n+\n+\n+static void\n+ngx_execute_proc(ngx_cycle_t *cycle, void *data)\n+{\n+    ngx_exec_ctx_t  *ctx = data;\n+\n+    if (execve(ctx->path, ctx->argv, ctx->envp) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      \"execve() failed while executing %s \\\"%s\\\"\",\n+                      ctx->name, ctx->path);\n+    }\n+\n+    exit(1);\n+}\n+\n+\n+ngx_int_t\n+ngx_init_signals(ngx_log_t *log)\n+{\n+    ngx_signal_t      *sig;\n+    struct sigaction   sa;\n+\n+    for (sig = signals; sig->signo != 0; sig++) {\n+        ngx_memzero(&sa, sizeof(struct sigaction));\n+\n+        if (sig->handler) {\n+            sa.sa_sigaction = sig->handler;\n+            sa.sa_flags = SA_SIGINFO;\n+\n+        } else {\n+            sa.sa_handler = SIG_IGN;\n+        }\n+\n+        sigemptyset(&sa.sa_mask);\n+        if (sigaction(sig->signo, &sa, NULL) == -1) {\n+#if (NGX_VALGRIND)\n+            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                          \"sigaction(%s) failed, ignored\", sig->signame);\n+#else\n+            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                          \"sigaction(%s) failed\", sig->signame);\n+            return NGX_ERROR;\n+#endif\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void\n+ngx_signal_handler(int signo, siginfo_t *siginfo, void *ucontext)\n+{\n+    char            *action;\n+    ngx_int_t        ignore;\n+    ngx_err_t        err;\n+    ngx_signal_t    *sig;\n+\n+    ignore = 0;\n+\n+    err = ngx_errno;\n+\n+    for (sig = signals; sig->signo != 0; sig++) {\n+        if (sig->signo == signo) {\n+            break;\n+        }\n+    }\n+\n+    ngx_time_sigsafe_update();\n+\n+    action = \"\";\n+\n+    switch (ngx_process) {\n+\n+    case NGX_PROCESS_MASTER:\n+    case NGX_PROCESS_SINGLE:\n+        switch (signo) {\n+\n+        case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):\n+            ngx_quit = 1;\n+            action = \", shutting down\";\n+            break;\n+\n+        case ngx_signal_value(NGX_TERMINATE_SIGNAL):\n+        case SIGINT:\n+            ngx_terminate = 1;\n+            action = \", exiting\";\n+            break;\n+\n+        case ngx_signal_value(NGX_NOACCEPT_SIGNAL):\n+            if (ngx_daemonized) {\n+                ngx_noaccept = 1;\n+                action = \", stop accepting connections\";\n+            }\n+            break;\n+\n+        case ngx_signal_value(NGX_RECONFIGURE_SIGNAL):\n+            ngx_reconfigure = 1;\n+            action = \", reconfiguring\";\n+            break;\n+\n+        case ngx_signal_value(NGX_REOPEN_SIGNAL):\n+            ngx_reopen = 1;\n+            action = \", reopening logs\";\n+            break;\n+\n+        case ngx_signal_value(NGX_CHANGEBIN_SIGNAL):\n+            if (ngx_getppid() == ngx_parent || ngx_new_binary > 0) {\n+\n+                /*\n+                 * Ignore the signal in the new binary if its parent is\n+                 * not changed, i.e. the old binary's process is still\n+                 * running.  Or ignore the signal in the old binary's\n+                 * process if the new binary's process is already running.\n+                 */\n+\n+                action = \", ignoring\";\n+                ignore = 1;\n+                break;\n+            }\n+\n+            ngx_change_binary = 1;\n+            action = \", changing binary\";\n+            break;\n+\n+        case SIGALRM:\n+            ngx_sigalrm = 1;\n+            break;\n+\n+        case SIGIO:\n+            ngx_sigio = 1;\n+            break;\n+\n+        case SIGCHLD:\n+            ngx_reap = 1;\n+            break;\n+        }\n+\n+        break;\n+\n+    case NGX_PROCESS_WORKER:\n+    case NGX_PROCESS_HELPER:\n+        switch (signo) {\n+\n+        case ngx_signal_value(NGX_NOACCEPT_SIGNAL):\n+            if (!ngx_daemonized) {\n+                break;\n+            }\n+            ngx_debug_quit = 1;\n+            /* fall through */\n+        case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):\n+            ngx_quit = 1;\n+            action = \", shutting down\";\n+            break;\n+\n+        case ngx_signal_value(NGX_TERMINATE_SIGNAL):\n+        case SIGINT:\n+            ngx_terminate = 1;\n+            action = \", exiting\";\n+            break;\n+\n+        case ngx_signal_value(NGX_REOPEN_SIGNAL):\n+            ngx_reopen = 1;\n+            action = \", reopening logs\";\n+            break;\n+\n+        case ngx_signal_value(NGX_RECONFIGURE_SIGNAL):\n+        case ngx_signal_value(NGX_CHANGEBIN_SIGNAL):\n+        case SIGIO:\n+            action = \", ignoring\";\n+            break;\n+        }\n+\n+        break;\n+    }\n+\n+    if (siginfo && siginfo->si_pid) {\n+        ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0,\n+                      \"signal %d (%s) received from %P%s\",\n+                      signo, sig->signame, siginfo->si_pid, action);\n+\n+    } else {\n+        ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0,\n+                      \"signal %d (%s) received%s\",\n+                      signo, sig->signame, action);\n+    }\n+\n+    if (ignore) {\n+        ngx_log_error(NGX_LOG_CRIT, ngx_cycle->log, 0,\n+                      \"the changing binary signal is ignored: \"\n+                      \"you should shutdown or terminate \"\n+                      \"before either old or new binary's process\");\n+    }\n+\n+    if (signo == SIGCHLD) {\n+        ngx_process_get_status();\n+    }\n+\n+    ngx_set_errno(err);\n+}\n+\n+\n+static void\n+ngx_process_get_status(void)\n+{\n+    int              status;\n+    char            *process;\n+    ngx_pid_t        pid;\n+    ngx_err_t        err;\n+    ngx_int_t        i;\n+    ngx_uint_t       one;\n+\n+    one = 0;\n+\n+    for ( ;; ) {\n+        pid = waitpid(-1, &status, WNOHANG);\n+\n+        if (pid == 0) {\n+            return;\n+        }\n+\n+        if (pid == -1) {\n+            err = ngx_errno;\n+\n+            if (err == NGX_EINTR) {\n+                continue;\n+            }\n+\n+            if (err == NGX_ECHILD && one) {\n+                return;\n+            }\n+\n+            /*\n+             * Solaris always calls the signal handler for each exited process\n+             * despite waitpid() may be already called for this process.\n+             *\n+             * When several processes exit at the same time FreeBSD may\n+             * erroneously call the signal handler for exited process\n+             * despite waitpid() may be already called for this process.\n+             */\n+\n+            if (err == NGX_ECHILD) {\n+                ngx_log_error(NGX_LOG_INFO, ngx_cycle->log, err,\n+                              \"waitpid() failed\");\n+                return;\n+            }\n+\n+            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, err,\n+                          \"waitpid() failed\");\n+            return;\n+        }\n+\n+\n+        one = 1;\n+        process = \"unknown process\";\n+\n+        for (i = 0; i < ngx_last_process; i++) {\n+            if (ngx_processes[i].pid == pid) {\n+                ngx_processes[i].status = status;\n+                ngx_processes[i].exited = 1;\n+                process = ngx_processes[i].name;\n+                break;\n+            }\n+        }\n+\n+        if (WTERMSIG(status)) {\n+#ifdef WCOREDUMP\n+            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n+                          \"%s %P exited on signal %d%s\",\n+                          process, pid, WTERMSIG(status),\n+                          WCOREDUMP(status) ? \" (core dumped)\" : \"\");\n+#else\n+            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n+                          \"%s %P exited on signal %d\",\n+                          process, pid, WTERMSIG(status));\n+#endif\n+\n+        } else {\n+            ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0,\n+                          \"%s %P exited with code %d\",\n+                          process, pid, WEXITSTATUS(status));\n+        }\n+\n+        if (WEXITSTATUS(status) == 2 && ngx_processes[i].respawn) {\n+            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n+                          \"%s %P exited with fatal code %d \"\n+                          \"and cannot be respawned\",\n+                          process, pid, WEXITSTATUS(status));\n+            ngx_processes[i].respawn = 0;\n+        }\n+\n+        ngx_unlock_mutexes(pid);\n+    }\n+}\n+\n+\n+static void\n+ngx_unlock_mutexes(ngx_pid_t pid)\n+{\n+    ngx_uint_t        i;\n+    ngx_shm_zone_t   *shm_zone;\n+    ngx_list_part_t  *part;\n+    ngx_slab_pool_t  *sp;\n+\n+    /*\n+     * unlock the accept mutex if the abnormally exited process\n+     * held it\n+     */\n+\n+    if (ngx_accept_mutex_ptr) {\n+        (void) ngx_shmtx_force_unlock(&ngx_accept_mutex, pid);\n+    }\n+\n+    /*\n+     * unlock shared memory mutexes if held by the abnormally exited\n+     * process\n+     */\n+\n+    part = (ngx_list_part_t *) &ngx_cycle->shared_memory.part;\n+    shm_zone = part->elts;\n+\n+    for (i = 0; /* void */ ; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+            part = part->next;\n+            shm_zone = part->elts;\n+            i = 0;\n+        }\n+\n+        sp = (ngx_slab_pool_t *) shm_zone[i].shm.addr;\n+\n+        if (ngx_shmtx_force_unlock(&sp->mutex, pid)) {\n+            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n+                          \"shared memory zone \\\"%V\\\" was locked by %P\",\n+                          &shm_zone[i].shm.name, pid);\n+        }\n+    }\n+}\n+\n+\n+void\n+ngx_debug_point(void)\n+{\n+    ngx_core_conf_t  *ccf;\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n+                                           ngx_core_module);\n+\n+    switch (ccf->debug_points) {\n+\n+    case NGX_DEBUG_POINTS_STOP:\n+        raise(SIGSTOP);\n+        break;\n+\n+    case NGX_DEBUG_POINTS_ABORT:\n+        ngx_abort();\n+    }\n+}\n+\n+\n+ngx_int_t\n+ngx_os_signal_process(ngx_cycle_t *cycle, char *name, ngx_pid_t pid)\n+{\n+    ngx_signal_t  *sig;\n+\n+    for (sig = signals; sig->signo != 0; sig++) {\n+        if (ngx_strcmp(name, sig->name) == 0) {\n+            if (kill(pid, sig->signo) != -1) {\n+                return 0;\n+            }\n+\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"kill(%P, %d) failed\", pid, sig->signo);\n+        }\n+    }\n+\n+    return 1;\n+}\nDiff:\n@@ -0,0 +1,90 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_PROCESS_H_INCLUDED_\n+#define _NGX_PROCESS_H_INCLUDED_\n+\n+\n+#include <ngx_setaffinity.h>\n+#include <ngx_setproctitle.h>\n+\n+\n+typedef pid_t       ngx_pid_t;\n+\n+#define NGX_INVALID_PID  -1\n+\n+typedef void (*ngx_spawn_proc_pt) (ngx_cycle_t *cycle, void *data);\n+\n+typedef struct {\n+    ngx_pid_t           pid;\n+    int                 status;\n+    ngx_socket_t        channel[2];\n+\n+    ngx_spawn_proc_pt   proc;\n+    void               *data;\n+    char               *name;\n+\n+    unsigned            respawn:1;\n+    unsigned            just_spawn:1;\n+    unsigned            detached:1;\n+    unsigned            exiting:1;\n+    unsigned            exited:1;\n+} ngx_process_t;\n+\n+\n+typedef struct {\n+    char         *path;\n+    char         *name;\n+    char *const  *argv;\n+    char *const  *envp;\n+} ngx_exec_ctx_t;\n+\n+\n+#define NGX_MAX_PROCESSES         1024\n+\n+#define NGX_PROCESS_NORESPAWN     -1\n+#define NGX_PROCESS_JUST_SPAWN    -2\n+#define NGX_PROCESS_RESPAWN       -3\n+#define NGX_PROCESS_JUST_RESPAWN  -4\n+#define NGX_PROCESS_DETACHED      -5\n+\n+\n+#define ngx_getpid   getpid\n+#define ngx_getppid  getppid\n+\n+#ifndef ngx_log_pid\n+#define ngx_log_pid  ngx_pid\n+#endif\n+\n+\n+ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle,\n+    ngx_spawn_proc_pt proc, void *data, char *name, ngx_int_t respawn);\n+ngx_pid_t ngx_execute(ngx_cycle_t *cycle, ngx_exec_ctx_t *ctx);\n+ngx_int_t ngx_init_signals(ngx_log_t *log);\n+void ngx_debug_point(void);\n+\n+\n+#if (NGX_HAVE_SCHED_YIELD)\n+#define ngx_sched_yield()  sched_yield()\n+#else\n+#define ngx_sched_yield()  usleep(1)\n+#endif\n+\n+\n+extern int            ngx_argc;\n+extern char         **ngx_argv;\n+extern char         **ngx_os_argv;\n+\n+extern ngx_pid_t      ngx_pid;\n+extern ngx_pid_t      ngx_parent;\n+extern ngx_socket_t   ngx_channel;\n+extern ngx_int_t      ngx_process_slot;\n+extern ngx_int_t      ngx_last_process;\n+extern ngx_process_t  ngx_processes[NGX_MAX_PROCESSES];\n+\n+\n+#endif /* _NGX_PROCESS_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,1229 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+#include <ngx_channel.h>\n+\n+\n+static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,\n+    ngx_int_t type);\n+static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,\n+    ngx_uint_t respawn);\n+static void ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch);\n+static void ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo);\n+static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle);\n+static void ngx_master_process_exit(ngx_cycle_t *cycle);\n+static void ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data);\n+static void ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker);\n+static void ngx_worker_process_exit(ngx_cycle_t *cycle);\n+static void ngx_channel_handler(ngx_event_t *ev);\n+static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle, void *data);\n+static void ngx_cache_manager_process_handler(ngx_event_t *ev);\n+static void ngx_cache_loader_process_handler(ngx_event_t *ev);\n+\n+\n+ngx_uint_t    ngx_process;\n+ngx_uint_t    ngx_worker;\n+ngx_pid_t     ngx_pid;\n+ngx_pid_t     ngx_parent;\n+\n+sig_atomic_t  ngx_reap;\n+sig_atomic_t  ngx_sigio;\n+sig_atomic_t  ngx_sigalrm;\n+sig_atomic_t  ngx_terminate;\n+sig_atomic_t  ngx_quit;\n+sig_atomic_t  ngx_debug_quit;\n+ngx_uint_t    ngx_exiting;\n+sig_atomic_t  ngx_reconfigure;\n+sig_atomic_t  ngx_reopen;\n+\n+sig_atomic_t  ngx_change_binary;\n+ngx_pid_t     ngx_new_binary;\n+ngx_uint_t    ngx_inherited;\n+ngx_uint_t    ngx_daemonized;\n+\n+sig_atomic_t  ngx_noaccept;\n+ngx_uint_t    ngx_noaccepting;\n+ngx_uint_t    ngx_restart;\n+\n+\n+static u_char  master_process[] = \"master process\";\n+\n+\n+static ngx_cache_manager_ctx_t  ngx_cache_manager_ctx = {\n+    ngx_cache_manager_process_handler, \"cache manager process\", 0\n+};\n+\n+static ngx_cache_manager_ctx_t  ngx_cache_loader_ctx = {\n+    ngx_cache_loader_process_handler, \"cache loader process\", 60000\n+};\n+\n+\n+static ngx_cycle_t      ngx_exit_cycle;\n+static ngx_log_t        ngx_exit_log;\n+static ngx_open_file_t  ngx_exit_log_file;\n+\n+\n+void\n+ngx_master_process_cycle(ngx_cycle_t *cycle)\n+{\n+    char              *title;\n+    u_char            *p;\n+    size_t             size;\n+    ngx_int_t          i;\n+    ngx_uint_t         n, sigio;\n+    sigset_t           set;\n+    struct itimerval   itv;\n+    ngx_uint_t         live;\n+    ngx_msec_t         delay;\n+    ngx_listening_t   *ls;\n+    ngx_core_conf_t   *ccf;\n+\n+    sigemptyset(&set);\n+    sigaddset(&set, SIGCHLD);\n+    sigaddset(&set, SIGALRM);\n+    sigaddset(&set, SIGIO);\n+    sigaddset(&set, SIGINT);\n+    sigaddset(&set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));\n+    sigaddset(&set, ngx_signal_value(NGX_REOPEN_SIGNAL));\n+    sigaddset(&set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));\n+    sigaddset(&set, ngx_signal_value(NGX_TERMINATE_SIGNAL));\n+    sigaddset(&set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n+    sigaddset(&set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));\n+\n+    if (sigprocmask(SIG_BLOCK, &set, NULL) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      \"sigprocmask() failed\");\n+    }\n+\n+    sigemptyset(&set);\n+\n+\n+    size = sizeof(master_process);\n+\n+    for (i = 0; i < ngx_argc; i++) {\n+        size += ngx_strlen(ngx_argv[i]) + 1;\n+    }\n+\n+    title = ngx_pnalloc(cycle->pool, size);\n+    if (title == NULL) {\n+        /* fatal */\n+        exit(2);\n+    }\n+\n+    p = ngx_cpymem(title, master_process, sizeof(master_process) - 1);\n+    for (i = 0; i < ngx_argc; i++) {\n+        *p++ = ' ';\n+        p = ngx_cpystrn(p, (u_char *) ngx_argv[i], size);\n+    }\n+\n+    ngx_setproctitle(title);\n+\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    ngx_start_worker_processes(cycle, ccf->worker_processes,\n+                               NGX_PROCESS_RESPAWN);\n+    ngx_start_cache_manager_processes(cycle, 0);\n+\n+    ngx_new_binary = 0;\n+    delay = 0;\n+    sigio = 0;\n+    live = 1;\n+\n+    for ( ;; ) {\n+        if (delay) {\n+            if (ngx_sigalrm) {\n+                sigio = 0;\n+                delay *= 2;\n+                ngx_sigalrm = 0;\n+            }\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                           \"termination cycle: %M\", delay);\n+\n+            itv.it_interval.tv_sec = 0;\n+            itv.it_interval.tv_usec = 0;\n+            itv.it_value.tv_sec = delay / 1000;\n+            itv.it_value.tv_usec = (delay % 1000 ) * 1000;\n+\n+            if (setitimer(ITIMER_REAL, &itv, NULL) == -1) {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                              \"setitimer() failed\");\n+            }\n+        }\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"sigsuspend\");\n+\n+        sigsuspend(&set);\n+\n+        ngx_time_update();\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                       \"wake up, sigio %i\", sigio);\n+\n+        if (ngx_reap) {\n+            ngx_reap = 0;\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"reap children\");\n+\n+            live = ngx_reap_children(cycle);\n+        }\n+\n+        if (!live && (ngx_terminate || ngx_quit)) {\n+            ngx_master_process_exit(cycle);\n+        }\n+\n+        if (ngx_terminate) {\n+            if (delay == 0) {\n+                delay = 50;\n+            }\n+\n+            if (sigio) {\n+                sigio--;\n+                continue;\n+            }\n+\n+            sigio = ccf->worker_processes + 2 /* cache processes */;\n+\n+            if (delay > 1000) {\n+                ngx_signal_worker_processes(cycle, SIGKILL);\n+            } else {\n+                ngx_signal_worker_processes(cycle,\n+                                       ngx_signal_value(NGX_TERMINATE_SIGNAL));\n+            }\n+\n+            continue;\n+        }\n+\n+        if (ngx_quit) {\n+            ngx_signal_worker_processes(cycle,\n+                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n+\n+            ls = cycle->listening.elts;\n+            for (n = 0; n < cycle->listening.nelts; n++) {\n+                if (ngx_close_socket(ls[n].fd) == -1) {\n+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n+                                  ngx_close_socket_n \" %V failed\",\n+                                  &ls[n].addr_text);\n+                }\n+            }\n+            cycle->listening.nelts = 0;\n+\n+            continue;\n+        }\n+\n+        if (ngx_reconfigure) {\n+            ngx_reconfigure = 0;\n+\n+            if (ngx_new_binary) {\n+                ngx_start_worker_processes(cycle, ccf->worker_processes,\n+                                           NGX_PROCESS_RESPAWN);\n+                ngx_start_cache_manager_processes(cycle, 0);\n+                ngx_noaccepting = 0;\n+\n+                continue;\n+            }\n+\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reconfiguring\");\n+\n+            cycle = ngx_init_cycle(cycle);\n+            if (cycle == NULL) {\n+                cycle = (ngx_cycle_t *) ngx_cycle;\n+                continue;\n+            }\n+\n+            ngx_cycle = cycle;\n+            ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,\n+                                                   ngx_core_module);\n+            ngx_start_worker_processes(cycle, ccf->worker_processes,\n+                                       NGX_PROCESS_JUST_RESPAWN);\n+            ngx_start_cache_manager_processes(cycle, 1);\n+\n+            /* allow new processes to start */\n+            ngx_msleep(100);\n+\n+            live = 1;\n+            ngx_signal_worker_processes(cycle,\n+                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n+        }\n+\n+        if (ngx_restart) {\n+            ngx_restart = 0;\n+            ngx_start_worker_processes(cycle, ccf->worker_processes,\n+                                       NGX_PROCESS_RESPAWN);\n+            ngx_start_cache_manager_processes(cycle, 0);\n+            live = 1;\n+        }\n+\n+        if (ngx_reopen) {\n+            ngx_reopen = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reopening logs\");\n+            ngx_reopen_files(cycle, ccf->user);\n+            ngx_signal_worker_processes(cycle,\n+                                        ngx_signal_value(NGX_REOPEN_SIGNAL));\n+        }\n+\n+        if (ngx_change_binary) {\n+            ngx_change_binary = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"changing binary\");\n+            ngx_new_binary = ngx_exec_new_binary(cycle, ngx_argv);\n+        }\n+\n+        if (ngx_noaccept) {\n+            ngx_noaccept = 0;\n+            ngx_noaccepting = 1;\n+            ngx_signal_worker_processes(cycle,\n+                                        ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n+        }\n+    }\n+}\n+\n+\n+void\n+ngx_single_process_cycle(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t  i;\n+\n+    if (ngx_set_environment(cycle, NULL) == NULL) {\n+        /* fatal */\n+        exit(2);\n+    }\n+\n+    for (i = 0; cycle->modules[i]; i++) {\n+        if (cycle->modules[i]->init_process) {\n+            if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {\n+                /* fatal */\n+                exit(2);\n+            }\n+        }\n+    }\n+\n+    for ( ;; ) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"worker cycle\");\n+\n+        ngx_process_events_and_timers(cycle);\n+\n+        if (ngx_terminate || ngx_quit) {\n+\n+            for (i = 0; cycle->modules[i]; i++) {\n+                if (cycle->modules[i]->exit_process) {\n+                    cycle->modules[i]->exit_process(cycle);\n+                }\n+            }\n+\n+            ngx_master_process_exit(cycle);\n+        }\n+\n+        if (ngx_reconfigure) {\n+            ngx_reconfigure = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reconfiguring\");\n+\n+            cycle = ngx_init_cycle(cycle);\n+            if (cycle == NULL) {\n+                cycle = (ngx_cycle_t *) ngx_cycle;\n+                continue;\n+            }\n+\n+            ngx_cycle = cycle;\n+        }\n+\n+        if (ngx_reopen) {\n+            ngx_reopen = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reopening logs\");\n+            ngx_reopen_files(cycle, (ngx_uid_t) -1);\n+        }\n+    }\n+}\n+\n+\n+static void\n+ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)\n+{\n+    ngx_int_t      i;\n+    ngx_channel_t  ch;\n+\n+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"start worker processes\");\n+\n+    ngx_memzero(&ch, sizeof(ngx_channel_t));\n+\n+    ch.command = NGX_CMD_OPEN_CHANNEL;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        ngx_spawn_process(cycle, ngx_worker_process_cycle,\n+                          (void *) (intptr_t) i, \"worker process\", type);\n+\n+        ch.pid = ngx_processes[ngx_process_slot].pid;\n+        ch.slot = ngx_process_slot;\n+        ch.fd = ngx_processes[ngx_process_slot].channel[0];\n+\n+        ngx_pass_open_channel(cycle, &ch);\n+    }\n+}\n+\n+\n+static void\n+ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n+{\n+    ngx_uint_t       i, manager, loader;\n+    ngx_path_t     **path;\n+    ngx_channel_t    ch;\n+\n+    manager = 0;\n+    loader = 0;\n+\n+    path = ngx_cycle->paths.elts;\n+    for (i = 0; i < ngx_cycle->paths.nelts; i++) {\n+\n+        if (path[i]->manager) {\n+            manager = 1;\n+        }\n+\n+        if (path[i]->loader) {\n+            loader = 1;\n+        }\n+    }\n+\n+    if (manager == 0) {\n+        return;\n+    }\n+\n+    ngx_spawn_process(cycle, ngx_cache_manager_process_cycle,\n+                      &ngx_cache_manager_ctx, \"cache manager process\",\n+                      respawn ? NGX_PROCESS_JUST_RESPAWN : NGX_PROCESS_RESPAWN);\n+\n+    ngx_memzero(&ch, sizeof(ngx_channel_t));\n+\n+    ch.command = NGX_CMD_OPEN_CHANNEL;\n+    ch.pid = ngx_processes[ngx_process_slot].pid;\n+    ch.slot = ngx_process_slot;\n+    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n+\n+    ngx_pass_open_channel(cycle, &ch);\n+\n+    if (loader == 0) {\n+        return;\n+    }\n+\n+    ngx_spawn_process(cycle, ngx_cache_manager_process_cycle,\n+                      &ngx_cache_loader_ctx, \"cache loader process\",\n+                      respawn ? NGX_PROCESS_JUST_SPAWN : NGX_PROCESS_NORESPAWN);\n+\n+    ch.command = NGX_CMD_OPEN_CHANNEL;\n+    ch.pid = ngx_processes[ngx_process_slot].pid;\n+    ch.slot = ngx_process_slot;\n+    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n+\n+    ngx_pass_open_channel(cycle, &ch);\n+}\n+\n+\n+static void\n+ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)\n+{\n+    ngx_int_t  i;\n+\n+    for (i = 0; i < ngx_last_process; i++) {\n+\n+        if (i == ngx_process_slot\n+            || ngx_processes[i].pid == -1\n+            || ngx_processes[i].channel[0] == -1)\n+        {\n+            continue;\n+        }\n+\n+        ngx_log_debug6(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n+                      \"pass channel s:%i pid:%P fd:%d to s:%i pid:%P fd:%d\",\n+                      ch->slot, ch->pid, ch->fd,\n+                      i, ngx_processes[i].pid,\n+                      ngx_processes[i].channel[0]);\n+\n+        /* TODO: NGX_AGAIN */\n+\n+        ngx_write_channel(ngx_processes[i].channel[0],\n+                          ch, sizeof(ngx_channel_t), cycle->log);\n+    }\n+}\n+\n+\n+static void\n+ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo)\n+{\n+    ngx_int_t      i;\n+    ngx_err_t      err;\n+    ngx_channel_t  ch;\n+\n+    ngx_memzero(&ch, sizeof(ngx_channel_t));\n+\n+#if (NGX_BROKEN_SCM_RIGHTS)\n+\n+    ch.command = 0;\n+\n+#else\n+\n+    switch (signo) {\n+\n+    case ngx_signal_value(NGX_SHUTDOWN_SIGNAL):\n+        ch.command = NGX_CMD_QUIT;\n+        break;\n+\n+    case ngx_signal_value(NGX_TERMINATE_SIGNAL):\n+        ch.command = NGX_CMD_TERMINATE;\n+        break;\n+\n+    case ngx_signal_value(NGX_REOPEN_SIGNAL):\n+        ch.command = NGX_CMD_REOPEN;\n+        break;\n+\n+    default:\n+        ch.command = 0;\n+    }\n+\n+#endif\n+\n+    ch.fd = -1;\n+\n+\n+    for (i = 0; i < ngx_last_process; i++) {\n+\n+        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                       \"child: %i %P e:%d t:%d d:%d r:%d j:%d\",\n+                       i,\n+                       ngx_processes[i].pid,\n+                       ngx_processes[i].exiting,\n+                       ngx_processes[i].exited,\n+                       ngx_processes[i].detached,\n+                       ngx_processes[i].respawn,\n+                       ngx_processes[i].just_spawn);\n+\n+        if (ngx_processes[i].detached || ngx_processes[i].pid == -1) {\n+            continue;\n+        }\n+\n+        if (ngx_processes[i].just_spawn) {\n+            ngx_processes[i].just_spawn = 0;\n+            continue;\n+        }\n+\n+        if (ngx_processes[i].exiting\n+            && signo == ngx_signal_value(NGX_SHUTDOWN_SIGNAL))\n+        {\n+            continue;\n+        }\n+\n+        if (ch.command) {\n+            if (ngx_write_channel(ngx_processes[i].channel[0],\n+                                  &ch, sizeof(ngx_channel_t), cycle->log)\n+                == NGX_OK)\n+            {\n+                if (signo != ngx_signal_value(NGX_REOPEN_SIGNAL)) {\n+                    ngx_processes[i].exiting = 1;\n+                }\n+\n+                continue;\n+            }\n+        }\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n+                       \"kill (%P, %d)\", ngx_processes[i].pid, signo);\n+\n+        if (kill(ngx_processes[i].pid, signo) == -1) {\n+            err = ngx_errno;\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, err,\n+                          \"kill(%P, %d) failed\", ngx_processes[i].pid, signo);\n+\n+            if (err == NGX_ESRCH) {\n+                ngx_processes[i].exited = 1;\n+                ngx_processes[i].exiting = 0;\n+                ngx_reap = 1;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (signo != ngx_signal_value(NGX_REOPEN_SIGNAL)) {\n+            ngx_processes[i].exiting = 1;\n+        }\n+    }\n+}\n+\n+\n+static ngx_uint_t\n+ngx_reap_children(ngx_cycle_t *cycle)\n+{\n+    ngx_int_t         i, n;\n+    ngx_uint_t        live;\n+    ngx_channel_t     ch;\n+    ngx_core_conf_t  *ccf;\n+\n+    ngx_memzero(&ch, sizeof(ngx_channel_t));\n+\n+    ch.command = NGX_CMD_CLOSE_CHANNEL;\n+    ch.fd = -1;\n+\n+    live = 0;\n+    for (i = 0; i < ngx_last_process; i++) {\n+\n+        ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                       \"child: %i %P e:%d t:%d d:%d r:%d j:%d\",\n+                       i,\n+                       ngx_processes[i].pid,\n+                       ngx_processes[i].exiting,\n+                       ngx_processes[i].exited,\n+                       ngx_processes[i].detached,\n+                       ngx_processes[i].respawn,\n+                       ngx_processes[i].just_spawn);\n+\n+        if (ngx_processes[i].pid == -1) {\n+            continue;\n+        }\n+\n+        if (ngx_processes[i].exited) {\n+\n+            if (!ngx_processes[i].detached) {\n+                ngx_close_channel(ngx_processes[i].channel, cycle->log);\n+\n+                ngx_processes[i].channel[0] = -1;\n+                ngx_processes[i].channel[1] = -1;\n+\n+                ch.pid = ngx_processes[i].pid;\n+                ch.slot = i;\n+\n+                for (n = 0; n < ngx_last_process; n++) {\n+                    if (ngx_processes[n].exited\n+                        || ngx_processes[n].pid == -1\n+                        || ngx_processes[n].channel[0] == -1)\n+                    {\n+                        continue;\n+                    }\n+\n+                    ngx_log_debug3(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n+                                   \"pass close channel s:%i pid:%P to:%P\",\n+                                   ch.slot, ch.pid, ngx_processes[n].pid);\n+\n+                    /* TODO: NGX_AGAIN */\n+\n+                    ngx_write_channel(ngx_processes[n].channel[0],\n+                                      &ch, sizeof(ngx_channel_t), cycle->log);\n+                }\n+            }\n+\n+            if (ngx_processes[i].respawn\n+                && !ngx_processes[i].exiting\n+                && !ngx_terminate\n+                && !ngx_quit)\n+            {\n+                if (ngx_spawn_process(cycle, ngx_processes[i].proc,\n+                                      ngx_processes[i].data,\n+                                      ngx_processes[i].name, i)\n+                    == NGX_INVALID_PID)\n+                {\n+                    ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n+                                  \"could not respawn %s\",\n+                                  ngx_processes[i].name);\n+                    continue;\n+                }\n+\n+\n+                ch.command = NGX_CMD_OPEN_CHANNEL;\n+                ch.pid = ngx_processes[ngx_process_slot].pid;\n+                ch.slot = ngx_process_slot;\n+                ch.fd = ngx_processes[ngx_process_slot].channel[0];\n+\n+                ngx_pass_open_channel(cycle, &ch);\n+\n+                live = 1;\n+\n+                continue;\n+            }\n+\n+            if (ngx_processes[i].pid == ngx_new_binary) {\n+\n+                ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx,\n+                                                       ngx_core_module);\n+\n+                if (ngx_rename_file((char *) ccf->oldpid.data,\n+                                    (char *) ccf->pid.data)\n+                    == NGX_FILE_ERROR)\n+                {\n+                    ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                                  ngx_rename_file_n \" %s back to %s failed \"\n+                                  \"after the new binary process \\\"%s\\\" exited\",\n+                                  ccf->oldpid.data, ccf->pid.data, ngx_argv[0]);\n+                }\n+\n+                ngx_new_binary = 0;\n+                if (ngx_noaccepting) {\n+                    ngx_restart = 1;\n+                    ngx_noaccepting = 0;\n+                }\n+            }\n+\n+            if (i == ngx_last_process - 1) {\n+                ngx_last_process--;\n+\n+            } else {\n+                ngx_processes[i].pid = -1;\n+            }\n+\n+        } else if (ngx_processes[i].exiting || !ngx_processes[i].detached) {\n+            live = 1;\n+        }\n+    }\n+\n+    return live;\n+}\n+\n+\n+static void\n+ngx_master_process_exit(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t  i;\n+\n+    ngx_delete_pidfile(cycle);\n+\n+    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exit\");\n+\n+    for (i = 0; cycle->modules[i]; i++) {\n+        if (cycle->modules[i]->exit_master) {\n+            cycle->modules[i]->exit_master(cycle);\n+        }\n+    }\n+\n+    ngx_close_listening_sockets(cycle);\n+\n+    /*\n+     * Copy ngx_cycle->log related data to the special static exit cycle,\n+     * log, and log file structures enough to allow a signal handler to log.\n+     * The handler may be called when standard ngx_cycle->log allocated from\n+     * ngx_cycle->pool is already destroyed.\n+     */\n+\n+\n+    ngx_exit_log = *ngx_log_get_file_log(ngx_cycle->log);\n+\n+    ngx_exit_log_file.fd = ngx_exit_log.file->fd;\n+    ngx_exit_log.file = &ngx_exit_log_file;\n+    ngx_exit_log.next = NULL;\n+    ngx_exit_log.writer = NULL;\n+\n+    ngx_exit_cycle.log = &ngx_exit_log;\n+    ngx_exit_cycle.files = ngx_cycle->files;\n+    ngx_exit_cycle.files_n = ngx_cycle->files_n;\n+    ngx_cycle = &ngx_exit_cycle;\n+\n+    ngx_destroy_pool(cycle->pool);\n+\n+    exit(0);\n+}\n+\n+\n+static void\n+ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)\n+{\n+    ngx_int_t worker = (intptr_t) data;\n+\n+    ngx_process = NGX_PROCESS_WORKER;\n+    ngx_worker = worker;\n+\n+    ngx_worker_process_init(cycle, worker);\n+\n+    ngx_setproctitle(\"worker process\");\n+\n+    for ( ;; ) {\n+\n+        if (ngx_exiting) {\n+            if (ngx_event_no_timers_left() == NGX_OK) {\n+                ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exiting\");\n+                ngx_worker_process_exit(cycle);\n+            }\n+        }\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0, \"worker cycle\");\n+\n+        ngx_process_events_and_timers(cycle);\n+\n+        if (ngx_terminate) {\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exiting\");\n+            ngx_worker_process_exit(cycle);\n+        }\n+\n+        if (ngx_quit) {\n+            ngx_quit = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,\n+                          \"gracefully shutting down\");\n+            ngx_setproctitle(\"worker process is shutting down\");\n+\n+            if (!ngx_exiting) {\n+                ngx_exiting = 1;\n+                ngx_set_shutdown_timer(cycle);\n+                ngx_close_listening_sockets(cycle);\n+                ngx_close_idle_connections(cycle);\n+            }\n+        }\n+\n+        if (ngx_reopen) {\n+            ngx_reopen = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reopening logs\");\n+            ngx_reopen_files(cycle, -1);\n+        }\n+    }\n+}\n+\n+\n+static void\n+ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)\n+{\n+    sigset_t          set;\n+    ngx_int_t         n;\n+    ngx_time_t       *tp;\n+    ngx_uint_t        i;\n+    ngx_cpuset_t     *cpu_affinity;\n+    struct rlimit     rlmt;\n+    ngx_core_conf_t  *ccf;\n+    ngx_listening_t  *ls;\n+\n+    if (ngx_set_environment(cycle, NULL) == NULL) {\n+        /* fatal */\n+        exit(2);\n+    }\n+\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (worker >= 0 && ccf->priority != 0) {\n+        if (setpriority(PRIO_PROCESS, 0, ccf->priority) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"setpriority(%d) failed\", ccf->priority);\n+        }\n+    }\n+\n+    if (ccf->rlimit_nofile != NGX_CONF_UNSET) {\n+        rlmt.rlim_cur = (rlim_t) ccf->rlimit_nofile;\n+        rlmt.rlim_max = (rlim_t) ccf->rlimit_nofile;\n+\n+        if (setrlimit(RLIMIT_NOFILE, &rlmt) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"setrlimit(RLIMIT_NOFILE, %i) failed\",\n+                          ccf->rlimit_nofile);\n+        }\n+    }\n+\n+    if (ccf->rlimit_core != NGX_CONF_UNSET) {\n+        rlmt.rlim_cur = (rlim_t) ccf->rlimit_core;\n+        rlmt.rlim_max = (rlim_t) ccf->rlimit_core;\n+\n+        if (setrlimit(RLIMIT_CORE, &rlmt) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"setrlimit(RLIMIT_CORE, %O) failed\",\n+                          ccf->rlimit_core);\n+        }\n+    }\n+\n+    if (geteuid() == 0) {\n+        if (setgid(ccf->group) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          \"setgid(%d) failed\", ccf->group);\n+            /* fatal */\n+            exit(2);\n+        }\n+\n+        if (initgroups(ccf->username, ccf->group) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          \"initgroups(%s, %d) failed\",\n+                          ccf->username, ccf->group);\n+        }\n+\n+#if (NGX_HAVE_PR_SET_KEEPCAPS && NGX_HAVE_CAPABILITIES)\n+        if (ccf->transparent && ccf->user) {\n+            if (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                              \"prctl(PR_SET_KEEPCAPS, 1) failed\");\n+                /* fatal */\n+                exit(2);\n+            }\n+        }\n+#endif\n+\n+        if (setuid(ccf->user) == -1) {\n+            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                          \"setuid(%d) failed\", ccf->user);\n+            /* fatal */\n+            exit(2);\n+        }\n+\n+#if (NGX_HAVE_CAPABILITIES)\n+        if (ccf->transparent && ccf->user) {\n+            struct __user_cap_data_struct    data;\n+            struct __user_cap_header_struct  header;\n+\n+            ngx_memzero(&header, sizeof(struct __user_cap_header_struct));\n+            ngx_memzero(&data, sizeof(struct __user_cap_data_struct));\n+\n+            header.version = _LINUX_CAPABILITY_VERSION_1;\n+            data.effective = CAP_TO_MASK(CAP_NET_RAW);\n+            data.permitted = data.effective;\n+\n+            if (syscall(SYS_capset, &header, &data) == -1) {\n+                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n+                              \"capset() failed\");\n+                /* fatal */\n+                exit(2);\n+            }\n+        }\n+#endif\n+    }\n+\n+    if (worker >= 0) {\n+        cpu_affinity = ngx_get_cpu_affinity(worker);\n+\n+        if (cpu_affinity) {\n+            ngx_setaffinity(cpu_affinity, cycle->log);\n+        }\n+    }\n+\n+#if (NGX_HAVE_PR_SET_DUMPABLE)\n+\n+    /* allow coredump after setuid() in Linux 2.4.x */\n+\n+    if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      \"prctl(PR_SET_DUMPABLE) failed\");\n+    }\n+\n+#endif\n+\n+    if (ccf->working_directory.len) {\n+        if (chdir((char *) ccf->working_directory.data) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"chdir(\\\"%s\\\") failed\", ccf->working_directory.data);\n+            /* fatal */\n+            exit(2);\n+        }\n+    }\n+\n+    sigemptyset(&set);\n+\n+    if (sigprocmask(SIG_SETMASK, &set, NULL) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      \"sigprocmask() failed\");\n+    }\n+\n+    tp = ngx_timeofday();\n+    srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n+\n+    /*\n+     * disable deleting previous events for the listening sockets because\n+     * in the worker processes there are no events at all at this point\n+     */\n+    ls = cycle->listening.elts;\n+    for (i = 0; i < cycle->listening.nelts; i++) {\n+        ls[i].previous = NULL;\n+    }\n+\n+    for (i = 0; cycle->modules[i]; i++) {\n+        if (cycle->modules[i]->init_process) {\n+            if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {\n+                /* fatal */\n+                exit(2);\n+            }\n+        }\n+    }\n+\n+    for (n = 0; n < ngx_last_process; n++) {\n+\n+        if (ngx_processes[n].pid == -1) {\n+            continue;\n+        }\n+\n+        if (n == ngx_process_slot) {\n+            continue;\n+        }\n+\n+        if (ngx_processes[n].channel[1] == -1) {\n+            continue;\n+        }\n+\n+        if (close(ngx_processes[n].channel[1]) == -1) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                          \"close() channel failed\");\n+        }\n+    }\n+\n+    if (close(ngx_processes[ngx_process_slot].channel[0]) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n+                      \"close() channel failed\");\n+    }\n+\n+#if 0\n+    ngx_last_process = 0;\n+#endif\n+\n+    if (ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT,\n+                              ngx_channel_handler)\n+        == NGX_ERROR)\n+    {\n+        /* fatal */\n+        exit(2);\n+    }\n+}\n+\n+\n+static void\n+ngx_worker_process_exit(ngx_cycle_t *cycle)\n+{\n+    ngx_uint_t         i;\n+    ngx_connection_t  *c;\n+\n+    for (i = 0; cycle->modules[i]; i++) {\n+        if (cycle->modules[i]->exit_process) {\n+            cycle->modules[i]->exit_process(cycle);\n+        }\n+    }\n+\n+    if (ngx_exiting) {\n+        c = cycle->connections;\n+        for (i = 0; i < cycle->connection_n; i++) {\n+            if (c[i].fd != -1\n+                && c[i].read\n+                && !c[i].read->accept\n+                && !c[i].read->channel\n+                && !c[i].read->resolver)\n+            {\n+                ngx_log_error(NGX_LOG_ALERT, cycle->log, 0,\n+                              \"*%uA open socket #%d left in connection %ui\",\n+                              c[i].number, c[i].fd, i);\n+                ngx_debug_quit = 1;\n+            }\n+        }\n+\n+        if (ngx_debug_quit) {\n+            ngx_log_error(NGX_LOG_ALERT, cycle->log, 0, \"aborting\");\n+            ngx_debug_point();\n+        }\n+    }\n+\n+    /*\n+     * Copy ngx_cycle->log related data to the special static exit cycle,\n+     * log, and log file structures enough to allow a signal handler to log.\n+     * The handler may be called when standard ngx_cycle->log allocated from\n+     * ngx_cycle->pool is already destroyed.\n+     */\n+\n+    ngx_exit_log = *ngx_log_get_file_log(ngx_cycle->log);\n+\n+    ngx_exit_log_file.fd = ngx_exit_log.file->fd;\n+    ngx_exit_log.file = &ngx_exit_log_file;\n+    ngx_exit_log.next = NULL;\n+    ngx_exit_log.writer = NULL;\n+\n+    ngx_exit_cycle.log = &ngx_exit_log;\n+    ngx_exit_cycle.files = ngx_cycle->files;\n+    ngx_exit_cycle.files_n = ngx_cycle->files_n;\n+    ngx_cycle = &ngx_exit_cycle;\n+\n+    ngx_destroy_pool(cycle->pool);\n+\n+    ngx_log_error(NGX_LOG_NOTICE, ngx_cycle->log, 0, \"exit\");\n+\n+    exit(0);\n+}\n+\n+\n+static void\n+ngx_channel_handler(ngx_event_t *ev)\n+{\n+    ngx_int_t          n;\n+    ngx_channel_t      ch;\n+    ngx_connection_t  *c;\n+\n+    if (ev->timedout) {\n+        ev->timedout = 0;\n+        return;\n+    }\n+\n+    c = ev->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, \"channel handler\");\n+\n+    for ( ;; ) {\n+\n+        n = ngx_read_channel(c->fd, &ch, sizeof(ngx_channel_t), ev->log);\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0, \"channel: %i\", n);\n+\n+        if (n == NGX_ERROR) {\n+\n+            if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+                ngx_del_conn(c, 0);\n+            }\n+\n+            ngx_close_connection(c);\n+            return;\n+        }\n+\n+        if (ngx_event_flags & NGX_USE_EVENTPORT_EVENT) {\n+            if (ngx_add_event(ev, NGX_READ_EVENT, 0) == NGX_ERROR) {\n+                return;\n+            }\n+        }\n+\n+        if (n == NGX_AGAIN) {\n+            return;\n+        }\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev->log, 0,\n+                       \"channel command: %ui\", ch.command);\n+\n+        switch (ch.command) {\n+\n+        case NGX_CMD_QUIT:\n+            ngx_quit = 1;\n+            break;\n+\n+        case NGX_CMD_TERMINATE:\n+            ngx_terminate = 1;\n+            break;\n+\n+        case NGX_CMD_REOPEN:\n+            ngx_reopen = 1;\n+            break;\n+\n+        case NGX_CMD_OPEN_CHANNEL:\n+\n+            ngx_log_debug3(NGX_LOG_DEBUG_CORE, ev->log, 0,\n+                           \"get channel s:%i pid:%P fd:%d\",\n+                           ch.slot, ch.pid, ch.fd);\n+\n+            ngx_processes[ch.slot].pid = ch.pid;\n+            ngx_processes[ch.slot].channel[0] = ch.fd;\n+            break;\n+\n+        case NGX_CMD_CLOSE_CHANNEL:\n+\n+            ngx_log_debug4(NGX_LOG_DEBUG_CORE, ev->log, 0,\n+                           \"close channel s:%i pid:%P our:%P fd:%d\",\n+                           ch.slot, ch.pid, ngx_processes[ch.slot].pid,\n+                           ngx_processes[ch.slot].channel[0]);\n+\n+            if (close(ngx_processes[ch.slot].channel[0]) == -1) {\n+                ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,\n+                              \"close() channel failed\");\n+            }\n+\n+            ngx_processes[ch.slot].channel[0] = -1;\n+            break;\n+        }\n+    }\n+}\n+\n+\n+static void\n+ngx_cache_manager_process_cycle(ngx_cycle_t *cycle, void *data)\n+{\n+    ngx_cache_manager_ctx_t *ctx = data;\n+\n+    void         *ident[4];\n+    ngx_event_t   ev;\n+\n+    /*\n+     * Set correct process type since closing listening Unix domain socket\n+     * in a master process also removes the Unix domain socket file.\n+     */\n+    ngx_process = NGX_PROCESS_HELPER;\n+\n+    ngx_close_listening_sockets(cycle);\n+\n+    /* Set a moderate number of connections for a helper process. */\n+    cycle->connection_n = 512;\n+\n+    ngx_worker_process_init(cycle, -1);\n+\n+    ngx_memzero(&ev, sizeof(ngx_event_t));\n+    ev.handler = ctx->handler;\n+    ev.data = ident;\n+    ev.log = cycle->log;\n+    ident[3] = (void *) -1;\n+\n+    ngx_use_accept_mutex = 0;\n+\n+    ngx_setproctitle(ctx->name);\n+\n+    ngx_add_timer(&ev, ctx->delay);\n+\n+    for ( ;; ) {\n+\n+        if (ngx_terminate || ngx_quit) {\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exiting\");\n+            exit(0);\n+        }\n+\n+        if (ngx_reopen) {\n+            ngx_reopen = 0;\n+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"reopening logs\");\n+            ngx_reopen_files(cycle, -1);\n+        }\n+\n+        ngx_process_events_and_timers(cycle);\n+    }\n+}\n+\n+\n+static void\n+ngx_cache_manager_process_handler(ngx_event_t *ev)\n+{\n+    ngx_uint_t    i;\n+    ngx_msec_t    next, n;\n+    ngx_path_t  **path;\n+\n+    next = 60 * 60 * 1000;\n+\n+    path = ngx_cycle->paths.elts;\n+    for (i = 0; i < ngx_cycle->paths.nelts; i++) {\n+\n+        if (path[i]->manager) {\n+            n = path[i]->manager(path[i]->data);\n+\n+            next = (n <= next) ? n : next;\n+\n+            ngx_time_update();\n+        }\n+    }\n+\n+    if (next == 0) {\n+        next = 1;\n+    }\n+\n+    ngx_add_timer(ev, next);\n+}\n+\n+\n+static void\n+ngx_cache_loader_process_handler(ngx_event_t *ev)\n+{\n+    ngx_uint_t     i;\n+    ngx_path_t   **path;\n+    ngx_cycle_t   *cycle;\n+\n+    cycle = (ngx_cycle_t *) ngx_cycle;\n+\n+    path = cycle->paths.elts;\n+    for (i = 0; i < cycle->paths.nelts; i++) {\n+\n+        if (ngx_terminate || ngx_quit) {\n+            break;\n+        }\n+\n+        if (path[i]->loader) {\n+            path[i]->loader(path[i]->data);\n+            ngx_time_update();\n+        }\n+    }\n+\n+    exit(0);\n+}\nDiff:\n@@ -0,0 +1,61 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_PROCESS_CYCLE_H_INCLUDED_\n+#define _NGX_PROCESS_CYCLE_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#define NGX_CMD_OPEN_CHANNEL   1\n+#define NGX_CMD_CLOSE_CHANNEL  2\n+#define NGX_CMD_QUIT           3\n+#define NGX_CMD_TERMINATE      4\n+#define NGX_CMD_REOPEN         5\n+\n+\n+#define NGX_PROCESS_SINGLE     0\n+#define NGX_PROCESS_MASTER     1\n+#define NGX_PROCESS_SIGNALLER  2\n+#define NGX_PROCESS_WORKER     3\n+#define NGX_PROCESS_HELPER     4\n+\n+\n+typedef struct {\n+    ngx_event_handler_pt       handler;\n+    char                      *name;\n+    ngx_msec_t                 delay;\n+} ngx_cache_manager_ctx_t;\n+\n+\n+void ngx_master_process_cycle(ngx_cycle_t *cycle);\n+void ngx_single_process_cycle(ngx_cycle_t *cycle);\n+\n+\n+extern ngx_uint_t      ngx_process;\n+extern ngx_uint_t      ngx_worker;\n+extern ngx_pid_t       ngx_pid;\n+extern ngx_pid_t       ngx_new_binary;\n+extern ngx_uint_t      ngx_inherited;\n+extern ngx_uint_t      ngx_daemonized;\n+extern ngx_uint_t      ngx_exiting;\n+\n+extern sig_atomic_t    ngx_reap;\n+extern sig_atomic_t    ngx_sigio;\n+extern sig_atomic_t    ngx_sigalrm;\n+extern sig_atomic_t    ngx_quit;\n+extern sig_atomic_t    ngx_debug_quit;\n+extern sig_atomic_t    ngx_terminate;\n+extern sig_atomic_t    ngx_noaccept;\n+extern sig_atomic_t    ngx_reconfigure;\n+extern sig_atomic_t    ngx_reopen;\n+extern sig_atomic_t    ngx_change_binary;\n+\n+\n+#endif /* _NGX_PROCESS_CYCLE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,248 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ssize_t\n+ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n+{\n+    u_char        *prev;\n+    ssize_t        n, size;\n+    ngx_err_t      err;\n+    ngx_array_t    vec;\n+    ngx_event_t   *rev;\n+    struct iovec  *iov, iovs[NGX_IOVS_PREALLOCATE];\n+\n+    rev = c->read;\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"readv: eof:%d, avail:%d, err:%d\",\n+                       rev->pending_eof, rev->available, rev->kq_errno);\n+\n+        if (rev->available == 0) {\n+            if (rev->pending_eof) {\n+                rev->ready = 0;\n+                rev->eof = 1;\n+\n+                ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,\n+                              \"kevent() reported about an closed connection\");\n+\n+                if (rev->kq_errno) {\n+                    rev->error = 1;\n+                    ngx_set_socket_errno(rev->kq_errno);\n+                    return NGX_ERROR;\n+                }\n+\n+                return 0;\n+\n+            } else {\n+                return NGX_AGAIN;\n+            }\n+        }\n+    }\n+\n+#endif\n+\n+#if (NGX_HAVE_EPOLLRDHUP)\n+\n+    if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"readv: eof:%d, avail:%d\",\n+                       rev->pending_eof, rev->available);\n+\n+        if (rev->available == 0 && !rev->pending_eof) {\n+            return NGX_AGAIN;\n+        }\n+    }\n+\n+#endif\n+\n+    prev = NULL;\n+    iov = NULL;\n+    size = 0;\n+\n+    vec.elts = iovs;\n+    vec.nelts = 0;\n+    vec.size = sizeof(struct iovec);\n+    vec.nalloc = NGX_IOVS_PREALLOCATE;\n+    vec.pool = c->pool;\n+\n+    /* coalesce the neighbouring bufs */\n+\n+    while (chain) {\n+        n = chain->buf->end - chain->buf->last;\n+\n+        if (limit) {\n+            if (size >= limit) {\n+                break;\n+            }\n+\n+            if (size + n > limit) {\n+                n = (ssize_t) (limit - size);\n+            }\n+        }\n+\n+        if (prev == chain->buf->last) {\n+            iov->iov_len += n;\n+\n+        } else {\n+            if (vec.nelts >= IOV_MAX) {\n+                break;\n+            }\n+\n+            iov = ngx_array_push(&vec);\n+            if (iov == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            iov->iov_base = (void *) chain->buf->last;\n+            iov->iov_len = n;\n+        }\n+\n+        size += n;\n+        prev = chain->buf->end;\n+        chain = chain->next;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"readv: %ui, last:%uz\", vec.nelts, iov->iov_len);\n+\n+    do {\n+        n = readv(c->fd, (struct iovec *) vec.elts, vec.nelts);\n+\n+        if (n == 0) {\n+            rev->ready = 0;\n+            rev->eof = 1;\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+            /*\n+             * on FreeBSD readv() may return 0 on closed socket\n+             * even if kqueue reported about available data\n+             */\n+\n+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+                rev->available = 0;\n+            }\n+\n+#endif\n+\n+            return 0;\n+        }\n+\n+        if (n > 0) {\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+                rev->available -= n;\n+\n+                /*\n+                 * rev->available may be negative here because some additional\n+                 * bytes may be received between kevent() and readv()\n+                 */\n+\n+                if (rev->available <= 0) {\n+                    if (!rev->pending_eof) {\n+                        rev->ready = 0;\n+                    }\n+\n+                    rev->available = 0;\n+                }\n+\n+                return n;\n+            }\n+\n+#endif\n+\n+#if (NGX_HAVE_FIONREAD)\n+\n+            if (rev->available >= 0) {\n+                rev->available -= n;\n+\n+                /*\n+                 * negative rev->available means some additional bytes\n+                 * were received between kernel notification and readv(),\n+                 * and therefore ev->ready can be safely reset even for\n+                 * edge-triggered event methods\n+                 */\n+\n+                if (rev->available < 0) {\n+                    rev->available = 0;\n+                    rev->ready = 0;\n+                }\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                               \"readv: avail:%d\", rev->available);\n+\n+            } else if (n == size) {\n+\n+                if (ngx_socket_nread(c->fd, &rev->available) == -1) {\n+                    n = ngx_connection_error(c, ngx_socket_errno,\n+                                             ngx_socket_nread_n \" failed\");\n+                    break;\n+                }\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                               \"readv: avail:%d\", rev->available);\n+            }\n+\n+#endif\n+\n+#if (NGX_HAVE_EPOLLRDHUP)\n+\n+            if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n+                && ngx_use_epoll_rdhup)\n+            {\n+                if (n < size) {\n+                    if (!rev->pending_eof) {\n+                        rev->ready = 0;\n+                    }\n+\n+                    rev->available = 0;\n+                }\n+\n+                return n;\n+            }\n+\n+#endif\n+\n+            if (n < size && !(ngx_event_flags & NGX_USE_GREEDY_EVENT)) {\n+                rev->ready = 0;\n+            }\n+\n+            return n;\n+        }\n+\n+        err = ngx_socket_errno;\n+\n+        if (err == NGX_EAGAIN || err == NGX_EINTR) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"readv() not ready\");\n+            n = NGX_AGAIN;\n+\n+        } else {\n+            n = ngx_connection_error(c, err, \"readv() failed\");\n+            break;\n+        }\n+\n+    } while (err == NGX_EINTR);\n+\n+    rev->ready = 0;\n+\n+    if (n == NGX_ERROR) {\n+        c->read->error = 1;\n+    }\n+\n+    return n;\n+}\nDiff:\n@@ -0,0 +1,201 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ssize_t\n+ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size)\n+{\n+    ssize_t       n;\n+    ngx_err_t     err;\n+    ngx_event_t  *rev;\n+\n+    rev = c->read;\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"recv: eof:%d, avail:%d, err:%d\",\n+                       rev->pending_eof, rev->available, rev->kq_errno);\n+\n+        if (rev->available == 0) {\n+            if (rev->pending_eof) {\n+                rev->ready = 0;\n+                rev->eof = 1;\n+\n+                if (rev->kq_errno) {\n+                    rev->error = 1;\n+                    ngx_set_socket_errno(rev->kq_errno);\n+\n+                    return ngx_connection_error(c, rev->kq_errno,\n+                               \"kevent() reported about an closed connection\");\n+                }\n+\n+                return 0;\n+\n+            } else {\n+                rev->ready = 0;\n+                return NGX_AGAIN;\n+            }\n+        }\n+    }\n+\n+#endif\n+\n+#if (NGX_HAVE_EPOLLRDHUP)\n+\n+    if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"recv: eof:%d, avail:%d\",\n+                       rev->pending_eof, rev->available);\n+\n+        if (rev->available == 0 && !rev->pending_eof) {\n+            rev->ready = 0;\n+            return NGX_AGAIN;\n+        }\n+    }\n+\n+#endif\n+\n+    do {\n+        n = recv(c->fd, buf, size, 0);\n+\n+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"recv: fd:%d %z of %uz\", c->fd, n, size);\n+\n+        if (n == 0) {\n+            rev->ready = 0;\n+            rev->eof = 1;\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+            /*\n+             * on FreeBSD recv() may return 0 on closed socket\n+             * even if kqueue reported about available data\n+             */\n+\n+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+                rev->available = 0;\n+            }\n+\n+#endif\n+\n+            return 0;\n+        }\n+\n+        if (n > 0) {\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+                rev->available -= n;\n+\n+                /*\n+                 * rev->available may be negative here because some additional\n+                 * bytes may be received between kevent() and recv()\n+                 */\n+\n+                if (rev->available <= 0) {\n+                    if (!rev->pending_eof) {\n+                        rev->ready = 0;\n+                    }\n+\n+                    rev->available = 0;\n+                }\n+\n+                return n;\n+            }\n+\n+#endif\n+\n+#if (NGX_HAVE_FIONREAD)\n+\n+            if (rev->available >= 0) {\n+                rev->available -= n;\n+\n+                /*\n+                 * negative rev->available means some additional bytes\n+                 * were received between kernel notification and recv(),\n+                 * and therefore ev->ready can be safely reset even for\n+                 * edge-triggered event methods\n+                 */\n+\n+                if (rev->available < 0) {\n+                    rev->available = 0;\n+                    rev->ready = 0;\n+                }\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                               \"recv: avail:%d\", rev->available);\n+\n+            } else if ((size_t) n == size) {\n+\n+                if (ngx_socket_nread(c->fd, &rev->available) == -1) {\n+                    n = ngx_connection_error(c, ngx_socket_errno,\n+                                             ngx_socket_nread_n \" failed\");\n+                    break;\n+                }\n+\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                               \"recv: avail:%d\", rev->available);\n+            }\n+\n+#endif\n+\n+#if (NGX_HAVE_EPOLLRDHUP)\n+\n+            if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n+                && ngx_use_epoll_rdhup)\n+            {\n+                if ((size_t) n < size) {\n+                    if (!rev->pending_eof) {\n+                        rev->ready = 0;\n+                    }\n+\n+                    rev->available = 0;\n+                }\n+\n+                return n;\n+            }\n+\n+#endif\n+\n+            if ((size_t) n < size\n+                && !(ngx_event_flags & NGX_USE_GREEDY_EVENT))\n+            {\n+                rev->ready = 0;\n+            }\n+\n+            return n;\n+        }\n+\n+        err = ngx_socket_errno;\n+\n+        if (err == NGX_EAGAIN || err == NGX_EINTR) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"recv() not ready\");\n+            n = NGX_AGAIN;\n+\n+        } else {\n+            n = ngx_connection_error(c, err, \"recv() failed\");\n+            break;\n+        }\n+\n+    } while (err == NGX_EINTR);\n+\n+    rev->ready = 0;\n+\n+    if (n == NGX_ERROR) {\n+        rev->error = 1;\n+    }\n+\n+    return n;\n+}\nDiff:\n@@ -0,0 +1,73 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ssize_t\n+ngx_unix_send(ngx_connection_t *c, u_char *buf, size_t size)\n+{\n+    ssize_t       n;\n+    ngx_err_t     err;\n+    ngx_event_t  *wev;\n+\n+    wev = c->write;\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n+        (void) ngx_connection_error(c, wev->kq_errno,\n+                               \"kevent() reported about an closed connection\");\n+        wev->error = 1;\n+        return NGX_ERROR;\n+    }\n+\n+#endif\n+\n+    for ( ;; ) {\n+        n = send(c->fd, buf, size, 0);\n+\n+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"send: fd:%d %z of %uz\", c->fd, n, size);\n+\n+        if (n > 0) {\n+            if (n < (ssize_t) size) {\n+                wev->ready = 0;\n+            }\n+\n+            c->sent += n;\n+\n+            return n;\n+        }\n+\n+        err = ngx_socket_errno;\n+\n+        if (n == 0) {\n+            ngx_log_error(NGX_LOG_ALERT, c->log, err, \"send() returned zero\");\n+            wev->ready = 0;\n+            return n;\n+        }\n+\n+        if (err == NGX_EAGAIN || err == NGX_EINTR) {\n+            wev->ready = 0;\n+\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"send() not ready\");\n+\n+            if (err == NGX_EAGAIN) {\n+                return NGX_AGAIN;\n+            }\n+\n+        } else {\n+            wev->error = 1;\n+            (void) ngx_connection_error(c, err, \"send() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,53 @@\n+\n+/*\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_HAVE_CPUSET_SETAFFINITY)\n+\n+void\n+ngx_setaffinity(ngx_cpuset_t *cpu_affinity, ngx_log_t *log)\n+{\n+    ngx_uint_t  i;\n+\n+    for (i = 0; i < CPU_SETSIZE; i++) {\n+        if (CPU_ISSET(i, cpu_affinity)) {\n+            ngx_log_error(NGX_LOG_NOTICE, log, 0,\n+                          \"cpuset_setaffinity(): using cpu #%ui\", i);\n+        }\n+    }\n+\n+    if (cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1,\n+                           sizeof(cpuset_t), cpu_affinity) == -1)\n+    {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"cpuset_setaffinity() failed\");\n+    }\n+}\n+\n+#elif (NGX_HAVE_SCHED_SETAFFINITY)\n+\n+void\n+ngx_setaffinity(ngx_cpuset_t *cpu_affinity, ngx_log_t *log)\n+{\n+    ngx_uint_t  i;\n+\n+    for (i = 0; i < CPU_SETSIZE; i++) {\n+        if (CPU_ISSET(i, cpu_affinity)) {\n+            ngx_log_error(NGX_LOG_NOTICE, log, 0,\n+                          \"sched_setaffinity(): using cpu #%ui\", i);\n+        }\n+    }\n+\n+    if (sched_setaffinity(0, sizeof(cpu_set_t), cpu_affinity) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sched_setaffinity() failed\");\n+    }\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,37 @@\n+\n+/*\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+#ifndef _NGX_SETAFFINITY_H_INCLUDED_\n+#define _NGX_SETAFFINITY_H_INCLUDED_\n+\n+\n+#if (NGX_HAVE_SCHED_SETAFFINITY || NGX_HAVE_CPUSET_SETAFFINITY)\n+\n+#define NGX_HAVE_CPU_AFFINITY 1\n+\n+#if (NGX_HAVE_SCHED_SETAFFINITY)\n+\n+typedef cpu_set_t  ngx_cpuset_t;\n+\n+#elif (NGX_HAVE_CPUSET_SETAFFINITY)\n+\n+#include <sys/cpuset.h>\n+\n+typedef cpuset_t  ngx_cpuset_t;\n+\n+#endif\n+\n+void ngx_setaffinity(ngx_cpuset_t *cpu_affinity, ngx_log_t *log);\n+\n+#else\n+\n+#define ngx_setaffinity(cpu_affinity, log)\n+\n+typedef uint64_t  ngx_cpuset_t;\n+\n+#endif\n+\n+\n+#endif /* _NGX_SETAFFINITY_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,135 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_SETPROCTITLE_USES_ENV)\n+\n+/*\n+ * To change the process title in Linux and Solaris we have to set argv[1]\n+ * to NULL and to copy the title to the same place where the argv[0] points to.\n+ * However, argv[0] may be too small to hold a new title.  Fortunately, Linux\n+ * and Solaris store argv[] and environ[] one after another.  So we should\n+ * ensure that is the continuous memory and then we allocate the new memory\n+ * for environ[] and copy it.  After this we could use the memory starting\n+ * from argv[0] for our process title.\n+ *\n+ * The Solaris's standard /bin/ps does not show the changed process title.\n+ * You have to use \"/usr/ucb/ps -w\" instead.  Besides, the UCB ps does not\n+ * show a new title if its length less than the origin command line length.\n+ * To avoid it we append to a new title the origin command line in the\n+ * parenthesis.\n+ */\n+\n+extern char **environ;\n+\n+static char *ngx_os_argv_last;\n+\n+ngx_int_t\n+ngx_init_setproctitle(ngx_log_t *log)\n+{\n+    u_char      *p;\n+    size_t       size;\n+    ngx_uint_t   i;\n+\n+    size = 0;\n+\n+    for (i = 0; environ[i]; i++) {\n+        size += ngx_strlen(environ[i]) + 1;\n+    }\n+\n+    p = ngx_alloc(size, log);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_os_argv_last = ngx_os_argv[0];\n+\n+    for (i = 0; ngx_os_argv[i]; i++) {\n+        if (ngx_os_argv_last == ngx_os_argv[i]) {\n+            ngx_os_argv_last = ngx_os_argv[i] + ngx_strlen(ngx_os_argv[i]) + 1;\n+        }\n+    }\n+\n+    for (i = 0; environ[i]; i++) {\n+        if (ngx_os_argv_last == environ[i]) {\n+\n+            size = ngx_strlen(environ[i]) + 1;\n+            ngx_os_argv_last = environ[i] + size;\n+\n+            ngx_cpystrn(p, (u_char *) environ[i], size);\n+            environ[i] = (char *) p;\n+            p += size;\n+        }\n+    }\n+\n+    ngx_os_argv_last--;\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_setproctitle(char *title)\n+{\n+    u_char     *p;\n+\n+#if (NGX_SOLARIS)\n+\n+    ngx_int_t   i;\n+    size_t      size;\n+\n+#endif\n+\n+    ngx_os_argv[1] = NULL;\n+\n+    p = ngx_cpystrn((u_char *) ngx_os_argv[0], (u_char *) \"nginx: \",\n+                    ngx_os_argv_last - ngx_os_argv[0]);\n+\n+    p = ngx_cpystrn(p, (u_char *) title, ngx_os_argv_last - (char *) p);\n+\n+#if (NGX_SOLARIS)\n+\n+    size = 0;\n+\n+    for (i = 0; i < ngx_argc; i++) {\n+        size += ngx_strlen(ngx_argv[i]) + 1;\n+    }\n+\n+    if (size > (size_t) ((char *) p - ngx_os_argv[0])) {\n+\n+        /*\n+         * ngx_setproctitle() is too rare operation so we use\n+         * the non-optimized copies\n+         */\n+\n+        p = ngx_cpystrn(p, (u_char *) \" (\", ngx_os_argv_last - (char *) p);\n+\n+        for (i = 0; i < ngx_argc; i++) {\n+            p = ngx_cpystrn(p, (u_char *) ngx_argv[i],\n+                            ngx_os_argv_last - (char *) p);\n+            p = ngx_cpystrn(p, (u_char *) \" \", ngx_os_argv_last - (char *) p);\n+        }\n+\n+        if (*(p - 1) == ' ') {\n+            *(p - 1) = ')';\n+        }\n+    }\n+\n+#endif\n+\n+    if (ngx_os_argv_last - (char *) p) {\n+        ngx_memset(p, NGX_SETPROCTITLE_PAD, ngx_os_argv_last - (char *) p);\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0,\n+                   \"setproctitle: \\\"%s\\\"\", ngx_os_argv[0]);\n+}\n+\n+#endif /* NGX_SETPROCTITLE_USES_ENV */\nDiff:\n@@ -0,0 +1,52 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_SETPROCTITLE_H_INCLUDED_\n+#define _NGX_SETPROCTITLE_H_INCLUDED_\n+\n+\n+#if (NGX_HAVE_SETPROCTITLE)\n+\n+/* FreeBSD, NetBSD, OpenBSD */\n+\n+#define ngx_init_setproctitle(log) NGX_OK\n+#define ngx_setproctitle(title)    setproctitle(\"%s\", title)\n+\n+\n+#else /* !NGX_HAVE_SETPROCTITLE */\n+\n+#if !defined NGX_SETPROCTITLE_USES_ENV\n+\n+#if (NGX_SOLARIS)\n+\n+#define NGX_SETPROCTITLE_USES_ENV  1\n+#define NGX_SETPROCTITLE_PAD       ' '\n+\n+ngx_int_t ngx_init_setproctitle(ngx_log_t *log);\n+void ngx_setproctitle(char *title);\n+\n+#elif (NGX_LINUX) || (NGX_DARWIN)\n+\n+#define NGX_SETPROCTITLE_USES_ENV  1\n+#define NGX_SETPROCTITLE_PAD       '\\0'\n+\n+ngx_int_t ngx_init_setproctitle(ngx_log_t *log);\n+void ngx_setproctitle(char *title);\n+\n+#else\n+\n+#define ngx_init_setproctitle(log) NGX_OK\n+#define ngx_setproctitle(title)\n+\n+#endif /* OSes */\n+\n+#endif /* NGX_SETPROCTITLE_USES_ENV */\n+\n+#endif /* NGX_HAVE_SETPROCTITLE */\n+\n+\n+#endif /* _NGX_SETPROCTITLE_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,126 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_HAVE_MAP_ANON)\n+\n+ngx_int_t\n+ngx_shm_alloc(ngx_shm_t *shm)\n+{\n+    shm->addr = (u_char *) mmap(NULL, shm->size,\n+                                PROT_READ|PROT_WRITE,\n+                                MAP_ANON|MAP_SHARED, -1, 0);\n+\n+    if (shm->addr == MAP_FAILED) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"mmap(MAP_ANON|MAP_SHARED, %uz) failed\", shm->size);\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_shm_free(ngx_shm_t *shm)\n+{\n+    if (munmap((void *) shm->addr, shm->size) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"munmap(%p, %uz) failed\", shm->addr, shm->size);\n+    }\n+}\n+\n+#elif (NGX_HAVE_MAP_DEVZERO)\n+\n+ngx_int_t\n+ngx_shm_alloc(ngx_shm_t *shm)\n+{\n+    ngx_fd_t  fd;\n+\n+    fd = open(\"/dev/zero\", O_RDWR);\n+\n+    if (fd == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"open(\\\"/dev/zero\\\") failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    shm->addr = (u_char *) mmap(NULL, shm->size, PROT_READ|PROT_WRITE,\n+                                MAP_SHARED, fd, 0);\n+\n+    if (shm->addr == MAP_FAILED) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"mmap(/dev/zero, MAP_SHARED, %uz) failed\", shm->size);\n+    }\n+\n+    if (close(fd) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"close(\\\"/dev/zero\\\") failed\");\n+    }\n+\n+    return (shm->addr == MAP_FAILED) ? NGX_ERROR : NGX_OK;\n+}\n+\n+\n+void\n+ngx_shm_free(ngx_shm_t *shm)\n+{\n+    if (munmap((void *) shm->addr, shm->size) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"munmap(%p, %uz) failed\", shm->addr, shm->size);\n+    }\n+}\n+\n+#elif (NGX_HAVE_SYSVSHM)\n+\n+#include <sys/ipc.h>\n+#include <sys/shm.h>\n+\n+\n+ngx_int_t\n+ngx_shm_alloc(ngx_shm_t *shm)\n+{\n+    int  id;\n+\n+    id = shmget(IPC_PRIVATE, shm->size, (SHM_R|SHM_W|IPC_CREAT));\n+\n+    if (id == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"shmget(%uz) failed\", shm->size);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, shm->log, 0, \"shmget id: %d\", id);\n+\n+    shm->addr = shmat(id, NULL, 0);\n+\n+    if (shm->addr == (void *) -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno, \"shmat() failed\");\n+    }\n+\n+    if (shmctl(id, IPC_RMID, NULL) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"shmctl(IPC_RMID) failed\");\n+    }\n+\n+    return (shm->addr == (void *) -1) ? NGX_ERROR : NGX_OK;\n+}\n+\n+\n+void\n+ngx_shm_free(ngx_shm_t *shm)\n+{\n+    if (shmdt(shm->addr) == -1) {\n+        ngx_log_error(NGX_LOG_ALERT, shm->log, ngx_errno,\n+                      \"shmdt(%p) failed\", shm->addr);\n+    }\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,29 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_SHMEM_H_INCLUDED_\n+#define _NGX_SHMEM_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef struct {\n+    u_char      *addr;\n+    size_t       size;\n+    ngx_str_t    name;\n+    ngx_log_t   *log;\n+    ngx_uint_t   exists;   /* unsigned  exists:1;  */\n+} ngx_shm_t;\n+\n+\n+ngx_int_t ngx_shm_alloc(ngx_shm_t *shm);\n+void ngx_shm_free(ngx_shm_t *shm);\n+\n+\n+#endif /* _NGX_SHMEM_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,116 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/*\n+ * ioctl(FIONBIO) sets a non-blocking mode with the single syscall\n+ * while fcntl(F_SETFL, O_NONBLOCK) needs to learn the current state\n+ * using fcntl(F_GETFL).\n+ *\n+ * ioctl() and fcntl() are syscalls at least in FreeBSD 2.x, Linux 2.2\n+ * and Solaris 7.\n+ *\n+ * ioctl() in Linux 2.4 and 2.6 uses BKL, however, fcntl(F_SETFL) uses it too.\n+ */\n+\n+\n+#if (NGX_HAVE_FIONBIO)\n+\n+int\n+ngx_nonblocking(ngx_socket_t s)\n+{\n+    int  nb;\n+\n+    nb = 1;\n+\n+    return ioctl(s, FIONBIO, &nb);\n+}\n+\n+\n+int\n+ngx_blocking(ngx_socket_t s)\n+{\n+    int  nb;\n+\n+    nb = 0;\n+\n+    return ioctl(s, FIONBIO, &nb);\n+}\n+\n+#endif\n+\n+\n+#if (NGX_FREEBSD)\n+\n+int\n+ngx_tcp_nopush(ngx_socket_t s)\n+{\n+    int  tcp_nopush;\n+\n+    tcp_nopush = 1;\n+\n+    return setsockopt(s, IPPROTO_TCP, TCP_NOPUSH,\n+                      (const void *) &tcp_nopush, sizeof(int));\n+}\n+\n+\n+int\n+ngx_tcp_push(ngx_socket_t s)\n+{\n+    int  tcp_nopush;\n+\n+    tcp_nopush = 0;\n+\n+    return setsockopt(s, IPPROTO_TCP, TCP_NOPUSH,\n+                      (const void *) &tcp_nopush, sizeof(int));\n+}\n+\n+#elif (NGX_LINUX)\n+\n+\n+int\n+ngx_tcp_nopush(ngx_socket_t s)\n+{\n+    int  cork;\n+\n+    cork = 1;\n+\n+    return setsockopt(s, IPPROTO_TCP, TCP_CORK,\n+                      (const void *) &cork, sizeof(int));\n+}\n+\n+\n+int\n+ngx_tcp_push(ngx_socket_t s)\n+{\n+    int  cork;\n+\n+    cork = 0;\n+\n+    return setsockopt(s, IPPROTO_TCP, TCP_CORK,\n+                      (const void *) &cork, sizeof(int));\n+}\n+\n+#else\n+\n+int\n+ngx_tcp_nopush(ngx_socket_t s)\n+{\n+    return 0;\n+}\n+\n+\n+int\n+ngx_tcp_push(ngx_socket_t s)\n+{\n+    return 0;\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,71 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_SOCKET_H_INCLUDED_\n+#define _NGX_SOCKET_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+\n+\n+#define NGX_WRITE_SHUTDOWN SHUT_WR\n+\n+typedef int  ngx_socket_t;\n+\n+#define ngx_socket          socket\n+#define ngx_socket_n        \"socket()\"\n+\n+\n+#if (NGX_HAVE_FIONBIO)\n+\n+int ngx_nonblocking(ngx_socket_t s);\n+int ngx_blocking(ngx_socket_t s);\n+\n+#define ngx_nonblocking_n   \"ioctl(FIONBIO)\"\n+#define ngx_blocking_n      \"ioctl(!FIONBIO)\"\n+\n+#else\n+\n+#define ngx_nonblocking(s)  fcntl(s, F_SETFL, fcntl(s, F_GETFL) | O_NONBLOCK)\n+#define ngx_nonblocking_n   \"fcntl(O_NONBLOCK)\"\n+\n+#define ngx_blocking(s)     fcntl(s, F_SETFL, fcntl(s, F_GETFL) & ~O_NONBLOCK)\n+#define ngx_blocking_n      \"fcntl(!O_NONBLOCK)\"\n+\n+#endif\n+\n+#if (NGX_HAVE_FIONREAD)\n+\n+#define ngx_socket_nread(s, n)  ioctl(s, FIONREAD, n)\n+#define ngx_socket_nread_n      \"ioctl(FIONREAD)\"\n+\n+#endif\n+\n+int ngx_tcp_nopush(ngx_socket_t s);\n+int ngx_tcp_push(ngx_socket_t s);\n+\n+#if (NGX_LINUX)\n+\n+#define ngx_tcp_nopush_n   \"setsockopt(TCP_CORK)\"\n+#define ngx_tcp_push_n     \"setsockopt(!TCP_CORK)\"\n+\n+#else\n+\n+#define ngx_tcp_nopush_n   \"setsockopt(TCP_NOPUSH)\"\n+#define ngx_tcp_push_n     \"setsockopt(!TCP_NOPUSH)\"\n+\n+#endif\n+\n+\n+#define ngx_shutdown_socket    shutdown\n+#define ngx_shutdown_socket_n  \"shutdown()\"\n+\n+#define ngx_close_socket    close\n+#define ngx_close_socket_n  \"close() socket\"\n+\n+\n+#endif /* _NGX_SOCKET_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,16 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_SOLARIS_H_INCLUDED_\n+#define _NGX_SOLARIS_H_INCLUDED_\n+\n+\n+ngx_chain_t *ngx_solaris_sendfilev_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+\n+#endif /* _NGX_SOLARIS_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,112 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_SOLARIS_CONFIG_H_INCLUDED_\n+#define _NGX_SOLARIS_CONFIG_H_INCLUDED_\n+\n+\n+#ifndef _REENTRANT\n+#define _REENTRANT\n+#endif\n+\n+#define _FILE_OFFSET_BITS  64   /* must be before <sys/types.h> */\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <unistd.h>\n+#include <stdarg.h>\n+#include <stddef.h>             /* offsetof() */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <signal.h>\n+#include <pwd.h>\n+#include <grp.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <time.h>\n+#include <sys/statvfs.h>        /* statvfs() */\n+\n+#include <sys/filio.h>          /* FIONBIO */\n+#include <sys/uio.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+\n+#include <sys/wait.h>\n+#include <sys/mman.h>\n+#include <sys/resource.h>\n+#include <sched.h>\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>        /* TCP_NODELAY */\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <sys/un.h>\n+\n+#include <sys/systeminfo.h>\n+#include <limits.h>             /* IOV_MAX */\n+#include <inttypes.h>\n+#include <crypt.h>\n+\n+#include <dlfcn.h>\n+\n+#define NGX_ALIGNMENT  _MAX_ALIGNMENT\n+\n+#include <ngx_auto_config.h>\n+\n+\n+#if (NGX_HAVE_POSIX_SEM)\n+#include <semaphore.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_POLL)\n+#include <poll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_DEVPOLL)\n+#include <sys/ioctl.h>\n+#include <sys/devpoll.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_EVENTPORT)\n+#include <port.h>\n+#endif\n+\n+\n+#if (NGX_HAVE_SENDFILE)\n+#include <sys/sendfile.h>\n+#endif\n+\n+\n+#define NGX_LISTEN_BACKLOG           511\n+\n+\n+#ifndef NGX_HAVE_INHERITED_NONBLOCK\n+#define NGX_HAVE_INHERITED_NONBLOCK  1\n+#endif\n+\n+\n+#ifndef NGX_HAVE_SO_SNDLOWAT\n+/* setsockopt(SO_SNDLOWAT) returns ENOPROTOOPT */\n+#define NGX_HAVE_SO_SNDLOWAT         0\n+#endif\n+\n+\n+#define NGX_HAVE_OS_SPECIFIC_INIT    1\n+#define ngx_debug_init()\n+\n+\n+extern char **environ;\n+\n+\n+#endif /* _NGX_SOLARIS_CONFIG_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,77 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+char ngx_solaris_sysname[20];\n+char ngx_solaris_release[10];\n+char ngx_solaris_version[50];\n+\n+\n+static ngx_os_io_t ngx_solaris_io = {\n+    ngx_unix_recv,\n+    ngx_readv_chain,\n+    ngx_udp_unix_recv,\n+    ngx_unix_send,\n+    ngx_udp_unix_send,\n+    ngx_udp_unix_sendmsg_chain,\n+#if (NGX_HAVE_SENDFILE)\n+    ngx_solaris_sendfilev_chain,\n+    NGX_IO_SENDFILE\n+#else\n+    ngx_writev_chain,\n+    0\n+#endif\n+};\n+\n+\n+ngx_int_t\n+ngx_os_specific_init(ngx_log_t *log)\n+{\n+    if (sysinfo(SI_SYSNAME, ngx_solaris_sysname, sizeof(ngx_solaris_sysname))\n+        == -1)\n+    {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sysinfo(SI_SYSNAME) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (sysinfo(SI_RELEASE, ngx_solaris_release, sizeof(ngx_solaris_release))\n+        == -1)\n+    {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sysinfo(SI_RELEASE) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (sysinfo(SI_VERSION, ngx_solaris_version, sizeof(ngx_solaris_version))\n+        == -1)\n+    {\n+        ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n+                      \"sysinfo(SI_SYSNAME) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+\n+    ngx_os_io = ngx_solaris_io;\n+\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_os_specific_status(ngx_log_t *log)\n+{\n+\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0, \"OS: %s %s\",\n+                  ngx_solaris_sysname, ngx_solaris_release);\n+\n+    ngx_log_error(NGX_LOG_NOTICE, log, 0, \"version: %s\",\n+                  ngx_solaris_version);\n+}\nDiff:\n@@ -0,0 +1,228 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+#if (NGX_TEST_BUILD_SOLARIS_SENDFILEV)\n+\n+/* Solaris declarations */\n+\n+typedef struct sendfilevec {\n+    int     sfv_fd;\n+    u_int   sfv_flag;\n+    off_t   sfv_off;\n+    size_t  sfv_len;\n+} sendfilevec_t;\n+\n+#define SFV_FD_SELF  -2\n+\n+static ssize_t sendfilev(int fd, const struct sendfilevec *vec,\n+    int sfvcnt, size_t *xferred)\n+{\n+    return -1;\n+}\n+\n+ngx_chain_t *ngx_solaris_sendfilev_chain(ngx_connection_t *c, ngx_chain_t *in,\n+    off_t limit);\n+\n+#endif\n+\n+\n+#define NGX_SENDFILEVECS  NGX_IOVS_PREALLOCATE\n+\n+\n+ngx_chain_t *\n+ngx_solaris_sendfilev_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n+{\n+    int             fd;\n+    u_char         *prev;\n+    off_t           size, send, prev_send, aligned, fprev;\n+    size_t          sent;\n+    ssize_t         n;\n+    ngx_int_t       eintr;\n+    ngx_err_t       err;\n+    ngx_buf_t      *file;\n+    ngx_uint_t      nsfv;\n+    sendfilevec_t  *sfv, sfvs[NGX_SENDFILEVECS];\n+    ngx_event_t    *wev;\n+    ngx_chain_t    *cl;\n+\n+    wev = c->write;\n+\n+    if (!wev->ready) {\n+        return in;\n+    }\n+\n+    if (!c->sendfile) {\n+        return ngx_writev_chain(c, in, limit);\n+    }\n+\n+\n+    /* the maximum limit size is the maximum size_t value - the page size */\n+\n+    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n+        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n+    }\n+\n+\n+    send = 0;\n+\n+    for ( ;; ) {\n+        fd = SFV_FD_SELF;\n+        prev = NULL;\n+        fprev = 0;\n+        file = NULL;\n+        sfv = NULL;\n+        eintr = 0;\n+        sent = 0;\n+        prev_send = send;\n+\n+        nsfv = 0;\n+\n+        /* create the sendfilevec and coalesce the neighbouring bufs */\n+\n+        for (cl = in; cl && send < limit; cl = cl->next) {\n+\n+            if (ngx_buf_special(cl->buf)) {\n+                continue;\n+            }\n+\n+            if (ngx_buf_in_memory_only(cl->buf)) {\n+                fd = SFV_FD_SELF;\n+\n+                size = cl->buf->last - cl->buf->pos;\n+\n+                if (send + size > limit) {\n+                    size = limit - send;\n+                }\n+\n+                if (prev == cl->buf->pos) {\n+                    sfv->sfv_len += (size_t) size;\n+\n+                } else {\n+                    if (nsfv == NGX_SENDFILEVECS) {\n+                        break;\n+                    }\n+\n+                    sfv = &sfvs[nsfv++];\n+\n+                    sfv->sfv_fd = SFV_FD_SELF;\n+                    sfv->sfv_flag = 0;\n+                    sfv->sfv_off = (off_t) (uintptr_t) cl->buf->pos;\n+                    sfv->sfv_len = (size_t) size;\n+                }\n+\n+                prev = cl->buf->pos + (size_t) size;\n+                send += size;\n+\n+            } else {\n+                prev = NULL;\n+\n+                size = cl->buf->file_last - cl->buf->file_pos;\n+\n+                if (send + size > limit) {\n+                    size = limit - send;\n+\n+                    aligned = (cl->buf->file_pos + size + ngx_pagesize - 1)\n+                               & ~((off_t) ngx_pagesize - 1);\n+\n+                    if (aligned <= cl->buf->file_last) {\n+                        size = aligned - cl->buf->file_pos;\n+                    }\n+                }\n+\n+                if (fd == cl->buf->file->fd && fprev == cl->buf->file_pos) {\n+                    sfv->sfv_len += (size_t) size;\n+\n+                } else {\n+                    if (nsfv == NGX_SENDFILEVECS) {\n+                        break;\n+                    }\n+\n+                    sfv = &sfvs[nsfv++];\n+\n+                    fd = cl->buf->file->fd;\n+                    sfv->sfv_fd = fd;\n+                    sfv->sfv_flag = 0;\n+                    sfv->sfv_off = cl->buf->file_pos;\n+                    sfv->sfv_len = (size_t) size;\n+                }\n+\n+                file = cl->buf;\n+                fprev = cl->buf->file_pos + size;\n+                send += size;\n+            }\n+        }\n+\n+        n = sendfilev(c->fd, sfvs, nsfv, &sent);\n+\n+        if (n == -1) {\n+            err = ngx_errno;\n+\n+            switch (err) {\n+            case NGX_EAGAIN:\n+                break;\n+\n+            case NGX_EINTR:\n+                eintr = 1;\n+                break;\n+\n+            default:\n+                wev->error = 1;\n+                ngx_connection_error(c, err, \"sendfilev() failed\");\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                          \"sendfilev() sent only %uz bytes\", sent);\n+\n+        } else if (n == 0 && sent == 0) {\n+\n+            /*\n+             * sendfilev() is documented to return -1 with errno\n+             * set to EINVAL if svf_len is greater than the file size,\n+             * but at least Solaris 11 returns 0 instead\n+             */\n+\n+            if (file) {\n+                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                        \"sendfilev() reported that \\\"%s\\\" was truncated at %O\",\n+                        file->file->name.data, file->file_pos);\n+\n+            } else {\n+                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                              \"sendfilev() returned 0 with memory buffers\");\n+            }\n+\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"sendfilev: %z %z\", n, sent);\n+\n+        c->sent += sent;\n+\n+        in = ngx_chain_update_sent(in, sent);\n+\n+        if (eintr) {\n+            send = prev_send + sent;\n+            continue;\n+        }\n+\n+        if (send - prev_send != (off_t) sent) {\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        if (send >= limit || in == NULL) {\n+            return in;\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,43 @@\n+/\n+/ Copyright (C) Igor Sysoev\n+/ Copyright (C) Nginx, Inc.\n+/\n+\n+/ ngx_atomic_uint_t ngx_atomic_cmp_set(ngx_atomic_t *lock,\n+/     ngx_atomic_uint_t old, ngx_atomic_uint_t set);\n+/\n+/ the arguments are passed in %rdi, %rsi, %rdx\n+/ the result is returned in the %rax\n+\n+        .inline ngx_atomic_cmp_set,0\n+        movq      %rsi, %rax\n+        lock\n+        cmpxchgq  %rdx, (%rdi)\n+        setz      %al\n+        movzbq    %al, %rax\n+        .end\n+\n+\n+/ ngx_atomic_int_t ngx_atomic_fetch_add(ngx_atomic_t *value,\n+/     ngx_atomic_int_t add);\n+/\n+/ the arguments are passed in %rdi, %rsi\n+/ the result is returned in the %rax\n+\n+        .inline ngx_atomic_fetch_add,0\n+        movq      %rsi, %rax\n+        lock\n+        xaddq     %rax, (%rdi)\n+        .end\n+\n+\n+/ ngx_cpu_pause()\n+/\n+/ the \"rep; nop\" is used instead of \"pause\" to avoid the \"[ PAUSE ]\" hardware\n+/ capability added by linker because Solaris/amd64 does not know about it:\n+/\n+/ ld.so.1: nginx: fatal: hardware capability unsupported: 0x2000 [ PAUSE ]\n+\n+        .inline ngx_cpu_pause,0\n+        rep; nop\n+        .end\nDiff:\n@@ -0,0 +1,61 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#if (NGX_PTR_SIZE == 4)\n+#define NGX_CASA  ngx_casa\n+#else\n+#define NGX_CASA  ngx_casxa\n+#endif\n+\n+\n+ngx_atomic_uint_t\n+ngx_casa(ngx_atomic_uint_t set, ngx_atomic_uint_t old, ngx_atomic_t *lock);\n+\n+ngx_atomic_uint_t\n+ngx_casxa(ngx_atomic_uint_t set, ngx_atomic_uint_t old, ngx_atomic_t *lock);\n+\n+/* the code in src/os/unix/ngx_sunpro_sparc64.il */\n+\n+\n+static ngx_inline ngx_atomic_uint_t\n+ngx_atomic_cmp_set(ngx_atomic_t *lock, ngx_atomic_uint_t old,\n+    ngx_atomic_uint_t set)\n+{\n+    set = NGX_CASA(set, old, lock);\n+\n+    return (set == old);\n+}\n+\n+\n+static ngx_inline ngx_atomic_int_t\n+ngx_atomic_fetch_add(ngx_atomic_t *value, ngx_atomic_int_t add)\n+{\n+    ngx_atomic_uint_t  old, res;\n+\n+    old = *value;\n+\n+    for ( ;; ) {\n+\n+        res = old + add;\n+\n+        res = NGX_CASA(res, old, value);\n+\n+        if (res == old) {\n+            return res;\n+        }\n+\n+        old = res;\n+    }\n+}\n+\n+\n+#define ngx_memory_barrier()                                                  \\\n+        __asm (\".volatile\");                                                  \\\n+        __asm (\"membar #LoadLoad | #LoadStore | #StoreStore | #StoreLoad\");   \\\n+        __asm (\".nonvolatile\")\n+\n+#define ngx_cpu_pause()\nDiff:\n@@ -0,0 +1,36 @@\n+/\n+/ Copyright (C) Igor Sysoev\n+/ Copyright (C) Nginx, Inc.\n+/\n+\n+\n+/  \"casa   [%o2] 0x80, %o1, %o0\"  and\n+/  \"casxa  [%o2] 0x80, %o1, %o0\"  do the following:\n+/\n+/       if ([%o2] == %o1) {\n+/           swap(%o0, [%o2]);\n+/       } else {\n+/           %o0 = [%o2];\n+/       }\n+\n+\n+/ ngx_atomic_uint_t ngx_casa(ngx_atomic_uint_t set, ngx_atomic_uint_t old,\n+/      ngx_atomic_t *lock);\n+/\n+/ the arguments are passed in the %o0, %o1, %o2\n+/ the result is returned in the %o0\n+\n+        .inline ngx_casa,0\n+        casa    [%o2] 0x80, %o1, %o0\n+        .end\n+\n+\n+/ ngx_atomic_uint_t ngx_casxa(ngx_atomic_uint_t set, ngx_atomic_uint_t old,\n+/      ngx_atomic_t *lock);\n+/\n+/ the arguments are passed in the %o0, %o1, %o2\n+/ the result is returned in the %o0\n+\n+        .inline ngx_casxa,0\n+        casxa   [%o2] 0x80, %o1, %o0\n+        .end\nDiff:\n@@ -0,0 +1,44 @@\n+/\n+/ Copyright (C) Igor Sysoev\n+/ Copyright (C) Nginx, Inc.\n+/\n+\n+/ ngx_atomic_uint_t ngx_atomic_cmp_set(ngx_atomic_t *lock,\n+/     ngx_atomic_uint_t old, ngx_atomic_uint_t set);\n+/\n+/ the arguments are passed on stack (%esp), 4(%esp), 8(%esp)\n+\n+        .inline ngx_atomic_cmp_set,0\n+        movl      (%esp), %ecx\n+        movl      4(%esp), %eax\n+        movl      8(%esp), %edx\n+        lock\n+        cmpxchgl  %edx, (%ecx)\n+        setz      %al\n+        movzbl    %al, %eax\n+        .end\n+\n+\n+/ ngx_atomic_int_t ngx_atomic_fetch_add(ngx_atomic_t *value,\n+/     ngx_atomic_int_t add);\n+/\n+/ the arguments are passed on stack (%esp), 4(%esp)\n+\n+        .inline ngx_atomic_fetch_add,0\n+        movl      (%esp), %ecx\n+        movl      4(%esp), %eax\n+        lock\n+        xaddl     %eax, (%ecx)\n+        .end\n+\n+\n+/ ngx_cpu_pause()\n+/\n+/ the \"rep; nop\" is used instead of \"pause\" to avoid the \"[ PAUSE ]\" hardware\n+/ capability added by linker because Solaris/i386 does not know about it:\n+/\n+/ ld.so.1: nginx: fatal: hardware capability unsupported: 0x2000  [ PAUSE ]\n+\n+        .inline ngx_cpu_pause,0\n+        rep; nop\n+        .end\nDiff:\n@@ -0,0 +1,71 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_THREAD_H_INCLUDED_\n+#define _NGX_THREAD_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+#if (NGX_THREADS)\n+\n+#include <pthread.h>\n+\n+\n+typedef pthread_mutex_t  ngx_thread_mutex_t;\n+\n+ngx_int_t ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log);\n+ngx_int_t ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log);\n+ngx_int_t ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log);\n+ngx_int_t ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log);\n+\n+\n+typedef pthread_cond_t  ngx_thread_cond_t;\n+\n+ngx_int_t ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log);\n+ngx_int_t ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log);\n+ngx_int_t ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log);\n+ngx_int_t ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx,\n+    ngx_log_t *log);\n+\n+\n+#if (NGX_LINUX)\n+\n+typedef pid_t      ngx_tid_t;\n+#define NGX_TID_T_FMT         \"%P\"\n+\n+#elif (NGX_FREEBSD)\n+\n+typedef uint32_t   ngx_tid_t;\n+#define NGX_TID_T_FMT         \"%uD\"\n+\n+#elif (NGX_DARWIN)\n+\n+typedef uint64_t   ngx_tid_t;\n+#define NGX_TID_T_FMT         \"%uL\"\n+\n+#else\n+\n+typedef uint64_t   ngx_tid_t;\n+#define NGX_TID_T_FMT         \"%uL\"\n+\n+#endif\n+\n+ngx_tid_t ngx_thread_tid(void);\n+\n+#define ngx_log_tid           ngx_thread_tid()\n+\n+#else\n+\n+#define ngx_log_tid           0\n+#define NGX_TID_T_FMT         \"%d\"\n+\n+#endif\n+\n+\n+#endif /* _NGX_THREAD_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,76 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_int_t\n+ngx_thread_cond_create(ngx_thread_cond_t *cond, ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_cond_init(cond, NULL);\n+    if (err == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_EMERG, log, err, \"pthread_cond_init() failed\");\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_thread_cond_destroy(ngx_thread_cond_t *cond, ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_cond_destroy(cond);\n+    if (err == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_EMERG, log, err, \"pthread_cond_destroy() failed\");\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_thread_cond_signal(ngx_thread_cond_t *cond, ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_cond_signal(cond);\n+    if (err == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_EMERG, log, err, \"pthread_cond_signal() failed\");\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_thread_cond_wait(ngx_thread_cond_t *cond, ngx_thread_mutex_t *mtx,\n+    ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_cond_wait(cond, mtx);\n+\n+#if 0\n+    ngx_time_update();\n+#endif\n+\n+    if (err == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_ALERT, log, err, \"pthread_cond_wait() failed\");\n+\n+    return NGX_ERROR;\n+}\nDiff:\n@@ -0,0 +1,70 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_thread_pool.h>\n+\n+\n+#if (NGX_LINUX)\n+\n+/*\n+ * Linux thread id is a pid of thread created by clone(2),\n+ * glibc does not provide a wrapper for gettid().\n+ */\n+\n+ngx_tid_t\n+ngx_thread_tid(void)\n+{\n+    return syscall(SYS_gettid);\n+}\n+\n+#elif (NGX_FREEBSD) && (__FreeBSD_version >= 900031)\n+\n+#include <pthread_np.h>\n+\n+ngx_tid_t\n+ngx_thread_tid(void)\n+{\n+    return pthread_getthreadid_np();\n+}\n+\n+#elif (NGX_DARWIN)\n+\n+/*\n+ * MacOSX thread has two thread ids:\n+ *\n+ * 1) MacOSX 10.6 (Snow Leoprad) has pthread_threadid_np() returning\n+ *    an uint64_t value, which is obtained using the __thread_selfid()\n+ *    syscall.  It is a number above 300,000.\n+ */\n+\n+ngx_tid_t\n+ngx_thread_tid(void)\n+{\n+    uint64_t  tid;\n+\n+    (void) pthread_threadid_np(NULL, &tid);\n+    return tid;\n+}\n+\n+/*\n+ * 2) Kernel thread mach_port_t returned by pthread_mach_thread_np().\n+ *    It is a number in range 100-100,000.\n+ *\n+ * return pthread_mach_thread_np(pthread_self());\n+ */\n+\n+#else\n+\n+ngx_tid_t\n+ngx_thread_tid(void)\n+{\n+    return (uint64_t) (uintptr_t) pthread_self();\n+}\n+\n+#endif\nDiff:\n@@ -0,0 +1,165 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/*\n+ * All modern pthread mutex implementations try to acquire a lock\n+ * atomically in userland before going to sleep in kernel.  Some\n+ * spins before the sleeping.\n+ *\n+ * In Solaris since version 8 all mutex types spin before sleeping.\n+ * The default spin count is 1000.  It can be overridden using\n+ * _THREAD_ADAPTIVE_SPIN=100 environment variable.\n+ *\n+ * In MacOSX all mutex types spin to acquire a lock protecting a mutex's\n+ * internals.  If the mutex is busy, thread calls Mach semaphore_wait().\n+ *\n+ *\n+ * PTHREAD_MUTEX_NORMAL lacks deadlock detection and is the fastest\n+ * mutex type.\n+ *\n+ *   Linux:    No spinning.  The internal name PTHREAD_MUTEX_TIMED_NP\n+ *             remains from the times when pthread_mutex_timedlock() was\n+ *             non-standard extension.  Alias name: PTHREAD_MUTEX_FAST_NP.\n+ *   FreeBSD:  No spinning.\n+ *\n+ *\n+ * PTHREAD_MUTEX_ERRORCHECK is usually as fast as PTHREAD_MUTEX_NORMAL\n+ * yet has lightweight deadlock detection.\n+ *\n+ *   Linux:    No spinning.  The internal name: PTHREAD_MUTEX_ERRORCHECK_NP.\n+ *   FreeBSD:  No spinning.\n+ *\n+ *\n+ * PTHREAD_MUTEX_RECURSIVE allows recursive locking.\n+ *\n+ *   Linux:    No spinning.  The internal name: PTHREAD_MUTEX_RECURSIVE_NP.\n+ *   FreeBSD:  No spinning.\n+ *\n+ *\n+ * PTHREAD_MUTEX_ADAPTIVE_NP spins on SMP systems before sleeping.\n+ *\n+ *   Linux:    No deadlock detection.  Dynamically changes a spin count\n+ *             for each mutex from 10 to 100 based on spin count taken\n+ *             previously.\n+ *   FreeBSD:  Deadlock detection.  The default spin count is 2000.\n+ *             It can be overridden using LIBPTHREAD_SPINLOOPS environment\n+ *             variable or by pthread_mutex_setspinloops_np().  If a lock\n+ *             is still busy, sched_yield() can be called on both UP and\n+ *             SMP systems.  The default yield loop count is zero, but\n+ *             it can be set by LIBPTHREAD_YIELDLOOPS environment\n+ *             variable or by pthread_mutex_setyieldloops_np().\n+ *   Solaris:  No PTHREAD_MUTEX_ADAPTIVE_NP.\n+ *   MacOSX:   No PTHREAD_MUTEX_ADAPTIVE_NP.\n+ *\n+ *\n+ * PTHREAD_MUTEX_ELISION_NP is a Linux extension to elide locks using\n+ * Intel Restricted Transactional Memory.  It is the most suitable for\n+ * rwlock pattern access because it allows simultaneous reads without lock.\n+ * Supported since glibc 2.18.\n+ *\n+ *\n+ * PTHREAD_MUTEX_DEFAULT is default mutex type.\n+ *\n+ *   Linux:    PTHREAD_MUTEX_NORMAL.\n+ *   FreeBSD:  PTHREAD_MUTEX_ERRORCHECK.\n+ *   Solaris:  PTHREAD_MUTEX_NORMAL.\n+ *   MacOSX:   PTHREAD_MUTEX_NORMAL.\n+ */\n+\n+\n+ngx_int_t\n+ngx_thread_mutex_create(ngx_thread_mutex_t *mtx, ngx_log_t *log)\n+{\n+    ngx_err_t            err;\n+    pthread_mutexattr_t  attr;\n+\n+    err = pthread_mutexattr_init(&attr);\n+    if (err != 0) {\n+        ngx_log_error(NGX_LOG_EMERG, log, err,\n+                      \"pthread_mutexattr_init() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    err = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);\n+    if (err != 0) {\n+        ngx_log_error(NGX_LOG_EMERG, log, err,\n+                      \"pthread_mutexattr_settype\"\n+                      \"(PTHREAD_MUTEX_ERRORCHECK) failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    err = pthread_mutex_init(mtx, &attr);\n+    if (err != 0) {\n+        ngx_log_error(NGX_LOG_EMERG, log, err,\n+                      \"pthread_mutex_init() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    err = pthread_mutexattr_destroy(&attr);\n+    if (err != 0) {\n+        ngx_log_error(NGX_LOG_ALERT, log, err,\n+                      \"pthread_mutexattr_destroy() failed\");\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_thread_mutex_destroy(ngx_thread_mutex_t *mtx, ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_mutex_destroy(mtx);\n+    if (err != 0) {\n+        ngx_log_error(NGX_LOG_ALERT, log, err,\n+                      \"pthread_mutex_destroy() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_thread_mutex_lock(ngx_thread_mutex_t *mtx, ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_mutex_lock(mtx);\n+    if (err == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_ALERT, log, err, \"pthread_mutex_lock() failed\");\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_thread_mutex_unlock(ngx_thread_mutex_t *mtx, ngx_log_t *log)\n+{\n+    ngx_err_t  err;\n+\n+    err = pthread_mutex_unlock(mtx);\n+\n+#if 0\n+    ngx_time_update();\n+#endif\n+\n+    if (err == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_ALERT, log, err, \"pthread_mutex_unlock() failed\");\n+\n+    return NGX_ERROR;\n+}\nDiff:\n@@ -0,0 +1,104 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+/*\n+ * FreeBSD does not test /etc/localtime change, however, we can workaround it\n+ * by calling tzset() with TZ and then without TZ to update timezone.\n+ * The trick should work since FreeBSD 2.1.0.\n+ *\n+ * Linux does not test /etc/localtime change in localtime(),\n+ * but may stat(\"/etc/localtime\") several times in every strftime(),\n+ * therefore we use it to update timezone.\n+ *\n+ * Solaris does not test /etc/TIMEZONE change too and no workaround available.\n+ */\n+\n+void\n+ngx_timezone_update(void)\n+{\n+#if (NGX_FREEBSD)\n+\n+    if (getenv(\"TZ\")) {\n+        return;\n+    }\n+\n+    putenv(\"TZ=UTC\");\n+\n+    tzset();\n+\n+    unsetenv(\"TZ\");\n+\n+    tzset();\n+\n+#elif (NGX_LINUX)\n+    time_t      s;\n+    struct tm  *t;\n+    char        buf[4];\n+\n+    s = time(0);\n+\n+    t = localtime(&s);\n+\n+    strftime(buf, 4, \"%H\", t);\n+\n+#endif\n+}\n+\n+\n+void\n+ngx_localtime(time_t s, ngx_tm_t *tm)\n+{\n+#if (NGX_HAVE_LOCALTIME_R)\n+    (void) localtime_r(&s, tm);\n+\n+#else\n+    ngx_tm_t  *t;\n+\n+    t = localtime(&s);\n+    *tm = *t;\n+\n+#endif\n+\n+    tm->ngx_tm_mon++;\n+    tm->ngx_tm_year += 1900;\n+}\n+\n+\n+void\n+ngx_libc_localtime(time_t s, struct tm *tm)\n+{\n+#if (NGX_HAVE_LOCALTIME_R)\n+    (void) localtime_r(&s, tm);\n+\n+#else\n+    struct tm  *t;\n+\n+    t = localtime(&s);\n+    *tm = *t;\n+\n+#endif\n+}\n+\n+\n+void\n+ngx_libc_gmtime(time_t s, struct tm *tm)\n+{\n+#if (NGX_HAVE_LOCALTIME_R)\n+    (void) gmtime_r(&s, tm);\n+\n+#else\n+    struct tm  *t;\n+\n+    t = gmtime(&s);\n+    *tm = *t;\n+\n+#endif\n+}\nDiff:\n@@ -0,0 +1,66 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_TIME_H_INCLUDED_\n+#define _NGX_TIME_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef ngx_rbtree_key_t      ngx_msec_t;\n+typedef ngx_rbtree_key_int_t  ngx_msec_int_t;\n+\n+typedef struct tm             ngx_tm_t;\n+\n+#define ngx_tm_sec            tm_sec\n+#define ngx_tm_min            tm_min\n+#define ngx_tm_hour           tm_hour\n+#define ngx_tm_mday           tm_mday\n+#define ngx_tm_mon            tm_mon\n+#define ngx_tm_year           tm_year\n+#define ngx_tm_wday           tm_wday\n+#define ngx_tm_isdst          tm_isdst\n+\n+#define ngx_tm_sec_t          int\n+#define ngx_tm_min_t          int\n+#define ngx_tm_hour_t         int\n+#define ngx_tm_mday_t         int\n+#define ngx_tm_mon_t          int\n+#define ngx_tm_year_t         int\n+#define ngx_tm_wday_t         int\n+\n+\n+#if (NGX_HAVE_GMTOFF)\n+#define ngx_tm_gmtoff         tm_gmtoff\n+#define ngx_tm_zone           tm_zone\n+#endif\n+\n+\n+#if (NGX_SOLARIS)\n+\n+#define ngx_timezone(isdst) (- (isdst ? altzone : timezone) / 60)\n+\n+#else\n+\n+#define ngx_timezone(isdst) (- (isdst ? timezone + 3600 : timezone) / 60)\n+\n+#endif\n+\n+\n+void ngx_timezone_update(void);\n+void ngx_localtime(time_t s, ngx_tm_t *tm);\n+void ngx_libc_localtime(time_t s, struct tm *tm);\n+void ngx_libc_gmtime(time_t s, struct tm *tm);\n+\n+#define ngx_gettimeofday(tp)  (void) gettimeofday(tp, NULL);\n+#define ngx_msleep(ms)        (void) usleep(ms * 1000)\n+#define ngx_sleep(s)          (void) sleep(s)\n+\n+\n+#endif /* _NGX_TIME_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,72 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ssize_t\n+ngx_udp_unix_recv(ngx_connection_t *c, u_char *buf, size_t size)\n+{\n+    ssize_t       n;\n+    ngx_err_t     err;\n+    ngx_event_t  *rev;\n+\n+    rev = c->read;\n+\n+    do {\n+        n = recv(c->fd, buf, size, 0);\n+\n+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"recv: fd:%d %z of %uz\", c->fd, n, size);\n+\n+        if (n >= 0) {\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+            if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n+                rev->available -= n;\n+\n+                /*\n+                 * rev->available may be negative here because some additional\n+                 * bytes may be received between kevent() and recv()\n+                 */\n+\n+                if (rev->available <= 0) {\n+                    rev->ready = 0;\n+                    rev->available = 0;\n+                }\n+            }\n+\n+#endif\n+\n+            return n;\n+        }\n+\n+        err = ngx_socket_errno;\n+\n+        if (err == NGX_EAGAIN || err == NGX_EINTR) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"recv() not ready\");\n+            n = NGX_AGAIN;\n+\n+        } else {\n+            n = ngx_connection_error(c, err, \"recv() failed\");\n+            break;\n+        }\n+\n+    } while (err == NGX_EINTR);\n+\n+    rev->ready = 0;\n+\n+    if (n == NGX_ERROR) {\n+        rev->error = 1;\n+    }\n+\n+    return n;\n+}\nDiff:\n@@ -0,0 +1,56 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ssize_t\n+ngx_udp_unix_send(ngx_connection_t *c, u_char *buf, size_t size)\n+{\n+    ssize_t       n;\n+    ngx_err_t     err;\n+    ngx_event_t  *wev;\n+\n+    wev = c->write;\n+\n+    for ( ;; ) {\n+        n = sendto(c->fd, buf, size, 0, c->sockaddr, c->socklen);\n+\n+        ngx_log_debug4(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"sendto: fd:%d %z of %uz to \\\"%V\\\"\",\n+                       c->fd, n, size, &c->addr_text);\n+\n+        if (n >= 0) {\n+            if ((size_t) n != size) {\n+                wev->error = 1;\n+                (void) ngx_connection_error(c, 0, \"sendto() incomplete\");\n+                return NGX_ERROR;\n+            }\n+\n+            c->sent += n;\n+\n+            return n;\n+        }\n+\n+        err = ngx_socket_errno;\n+\n+        if (err == NGX_EAGAIN) {\n+            wev->ready = 0;\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, NGX_EAGAIN,\n+                           \"sendto() not ready\");\n+            return NGX_AGAIN;\n+        }\n+\n+        if (err != NGX_EINTR) {\n+            wev->error = 1;\n+            (void) ngx_connection_error(c, err, \"sendto() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+}\nDiff:\n@@ -0,0 +1,335 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec,\n+    ngx_chain_t *in, ngx_log_t *log);\n+static ssize_t ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec);\n+\n+\n+ngx_chain_t *\n+ngx_udp_unix_sendmsg_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n+{\n+    ssize_t        n;\n+    off_t          send;\n+    ngx_chain_t   *cl;\n+    ngx_event_t   *wev;\n+    ngx_iovec_t    vec;\n+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];\n+\n+    wev = c->write;\n+\n+    if (!wev->ready) {\n+        return in;\n+    }\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n+        (void) ngx_connection_error(c, wev->kq_errno,\n+                               \"kevent() reported about an closed connection\");\n+        wev->error = 1;\n+        return NGX_CHAIN_ERROR;\n+    }\n+\n+#endif\n+\n+    /* the maximum limit size is the maximum size_t value - the page size */\n+\n+    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n+        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n+    }\n+\n+    send = 0;\n+\n+    vec.iovs = iovs;\n+    vec.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    for ( ;; ) {\n+\n+        /* create the iovec and coalesce the neighbouring bufs */\n+\n+        cl = ngx_udp_output_chain_to_iovec(&vec, in, c->log);\n+\n+        if (cl == NGX_CHAIN_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        if (cl && cl->buf->in_file) {\n+            ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"file buf in sendmsg \"\n+                          \"t:%d r:%d f:%d %p %p-%p %p %O-%O\",\n+                          cl->buf->temporary,\n+                          cl->buf->recycled,\n+                          cl->buf->in_file,\n+                          cl->buf->start,\n+                          cl->buf->pos,\n+                          cl->buf->last,\n+                          cl->buf->file,\n+                          cl->buf->file_pos,\n+                          cl->buf->file_last);\n+\n+            ngx_debug_point();\n+\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        if (cl == in) {\n+            return in;\n+        }\n+\n+        send += vec.size;\n+\n+        n = ngx_sendmsg(c, &vec);\n+\n+        if (n == NGX_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        if (n == NGX_AGAIN) {\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        c->sent += n;\n+\n+        in = ngx_chain_update_sent(in, n);\n+\n+        if (send >= limit || in == NULL) {\n+            return in;\n+        }\n+    }\n+}\n+\n+\n+static ngx_chain_t *\n+ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, ngx_log_t *log)\n+{\n+    size_t         total, size;\n+    u_char        *prev;\n+    ngx_uint_t     n, flush;\n+    ngx_chain_t   *cl;\n+    struct iovec  *iov;\n+\n+    cl = in;\n+    iov = NULL;\n+    prev = NULL;\n+    total = 0;\n+    n = 0;\n+    flush = 0;\n+\n+    for ( /* void */ ; in && !flush; in = in->next) {\n+\n+        if (in->buf->flush || in->buf->last_buf) {\n+            flush = 1;\n+        }\n+\n+        if (ngx_buf_special(in->buf)) {\n+            continue;\n+        }\n+\n+        if (in->buf->in_file) {\n+            break;\n+        }\n+\n+        if (!ngx_buf_in_memory(in->buf)) {\n+            ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                          \"bad buf in output chain \"\n+                          \"t:%d r:%d f:%d %p %p-%p %p %O-%O\",\n+                          in->buf->temporary,\n+                          in->buf->recycled,\n+                          in->buf->in_file,\n+                          in->buf->start,\n+                          in->buf->pos,\n+                          in->buf->last,\n+                          in->buf->file,\n+                          in->buf->file_pos,\n+                          in->buf->file_last);\n+\n+            ngx_debug_point();\n+\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        size = in->buf->last - in->buf->pos;\n+\n+        if (prev == in->buf->pos) {\n+            iov->iov_len += size;\n+\n+        } else {\n+            if (n == vec->nalloc) {\n+                ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                              \"too many parts in a datagram\");\n+                return NGX_CHAIN_ERROR;\n+            }\n+\n+            iov = &vec->iovs[n++];\n+\n+            iov->iov_base = (void *) in->buf->pos;\n+            iov->iov_len = size;\n+        }\n+\n+        prev = in->buf->pos + size;\n+        total += size;\n+    }\n+\n+    if (!flush) {\n+#if (NGX_SUPPRESS_WARN)\n+        vec->size = 0;\n+        vec->count = 0;\n+#endif\n+        return cl;\n+    }\n+\n+    vec->count = n;\n+    vec->size = total;\n+\n+    return in;\n+}\n+\n+\n+static ssize_t\n+ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n+{\n+    ssize_t        n;\n+    ngx_err_t      err;\n+    struct msghdr  msg;\n+\n+#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+\n+#if (NGX_HAVE_IP_SENDSRCADDR)\n+    u_char         msg_control[CMSG_SPACE(sizeof(struct in_addr))];\n+#elif (NGX_HAVE_IP_PKTINFO)\n+    u_char         msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    u_char         msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n+#endif\n+\n+#endif\n+\n+    ngx_memzero(&msg, sizeof(struct msghdr));\n+\n+    if (c->socklen) {\n+        msg.msg_name = c->sockaddr;\n+        msg.msg_namelen = c->socklen;\n+    }\n+\n+    msg.msg_iov = vec->iovs;\n+    msg.msg_iovlen = vec->count;\n+\n+#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+\n+    if (c->listening && c->listening->wildcard && c->local_sockaddr) {\n+\n+#if (NGX_HAVE_IP_SENDSRCADDR)\n+\n+        if (c->local_sockaddr->sa_family == AF_INET) {\n+            struct cmsghdr      *cmsg;\n+            struct in_addr      *addr;\n+            struct sockaddr_in  *sin;\n+\n+            msg.msg_control = &msg_control;\n+            msg.msg_controllen = sizeof(msg_control);\n+\n+            cmsg = CMSG_FIRSTHDR(&msg);\n+            cmsg->cmsg_level = IPPROTO_IP;\n+            cmsg->cmsg_type = IP_SENDSRCADDR;\n+            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_addr));\n+\n+            sin = (struct sockaddr_in *) c->local_sockaddr;\n+\n+            addr = (struct in_addr *) CMSG_DATA(cmsg);\n+            *addr = sin->sin_addr;\n+        }\n+\n+#elif (NGX_HAVE_IP_PKTINFO)\n+\n+        if (c->local_sockaddr->sa_family == AF_INET) {\n+            struct cmsghdr      *cmsg;\n+            struct in_pktinfo   *pkt;\n+            struct sockaddr_in  *sin;\n+\n+            msg.msg_control = &msg_control;\n+            msg.msg_controllen = sizeof(msg_control);\n+\n+            cmsg = CMSG_FIRSTHDR(&msg);\n+            cmsg->cmsg_level = IPPROTO_IP;\n+            cmsg->cmsg_type = IP_PKTINFO;\n+            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));\n+\n+            sin = (struct sockaddr_in *) c->local_sockaddr;\n+\n+            pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n+            ngx_memzero(pkt, sizeof(struct in_pktinfo));\n+            pkt->ipi_spec_dst = sin->sin_addr;\n+        }\n+\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+\n+        if (c->local_sockaddr->sa_family == AF_INET6) {\n+            struct cmsghdr       *cmsg;\n+            struct in6_pktinfo   *pkt6;\n+            struct sockaddr_in6  *sin6;\n+\n+            msg.msg_control = &msg_control6;\n+            msg.msg_controllen = sizeof(msg_control6);\n+\n+            cmsg = CMSG_FIRSTHDR(&msg);\n+            cmsg->cmsg_level = IPPROTO_IPV6;\n+            cmsg->cmsg_type = IPV6_PKTINFO;\n+            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n+\n+            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;\n+\n+            pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n+            ngx_memzero(pkt6, sizeof(struct in6_pktinfo));\n+            pkt6->ipi6_addr = sin6->sin6_addr;\n+        }\n+\n+#endif\n+    }\n+\n+#endif\n+\n+eintr:\n+\n+    n = sendmsg(c->fd, &msg, 0);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"sendmsg: %z of %uz\", n, vec->size);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+\n+        switch (err) {\n+        case NGX_EAGAIN:\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"sendmsg() not ready\");\n+            return NGX_AGAIN;\n+\n+        case NGX_EINTR:\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"sendmsg() was interrupted\");\n+            goto eintr;\n+\n+        default:\n+            c->write->error = 1;\n+            ngx_connection_error(c, err, \"sendmsg() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    return n;\n+}\nDiff:\n@@ -0,0 +1,76 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if (NGX_CRYPT)\n+\n+#if (NGX_HAVE_GNU_CRYPT_R)\n+\n+ngx_int_t\n+ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    char               *value;\n+    size_t              len;\n+    struct crypt_data   cd;\n+\n+    cd.initialized = 0;\n+\n+    value = crypt_r((char *) key, (char *) salt, &cd);\n+\n+    if (value) {\n+        len = ngx_strlen(value) + 1;\n+\n+        *encrypted = ngx_pnalloc(pool, len);\n+        if (*encrypted == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_memcpy(*encrypted, value, len);\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_CRIT, pool->log, ngx_errno, \"crypt_r() failed\");\n+\n+    return NGX_ERROR;\n+}\n+\n+#else\n+\n+ngx_int_t\n+ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt, u_char **encrypted)\n+{\n+    char       *value;\n+    size_t      len;\n+    ngx_err_t   err;\n+\n+    value = crypt((char *) key, (char *) salt);\n+\n+    if (value) {\n+        len = ngx_strlen(value) + 1;\n+\n+        *encrypted = ngx_pnalloc(pool, len);\n+        if (*encrypted == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_memcpy(*encrypted, value, len);\n+        return NGX_OK;\n+    }\n+\n+    err = ngx_errno;\n+\n+    ngx_log_error(NGX_LOG_CRIT, pool->log, err, \"crypt() failed\");\n+\n+    return NGX_ERROR;\n+}\n+\n+#endif\n+\n+#endif /* NGX_CRYPT */\nDiff:\n@@ -0,0 +1,24 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_USER_H_INCLUDED_\n+#define _NGX_USER_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+typedef uid_t  ngx_uid_t;\n+typedef gid_t  ngx_gid_t;\n+\n+\n+ngx_int_t ngx_libc_crypt(ngx_pool_t *pool, u_char *key, u_char *salt,\n+    u_char **encrypted);\n+\n+\n+#endif /* _NGX_USER_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,216 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_event.h>\n+\n+\n+ngx_chain_t *\n+ngx_writev_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n+{\n+    ssize_t        n, sent;\n+    off_t          send, prev_send;\n+    ngx_chain_t   *cl;\n+    ngx_event_t   *wev;\n+    ngx_iovec_t    vec;\n+    struct iovec   iovs[NGX_IOVS_PREALLOCATE];\n+\n+    wev = c->write;\n+\n+    if (!wev->ready) {\n+        return in;\n+    }\n+\n+#if (NGX_HAVE_KQUEUE)\n+\n+    if ((ngx_event_flags & NGX_USE_KQUEUE_EVENT) && wev->pending_eof) {\n+        (void) ngx_connection_error(c, wev->kq_errno,\n+                               \"kevent() reported about an closed connection\");\n+        wev->error = 1;\n+        return NGX_CHAIN_ERROR;\n+    }\n+\n+#endif\n+\n+    /* the maximum limit size is the maximum size_t value - the page size */\n+\n+    if (limit == 0 || limit > (off_t) (NGX_MAX_SIZE_T_VALUE - ngx_pagesize)) {\n+        limit = NGX_MAX_SIZE_T_VALUE - ngx_pagesize;\n+    }\n+\n+    send = 0;\n+\n+    vec.iovs = iovs;\n+    vec.nalloc = NGX_IOVS_PREALLOCATE;\n+\n+    for ( ;; ) {\n+        prev_send = send;\n+\n+        /* create the iovec and coalesce the neighbouring bufs */\n+\n+        cl = ngx_output_chain_to_iovec(&vec, in, limit - send, c->log);\n+\n+        if (cl == NGX_CHAIN_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        if (cl && cl->buf->in_file) {\n+            ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"file buf in writev \"\n+                          \"t:%d r:%d f:%d %p %p-%p %p %O-%O\",\n+                          cl->buf->temporary,\n+                          cl->buf->recycled,\n+                          cl->buf->in_file,\n+                          cl->buf->start,\n+                          cl->buf->pos,\n+                          cl->buf->last,\n+                          cl->buf->file,\n+                          cl->buf->file_pos,\n+                          cl->buf->file_last);\n+\n+            ngx_debug_point();\n+\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        send += vec.size;\n+\n+        n = ngx_writev(c, &vec);\n+\n+        if (n == NGX_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        sent = (n == NGX_AGAIN) ? 0 : n;\n+\n+        c->sent += sent;\n+\n+        in = ngx_chain_update_sent(in, sent);\n+\n+        if (send - prev_send != sent) {\n+            wev->ready = 0;\n+            return in;\n+        }\n+\n+        if (send >= limit || in == NULL) {\n+            return in;\n+        }\n+    }\n+}\n+\n+\n+ngx_chain_t *\n+ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,\n+    ngx_log_t *log)\n+{\n+    size_t         total, size;\n+    u_char        *prev;\n+    ngx_uint_t     n;\n+    struct iovec  *iov;\n+\n+    iov = NULL;\n+    prev = NULL;\n+    total = 0;\n+    n = 0;\n+\n+    for ( /* void */ ; in && total < limit; in = in->next) {\n+\n+        if (ngx_buf_special(in->buf)) {\n+            continue;\n+        }\n+\n+        if (in->buf->in_file) {\n+            break;\n+        }\n+\n+        if (!ngx_buf_in_memory(in->buf)) {\n+            ngx_log_error(NGX_LOG_ALERT, log, 0,\n+                          \"bad buf in output chain \"\n+                          \"t:%d r:%d f:%d %p %p-%p %p %O-%O\",\n+                          in->buf->temporary,\n+                          in->buf->recycled,\n+                          in->buf->in_file,\n+                          in->buf->start,\n+                          in->buf->pos,\n+                          in->buf->last,\n+                          in->buf->file,\n+                          in->buf->file_pos,\n+                          in->buf->file_last);\n+\n+            ngx_debug_point();\n+\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        size = in->buf->last - in->buf->pos;\n+\n+        if (size > limit - total) {\n+            size = limit - total;\n+        }\n+\n+        if (prev == in->buf->pos) {\n+            iov->iov_len += size;\n+\n+        } else {\n+            if (n == vec->nalloc) {\n+                break;\n+            }\n+\n+            iov = &vec->iovs[n++];\n+\n+            iov->iov_base = (void *) in->buf->pos;\n+            iov->iov_len = size;\n+        }\n+\n+        prev = in->buf->pos + size;\n+        total += size;\n+    }\n+\n+    vec->count = n;\n+    vec->size = total;\n+\n+    return in;\n+}\n+\n+\n+ssize_t\n+ngx_writev(ngx_connection_t *c, ngx_iovec_t *vec)\n+{\n+    ssize_t    n;\n+    ngx_err_t  err;\n+\n+eintr:\n+\n+    n = writev(c->fd, vec->iovs, vec->count);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"writev: %z of %uz\", n, vec->size);\n+\n+    if (n == -1) {\n+        err = ngx_errno;\n+\n+        switch (err) {\n+        case NGX_EAGAIN:\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"writev() not ready\");\n+            return NGX_AGAIN;\n+\n+        case NGX_EINTR:\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, err,\n+                           \"writev() was interrupted\");\n+            goto eintr;\n+\n+        default:\n+            c->write->error = 1;\n+            ngx_connection_error(c, err, \"writev() failed\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    return n;\n+}\nDiff:\nNone\nDiff:\n@@ -0,0 +1,6 @@\n+\n+// Copyright (C) Igor Sysoev\n+// Copyright (C) Nginx, Inc.\n+\n+\n+nginx   icon  discardable  \"src\\\\os\\\\win32\\\\nginx.ico\"\nDiff:\n@@ -0,0 +1,24 @@\n+/* XPM */\n+static char * nginx_xpm[] = {\n+\"16 16 2 2\",\n+/* colors */\n+\"   c none\",\n+\"GG c #009900\",\n+/* pixels */\n+\"                                \",\n+\"        GGGGGGGGGGGGGGGG        \",\n+\"        GGGGGGGGGGGGGGGG        \",\n+\"      GGGGGGGGGGGGGGGGGGGG      \",\n+\"      GGGGGG        GGGGGG      \",\n+\"    GGGGGG            GGGGGG    \",\n+\"    GGGGGG                      \",\n+\"  GGGGGG      GGGGGGGGGGGGGGGG  \",\n+\"  GGGGGG    GGGGGGGGGGGGGGGGGG  \",\n+\"    GGGGGG    GGGGGGGGGGGGGG    \",\n+\"    GGGGGG            GGGGGG    \",\n+\"      GGGGGG        GGGGGG      \",\n+\"      GGGGGGGGGGGGGGGGGGGG      \",\n+\"        GGGGGGGGGGGGGGGG        \",\n+\"        GGGGGGGGGGGGGGGG        \",\n+\"                                \"\n+};\nDiff:\n@@ -0,0 +1,39 @@\n+/* XPM */\n+static char * nginx_xpm[] = {\n+\"32 32 2 2\",\n+/* colors */\n+\"   c none\",\n+\"GG c #009900\",\n+/* pixels */\n+\"                                                                \",\n+\"                                                                \",\n+\"                                                                \",\n+\"                                                                \",\n+\"                  GGGGGGGGGGGGGGGGGGGGGGGGGGGG                  \",\n+\"                GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                \",\n+\"                GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                \",\n+\"              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG              \",\n+\"              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG              \",\n+\"            GGGGGGGGGG                    GGGGGGGGGG            \",\n+\"            GGGGGGGGGG                    GGGGGGGGGG            \",\n+\"          GGGGGGGGGG                        GGGGGGGGGG          \",\n+\"          GGGGGGGGGG                        GGGGGGGGGG          \",\n+\"        GGGGGGGGGG                                              \",\n+\"        GGGGGGGGGG                                              \",\n+\"      GGGGGGGGGG            GGGGGGGGGGGGGGGGGGGGGGGGGGGGGG      \",\n+\"      GGGGGGGGGG          GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG      \",\n+\"        GGGGGGGGGG        GGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        \",\n+\"        GGGGGGGGGG        GGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        \",\n+\"          GGGGGGGGGG        GGGGGGGGGGGGGGGGGGGGGGGGGG          \",\n+\"          GGGGGGGGGG                        GGGGGGGGGG          \",\n+\"            GGGGGGGGGG                    GGGGGGGGGG            \",\n+\"            GGGGGGGGGG                    GGGGGGGGGG            \",\n+\"              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG              \",\n+\"              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG              \",\n+\"                GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                \",\n+\"                GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                \",\n+\"                  GGGGGGGGGGGGGGGGGGGGGGGGGGGG                  \",\n+\"                                                                \",\n+\"                                                                \",\n+\"                                                                \",\n+\"                                                                \"\nDiff:\n@@ -0,0 +1,55 @@\n+/* XPM */\n+static char * nginx_xpm[] = {\n+\"48 48 2 2\",\n+/* colors */\n+\"   c none\",\n+\"GG c #009900\",\n+/* pixels */\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                        GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                        \",\n+\"                        GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                        \",\n+\"                      GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                      \",\n+\"                      GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                      \",\n+\"                    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                    \",\n+\"                    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                    \",\n+\"                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                  \",\n+\"                  GGGGGGGGGGGGGGGG                            GGGGGGGGGGGGGGGG                  \",\n+\"                GGGGGGGGGGGGGGGG                                GGGGGGGGGGGGGGGG                \",\n+\"                GGGGGGGGGGGGGGGG                                GGGGGGGGGGGGGGGG                \",\n+\"              GGGGGGGGGGGGGGGG                                    GGGGGGGGGGGGGGGG              \",\n+\"              GGGGGGGGGGGGGGGG                                    GGGGGGGGGGGGGGGG              \",\n+\"            GGGGGGGGGGGGGGGG                                        GGGGGGGGGGGGGGGG            \",\n+\"            GGGGGGGGGGGGGGGG                                        GGGGGGGGGGGGGGGG            \",\n+\"          GGGGGGGGGGGGGGGG                                            GGGGGGGGGGGGGGGG          \",\n+\"          GGGGGGGGGGGGGGGG                                                                      \",\n+\"        GGGGGGGGGGGGGGGG                                                                        \",\n+\"        GGGGGGGGGGGGGGGG                                                                        \",\n+\"      GGGGGGGGGGGGGGGG                    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG      \",\n+\"      GGGGGGGGGGGGGGGG                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG      \",\n+\"        GGGGGGGGGGGGGGGG              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        \",\n+\"        GGGGGGGGGGGGGGGG              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        \",\n+\"          GGGGGGGGGGGGGGGG            GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG          \",\n+\"          GGGGGGGGGGGGGGGG              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG          \",\n+\"            GGGGGGGGGGGGGGGG              GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG            \",\n+\"            GGGGGGGGGGGGGGGG                                        GGGGGGGGGGGGGGGG            \",\n+\"              GGGGGGGGGGGGGGGG                                    GGGGGGGGGGGGGGGG              \",\n+\"              GGGGGGGGGGGGGGGG                                    GGGGGGGGGGGGGGGG              \",\n+\"                GGGGGGGGGGGGGGGG                                GGGGGGGGGGGGGGGG                \",\n+\"                GGGGGGGGGGGGGGGG                                GGGGGGGGGGGGGGGG                \",\n+\"                  GGGGGGGGGGGGGGGG                            GGGGGGGGGGGGGGGG                  \",\n+\"                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                  \",\n+\"                    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                    \",\n+\"                    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                    \",\n+\"                      GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                      \",\n+\"                      GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                      \",\n+\"                        GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                        \",\n+\"                        GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG                        \",\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                                                                                                \",\n+\"                                                                                                \",\nDiff:\n@@ -0,0 +1,44 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+ngx_uint_t  ngx_pagesize;\n+ngx_uint_t  ngx_pagesize_shift;\n+ngx_uint_t  ngx_cacheline_size;\n+\n+\n+void *ngx_alloc(size_t size, ngx_log_t *log)\n+{\n+    void  *p;\n+\n+    p = malloc(size);\n+    if (p == NULL) {\n+        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,\n+                      \"malloc(%uz) failed\", size);\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, log, 0, \"malloc: %p:%uz\", p, size);\n+\n+    return p;\n+}\n+\n+\n+void *ngx_calloc(size_t size, ngx_log_t *log)\n+{\n+    void  *p;\n+\n+    p = ngx_alloc(size, log);\n+\n+    if (p) {\n+        ngx_memzero(p, size);\n+    }\n+\n+    return p;\n+}\nDiff:\n@@ -0,0 +1,27 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_ALLOC_H_INCLUDED_\n+#define _NGX_ALLOC_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+void *ngx_alloc(size_t size, ngx_log_t *log);\n+void *ngx_calloc(size_t size, ngx_log_t *log);\n+\n+#define ngx_free          free\n+#define ngx_memalign(alignment, size, log)  ngx_alloc(size, log)\n+\n+extern ngx_uint_t  ngx_pagesize;\n+extern ngx_uint_t  ngx_pagesize_shift;\n+extern ngx_uint_t  ngx_cacheline_size;\n+\n+\n+#endif /* _NGX_ALLOC_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,69 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_ATOMIC_H_INCLUDED_\n+#define _NGX_ATOMIC_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#define NGX_HAVE_ATOMIC_OPS   1\n+\n+typedef int32_t                     ngx_atomic_int_t;\n+typedef uint32_t                    ngx_atomic_uint_t;\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+\n+\n+#if defined( __WATCOMC__ ) || defined( __BORLANDC__ ) || defined(__GNUC__)    \\\n+    || ( _MSC_VER >= 1300 )\n+\n+/* the new SDK headers */\n+\n+#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n+    ((ngx_atomic_uint_t) InterlockedCompareExchange((long *) lock, set, old)  \\\n+                         == old)\n+\n+#else\n+\n+/* the old MS VC6.0SP2 SDK headers */\n+\n+#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n+    (InterlockedCompareExchange((void **) lock, (void *) set, (void *) old)   \\\n+     == (void *) old)\n+\n+#endif\n+\n+\n+#define ngx_atomic_fetch_add(p, add) InterlockedExchangeAdd((long *) p, add)\n+\n+\n+#define ngx_memory_barrier()\n+\n+\n+#if defined( __BORLANDC__ ) || ( __WATCOMC__ < 1230 )\n+\n+/*\n+ * Borland C++ 5.5 (tasm32) and Open Watcom C prior to 1.3\n+ * do not understand the \"pause\" instruction\n+ */\n+\n+#define ngx_cpu_pause()\n+#else\n+#define ngx_cpu_pause()       __asm { pause }\n+#endif\n+\n+\n+void ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin);\n+\n+#define ngx_trylock(lock)  (*(lock) == 0 && ngx_atomic_cmp_set(lock, 0, 1))\n+#define ngx_unlock(lock)    *(lock) = 0\n+\n+\n+#endif /* _NGX_ATOMIC_H_INCLUDED_ */\nDiff:\n@@ -0,0 +1,22 @@\n+\n+/*\n+ * Copyright (C) Maxim Dounin\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+char *\n+ngx_dlerror(void)\n+{\n+    u_char         *p;\n+    static u_char   errstr[NGX_MAX_ERROR_STR];\n+\n+    p = ngx_strerror(ngx_errno, errstr, NGX_MAX_ERROR_STR);\n+    *p = '\\0';\n+\n+    return (char *) errstr;\n+}\nDiff:\n@@ -0,0 +1,32 @@\n+\n+/*\n+ * Copyright (C) Maxim Dounin\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_DLOPEN_H_INCLUDED_\n+#define _NGX_DLOPEN_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#define NGX_HAVE_DLOPEN  1\n+\n+\n+#define ngx_dlopen(path)           LoadLibrary((char *) path)\n+#define ngx_dlopen_n               \"LoadLibrary()\"\n+\n+#define ngx_dlsym(handle, symbol)  (void *) GetProcAddress(handle, symbol)\n+#define ngx_dlsym_n                \"GetProcAddress()\"\n+\n+#define ngx_dlclose(handle)        (FreeLibrary(handle) ? 0 : -1)\n+#define ngx_dlclose_n              \"FreeLibrary()\"\n+\n+\n+char *ngx_dlerror(void);\n+\n+\n+#endif /* _NGX_DLOPEN_H_INCLUDED_ */\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\nDiff:\nNone\n"
    }
]
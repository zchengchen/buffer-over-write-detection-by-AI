[
    {
        "commit_index": "Commit 190",
        "commit_diff": "Diff:\n@@ -471,3 +471,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\n ff3afd1ce6a6b65057741df442adfaa71a0e2588 release-1.23.3\n+ac779115ed6ee4f3039e9aea414a54e560450ee2 release-1.23.4\nDiff:\n@@ -5,6 +5,20 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.24.0\" date=\"2023-04-11\">\n+\n+<change>\n+<para lang=\"ru\">\n+Стабильная ветка 1.24.x.\n+</para>\n+<para lang=\"en\">\n+1.24.x stable branch.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.4\" date=\"2023-03-28\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023004\n-#define NGINX_VERSION      \"1.23.4\"\n+#define nginx_version      1024000\n+#define NGINX_VERSION      \"1.24.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 189",
        "commit_diff": "Diff:\n@@ -5,6 +5,163 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.4\" date=\"2023-03-28\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь протокол TLSv1.3 разрешён по умолчанию.\n+</para>\n+<para lang=\"en\">\n+now TLSv1.3 protocol is enabled by default.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx выдаёт предупреждение\n+при переопределении параметров listen-сокета, задающих используемые протоколы.\n+</para>\n+<para lang=\"en\">\n+now nginx issues a warning\n+if protocol parameters of a listening socket are redefined.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь, если клиент использует pipelining,\n+nginx закрывает соединения с ожиданием дополнительных данных (lingering close).\n+</para>\n+<para lang=\"en\">\n+now nginx closes connections with lingering\n+if pipelining was used by the client.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+поддержка byte ranges для ответов модуля ngx_http_gzip_static_module.\n+</para>\n+<para lang=\"en\">\n+byte ranges support in the ngx_http_gzip_static_module.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+диапазоны портов в директиве listen не работали;\n+ошибка появилась в 1.23.3.<br/>\n+Спасибо Валентину Бартеневу.\n+</para>\n+<para lang=\"en\">\n+port ranges in the \"listen\" directive did not work;\n+the bug had appeared in 1.23.3.<br/>\n+Thanks to Valentin Bartenev.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+для обработки запроса мог быть выбран неверный location,\n+если в конфигурации использовался\n+префиксный location длиннее 255 символов.\n+</para>\n+<para lang=\"en\">\n+incorrect location might be chosen to process a request\n+if a prefix location longer than 255 characters\n+was used in the configuration.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+не-ASCII символы в именах файлов на Windows\n+не поддерживались модулями ngx_http_autoindex_module и\n+ngx_http_dav_module, а также директивой include.\n+</para>\n+<para lang=\"en\">\n+non-ASCII characters in file names on Windows were not supported\n+by the ngx_http_autoindex_module, the ngx_http_dav_module,\n+and the \"include\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL\n+\"data length too long\", \"length too short\", \"bad legacy version\",\n+\"no shared signature algorithms\", \"bad digest length\",\n+\"missing sigalgs extension\", \"encrypted length too long\",\n+\"bad length\", \"bad key update\", \"mixed handshake and non handshake data\",\n+\"ccs received early\", \"data between ccs and finished\",\n+\"packet length too long\", \"too many warn alerts\", \"record too small\",\n+и \"got a fin before a ccs\"\n+понижен с уровня crit до info.\n+</para>\n+<para lang=\"en\">\n+the logging level of the\n+\"data length too long\", \"length too short\", \"bad legacy version\",\n+\"no shared signature algorithms\", \"bad digest length\",\n+\"missing sigalgs extension\", \"encrypted length too long\",\n+\"bad length\", \"bad key update\", \"mixed handshake and non handshake data\",\n+\"ccs received early\", \"data between ccs and finished\",\n+\"packet length too long\", \"too many warn alerts\", \"record too small\",\n+and \"got a fin before a ccs\" SSL errors\n+has been lowered from \"crit\" to \"info\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2 и директивы error_page\n+для перенаправления ошибок с кодом 400\n+могла происходить утечка сокетов.\n+</para>\n+<para lang=\"en\">\n+a socket leak might occur\n+when using HTTP/2 and the \"error_page\" directive\n+to redirect errors with code 400.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+сообщения об ошибках записи в syslog\n+не содержали информации о том, что\n+ошибки происходили в процессе записи в syslog.<br/>\n+Спасибо Safar Safarly.\n+</para>\n+<para lang=\"en\">\n+messages about logging to syslog errors\n+did not contain information\n+that the errors happened while logging to syslog.<br/>\n+Thanks to Safar Safarly.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании zlib-ng\n+в логах появлялись сообщения \"gzip filter failed to use preallocated memory\".\n+</para>\n+<para lang=\"en\">\n+\"gzip filter failed to use preallocated memory\" alerts appeared in logs\n+when using zlib-ng.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+in the mail proxy server.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.3\" date=\"2022-12-13\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1s\n+OPENSSL =\topenssl-1.1.1t\n ZLIB =\t\tzlib-1.2.13\n PCRE =\t\tpcre2-10.39\n \nDiff:\n@@ -57,6 +57,7 @@ typedef struct {\n     unsigned             nomem:1;\n     unsigned             buffering:1;\n     unsigned             zlib_ng:1;\n+    unsigned             state_allocated:1;\n \n     size_t               zin;\n     size_t               zout;\n@@ -514,17 +515,19 @@ ngx_http_gzip_filter_memory(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)\n     } else {\n         /*\n          * Another zlib variant, https://github.com/zlib-ng/zlib-ng.\n-         * It forces window bits to 13 for fast compression level,\n-         * uses 16-byte padding in one of window-sized buffers, and\n-         * uses 128K hash.\n+         * It used to force window bits to 13 for fast compression level,\n+         * uses (64 + sizeof(void*)) additional space on all allocations\n+         * for alignment, 16-byte padding in one of window-sized buffers,\n+         * and 128K hash.\n          */\n \n         if (conf->level == 1) {\n             wbits = ngx_max(wbits, 13);\n         }\n \n         ctx->allocated = 8192 + 16 + (1 << (wbits + 2))\n-                         + 131072 + (1 << (memlevel + 8));\n+                         + 131072 + (1 << (memlevel + 8))\n+                         + 4 * (64 + sizeof(void*));\n         ctx->zlib_ng = 1;\n     }\n }\n@@ -926,13 +929,16 @@ ngx_http_gzip_filter_alloc(void *opaque, u_int items, u_int size)\n \n     alloc = items * size;\n \n-    if (items == 1 && alloc % 512 != 0 && alloc < 8192) {\n-\n+    if (items == 1 && alloc % 512 != 0 && alloc < 8192\n+        && !ctx->state_allocated)\n+    {\n         /*\n          * The zlib deflate_state allocation, it takes about 6K,\n          * we allocate 8K.  Other allocations are divisible by 512.\n          */\n \n+        ctx->state_allocated = 1;\n+\n         alloc = 8192;\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 188",
        "commit_diff": "Diff:\n@@ -4473,8 +4473,9 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->upstream.ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                                 (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                                  |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                                  |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\nDiff:\n@@ -3734,8 +3734,9 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->upstream.ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                                 (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                                  |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                                  |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\nDiff:\n@@ -632,8 +632,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->reject_handshake, prev->reject_handshake, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n-                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                         (NGX_CONF_BITMASK_SET\n+                          |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                          |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n                          NGX_SSL_BUFSIZE);\nDiff:\n@@ -1875,8 +1875,9 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->upstream.ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                                 (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                                  |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                                 (NGX_CONF_BITMASK_SET\n+                                  |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                                  |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\nDiff:\n@@ -360,8 +360,9 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                          prev->prefer_server_ciphers, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n-                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                         (NGX_CONF_BITMASK_SET\n+                          |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                          |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);\n     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);\nDiff:\n@@ -2163,8 +2163,9 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_session_reuse, 1);\n \n     ngx_conf_merge_bitmask_value(conf->ssl_protocols, prev->ssl_protocols,\n-                              (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                               |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                              (NGX_CONF_BITMASK_SET\n+                               |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                               |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers, \"DEFAULT\");\n \nDiff:\n@@ -703,8 +703,9 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                          prev->prefer_server_ciphers, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n-                         (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n-                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));\n+                         (NGX_CONF_BITMASK_SET\n+                          |NGX_SSL_TLSv1|NGX_SSL_TLSv1_1\n+                          |NGX_SSL_TLSv1_2|NGX_SSL_TLSv1_3));\n \n     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);\n     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 187",
        "commit_diff": "Diff:\n@@ -18,6 +18,7 @@\n static char *ngx_syslog_parse_args(ngx_conf_t *cf, ngx_syslog_peer_t *peer);\n static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer);\n static void ngx_syslog_cleanup(void *data);\n+static u_char *ngx_syslog_log_error(ngx_log_t *log, u_char *buf, size_t len);\n \n \n static char  *facilities[] = {\n@@ -67,7 +68,7 @@ ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer)\n     }\n \n     peer->hostname = &cf->cycle->hostname;\n-    peer->log = &cf->cycle->new_log;\n+    peer->logp = &cf->cycle->new_log;\n \n     peer->conn.fd = (ngx_socket_t) -1;\n \n@@ -289,6 +290,13 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n {\n     ssize_t  n;\n \n+    if (peer->log.handler == NULL) {\n+        peer->log = *peer->logp;\n+        peer->log.handler = ngx_syslog_log_error;\n+        peer->log.data = peer;\n+        peer->log.action = \"logging to syslog\";\n+    }\n+\n     if (peer->conn.fd == (ngx_socket_t) -1) {\n         if (ngx_syslog_init_peer(peer) != NGX_OK) {\n             return NGX_ERROR;\n@@ -306,7 +314,7 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n     if (n == NGX_ERROR) {\n \n         if (ngx_close_socket(peer->conn.fd) == -1) {\n-            ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+            ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                           ngx_close_socket_n \" failed\");\n         }\n \n@@ -324,25 +332,25 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n \n     fd = ngx_socket(peer->server.sockaddr->sa_family, SOCK_DGRAM, 0);\n     if (fd == (ngx_socket_t) -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_socket_n \" failed\");\n         return NGX_ERROR;\n     }\n \n     if (ngx_nonblocking(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_nonblocking_n \" failed\");\n         goto failed;\n     }\n \n     if (connect(fd, peer->server.sockaddr, peer->server.socklen) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       \"connect() failed\");\n         goto failed;\n     }\n \n     peer->conn.fd = fd;\n-    peer->conn.log = peer->log;\n+    peer->conn.log = &peer->log;\n \n     /* UDP sockets are always ready to write */\n     peer->conn.write->ready = 1;\n@@ -352,7 +360,7 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n failed:\n \n     if (ngx_close_socket(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n \n@@ -373,7 +381,30 @@ ngx_syslog_cleanup(void *data)\n     }\n \n     if (ngx_close_socket(peer->conn.fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, &peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n }\n+\n+\n+static u_char *\n+ngx_syslog_log_error(ngx_log_t *log, u_char *buf, size_t len)\n+{\n+    u_char             *p;\n+    ngx_syslog_peer_t  *peer;\n+\n+    p = buf;\n+\n+    if (log->action) {\n+        p = ngx_snprintf(buf, len, \" while %s\", log->action);\n+        len -= p - buf;\n+    }\n+\n+    peer = log->data;\n+\n+    if (peer) {\n+        p = ngx_snprintf(p, len, \", server: %V\", &peer->server.name);\n+    }\n+\n+    return p;\n+}\nDiff:\n@@ -18,7 +18,8 @@ typedef struct {\n     ngx_addr_t         server;\n     ngx_connection_t   conn;\n \n-    ngx_log_t         *log;\n+    ngx_log_t          log;\n+    ngx_log_t         *logp;\n \n     unsigned           busy:1;\n     unsigned           nohostname:1;\nDiff:\n@@ -327,7 +327,9 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos < s->buffer->last) {\n+        if (s->buffer->pos < s->buffer->last\n+            || s->connection->read->ready)\n+        {\n             ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n@@ -486,7 +488,9 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos < s->buffer->last) {\n+        if (s->buffer->pos < s->buffer->last\n+            || s->connection->read->ready)\n+        {\n             ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n@@ -821,7 +825,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos < s->buffer->last) {\n+        if (s->buffer->pos < s->buffer->last\n+            || s->connection->read->ready)\n+        {\n             ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n",
        "analysis": "Analyzing newly added functions:\n\n1. **Function: `ngx_syslog_log_error`**\n\n```c\nstatic u_char *ngx_syslog_log_error(ngx_log_t *log, u_char *buf, size_t len)\n{\n    u_char             *p;\n    ngx_syslog_peer_t  *peer;\n\n    p = buf;\n\n    if (log->action) {\n        p = ngx_snprintf(buf, len, \" while %s\", log->action);\n        len -= p - buf;\n    }\n\n    peer = log->data;\n\n    if (peer) {\n        p = ngx_snprintf(p, len, \", server: %V\", &peer->server.name);\n    }\n\n    return p;\n}\n```\n\n- The function `ngx_syslog_log_error` is evaluated line by line:\n\n  - Lines 2-3: Variable declarations are safe. \n  - Line 5: `p` is initialized with `buf`.\n  - Lines 7-9: Checks if `log->action` exists, then writes a formatted string to `buf` using `ngx_snprintf`. The use of `ngx_snprintf` is generally safe if used properly, since it ensures that the size specified (`len`) is not exceeded, protecting from buffer overflow.\n  - Line 10: `len -= p - buf;` is adjusting `len` to reflect the space left in the buffer, which is a necessary step to avoid overwriting.\n  - Line 12: Assigns `log->data` to `peer`.\n  - Lines 14-16: If `peer` is not NULL, writes another formatted string to `buf` with the remaining `len` using `ngx_snprintf`.\n  - Line 18: Returns `p`.\n\n- No definitive out-of-bounds write detected. However, since `ngx_snprintf` is used, potential danger exists only if assumptions about buffer sizes and formatting lengths are violated elsewhere in the program.\n\nConclusion: No evident out-of-bounds write, but the use of `ngx_snprintf` is inherently safer, and is performed with length checks.\n\nFinal Result:\n\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 186",
        "commit_diff": "Diff:\n@@ -66,6 +66,9 @@ ngx_syslog_process_conf(ngx_conf_t *cf, ngx_syslog_peer_t *peer)\n         ngx_str_set(&peer->tag, \"nginx\");\n     }\n \n+    peer->hostname = &cf->cycle->hostname;\n+    peer->log = &cf->cycle->new_log;\n+\n     peer->conn.fd = (ngx_socket_t) -1;\n \n     peer->conn.read = &ngx_syslog_dummy_event;\n@@ -243,7 +246,7 @@ ngx_syslog_add_header(ngx_syslog_peer_t *peer, u_char *buf)\n     }\n \n     return ngx_sprintf(buf, \"<%ui>%V %V %V: \", pri, &ngx_cached_syslog_time,\n-                       &ngx_cycle->hostname, &peer->tag);\n+                       peer->hostname, &peer->tag);\n }\n \n \n@@ -292,9 +295,6 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n         }\n     }\n \n-    /* log syslog socket events with valid log */\n-    peer->conn.log = ngx_cycle->log;\n-\n     if (ngx_send) {\n         n = ngx_send(&peer->conn, buf, len);\n \n@@ -306,7 +306,7 @@ ngx_syslog_send(ngx_syslog_peer_t *peer, u_char *buf, size_t len)\n     if (n == NGX_ERROR) {\n \n         if (ngx_close_socket(peer->conn.fd) == -1) {\n-            ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+            ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                           ngx_close_socket_n \" failed\");\n         }\n \n@@ -324,24 +324,25 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n \n     fd = ngx_socket(peer->server.sockaddr->sa_family, SOCK_DGRAM, 0);\n     if (fd == (ngx_socket_t) -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_socket_n \" failed\");\n         return NGX_ERROR;\n     }\n \n     if (ngx_nonblocking(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_nonblocking_n \" failed\");\n         goto failed;\n     }\n \n     if (connect(fd, peer->server.sockaddr, peer->server.socklen) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       \"connect() failed\");\n         goto failed;\n     }\n \n     peer->conn.fd = fd;\n+    peer->conn.log = peer->log;\n \n     /* UDP sockets are always ready to write */\n     peer->conn.write->ready = 1;\n@@ -351,7 +352,7 @@ ngx_syslog_init_peer(ngx_syslog_peer_t *peer)\n failed:\n \n     if (ngx_close_socket(fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n \n@@ -372,7 +373,7 @@ ngx_syslog_cleanup(void *data)\n     }\n \n     if (ngx_close_socket(peer->conn.fd) == -1) {\n-        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, ngx_socket_errno,\n+        ngx_log_error(NGX_LOG_ALERT, peer->log, ngx_socket_errno,\n                       ngx_close_socket_n \" failed\");\n     }\n }\nDiff:\n@@ -9,14 +9,19 @@\n \n \n typedef struct {\n-    ngx_uint_t        facility;\n-    ngx_uint_t        severity;\n-    ngx_str_t         tag;\n-\n-    ngx_addr_t        server;\n-    ngx_connection_t  conn;\n-    unsigned          busy:1;\n-    unsigned          nohostname:1;\n+    ngx_uint_t         facility;\n+    ngx_uint_t         severity;\n+    ngx_str_t          tag;\n+\n+    ngx_str_t         *hostname;\n+\n+    ngx_addr_t         server;\n+    ngx_connection_t   conn;\n+\n+    ngx_log_t         *log;\n+\n+    unsigned           busy:1;\n+    unsigned           nohostname:1;\n } ngx_syslog_peer_t;\n \n \nDiff:\n@@ -1794,14 +1794,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n \n     /* TODO Optimization: validate headers while parsing. */\n     if (ngx_http_v2_validate_header(r, header) != NGX_OK) {\n-        if (ngx_http_v2_terminate_stream(h2c, h2c->state.stream,\n-                                         NGX_HTTP_V2_PROTOCOL_ERROR)\n-            == NGX_ERROR)\n-        {\n-            return ngx_http_v2_connection_error(h2c,\n-                                                NGX_HTTP_V2_INTERNAL_ERROR);\n-        }\n-\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n         goto error;\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 185",
        "commit_diff": "Diff:\n@@ -1364,7 +1364,12 @@ ngx_utf8_decode(u_char **p, size_t n)\n \n     u = **p;\n \n-    if (u >= 0xf0) {\n+    if (u >= 0xf8) {\n+\n+        (*p)++;\n+        return 0xffffffff;\n+\n+    } else if (u >= 0xf0) {\n \n         u &= 0x07;\n         valid = 0xffff;\nDiff:\n@@ -3389,29 +3389,58 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n \n     } else if (sslerr == SSL_ERROR_SSL) {\n \n-        n = ERR_GET_REASON(ERR_peek_error());\n+        n = ERR_GET_REASON(ERR_peek_last_error());\n \n             /* handshake failures */\n         if (n == SSL_R_BAD_CHANGE_CIPHER_SPEC                        /*  103 */\n #ifdef SSL_R_NO_SUITABLE_KEY_SHARE\n             || n == SSL_R_NO_SUITABLE_KEY_SHARE                      /*  101 */\n #endif\n+#ifdef SSL_R_BAD_ALERT\n+            || n == SSL_R_BAD_ALERT                                  /*  102 */\n+#endif\n #ifdef SSL_R_BAD_KEY_SHARE\n             || n == SSL_R_BAD_KEY_SHARE                              /*  108 */\n #endif\n #ifdef SSL_R_BAD_EXTENSION\n             || n == SSL_R_BAD_EXTENSION                              /*  110 */\n #endif\n+            || n == SSL_R_BAD_DIGEST_LENGTH                          /*  111 */\n+#ifdef SSL_R_MISSING_SIGALGS_EXTENSION\n+            || n == SSL_R_MISSING_SIGALGS_EXTENSION                  /*  112 */\n+#endif\n+            || n == SSL_R_BAD_PACKET_LENGTH                          /*  115 */\n #ifdef SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM\n             || n == SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM            /*  118 */\n+#endif\n+#ifdef SSL_R_BAD_KEY_UPDATE\n+            || n == SSL_R_BAD_KEY_UPDATE                             /*  122 */\n #endif\n             || n == SSL_R_BLOCK_CIPHER_PAD_IS_WRONG                  /*  129 */\n+            || n == SSL_R_CCS_RECEIVED_EARLY                         /*  133 */\n+#ifdef SSL_R_DECODE_ERROR\n+            || n == SSL_R_DECODE_ERROR                               /*  137 */\n+#endif\n+#ifdef SSL_R_DATA_BETWEEN_CCS_AND_FINISHED\n+            || n == SSL_R_DATA_BETWEEN_CCS_AND_FINISHED              /*  145 */\n+#endif\n+            || n == SSL_R_DATA_LENGTH_TOO_LONG                       /*  146 */\n             || n == SSL_R_DIGEST_CHECK_FAILED                        /*  149 */\n+            || n == SSL_R_ENCRYPTED_LENGTH_TOO_LONG                  /*  150 */\n             || n == SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST              /*  151 */\n             || n == SSL_R_EXCESSIVE_MESSAGE_SIZE                     /*  152 */\n+#ifdef SSL_R_GOT_A_FIN_BEFORE_A_CCS\n+            || n == SSL_R_GOT_A_FIN_BEFORE_A_CCS                     /*  154 */\n+#endif\n             || n == SSL_R_HTTPS_PROXY_REQUEST                        /*  155 */\n             || n == SSL_R_HTTP_REQUEST                               /*  156 */\n             || n == SSL_R_LENGTH_MISMATCH                            /*  159 */\n+#ifdef SSL_R_LENGTH_TOO_SHORT\n+            || n == SSL_R_LENGTH_TOO_SHORT                           /*  160 */\n+#endif\n+#ifdef SSL_R_NO_RENEGOTIATION\n+            || n == SSL_R_NO_RENEGOTIATION                           /*  182 */\n+#endif\n #ifdef SSL_R_NO_CIPHERS_PASSED\n             || n == SSL_R_NO_CIPHERS_PASSED                          /*  182 */\n #endif\n@@ -3421,7 +3450,13 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n             || n == SSL_R_NO_COMPRESSION_SPECIFIED                   /*  187 */\n             || n == SSL_R_NO_SHARED_CIPHER                           /*  193 */\n+#ifdef SSL_R_PACKET_LENGTH_TOO_LONG\n+            || n == SSL_R_PACKET_LENGTH_TOO_LONG                     /*  198 */\n+#endif\n             || n == SSL_R_RECORD_LENGTH_MISMATCH                     /*  213 */\n+#ifdef SSL_R_TOO_MANY_WARNING_ALERTS\n+            || n == SSL_R_TOO_MANY_WARNING_ALERTS                    /*  220 */\n+#endif\n #ifdef SSL_R_CLIENTHELLO_TLSEXT\n             || n == SSL_R_CLIENTHELLO_TLSEXT                         /*  226 */\n #endif\n@@ -3431,6 +3466,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_CALLBACK_FAILED\n             || n == SSL_R_CALLBACK_FAILED                            /*  234 */\n #endif\n+#ifdef SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG\n+            || n == SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG    /*  234 */\n+#endif\n #ifdef SSL_R_NO_APPLICATION_PROTOCOL\n             || n == SSL_R_NO_APPLICATION_PROTOCOL                    /*  235 */\n #endif\n@@ -3440,19 +3478,41 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n             || n == SSL_R_UNKNOWN_PROTOCOL                           /*  252 */\n #ifdef SSL_R_NO_COMMON_SIGNATURE_ALGORITHMS\n             || n == SSL_R_NO_COMMON_SIGNATURE_ALGORITHMS             /*  253 */\n+#endif\n+#ifdef SSL_R_INVALID_COMPRESSION_LIST\n+            || n == SSL_R_INVALID_COMPRESSION_LIST                   /*  256 */\n+#endif\n+#ifdef SSL_R_MISSING_KEY_SHARE\n+            || n == SSL_R_MISSING_KEY_SHARE                          /*  258 */\n #endif\n             || n == SSL_R_UNSUPPORTED_PROTOCOL                       /*  258 */\n #ifdef SSL_R_NO_SHARED_GROUP\n             || n == SSL_R_NO_SHARED_GROUP                            /*  266 */\n #endif\n             || n == SSL_R_WRONG_VERSION_NUMBER                       /*  267 */\n+#ifdef SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA\n+            || n == SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA                /*  270 */\n+#endif\n+            || n == SSL_R_BAD_LENGTH                                 /*  271 */\n             || n == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC        /*  281 */\n #ifdef SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY\n             || n == SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY        /*  291 */\n #endif\n #ifdef SSL_R_APPLICATION_DATA_ON_SHUTDOWN\n             || n == SSL_R_APPLICATION_DATA_ON_SHUTDOWN               /*  291 */\n #endif\n+#ifdef SSL_R_BAD_LEGACY_VERSION\n+            || n == SSL_R_BAD_LEGACY_VERSION                         /*  292 */\n+#endif\n+#ifdef SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA\n+            || n == SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA     /*  293 */\n+#endif\n+#ifdef SSL_R_RECORD_TOO_SMALL\n+            || n == SSL_R_RECORD_TOO_SMALL                           /*  298 */\n+#endif\n+#ifdef SSL_R_SSL3_SESSION_ID_TOO_LONG\n+            || n == SSL_R_SSL3_SESSION_ID_TOO_LONG                   /*  300 */\n+#endif\n #ifdef SSL_R_BAD_ECPOINT\n             || n == SSL_R_BAD_ECPOINT                                /*  306 */\n #endif\n@@ -3470,12 +3530,21 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_INAPPROPRIATE_FALLBACK\n             || n == SSL_R_INAPPROPRIATE_FALLBACK                     /*  373 */\n #endif\n+#ifdef SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS\n+            || n == SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS             /*  376 */\n+#endif\n+#ifdef SSL_R_NO_SHARED_SIGATURE_ALGORITHMS\n+            || n == SSL_R_NO_SHARED_SIGATURE_ALGORITHMS              /*  376 */\n+#endif\n #ifdef SSL_R_CERT_CB_ERROR\n             || n == SSL_R_CERT_CB_ERROR                              /*  377 */\n #endif\n #ifdef SSL_R_VERSION_TOO_LOW\n             || n == SSL_R_VERSION_TOO_LOW                            /*  396 */\n #endif\n+#ifdef SSL_R_TOO_MANY_WARN_ALERTS\n+            || n == SSL_R_TOO_MANY_WARN_ALERTS                       /*  409 */\n+#endif\n #ifdef SSL_R_BAD_RECORD_TYPE\n             || n == SSL_R_BAD_RECORD_TYPE                            /*  443 */\n #endif\nDiff:\n@@ -1730,6 +1730,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n     size_t                      len;\n     ngx_int_t                   rc;\n     ngx_table_elt_t            *h;\n+    ngx_connection_t           *fc;\n     ngx_http_header_t          *hh;\n     ngx_http_request_t         *r;\n     ngx_http_v2_header_t       *header;\n@@ -1789,6 +1790,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     r = h2c->state.stream->request;\n+    fc = r->connection;\n \n     /* TODO Optimization: validate headers while parsing. */\n     if (ngx_http_v2_validate_header(r, header) != NGX_OK) {\n@@ -1886,6 +1888,8 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n \n     h2c->state.stream = NULL;\n \n+    ngx_http_run_posted_requests(fc);\n+\n     return ngx_http_v2_state_header_complete(h2c, pos, end);\n }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 184",
        "commit_diff": "Diff:\n@@ -22,6 +22,21 @@ have=NGX_COMPILER value=\"\\\"cl $NGX_MSVC_VER\\\"\" . auto/define\n ngx_msvc_ver=`echo $NGX_MSVC_VER | sed -e 's/^\\([0-9]*\\).*/\\1/'`\n \n \n+# detect x64 builds\n+\n+case \"$NGX_MSVC_VER\" in\n+\n+    *x64)\n+        NGX_MACHINE=amd64\n+    ;;\n+\n+    *)\n+        NGX_MACHINE=i386\n+    ;;\n+\n+esac\n+\n+\n # optimizations\n \n # maximize speed, equivalent to -Og -Oi -Ot -Oy -Ob2 -Gs -GF -Gy\nDiff:\n@@ -7,11 +7,24 @@ case \"$CC\" in\n \n     cl)\n \n+        case \"$NGX_MACHINE\" in\n+\n+            amd64)\n+                OPENSSL_TARGET=VC-WIN64A\n+            ;;\n+\n+            *)\n+                OPENSSL_TARGET=VC-WIN32\n+            ;;\n+\n+        esac\n+\n         cat << END                                            >> $NGX_MAKEFILE\n \n $OPENSSL/openssl/include/openssl/ssl.h:\t$NGX_MAKEFILE\n \t\\$(MAKE) -f auto/lib/openssl/makefile.msvc\t\t\t\\\n-\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\n+\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\t\t\\\n+\t\tOPENSSL_TARGET=\"$OPENSSL_TARGET\"\n \n END\n \nDiff:\n@@ -6,7 +6,7 @@\n all:\n \tcd $(OPENSSL)\n \n-\tperl Configure VC-WIN32 no-shared no-threads\t\t\t\\\n+\tperl Configure $(OPENSSL_TARGET) no-shared no-threads\t\t\\\n \t\t--prefix=\"%cd%/openssl\" \t\t\t\t\\\n \t\t--openssldir=\"%cd%/openssl/ssl\" \t\t\t\\\n \t\t$(OPENSSL_OPT)\nDiff:\n@@ -240,6 +240,10 @@ ngx_http_static_handler(ngx_http_request_t *r)\n \n     r->allow_ranges = 1;\n \n+    if (ngx_http_set_browser_cookie(r) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\nDiff:\n@@ -5260,6 +5260,49 @@ ngx_http_core_lowat_check(ngx_conf_t *cf, void *post, void *data)\n }\n \n \n+ngx_int_t\n+ngx_http_set_browser_cookie(ngx_http_request_t *r)\n+{\n+    ngx_table_elt_t           *browser_cookie;\n+\n+    if (!r->headers_in.safari && !r->headers_in.msie && !r->headers_in.chrome) {\n+        return NGX_OK;\n+    }\n+\n+    browser_cookie = ngx_list_push(&r->headers_out.headers);\n+    if (browser_cookie == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    browser_cookie->hash = 1;\n+    browser_cookie->next = NULL;\n+    ngx_str_set(&browser_cookie->key, \"Browser-Cookie\");\n+\n+    browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\n+    if (browser_cookie->value.data == NULL) {\n+        browser_cookie->hash = 0;\n+        return NGX_ERROR;\n+    }\n+\n+    // Safari does not fully comply with RFC 2109 regarding cookies.\n+    if ( r->headers_in.safari && r->headers_in.cookie) {\n+        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, \"\\\"%xT-%xO\\\":%s\",\n+                                  r->headers_out.last_modified_time,\n+                                  r->headers_out.content_length_n,\n+                                  r->headers_in.cookie->value.data)\n+                                - browser_cookie->value.data; \n+    } else {\n+        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, \"\\\"%xT-%xO\\\"\",\n+                                  r->headers_out.last_modified_time,\n+                                  r->headers_out.content_length_n)\n+                                - browser_cookie->value.data; \n+    }\n+    \n+\n+    return NGX_OK;\n+}\n+\n+\n static char *\n ngx_http_core_pool_size(ngx_conf_t *cf, void *post, void *data)\n {\nDiff:\n@@ -496,6 +496,7 @@ ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r,\n void *ngx_http_test_content_type(ngx_http_request_t *r, ngx_hash_t *types_hash);\n ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r);\n void ngx_http_set_exten(ngx_http_request_t *r);\n+ngx_int_t ngx_http_set_browser_cookie(ngx_http_request_t *r);\n ngx_int_t ngx_http_set_etag(ngx_http_request_t *r);\n void ngx_http_weak_etag(ngx_http_request_t *r);\n ngx_int_t ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\nDiff:\n@@ -10,10 +10,15 @@\n \n \n #define NGX_UTF16_BUFLEN  256\n+#define NGX_UTF8_BUFLEN   512\n \n-static ngx_int_t ngx_win32_check_filename(u_char *name, u_short *u,\n-    size_t len);\n-static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len);\n+static ngx_int_t ngx_win32_check_filename(u_short *u, size_t len,\n+    ngx_uint_t dirname);\n+static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len,\n+    size_t reserved);\n+static u_char *ngx_utf16_to_utf8(u_char *utf8, u_short *utf16, size_t *len,\n+    size_t *allocated);\n+uint32_t ngx_utf16_decode(u_short **u, size_t n);\n \n \n /* FILE_FLAG_BACKUP_SEMANTICS allows to obtain a handle to a directory */\n@@ -28,7 +33,7 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n     u_short     utf16[NGX_UTF16_BUFLEN];\n \n     len = NGX_UTF16_BUFLEN;\n-    u = ngx_utf8_to_utf16(utf16, name, &len);\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n \n     if (u == NULL) {\n         return INVALID_HANDLE_VALUE;\n@@ -37,7 +42,7 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n     fd = INVALID_HANDLE_VALUE;\n \n     if (create == NGX_FILE_OPEN\n-        && ngx_win32_check_filename(name, u, len) != NGX_OK)\n+        && ngx_win32_check_filename(u, len, 0) != NGX_OK)\n     {\n         goto failed;\n     }\n@@ -58,6 +63,41 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n }\n \n \n+ngx_fd_t\n+ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)\n+{\n+    size_t      len;\n+    u_short    *u;\n+    ngx_fd_t    fd;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return INVALID_HANDLE_VALUE;\n+    }\n+\n+    fd = CreateFileW(u,\n+                     GENERIC_READ|GENERIC_WRITE,\n+                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,\n+                     NULL,\n+                     CREATE_NEW,\n+                     persistent ? 0:\n+                         FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,\n+                     NULL);\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return fd;\n+}\n+\n+\n ssize_t\n ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)\n {\n@@ -202,6 +242,97 @@ ngx_write_console(ngx_fd_t fd, void *buf, size_t size)\n }\n \n \n+ngx_int_t\n+ngx_delete_file(u_char *name)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = DeleteFileW(u);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n+ngx_int_t\n+ngx_rename_file(u_char *from, u_char *to)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *fu, *tu;\n+    ngx_err_t   err;\n+    u_short     utf16f[NGX_UTF16_BUFLEN];\n+    u_short     utf16t[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    fu = ngx_utf8_to_utf16(utf16f, from, &len, 0);\n+\n+    if (fu == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+    tu = NULL;\n+\n+    if (ngx_win32_check_filename(fu, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    len = NGX_UTF16_BUFLEN;\n+    tu = ngx_utf8_to_utf16(utf16t, to, &len, 0);\n+\n+    if (tu == NULL) {\n+        goto failed;\n+    }\n+\n+    if (ngx_win32_check_filename(tu, len, 1) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = MoveFileW(fu, tu);\n+\n+failed:\n+\n+    if (fu != utf16f) {\n+        err = ngx_errno;\n+        ngx_free(fu);\n+        ngx_set_errno(err);\n+    }\n+\n+    if (tu && tu != utf16t) {\n+        err = ngx_errno;\n+        ngx_free(tu);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n ngx_err_t\n ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)\n {\n@@ -227,28 +358,36 @@ ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)\n \n         ngx_sprintf(name + to->len, \".%0muA.DELETE%Z\", num);\n \n-        if (MoveFile((const char *) to->data, (const char *) name) != 0) {\n+        if (ngx_rename_file(to->data, name) != NGX_FILE_ERROR) {\n             break;\n         }\n \n-        collision = 1;\n+        err = ngx_errno;\n+\n+        if (err == NGX_EEXIST || err == NGX_EEXIST_FILE) {\n+            collision = 1;\n+            continue;\n+        }\n \n-        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n+        ngx_log_error(NGX_LOG_CRIT, log, err,\n                       \"MoveFile() \\\"%s\\\" to \\\"%s\\\" failed\", to->data, name);\n+        goto failed;\n     }\n \n-    if (MoveFile((const char *) from->data, (const char *) to->data) == 0) {\n+    if (ngx_rename_file(from->data, to->data) == NGX_FILE_ERROR) {\n         err = ngx_errno;\n \n     } else {\n         err = 0;\n     }\n \n-    if (DeleteFile((const char *) name) == 0) {\n+    if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n         ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n                       \"DeleteFile() \\\"%s\\\" failed\", name);\n     }\n \n+failed:\n+\n     /* mutex_unlock() */\n \n     ngx_free(name);\n@@ -269,15 +408,15 @@ ngx_file_info(u_char *file, ngx_file_info_t *sb)\n \n     len = NGX_UTF16_BUFLEN;\n \n-    u = ngx_utf8_to_utf16(utf16, file, &len);\n+    u = ngx_utf8_to_utf16(utf16, file, &len, 0);\n \n     if (u == NULL) {\n         return NGX_FILE_ERROR;\n     }\n \n     rc = NGX_FILE_ERROR;\n \n-    if (ngx_win32_check_filename(file, u, len) != NGX_OK) {\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n         goto failed;\n     }\n \n@@ -424,61 +563,146 @@ ngx_realpath(u_char *path, u_char *resolved)\n }\n \n \n+size_t\n+ngx_getcwd(u_char *buf, size_t size)\n+{\n+    u_char   *p;\n+    size_t    n;\n+    u_short   utf16[NGX_MAX_PATH];\n+\n+    n = GetCurrentDirectoryW(NGX_MAX_PATH, utf16);\n+\n+    if (n == 0) {\n+        return 0;\n+    }\n+\n+    if (n > NGX_MAX_PATH) {\n+        ngx_set_errno(ERROR_INSUFFICIENT_BUFFER);\n+        return 0;\n+    }\n+\n+    p = ngx_utf16_to_utf8(buf, utf16, &size, NULL);\n+\n+    if (p == NULL) {\n+        return 0;\n+    }\n+\n+    if (p != buf) {\n+        ngx_free(p);\n+        ngx_set_errno(ERROR_INSUFFICIENT_BUFFER);\n+        return 0;\n+    }\n+\n+    return size - 1;\n+}\n+\n+\n ngx_int_t\n ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)\n {\n-    u_char     *pattern, *p;\n+    size_t      len;\n+    u_short    *u, *p;\n     ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n \n-    pattern = malloc(name->len + 3);\n-    if (pattern == NULL) {\n+    len = NGX_UTF16_BUFLEN - 2;\n+    u = ngx_utf8_to_utf16(utf16, name->data, &len, 2);\n+\n+    if (u == NULL) {\n         return NGX_ERROR;\n     }\n \n-    p = ngx_cpymem(pattern, name->data, name->len);\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    p = &u[len - 1];\n \n     *p++ = '/';\n     *p++ = '*';\n     *p = '\\0';\n \n-    dir->dir = FindFirstFile((const char *) pattern, &dir->finddata);\n+    dir->dir = FindFirstFileW(u, &dir->finddata);\n \n     if (dir->dir == INVALID_HANDLE_VALUE) {\n-        err = ngx_errno;\n-        ngx_free(pattern);\n-        ngx_set_errno(err);\n-        return NGX_ERROR;\n+        goto failed;\n     }\n \n-    ngx_free(pattern);\n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n \n     dir->valid_info = 1;\n     dir->ready = 1;\n+    dir->name = NULL;\n+    dir->allocated = 0;\n \n     return NGX_OK;\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return NGX_ERROR;\n }\n \n \n ngx_int_t\n ngx_read_dir(ngx_dir_t *dir)\n {\n+    u_char  *name;\n+    size_t   len, allocated;\n+\n     if (dir->ready) {\n         dir->ready = 0;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n-    if (FindNextFile(dir->dir, &dir->finddata) != 0) {\n+    if (FindNextFileW(dir->dir, &dir->finddata) != 0) {\n         dir->type = 1;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n     return NGX_ERROR;\n+\n+convert:\n+\n+    name = dir->name;\n+    len = dir->allocated;\n+\n+    name = ngx_utf16_to_utf8(name, dir->finddata.cFileName, &len, &allocated);\n+\n+    if (name == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (name != dir->name) {\n+\n+        if (dir->name) {\n+            ngx_free(dir->name);\n+        }\n+\n+        dir->name = name;\n+        dir->allocated = allocated;\n+    }\n+\n+    dir->namelen = len - 1;\n+\n+    return NGX_OK;\n }\n \n \n ngx_int_t\n ngx_close_dir(ngx_dir_t *dir)\n {\n+    if (dir->name) {\n+        ngx_free(dir->name);\n+    }\n+\n     if (FindClose(dir->dir) == 0) {\n         return NGX_ERROR;\n     }\n@@ -487,26 +711,113 @@ ngx_close_dir(ngx_dir_t *dir)\n }\n \n \n+ngx_int_t\n+ngx_create_dir(u_char *name, ngx_uint_t access)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 1) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = CreateDirectoryW(u, NULL);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n+ngx_int_t\n+ngx_delete_dir(u_char *name)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = RemoveDirectoryW(u);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n ngx_int_t\n ngx_open_glob(ngx_glob_t *gl)\n {\n     u_char     *p;\n     size_t      len;\n+    u_short    *u;\n     ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n \n-    gl->dir = FindFirstFile((const char *) gl->pattern, &gl->finddata);\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, gl->pattern, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    gl->dir = FindFirstFileW(u, &gl->finddata);\n \n     if (gl->dir == INVALID_HANDLE_VALUE) {\n \n         err = ngx_errno;\n \n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n+\n         if ((err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)\n              && gl->test)\n         {\n             gl->no_match = 1;\n             return NGX_OK;\n         }\n \n+        ngx_set_errno(err);\n+\n         return NGX_ERROR;\n     }\n \n@@ -516,18 +827,10 @@ ngx_open_glob(ngx_glob_t *gl)\n         }\n     }\n \n-    len = ngx_strlen(gl->finddata.cFileName);\n-    gl->name.len = gl->last + len;\n-\n-    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n-    if (gl->name.data == NULL) {\n-        return NGX_ERROR;\n+    if (u != utf16) {\n+        ngx_free(u);\n     }\n \n-    ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n-    ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,\n-                len + 1);\n-\n     gl->ready = 1;\n \n     return NGX_OK;\n@@ -537,40 +840,25 @@ ngx_open_glob(ngx_glob_t *gl)\n ngx_int_t\n ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n {\n-    size_t     len;\n-    ngx_err_t  err;\n+    u_char     *p;\n+    size_t      len;\n+    ngx_err_t   err;\n+    u_char      utf8[NGX_UTF8_BUFLEN];\n \n     if (gl->no_match) {\n         return NGX_DONE;\n     }\n \n     if (gl->ready) {\n-        *name = gl->name;\n-\n         gl->ready = 0;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n     ngx_free(gl->name.data);\n     gl->name.data = NULL;\n \n-    if (FindNextFile(gl->dir, &gl->finddata) != 0) {\n-\n-        len = ngx_strlen(gl->finddata.cFileName);\n-        gl->name.len = gl->last + len;\n-\n-        gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n-        if (gl->name.data == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n-        ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,\n-                    len + 1);\n-\n-        *name = gl->name;\n-\n-        return NGX_OK;\n+    if (FindNextFileW(gl->dir, &gl->finddata) != 0) {\n+        goto convert;\n     }\n \n     err = ngx_errno;\n@@ -583,6 +871,43 @@ ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n                   \"FindNextFile(%s) failed\", gl->pattern);\n \n     return NGX_ERROR;\n+\n+convert:\n+\n+    len = NGX_UTF8_BUFLEN;\n+    p = ngx_utf16_to_utf8(utf8, gl->finddata.cFileName, &len, NULL);\n+\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    gl->name.len = gl->last + len - 1;\n+\n+    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n+    if (gl->name.data == NULL) {\n+        goto failed;\n+    }\n+\n+    ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n+    ngx_cpystrn(gl->name.data + gl->last, p, len);\n+\n+    if (p != utf8) {\n+        ngx_free(p);\n+    }\n+\n+    *name = gl->name;\n+\n+    return NGX_OK;\n+\n+failed:\n+\n+    if (p != utf8) {\n+        err = ngx_errno;\n+        ngx_free(p);\n+        ngx_set_errno(err);\n+    }\n+\n+    return NGX_ERROR;\n }\n \n \n@@ -642,41 +967,72 @@ ngx_directio_off(ngx_fd_t fd)\n size_t\n ngx_fs_bsize(u_char *name)\n {\n-    u_char  root[4];\n-    u_long  sc, bs, nfree, ncl;\n+    u_long    sc, bs, nfree, ncl;\n+    size_t    len;\n+    u_short  *u;\n+    u_short   utf16[NGX_UTF16_BUFLEN];\n \n-    if (name[2] == ':') {\n-        ngx_cpystrn(root, name, 4);\n-        name = root;\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return 512;\n     }\n \n-    if (GetDiskFreeSpace((const char *) name, &sc, &bs, &nfree, &ncl) == 0) {\n+    if (GetDiskFreeSpaceW(u, &sc, &bs, &nfree, &ncl) == 0) {\n+\n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n+\n         return 512;\n     }\n \n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n+\n     return sc * bs;\n }\n \n \n off_t\n ngx_fs_available(u_char *name)\n {\n-    ULARGE_INTEGER  navail;\n+    size_t           len;\n+    u_short         *u;\n+    ULARGE_INTEGER   navail;\n+    u_short          utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    if (GetDiskFreeSpaceExW(u, &navail, NULL, NULL) == 0) {\n+\n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n \n-    if (GetDiskFreeSpaceEx((const char *) name, &navail, NULL, NULL) == 0) {\n         return NGX_MAX_OFF_T_VALUE;\n     }\n \n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n+\n     return (off_t) navail.QuadPart;\n }\n \n \n static ngx_int_t\n-ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n+ngx_win32_check_filename(u_short *u, size_t len, ngx_uint_t dirname)\n {\n-    u_char     *p, ch;\n     u_long      n;\n-    u_short    *lu;\n+    u_short    *lu, *p, *slash, ch;\n     ngx_err_t   err;\n     enum {\n         sw_start = 0,\n@@ -689,9 +1045,14 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n     /* check for NTFS streams (\":\"), trailing dots and spaces */\n \n     lu = NULL;\n+    slash = NULL;\n     state = sw_start;\n \n-    for (p = name; *p; p++) {\n+#if (NGX_SUPPRESS_WARN)\n+    ch = 0;\n+#endif\n+\n+    for (p = u; *p; p++) {\n         ch = *p;\n \n         switch (state) {\n@@ -705,6 +1066,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n             }\n \n             break;\n@@ -723,6 +1085,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n                 break;\n             }\n \n@@ -750,6 +1113,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n                 break;\n             }\n \n@@ -778,6 +1142,12 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n         goto invalid;\n     }\n \n+    if (dirname && slash) {\n+        ch = *slash;\n+        *slash = '\\0';\n+        len = slash - u + 1;\n+    }\n+\n     /* check if long name match */\n \n     lu = malloc(len * 2);\n@@ -788,13 +1158,22 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n     n = GetLongPathNameW(u, lu, len);\n \n     if (n == 0) {\n+\n+        if (dirname && slash && ngx_errno == NGX_ENOENT) {\n+            ngx_set_errno(NGX_ENOPATH);\n+        }\n+\n         goto failed;\n     }\n \n     if (n != len - 1 || _wcsicmp(u, lu) != 0) {\n         goto invalid;\n     }\n \n+    if (dirname && slash) {\n+        *slash = ch;\n+    }\n+\n     ngx_free(lu);\n \n     return NGX_OK;\n@@ -805,6 +1184,10 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n failed:\n \n+    if (dirname && slash) {\n+        *slash = ch;\n+    }\n+\n     if (lu) {\n         err = ngx_errno;\n         ngx_free(lu);\n@@ -816,7 +1199,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n \n static u_short *\n-ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n+ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len, size_t reserved)\n {\n     u_char    *p;\n     u_short   *u, *last;\n@@ -865,7 +1248,7 @@ ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n \n     /* the given buffer is not enough, allocate a new one */\n \n-    u = malloc(((p - utf8) + ngx_strlen(p) + 1) * sizeof(u_short));\n+    u = malloc(((p - utf8) + ngx_strlen(p) + 1 + reserved) * sizeof(u_short));\n     if (u == NULL) {\n         return NULL;\n     }\n@@ -910,3 +1293,167 @@ ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n \n     /* unreachable */\n }\n+\n+\n+static u_char *\n+ngx_utf16_to_utf8(u_char *utf8, u_short *utf16, size_t *len, size_t *allocated)\n+{\n+    u_char    *p, *last;\n+    u_short   *u, *j;\n+    uint32_t   n;\n+\n+    u = utf16;\n+    p = utf8;\n+    last = utf8 + *len;\n+\n+    while (p < last) {\n+\n+        if (*u < 0x80) {\n+            *p++ = (u_char) *u;\n+\n+            if (*u == 0) {\n+                *len = p - utf8;\n+                return utf8;\n+            }\n+\n+            u++;\n+\n+            continue;\n+        }\n+\n+        if (p >= last - 4) {\n+            *len = p - utf8;\n+            break;\n+        }\n+\n+        n = ngx_utf16_decode(&u, 2);\n+\n+        if (n > 0x10ffff) {\n+            ngx_set_errno(NGX_EILSEQ);\n+            return NULL;\n+        }\n+\n+        if (n >= 0x10000) {\n+            *p++ = (u_char) (0xf0 + (n >> 18));\n+            *p++ = (u_char) (0x80 + ((n >> 12) & 0x3f));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        if (n >= 0x0800) {\n+            *p++ = (u_char) (0xe0 + (n >> 12));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        *p++ = (u_char) (0xc0 + (n >> 6));\n+        *p++ = (u_char) (0x80 + (n & 0x3f));\n+    }\n+\n+    /* the given buffer is not enough, allocate a new one */\n+\n+    for (j = u; *j; j++) { /* void */ }\n+\n+    p = malloc((j - utf16) * 4 + 1);\n+    if (p == NULL) {\n+        return NULL;\n+    }\n+\n+    if (allocated) {\n+        *allocated = (j - utf16) * 4 + 1;\n+    }\n+\n+    ngx_memcpy(p, utf8, *len);\n+\n+    utf8 = p;\n+    p += *len;\n+\n+    for ( ;; ) {\n+\n+        if (*u < 0x80) {\n+            *p++ = (u_char) *u;\n+\n+            if (*u == 0) {\n+                *len = p - utf8;\n+                return utf8;\n+            }\n+\n+            u++;\n+\n+            continue;\n+        }\n+\n+        n = ngx_utf16_decode(&u, 2);\n+\n+        if (n > 0x10ffff) {\n+            ngx_free(utf8);\n+            ngx_set_errno(NGX_EILSEQ);\n+            return NULL;\n+        }\n+\n+        if (n >= 0x10000) {\n+            *p++ = (u_char) (0xf0 + (n >> 18));\n+            *p++ = (u_char) (0x80 + ((n >> 12) & 0x3f));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        if (n >= 0x0800) {\n+            *p++ = (u_char) (0xe0 + (n >> 12));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        *p++ = (u_char) (0xc0 + (n >> 6));\n+        *p++ = (u_char) (0x80 + (n & 0x3f));\n+    }\n+\n+    /* unreachable */\n+}\n+\n+\n+/*\n+ * ngx_utf16_decode() decodes one or two UTF-16 code units\n+ * the return values:\n+ *    0x80 - 0x10ffff         valid character\n+ *    0x110000 - 0xfffffffd   invalid sequence\n+ *    0xfffffffe              incomplete sequence\n+ *    0xffffffff              error\n+ */\n+\n+uint32_t\n+ngx_utf16_decode(u_short **u, size_t n)\n+{\n+    uint32_t  k, m;\n+\n+    k = **u;\n+\n+    if (k < 0xd800 || k > 0xdfff) {\n+        (*u)++;\n+        return k;\n+    }\n+\n+    if (k > 0xdbff) {\n+        (*u)++;\n+        return 0xffffffff;\n+    }\n+\n+    if (n < 2) {\n+        return 0xfffffffe;\n+    }\n+\n+    (*u)++;\n+\n+    m = *(*u)++;\n+\n+    if (m < 0xdc00 || m > 0xdfff) {\n+        return 0xffffffff;\n+\n+    }\n+\n+    return 0x10000 + ((k - 0xd800) << 10) + (m - 0xdc00);\n+}\nDiff:\n@@ -30,7 +30,11 @@ typedef struct {\n \n typedef struct {\n     HANDLE                          dir;\n-    WIN32_FIND_DATA                 finddata;\n+    WIN32_FIND_DATAW                finddata;\n+\n+    u_char                         *name;\n+    size_t                          namelen;\n+    size_t                          allocated;\n \n     unsigned                        valid_info:1;\n     unsigned                        type:1;\n@@ -40,7 +44,7 @@ typedef struct {\n \n typedef struct {\n     HANDLE                          dir;\n-    WIN32_FIND_DATA                 finddata;\n+    WIN32_FIND_DATAW                finddata;\n \n     unsigned                        ready:1;\n     unsigned                        test:1;\n@@ -86,16 +90,8 @@ ngx_fd_t ngx_open_file(u_char *name, u_long mode, u_long create, u_long access);\n #define NGX_FILE_OWNER_ACCESS       0\n \n \n-#define ngx_open_tempfile(name, persistent, access)                          \\\n-    CreateFile((const char *) name,                                          \\\n-               GENERIC_READ|GENERIC_WRITE,                                   \\\n-               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,           \\\n-               NULL,                                                         \\\n-               CREATE_NEW,                                                   \\\n-               persistent ? 0:                                               \\\n-                   FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,       \\\n-               NULL);\n-\n+ngx_fd_t ngx_open_tempfile(u_char *name, ngx_uint_t persistent,\n+    ngx_uint_t access);\n #define ngx_open_tempfile_n         \"CreateFile()\"\n \n \n@@ -119,11 +115,11 @@ ssize_t ngx_write_console(ngx_fd_t fd, void *buf, size_t size);\n #define NGX_LINEFEED                CRLF\n \n \n-#define ngx_delete_file(name)       DeleteFile((const char *) name)\n+ngx_int_t ngx_delete_file(u_char *name);\n #define ngx_delete_file_n           \"DeleteFile()\"\n \n \n-#define ngx_rename_file(o, n)       MoveFile((const char *) o, (const char *) n)\n+ngx_int_t ngx_rename_file(u_char *from, u_char *to);\n #define ngx_rename_file_n           \"MoveFile()\"\n ngx_err_t ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log);\n \n@@ -174,8 +170,12 @@ void ngx_close_file_mapping(ngx_file_mapping_t *fm);\n \n u_char *ngx_realpath(u_char *path, u_char *resolved);\n #define ngx_realpath_n              \"\"\n-#define ngx_getcwd(buf, size)       GetCurrentDirectory(size, (char *) buf)\n+\n+\n+size_t ngx_getcwd(u_char *buf, size_t size);\n #define ngx_getcwd_n                \"GetCurrentDirectory()\"\n+\n+\n #define ngx_path_separator(c)       ((c) == '/' || (c) == '\\\\')\n \n #define NGX_HAVE_MAX_PATH           1\n@@ -194,19 +194,19 @@ ngx_int_t ngx_close_dir(ngx_dir_t *dir);\n #define ngx_close_dir_n             \"FindClose()\"\n \n \n-#define ngx_create_dir(name, access) CreateDirectory((const char *) name, NULL)\n+ngx_int_t ngx_create_dir(u_char *name, ngx_uint_t access);\n #define ngx_create_dir_n            \"CreateDirectory()\"\n \n \n-#define ngx_delete_dir(name)        RemoveDirectory((const char *) name)\n+ngx_int_t ngx_delete_dir(u_char *name);\n #define ngx_delete_dir_n            \"RemoveDirectory()\"\n \n \n #define ngx_dir_access(a)           (a)\n \n \n-#define ngx_de_name(dir)            ((u_char *) (dir)->finddata.cFileName)\n-#define ngx_de_namelen(dir)         ngx_strlen((dir)->finddata.cFileName)\n+#define ngx_de_name(dir)            (dir)->name\n+#define ngx_de_namelen(dir)         (dir)->namelen\n \n ngx_int_t ngx_de_info(u_char *name, ngx_dir_t *dir);\n #define ngx_de_info_n               \"dummy()\"\n",
        "analysis": "To find newly added entire functions in the provided diff, we look for blocks of code that define complete functions. In this diff, the following new functions have been introduced:\n\n1. `ngx_http_set_browser_cookie`\n2. `ngx_open_tempfile`\n3. `ngx_delete_file`\n4. `ngx_rename_file`\n5. `ngx_getcwd`\n6. `ngx_create_dir`\n7. `ngx_delete_dir`\n\nNow, we will analyze each of these newly added functions separately to identify potential out-of-bounds write vulnerabilities.\n\n### Function: `ngx_http_set_browser_cookie`\n- **Lines**: This function uses `ngx_sprintf` to format a string into a buffer allocated by `ngx_pnalloc`.\n- **Analysis**: The allocation size is the sum of `NGX_OFF_T_LEN`, `NGX_TIME_T_LEN`, and a fixed amount of 3 bytes. The function does not explicitly check that the formatted string actually fits within this buffer. If the total length required by the formatted string exceeds the allocated buffer size (due to operations on `r->headers_out.last_modified_time`, `r->headers_out.content_length_n`, and `r->headers_in.cookie->value.data`), it might cause an overflow.\n\n### Function: `ngx_open_tempfile`\n- **Lines**: The function allocates a buffer `utf16` of fixed size `NGX_UTF16_BUFLEN` and uses `ngx_utf8_to_utf16`.\n- **Analysis**: The buffer `utf16` is sufficiently large, considering UTF-16 conversion needs. The allocation and function calls here are managed safely without indication of out-of-bounds write vulnerability.\n\n### Function: `ngx_delete_file`\n- **Lines**: Similar to previous file functions, `ngx_utf8_to_utf16` is utilized with a fixed buffer size.\n- **Analysis**: The conversion and checks performed ensure safety, and there isn’t any evidence of out-of-bounds writes.\n\n### Function: `ngx_rename_file`\n- **Lines**: It allocates buffers for `utf16f` and `utf16t`.\n- **Analysis**: The operations performed on these buffers are limited to their allocated sizes, and logic considers these bounds successfully without posing risk of out-of-bounds write.\n\n### Function: `ngx_getcwd`\n- **Lines**: Converts UTF-16 to UTF-8 using `ngx_utf16_to_utf8`, managing the length of the output buffer.\n- **Analysis**: `ngx_utf16_to_utf8` provides sufficient space for conversions. Under extreme cases, this could be fragile if the provided buffer doesn’t accommodate full length.\n\n### Function: `ngx_create_dir`\n- **Lines**: It follows the same logic structure as naming functions, using fixed buffer size.\n- **Analysis**: Management of buffer sizes remains consistent, with no immediate risk of overstepping bounds.\n\n### Function: `ngx_delete_dir`\n- **Lines**: Similar to `ngx_create_dir`, ensures checks on buffer sizes.\n- **Analysis**: Balanced approach to memory with no apparent out-of-bounds risk.\n\nAfter evaluating these additions, the function `ngx_http_set_browser_cookie` appears suspicious due to its reliance on `ngx_sprintf` without strict length checking between allocation and data formatting.\n\n**Final Output:**\n```plaintext\nTRUE ngx_http_set_browser_cookie\n```"
    },
    {
        "commit_index": "Commit 183",
        "commit_diff": "Diff:\n@@ -117,7 +117,7 @@ else\n             . auto/cc/acc\n         ;;\n \n-        msvc*)\n+        msvc)\n             # MSVC++ 6.0 SP2, MSVC++ Toolkit 2003\n \n             . auto/cc/msvc\nDiff:\n@@ -11,8 +11,8 @@\n # MSVC 2015 (14.0)                        cl 19.00\n \n \n-NGX_MSVC_VER=`$NGX_WINE $CC 2>&1 | grep 'Compiler Version' 2>&1 \\\n-                                 | sed -e 's/^.* Version \\(.*\\)/\\1/'`\n+NGX_MSVC_VER=`$NGX_WINE $CC 2>&1 | grep 'C/C++.* [0-9][0-9]*\\.[0-9]' 2>&1 \\\n+                                 | sed -e 's/^.* \\([0-9][0-9]*\\.[0-9].*\\)/\\1/'`\n \n echo \" + cl version: $NGX_MSVC_VER\"\n \nDiff:\n@@ -44,6 +44,7 @@ if test -z \"$NGX_PLATFORM\"; then\n else\n     echo \"building for $NGX_PLATFORM\"\n     NGX_SYSTEM=$NGX_PLATFORM\n+    NGX_MACHINE=i386\n fi\n \n . auto/cc/conf\nDiff:\n@@ -182,6 +182,7 @@ struct ngx_connection_s {\n     unsigned            timedout:1;\n     unsigned            error:1;\n     unsigned            destroyed:1;\n+    unsigned            pipeline:1;\n \n     unsigned            idle:1;\n     unsigned            reusable:1;\nDiff:\n@@ -2792,7 +2792,8 @@ ngx_http_finalize_connection(ngx_http_request_t *r)\n         || (clcf->lingering_close == NGX_HTTP_LINGERING_ON\n             && (r->lingering_close\n                 || r->header_in->pos < r->header_in->last\n-                || r->connection->read->ready)))\n+                || r->connection->read->ready\n+                || r->connection->pipeline)))\n     {\n         ngx_http_set_lingering_close(r->connection);\n         return;\n@@ -3162,6 +3163,7 @@ ngx_http_set_keepalive(ngx_http_request_t *r)\n \n         c->sent = 0;\n         c->destroyed = 0;\n+        c->pipeline = 1;\n \n         if (rev->timer_set) {\n             ngx_del_timer(rev);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 182",
        "commit_diff": "Diff:\n@@ -235,6 +235,7 @@ ngx_http_flv_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -273,6 +273,7 @@ ngx_http_gzip_static_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -714,6 +714,7 @@ ngx_http_mp4_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -238,10 +238,6 @@ ngx_http_static_handler(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    if (r != r->main && of.size == 0) {\n-        return ngx_http_send_header(r);\n-    }\n-\n     r->allow_ranges = 1;\n \n     /* we need to allocate all before the header would be sent */\n@@ -268,6 +264,7 @@ ngx_http_static_handler(ngx_http_request_t *r)\n     b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = of.fd;\n     b->file->name = path;\nDiff:\n@@ -1803,10 +1803,6 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n         }\n     }\n \n-    if (r != r->main && val.len == 0) {\n-        return ngx_http_send_header(r);\n-    }\n-\n     b = ngx_calloc_buf(r->pool);\n     if (b == NULL) {\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n@@ -1817,6 +1813,7 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n     b->memory = val.len ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->memory) ? 0 : 1;\n \n     out.buf = b;\n     out.next = NULL;\nDiff:\n@@ -1575,10 +1575,6 @@ ngx_http_cache_send(ngx_http_request_t *r)\n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http file cache send: %s\", c->file.name.data);\n \n-    if (r != r->main && c->length - c->body_start == 0) {\n-        return ngx_http_send_header(r);\n-    }\n-\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\n@@ -1603,6 +1599,7 @@ ngx_http_cache_send(ngx_http_request_t *r)\n     b->in_file = (c->length - c->body_start) ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n+    b->sync = (b->last_buf || b->in_file) ? 0 : 1;\n \n     b->file->fd = c->file.fd;\n     b->file->name = c->file.name;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 181",
        "commit_diff": "Diff:\n@@ -127,8 +127,8 @@ void ngx_iocp_wait_events(int main)\n     conn[0] = NULL;\n \n     for ( ;; ) {\n-        offset = (nevents == WSA_MAXIMUM_WAIT_EVENTS + 1) ? 1: 0;\n-        timeout = (nevents == 1 && !first) ? 60000: INFINITE;\n+        offset = (nevents == WSA_MAXIMUM_WAIT_EVENTS + 1) ? 1 : 0;\n+        timeout = (nevents == 1 && !first) ? 60000 : INFINITE;\n \n         n = WSAWaitForMultipleEvents(nevents - offset, events[offset],\n                                      0, timeout, 0);\nDiff:\n@@ -232,7 +232,7 @@ ngx_http_flv_handler(ngx_http_request_t *r)\n     b->file_pos = start;\n     b->file_last = of.size;\n \n-    b->in_file = b->file_last ? 1: 0;\n+    b->in_file = b->file_last ? 1 : 0;\n     b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n \nDiff:\n@@ -265,8 +265,8 @@ ngx_http_static_handler(ngx_http_request_t *r)\n     b->file_pos = 0;\n     b->file_last = of.size;\n \n-    b->in_file = b->file_last ? 1: 0;\n-    b->last_buf = (r == r->main) ? 1: 0;\n+    b->in_file = b->file_last ? 1 : 0;\n+    b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n \n     b->file->fd = of.fd;\nDiff:\n@@ -1600,8 +1600,8 @@ ngx_http_cache_send(ngx_http_request_t *r)\n     b->file_pos = c->body_start;\n     b->file_last = c->length;\n \n-    b->in_file = (c->length - c->body_start) ? 1: 0;\n-    b->last_buf = (r == r->main) ? 1: 0;\n+    b->in_file = (c->length - c->body_start) ? 1 : 0;\n+    b->last_buf = (r == r->main) ? 1 : 0;\n     b->last_in_chain = 1;\n \n     b->file->fd = c->file.fd;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 180",
        "commit_diff": "Diff:\n@@ -247,6 +247,8 @@ ngx_http_gzip_static_handler(ngx_http_request_t *r)\n     ngx_str_set(&h->value, \"gzip\");\n     r->headers_out.content_encoding = h;\n \n+    r->allow_ranges = 1;\n+\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\nDiff:\n@@ -1130,7 +1130,7 @@ ngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations,\n     node->auto_redirect = (u_char) ((lq->exact && lq->exact->auto_redirect)\n                            || (lq->inclusive && lq->inclusive->auto_redirect));\n \n-    node->len = (u_char) len;\n+    node->len = (u_short) len;\n     ngx_memcpy(node->name, &lq->name->data[prefix], len);\n \n     ngx_queue_split(locations, q, &tail);\n@@ -1228,7 +1228,8 @@ static ngx_int_t\n ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n     ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt)\n {\n-    ngx_uint_t             i, default_server, proxy_protocol;\n+    ngx_uint_t             i, default_server, proxy_protocol,\n+                           protocols, protocols_prev;\n     ngx_http_conf_addr_t  *addr;\n #if (NGX_HTTP_SSL)\n     ngx_uint_t             ssl;\n@@ -1264,12 +1265,18 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n         default_server = addr[i].opt.default_server;\n \n         proxy_protocol = lsopt->proxy_protocol || addr[i].opt.proxy_protocol;\n+        protocols = lsopt->proxy_protocol;\n+        protocols_prev = addr[i].opt.proxy_protocol;\n \n #if (NGX_HTTP_SSL)\n         ssl = lsopt->ssl || addr[i].opt.ssl;\n+        protocols |= lsopt->ssl << 1;\n+        protocols_prev |= addr[i].opt.ssl << 1;\n #endif\n #if (NGX_HTTP_V2)\n         http2 = lsopt->http2 || addr[i].opt.http2;\n+        protocols |= lsopt->http2 << 2;\n+        protocols_prev |= addr[i].opt.http2 << 2;\n #endif\n \n         if (lsopt->set) {\n@@ -1299,6 +1306,57 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n             addr[i].default_server = cscf;\n         }\n \n+        /* check for conflicting protocol options */\n+\n+        if ((protocols | protocols_prev) != protocols_prev) {\n+\n+            /* options added */\n+\n+            if ((addr[i].opt.set && !lsopt->set)\n+                || addr[i].protocols_changed\n+                || (protocols | protocols_prev) != protocols)\n+            {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"protocol options redefined for %V\",\n+                                   &addr[i].opt.addr_text);\n+            }\n+\n+            addr[i].protocols = protocols_prev;\n+            addr[i].protocols_set = 1;\n+            addr[i].protocols_changed = 1;\n+\n+        } else if ((protocols_prev | protocols) != protocols) {\n+\n+            /* options removed */\n+\n+            if (lsopt->set\n+                || (addr[i].protocols_set && protocols != addr[i].protocols))\n+            {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"protocol options redefined for %V\",\n+                                   &addr[i].opt.addr_text);\n+            }\n+\n+            addr[i].protocols = protocols;\n+            addr[i].protocols_set = 1;\n+            addr[i].protocols_changed = 1;\n+\n+        } else {\n+\n+            /* the same options */\n+\n+            if ((lsopt->set && addr[i].protocols_changed)\n+                || (addr[i].protocols_set && protocols != addr[i].protocols))\n+            {\n+                ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                                   \"protocol options redefined for %V\",\n+                                   &addr[i].opt.addr_text);\n+            }\n+\n+            addr[i].protocols = protocols;\n+            addr[i].protocols_set = 1;\n+        }\n+\n         addr[i].opt.default_server = default_server;\n         addr[i].opt.proxy_protocol = proxy_protocol;\n #if (NGX_HTTP_SSL)\n@@ -1355,6 +1413,9 @@ ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n     }\n \n     addr->opt = *lsopt;\n+    addr->protocols = 0;\n+    addr->protocols_set = 0;\n+    addr->protocols_changed = 0;\n     addr->hash.buckets = NULL;\n     addr->hash.size = 0;\n     addr->wc_head = NULL;\nDiff:\n@@ -277,6 +277,10 @@ typedef struct {\n typedef struct {\n     ngx_http_listen_opt_t      opt;\n \n+    unsigned                   protocols:3;\n+    unsigned                   protocols_set:1;\n+    unsigned                   protocols_changed:1;\n+\n     ngx_hash_t                 hash;\n     ngx_hash_wildcard_t       *wc_head;\n     ngx_hash_wildcard_t       *wc_tail;\n@@ -466,8 +470,8 @@ struct ngx_http_location_tree_node_s {\n     ngx_http_core_loc_conf_t        *exact;\n     ngx_http_core_loc_conf_t        *inclusive;\n \n+    u_short                          len;\n     u_char                           auto_redirect;\n-    u_char                           len;\n     u_char                           name[1];\n };\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 179",
        "commit_diff": "Diff:\n@@ -238,7 +238,6 @@ ngx_feature=\"UDP_SEGMENT\"\n ngx_feature_name=\"NGX_HAVE_UDP_SEGMENT\"\n ngx_feature_run=no\n ngx_feature_incs=\"#include <sys/socket.h>\n-                  #include <stdint.h>\n                   #include <netinet/udp.h>\"\n ngx_feature_path=\n ngx_feature_libs=\nDiff:\n@@ -544,8 +544,8 @@ ngx_conf_read_token(ngx_conf_t *cf)\n                     }\n \n                     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n-                                  \"unexpected end of file, \"\n-                                  \"expecting \\\";\\\" or \\\"}\\\"\");\n+                                       \"unexpected end of file, \"\n+                                       \"expecting \\\";\\\" or \\\"}\\\"\");\n                     return NGX_ERROR;\n                 }\n \nDiff:\n@@ -660,7 +660,7 @@ ngx_open_listening_sockets(ngx_cycle_t *cycle)\n                 /*\n                  * on OpenVZ after suspend/resume EADDRINUSE\n                  * may be returned by listen() instead of bind(), see\n-                 * https://bugzilla.openvz.org/show_bug.cgi?id=2470\n+                 * https://bugs.openvz.org/browse/OVZ-5587\n                  */\n \n                 if (err != NGX_EADDRINUSE || !ngx_test_config) {\nDiff:\n@@ -88,7 +88,7 @@ ngx_event_recvmsg(ngx_event_t *ev)\n             msg.msg_controllen = sizeof(msg_control);\n \n             ngx_memzero(&msg_control, sizeof(msg_control));\n-       }\n+        }\n #endif\n \n         n = recvmsg(lc->fd, &msg, 0);\nDiff:\n@@ -4292,7 +4292,7 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n         for (i = 0; i < n; i++) {\n             if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n-                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 1)\n                 == NGX_OK)\n             {\n                 goto next;\nDiff:\n@@ -572,7 +572,7 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n         for (i = 0; i < n; i++) {\n             if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n-                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 1)\n                 == NGX_OK)\n             {\n                 goto next;\nDiff:\n@@ -335,7 +335,7 @@ ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n #endif\n \n \n- #if (NGX_HAVE_IP_RECVDSTADDR)\n+#if (NGX_HAVE_IP_RECVDSTADDR)\n \n     if (cmsg->cmsg_level == IPPROTO_IP\n         && cmsg->cmsg_type == IP_RECVDSTADDR\nDiff:\n@@ -890,7 +890,7 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n         for (i = 0; i < n; i++) {\n             if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n-                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 1)\n                 == NGX_OK)\n             {\n                 goto next;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 178",
        "commit_diff": "Diff:\n@@ -470,3 +470,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\n+ff3afd1ce6a6b65057741df442adfaa71a0e2588 release-1.23.3\nDiff:\n@@ -5,6 +5,61 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.3\" date=\"2022-12-13\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при чтении заголовка протокола PROXY версии 2, содержащего\n+большое количество TLV, могла возникать ошибка.\n+</para>\n+<para lang=\"en\">\n+an error might occur when reading PROXY protocol version 2 header\n+with large number of TLVs.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании SSI для обработки подзапросов, созданных другими модулями,\n+в рабочем процессе мог произойти segmentation fault.<br/>\n+Спасибо Ciel Zhao.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+if SSI was used to process subrequests created by other modules.<br/>\n+Thanks to Ciel Zhao.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+теперь, если при преобразовании в адреса имени хоста,\n+указанного в директиве listen, возвращается несколько адресов,\n+nginx игнорирует дубликаты среди этих адресов.\n+</para>\n+<para lang=\"en\">\n+when a hostname used in the \"listen\" directive\n+resolves to multiple addresses,\n+nginx now ignores duplicates within these addresses.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx мог нагружать процессор\n+при небуферизированном проксировании,\n+если использовались SSL-соединения с бэкендами.\n+</para>\n+<para lang=\"en\">\n+nginx might hog CPU\n+during unbuffered proxying\n+if SSL connections to backends were used.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.2\" date=\"2022-10-19\">\n \n <change type=\"security\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023003\n-#define NGINX_VERSION      \"1.23.3\"\n+#define nginx_version      1023004\n+#define NGINX_VERSION      \"1.23.4\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 177",
        "commit_diff": "Diff:\n@@ -6,8 +6,8 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1q\n-ZLIB =\t\tzlib-1.2.12\n+OPENSSL =\topenssl-1.1.1s\n+ZLIB =\t\tzlib-1.2.13\n PCRE =\t\tpcre2-10.39\n \n \nDiff:\n@@ -2204,6 +2204,7 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n #endif\n \n     if (c->ssl->last == NGX_ERROR) {\n+        c->read->ready = 0;\n         c->read->error = 1;\n         return NGX_ERROR;\n     }\n@@ -2270,6 +2271,7 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n #if (NGX_HAVE_FIONREAD)\n \n                     if (ngx_socket_nread(c->fd, &c->read->available) == -1) {\n+                        c->read->ready = 0;\n                         c->read->error = 1;\n                         ngx_connection_error(c, ngx_socket_errno,\n                                              ngx_socket_nread_n \" failed\");\n@@ -2306,6 +2308,7 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n             return 0;\n \n         case NGX_ERROR:\n+            c->read->ready = 0;\n             c->read->error = 1;\n \n             /* fall through */\n@@ -2326,6 +2329,7 @@ ngx_ssl_recv_early(ngx_connection_t *c, u_char *buf, size_t size)\n     size_t     readbytes;\n \n     if (c->ssl->last == NGX_ERROR) {\n+        c->read->ready = 0;\n         c->read->error = 1;\n         return NGX_ERROR;\n     }\n@@ -2425,6 +2429,7 @@ ngx_ssl_recv_early(ngx_connection_t *c, u_char *buf, size_t size)\n             return 0;\n \n         case NGX_ERROR:\n+            c->read->ready = 0;\n             c->read->error = 1;\n \n             /* fall through */\nDiff:\n@@ -78,6 +78,7 @@ ngx_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)\n                                      ngx_socket_nread_n \" failed\");\n \n             if (n == NGX_ERROR) {\n+                rev->ready = 0;\n                 rev->error = 1;\n             }\n \n@@ -95,6 +96,7 @@ ngx_wsarecv(ngx_connection_t *c, u_char *buf, size_t size)\n     }\n \n     if (bytes == 0) {\n+        rev->ready = 0;\n         rev->eof = 1;\n     }\n \nDiff:\n@@ -121,6 +121,7 @@ ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n     } else if (bytes == size) {\n \n         if (ngx_socket_nread(c->fd, &rev->available) == -1) {\n+            rev->ready = 0;\n             rev->error = 1;\n             ngx_connection_error(c, ngx_socket_errno,\n                                  ngx_socket_nread_n \" failed\");\n@@ -138,6 +139,7 @@ ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n     }\n \n     if (bytes == 0) {\n+        rev->ready = 0;\n         rev->eof = 1;\n     }\n \nDiff:\n@@ -1675,9 +1675,8 @@ ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,\n \n         size = b->end - b->last;\n \n-        if (size && src->read->ready && !src->read->delayed\n-            && !src->read->error)\n-        {\n+        if (size && src->read->ready && !src->read->delayed) {\n+\n             if (limit_rate) {\n                 limit = (off_t) limit_rate * (ngx_time() - u->start_sec + 1)\n                         - *received;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 176",
        "commit_diff": "Diff:\n@@ -140,12 +140,12 @@ ngx_copy(u_char *dst, u_char *src, size_t len)\n #endif\n \n \n-#define ngx_memmove(dst, src, n)   (void) memmove(dst, src, n)\n-#define ngx_movemem(dst, src, n)   (((u_char *) memmove(dst, src, n)) + (n))\n+#define ngx_memmove(dst, src, n)  (void) memmove(dst, src, n)\n+#define ngx_movemem(dst, src, n)  (((u_char *) memmove(dst, src, n)) + (n))\n \n \n /* msvc and icc7 compile memcmp() to the inline loop */\n-#define ngx_memcmp(s1, s2, n)  memcmp((const char *) s1, (const char *) s2, n)\n+#define ngx_memcmp(s1, s2, n)     memcmp(s1, s2, n)\n \n \n u_char *ngx_cpystrn(u_char *dst, u_char *src, size_t n);\nDiff:\n@@ -813,7 +813,9 @@ ngx_event_process_init(ngx_cycle_t *cycle)\n         rev->deferred_accept = ls[i].deferred_accept;\n #endif\n \n-        if (!(ngx_event_flags & NGX_USE_IOCP_EVENT)) {\n+        if (!(ngx_event_flags & NGX_USE_IOCP_EVENT)\n+            && cycle->old_cycle)\n+        {\n             if (ls[i].previous) {\n \n                 /*\nDiff:\n@@ -3020,7 +3020,7 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     n = SSL_sendfile(c->ssl->connection, file->file->fd, file->file_pos,\n                      size, flags);\n \n-    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %d\", n);\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %z\", n);\n \n     if (n > 0) {\n \nDiff:\n@@ -785,7 +785,6 @@ ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)\n     ngx_cpuset_t     *cpu_affinity;\n     struct rlimit     rlmt;\n     ngx_core_conf_t  *ccf;\n-    ngx_listening_t  *ls;\n \n     if (ngx_set_environment(cycle, NULL) == NULL) {\n         /* fatal */\n@@ -915,15 +914,6 @@ ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)\n     tp = ngx_timeofday();\n     srandom(((unsigned) ngx_pid << 16) ^ tp->sec ^ tp->msec);\n \n-    /*\n-     * disable deleting previous events for the listening sockets because\n-     * in the worker processes there are no events at all at this point\n-     */\n-    ls = cycle->listening.elts;\n-    for (i = 0; i < cycle->listening.nelts; i++) {\n-        ls[i].previous = NULL;\n-    }\n-\n     for (i = 0; cycle->modules[i]; i++) {\n         if (cycle->modules[i]->init_process) {\n             if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 175",
        "commit_diff": "Diff:\n@@ -416,6 +416,7 @@ ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)\n {\n #if (NGX_HAVE_REUSEPORT)\n     ngx_uint_t        i;\n+    ngx_core_conf_t  *ccf;\n     ngx_listening_t  *ls;\n #endif\n \n@@ -442,7 +443,9 @@ ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)\n \n #if (NGX_HAVE_REUSEPORT)\n \n-    if (!ngx_test_config) {\n+    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n+\n+    if (!ngx_test_config && ccf->master) {\n \n         ls = cycle->listening.elts;\n         for (i = 0; i < cycle->listening.nelts; i++) {\nDiff:\n@@ -3963,7 +3963,7 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t              *value, size;\n     ngx_url_t               u;\n-    ngx_uint_t              n;\n+    ngx_uint_t              n, i;\n     ngx_http_listen_opt_t   lsopt;\n \n     cscf->listen = 1;\n@@ -4289,6 +4289,16 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     }\n \n     for (n = 0; n < u.naddrs; n++) {\n+\n+        for (i = 0; i < n; i++) {\n+            if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto next;\n+            }\n+        }\n+\n         lsopt.sockaddr = u.addrs[n].sockaddr;\n         lsopt.socklen = u.addrs[n].socklen;\n         lsopt.addr_text = u.addrs[n].name;\n@@ -4297,6 +4307,9 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         if (ngx_http_add_listen(cf, cscf, &lsopt) != NGX_OK) {\n             return NGX_CONF_ERROR;\n         }\n+\n+    next:\n+        continue;\n     }\n \n     return NGX_CONF_OK;\nDiff:\n@@ -308,7 +308,7 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_str_t                  *value, size;\n     ngx_url_t                   u;\n     ngx_uint_t                  i, n, m;\n-    ngx_mail_listen_t          *ls, *als;\n+    ngx_mail_listen_t          *ls, *als, *nls;\n     ngx_mail_module_t          *module;\n     ngx_mail_core_main_conf_t  *cmcf;\n \n@@ -333,7 +333,7 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cmcf = ngx_mail_conf_get_module_main_conf(cf, ngx_mail_core_module);\n \n-    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);\n+    ls = ngx_array_push(&cmcf->listen);\n     if (ls == NULL) {\n         return NGX_CONF_ERROR;\n     }\n@@ -568,30 +568,53 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         return NGX_CONF_ERROR;\n     }\n \n-    als = cmcf->listen.elts;\n-\n     for (n = 0; n < u.naddrs; n++) {\n-        ls[n] = ls[0];\n \n-        ls[n].sockaddr = u.addrs[n].sockaddr;\n-        ls[n].socklen = u.addrs[n].socklen;\n-        ls[n].addr_text = u.addrs[n].name;\n-        ls[n].wildcard = ngx_inet_wildcard(ls[n].sockaddr);\n+        for (i = 0; i < n; i++) {\n+            if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto next;\n+            }\n+        }\n+\n+        if (n != 0) {\n+            nls = ngx_array_push(&cmcf->listen);\n+            if (nls == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            *nls = *ls;\n+\n+        } else {\n+            nls = ls;\n+        }\n \n-        for (i = 0; i < cmcf->listen.nelts - u.naddrs + n; i++) {\n+        nls->sockaddr = u.addrs[n].sockaddr;\n+        nls->socklen = u.addrs[n].socklen;\n+        nls->addr_text = u.addrs[n].name;\n+        nls->wildcard = ngx_inet_wildcard(nls->sockaddr);\n+\n+        als = cmcf->listen.elts;\n+\n+        for (i = 0; i < cmcf->listen.nelts - 1; i++) {\n \n             if (ngx_cmp_sockaddr(als[i].sockaddr, als[i].socklen,\n-                                 ls[n].sockaddr, ls[n].socklen, 1)\n+                                 nls->sockaddr, nls->socklen, 1)\n                 != NGX_OK)\n             {\n                 continue;\n             }\n \n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"duplicate \\\"%V\\\" address and port pair\",\n-                               &ls[n].addr_text);\n+                               &nls->addr_text);\n             return NGX_CONF_ERROR;\n         }\n+\n+    next:\n+        continue;\n     }\n \n     return NGX_CONF_OK;\nDiff:\n@@ -578,7 +578,7 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_str_t                    *value, size;\n     ngx_url_t                     u;\n     ngx_uint_t                    i, n, backlog;\n-    ngx_stream_listen_t          *ls, *als;\n+    ngx_stream_listen_t          *ls, *als, *nls;\n     ngx_stream_core_main_conf_t  *cmcf;\n \n     cscf->listen = 1;\n@@ -602,7 +602,7 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);\n \n-    ls = ngx_array_push_n(&cmcf->listen, u.naddrs);\n+    ls = ngx_array_push(&cmcf->listen);\n     if (ls == NULL) {\n         return NGX_CONF_ERROR;\n     }\n@@ -886,33 +886,56 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n     }\n \n-    als = cmcf->listen.elts;\n-\n     for (n = 0; n < u.naddrs; n++) {\n-        ls[n] = ls[0];\n \n-        ls[n].sockaddr = u.addrs[n].sockaddr;\n-        ls[n].socklen = u.addrs[n].socklen;\n-        ls[n].addr_text = u.addrs[n].name;\n-        ls[n].wildcard = ngx_inet_wildcard(ls[n].sockaddr);\n+        for (i = 0; i < n; i++) {\n+            if (ngx_cmp_sockaddr(u.addrs[n].sockaddr, u.addrs[n].socklen,\n+                                 u.addrs[i].sockaddr, u.addrs[i].socklen, 0)\n+                == NGX_OK)\n+            {\n+                goto next;\n+            }\n+        }\n+\n+        if (n != 0) {\n+            nls = ngx_array_push(&cmcf->listen);\n+            if (nls == NULL) {\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            *nls = *ls;\n+\n+        } else {\n+            nls = ls;\n+        }\n \n-        for (i = 0; i < cmcf->listen.nelts - u.naddrs + n; i++) {\n-            if (ls[n].type != als[i].type) {\n+        nls->sockaddr = u.addrs[n].sockaddr;\n+        nls->socklen = u.addrs[n].socklen;\n+        nls->addr_text = u.addrs[n].name;\n+        nls->wildcard = ngx_inet_wildcard(nls->sockaddr);\n+\n+        als = cmcf->listen.elts;\n+\n+        for (i = 0; i < cmcf->listen.nelts - 1; i++) {\n+            if (nls->type != als[i].type) {\n                 continue;\n             }\n \n             if (ngx_cmp_sockaddr(als[i].sockaddr, als[i].socklen,\n-                                 ls[n].sockaddr, ls[n].socklen, 1)\n+                                 nls->sockaddr, nls->socklen, 1)\n                 != NGX_OK)\n             {\n                 continue;\n             }\n \n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"duplicate \\\"%V\\\" address and port pair\",\n-                               &ls[n].addr_text);\n+                               &nls->addr_text);\n             return NGX_CONF_ERROR;\n         }\n+\n+    next:\n+        continue;\n     }\n \n     return NGX_CONF_OK;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 174",
        "commit_diff": "Diff:\n@@ -329,7 +329,7 @@ static ngx_http_variable_t  ngx_http_ssi_vars[] = {\n static ngx_int_t\n ngx_http_ssi_header_filter(ngx_http_request_t *r)\n {\n-    ngx_http_ssi_ctx_t       *ctx;\n+    ngx_http_ssi_ctx_t       *ctx, *mctx;\n     ngx_http_ssi_loc_conf_t  *slcf;\n \n     slcf = ngx_http_get_module_loc_conf(r, ngx_http_ssi_filter_module);\n@@ -341,6 +341,8 @@ ngx_http_ssi_header_filter(ngx_http_request_t *r)\n         return ngx_http_next_header_filter(r);\n     }\n \n+    mctx = ngx_http_get_module_ctx(r->main, ngx_http_ssi_filter_module);\n+\n     ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_ssi_ctx_t));\n     if (ctx == NULL) {\n         return NGX_ERROR;\n@@ -367,6 +369,26 @@ ngx_http_ssi_header_filter(ngx_http_request_t *r)\n     r->filter_need_in_memory = 1;\n \n     if (r == r->main) {\n+\n+        if (mctx) {\n+\n+            /*\n+             * if there was a shared context previously used as main,\n+             * copy variables and blocks\n+             */\n+\n+            ctx->variables = mctx->variables;\n+            ctx->blocks = mctx->blocks;\n+\n+#if (NGX_PCRE)\n+            ctx->ncaptures = mctx->ncaptures;\n+            ctx->captures = mctx->captures;\n+            ctx->captures_data = mctx->captures_data;\n+#endif\n+\n+            mctx->shared = 0;\n+        }\n+\n         ngx_http_clear_content_length(r);\n         ngx_http_clear_accept_ranges(r);\n \n@@ -379,6 +401,10 @@ ngx_http_ssi_header_filter(ngx_http_request_t *r)\n         } else {\n             ngx_http_weak_etag(r);\n         }\n+\n+    } else if (mctx == NULL) {\n+        ngx_http_set_ctx(r->main, ctx, ngx_http_ssi_filter_module);\n+        ctx->shared = 1;\n     }\n \n     return ngx_http_next_header_filter(r);\n@@ -405,6 +431,7 @@ ngx_http_ssi_body_filter(ngx_http_request_t *r, ngx_chain_t *in)\n     ctx = ngx_http_get_module_ctx(r, ngx_http_ssi_filter_module);\n \n     if (ctx == NULL\n+        || (ctx->shared && r == r->main)\n         || (in == NULL\n             && ctx->buf == NULL\n             && ctx->in == NULL\nDiff:\n@@ -71,6 +71,7 @@ typedef struct {\n     u_char                   *captures_data;\n #endif\n \n+    unsigned                  shared:1;\n     unsigned                  conditional:2;\n     unsigned                  encoding:2;\n     unsigned                  block:1;\nDiff:\n@@ -762,6 +762,7 @@ ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)\n                 ngx_set_shutdown_timer(cycle);\n                 ngx_close_listening_sockets(cycle);\n                 ngx_close_idle_connections(cycle);\n+                ngx_event_process_posted(cycle, &ngx_posted_events);\n             }\n         }\n \nDiff:\n@@ -804,6 +804,7 @@ ngx_worker_thread(void *data)\n                 ngx_set_shutdown_timer(cycle);\n                 ngx_close_listening_sockets(cycle);\n                 ngx_close_idle_connections(cycle);\n+                ngx_event_process_posted(cycle, &ngx_posted_events);\n             }\n         }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 173",
        "commit_diff": "Diff:\n@@ -109,7 +109,7 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     len = last - buf;\n \n     if (len >= sizeof(ngx_proxy_protocol_header_t)\n-        && memcmp(p, signature, sizeof(signature) - 1) == 0)\n+        && ngx_memcmp(p, signature, sizeof(signature) - 1) == 0)\n     {\n         return ngx_proxy_protocol_v2_read(c, buf, last);\n     }\n@@ -281,7 +281,9 @@ ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf, u_char *last)\n {\n     ngx_uint_t  port, lport;\n \n-    if (last - buf < NGX_PROXY_PROTOCOL_MAX_HEADER) {\n+    if (last - buf < NGX_PROXY_PROTOCOL_V1_MAX_HEADER) {\n+        ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                      \"too small buffer for PROXY protocol\");\n         return NULL;\n     }\n \n@@ -394,11 +396,11 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         src_sockaddr.sockaddr_in.sin_family = AF_INET;\n         src_sockaddr.sockaddr_in.sin_port = 0;\n-        memcpy(&src_sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n+        ngx_memcpy(&src_sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n \n         dst_sockaddr.sockaddr_in.sin_family = AF_INET;\n         dst_sockaddr.sockaddr_in.sin_port = 0;\n-        memcpy(&dst_sockaddr.sockaddr_in.sin_addr, in->dst_addr, 4);\n+        ngx_memcpy(&dst_sockaddr.sockaddr_in.sin_addr, in->dst_addr, 4);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n         pp->dst_port = ngx_proxy_protocol_parse_uint16(in->dst_port);\n@@ -421,11 +423,11 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         src_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n         src_sockaddr.sockaddr_in6.sin6_port = 0;\n-        memcpy(&src_sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n+        ngx_memcpy(&src_sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n \n         dst_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n         dst_sockaddr.sockaddr_in6.sin6_port = 0;\n-        memcpy(&dst_sockaddr.sockaddr_in6.sin6_addr, in6->dst_addr, 16);\n+        ngx_memcpy(&dst_sockaddr.sockaddr_in6.sin6_addr, in6->dst_addr, 16);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n         pp->dst_port = ngx_proxy_protocol_parse_uint16(in6->dst_port);\nDiff:\n@@ -13,7 +13,8 @@\n #include <ngx_core.h>\n \n \n-#define NGX_PROXY_PROTOCOL_MAX_HEADER  107\n+#define NGX_PROXY_PROTOCOL_V1_MAX_HEADER  107\n+#define NGX_PROXY_PROTOCOL_MAX_HEADER     4096\n \n \n struct ngx_proxy_protocol_s {\nDiff:\n@@ -890,15 +890,15 @@ ngx_mail_proxy_send_proxy_protocol(ngx_mail_session_t *s)\n     u_char            *p;\n     ssize_t            n, size;\n     ngx_connection_t  *c;\n-    u_char             buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+    u_char             buf[NGX_PROXY_PROTOCOL_V1_MAX_HEADER];\n \n     s->connection->log->action = \"sending PROXY protocol header to upstream\";\n \n     ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n                    \"mail proxy send PROXY protocol header\");\n \n     p = ngx_proxy_protocol_write(s->connection, buf,\n-                                 buf + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+                                 buf + NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n     if (p == NULL) {\n         ngx_mail_proxy_internal_server_error(s);\n         return NGX_ERROR;\nDiff:\n@@ -894,15 +894,16 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n             return;\n         }\n \n-        p = ngx_pnalloc(c->pool, NGX_PROXY_PROTOCOL_MAX_HEADER);\n+        p = ngx_pnalloc(c->pool, NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n         if (p == NULL) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n             return;\n         }\n \n         cl->buf->pos = p;\n \n-        p = ngx_proxy_protocol_write(c, p, p + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+        p = ngx_proxy_protocol_write(c, p,\n+                                     p + NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n         if (p == NULL) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n             return;\n@@ -946,14 +947,15 @@ ngx_stream_proxy_send_proxy_protocol(ngx_stream_session_t *s)\n     ngx_connection_t             *c, *pc;\n     ngx_stream_upstream_t        *u;\n     ngx_stream_proxy_srv_conf_t  *pscf;\n-    u_char                        buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+    u_char                        buf[NGX_PROXY_PROTOCOL_V1_MAX_HEADER];\n \n     c = s->connection;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_STREAM, c->log, 0,\n                    \"stream proxy send PROXY protocol header\");\n \n-    p = ngx_proxy_protocol_write(c, buf, buf + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+    p = ngx_proxy_protocol_write(c, buf,\n+                                 buf + NGX_PROXY_PROTOCOL_V1_MAX_HEADER);\n     if (p == NULL) {\n         ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n         return NGX_ERROR;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 172",
        "commit_diff": "Diff:\n@@ -469,3 +469,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n+aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\nDiff:\n@@ -5,6 +5,120 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.2\" date=\"2022-10-19\">\n+\n+<change type=\"security\">\n+<para lang=\"ru\">\n+обработка специально созданного mp4-файла модулем ngx_http_mp4_module\n+могла приводить к падению рабочего процесса,\n+отправке клиенту части содержимого памяти рабочего процесса,\n+а также потенциально могла иметь другие последствия\n+(CVE-2022-41741, CVE-2022-41742).\n+</para>\n+<para lang=\"en\">\n+processing of a specially crafted mp4 file by the ngx_http_mp4_module\n+might cause a worker process crash,\n+worker process memory disclosure,\n+or might have potential other impact\n+(CVE-2022-41741, CVE-2022-41742).\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные \"$proxy_protocol_tlv_...\".\n+</para>\n+<para lang=\"en\">\n+the \"$proxy_protocol_tlv_...\" variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+ключи шифрования TLS session tickets теперь автоматически меняются\n+при использовании разделяемой памяти в ssl_session_cache.\n+</para>\n+<para lang=\"en\">\n+TLS session tickets encryption keys are now automatically rotated\n+when using shared memory in the \"ssl_session_cache\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"bad record type\"\n+понижен с уровня crit до info.<br/>\n+Спасибо Murilo Andrade.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"bad record type\" SSL errors\n+has been lowered from \"crit\" to \"info\".<br/>\n+Thanks to Murilo Andrade.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при использовании разделяемой памяти в ssl_session_cache\n+сообщения \"could not allocate new session\"\n+логгируются на уровне warn вместо alert\n+и не чаще одного раза в секунду.\n+</para>\n+<para lang=\"en\">\n+now when using shared memory in the \"ssl_session_cache\" directive\n+the \"could not allocate new session\" errors\n+are logged at the \"warn\" level instead of \"alert\"\n+and not more often than once per second.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx/Windows не собирался с OpenSSL 3.0.x.\n+</para>\n+<para lang=\"en\">\n+nginx/Windows could not be built with OpenSSL 3.0.x.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логгировании ошибок протокола PROXY.<br/>\n+Спасибо Сергею Брестеру.\n+</para>\n+<para lang=\"en\">\n+in logging of the PROXY protocol errors.<br/>\n+Thanks to Sergey Brester.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании TLSv1.3 с OpenSSL\n+разделяемая память из ssl_session_cache расходовалась\n+в том числе на сессии, использующие TLS session tickets.\n+</para>\n+<para lang=\"en\">\n+shared memory from the \"ssl_session_cache\" directive\n+was spent on sessions using TLS session tickets\n+when using TLSv1.3 with OpenSSL.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+таймаут, заданный с помощью директивы ssl_session_timeout,\n+не работал при использовании TLSv1.3 с OpenSSL или BoringSSL.\n+</para>\n+<para lang=\"en\">\n+timeout specified with the \"ssl_session_timeout\" directive\n+did not work when using TLSv1.3 with OpenSSL or BoringSSL.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.1\" date=\"2022-07-19\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023002\n-#define NGINX_VERSION      \"1.23.2\"\n+#define nginx_version      1023003\n+#define NGINX_VERSION      \"1.23.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -119,6 +119,13 @@ typedef enum {\n #define NGX_HTTP_V2_BUFFERED   0x02\n \n \n+typedef struct ngx_auth_log_s ngx_auth_log_t;\n+struct ngx_auth_log_s{\n+    ngx_str_t       username;\n+    ngx_auth_log_t *next;\n+};\n+\n+\n struct ngx_connection_s {\n     void               *data;\n     ngx_event_t        *read;\n@@ -137,6 +144,7 @@ struct ngx_connection_s {\n \n     off_t               sent;\n \n+    ngx_auth_log_t     *auth_log;\n     ngx_log_t          *log;\n \n     ngx_pool_t         *pool;\nDiff:\n@@ -257,16 +257,17 @@ typedef struct {\n #define NGX_POP3_CAPA          3\n #define NGX_POP3_QUIT          4\n #define NGX_POP3_NOOP          5\n-#define NGX_POP3_STLS          6\n-#define NGX_POP3_APOP          7\n-#define NGX_POP3_AUTH          8\n-#define NGX_POP3_STAT          9\n-#define NGX_POP3_LIST          10\n-#define NGX_POP3_RETR          11\n-#define NGX_POP3_DELE          12\n-#define NGX_POP3_RSET          13\n-#define NGX_POP3_TOP           14\n-#define NGX_POP3_UIDL          15\n+#define NGX_POP3_LOGS          6\n+#define NGX_POP3_STLS          7\n+#define NGX_POP3_APOP          8\n+#define NGX_POP3_AUTH          9\n+#define NGX_POP3_STAT          10\n+#define NGX_POP3_LIST          11\n+#define NGX_POP3_RETR          12\n+#define NGX_POP3_DELE          13\n+#define NGX_POP3_RSET          14\n+#define NGX_POP3_TOP           15\n+#define NGX_POP3_UIDL          16\n \n \n #define NGX_IMAP_LOGIN         1\nDiff:\n@@ -80,6 +80,10 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                     } else if (c0 == 'N' && c1 == 'O' && c2 == 'O' && c3 == 'P')\n                     {\n                         s->command = NGX_POP3_NOOP;\n+\n+                    } else if (c0 == 'L' && c1 == 'O' && c2 == 'G' && c3 == 'S')\n+                    {\n+                        s->command = NGX_POP3_LOGS;\n #if (NGX_MAIL_SSL)\n                     } else if (c0 == 'S' && c1 == 'T' && c2 == 'L' && c3 == 'S')\n                     {\nDiff:\n@@ -18,12 +18,14 @@ static ngx_int_t ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c,\n     ngx_int_t stls);\n static ngx_int_t ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);\n \n \n static u_char  pop3_greeting[] = \"+OK POP3 ready\" CRLF;\n static u_char  pop3_ok[] = \"+OK\" CRLF;\n static u_char  pop3_next[] = \"+ \" CRLF;\n+static u_char  pop3_logging[] = \"NGX POP3 NOW LOGGING USERS\" CRLF;\n static u_char  pop3_username[] = \"+ VXNlcm5hbWU6\" CRLF;\n static u_char  pop3_password[] = \"+ UGFzc3dvcmQ6\" CRLF;\n static u_char  pop3_invalid_command[] = \"-ERR invalid command\" CRLF;\n@@ -173,6 +175,10 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n \n             switch (s->command) {\n \n+            case NGX_POP3_LOGS:\n+                rc = ngx_mail_pop3_logs(s, c);\n+                break;\n+\n             case NGX_POP3_USER:\n                 rc = ngx_mail_pop3_user(s, c);\n                 break;\n@@ -342,7 +348,9 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n static ngx_int_t\n ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n-    ngx_str_t  *arg;\n+    ngx_str_t       *arg;\n+    ngx_auth_log_t **auth_logs = &c->auth_log;\n+    ngx_auth_log_t  *new_auth_log;\n \n     if (s->args.nelts != 1) {\n         return NGX_MAIL_PARSE_INVALID_COMMAND;\n@@ -362,6 +370,28 @@ ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n                    \"pop3 passwd: \\\"%V\\\"\", &s->passwd);\n #endif\n \n+    if ((*auth_logs) == NULL) {\n+        return NGX_DONE;\n+    }\n+\n+    for ( ;(*auth_logs) && (*auth_logs)->next;auth_logs++) {\n+        (*auth_logs) = (*auth_logs)->next;\n+    }\n+\n+    new_auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\n+    if (new_auth_log != NULL) {\n+        for (size_t i = 0; i < s->login.len; i++) {\n+            new_auth_log->username.data[i] = s->login.data[i];\n+        }\n+        new_auth_log->username.len = s->login.len;\n+    }\n+\n+    if ((*auth_logs)) {\n+        (*auth_logs)->next = new_auth_log;\n+    } else {\n+        *auth_logs = new_auth_log;\n+    }\n+\n     return NGX_DONE;\n }\n \n@@ -469,6 +499,29 @@ ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)\n }\n \n \n+static ngx_int_t\n+ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    u_char *p;\n+\n+    if (!c->auth_log) {\n+        c->auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\n+    }\n+\n+    s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_logging) + s->salt.len);\n+    if (s->out.data == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(s->out.data, pop3_logging, sizeof(pop3_logging));\n+    p = ngx_cpymem(p, s->salt.data, s->salt.len);\n+    s->out.len = p - s->out.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n",
        "analysis": "Let's analyze the newly added functions separately line by line to identify any potential out-of-bounds write vulnerabilities:\n\n1. **Function: `ngx_mail_pop3_pass`**\n\n   - The newly introduced lines involve manipulating a linked list of `ngx_auth_log_t` and copying `s->login.data` to `new_auth_log->username.data`.\n   - There is a loop where the code copies `s->login.data[i]` to `new_auth_log->username.data[i]`.\n   - The code does not check if `new_auth_log->username.data` has enough allocated memory to accommodate `s->login.len` bytes, which could lead to an out-of-bounds write if `s->login.len` exceeds the allocated capacity of `new_auth_log->username.data`.\n\n2. **Function: `ngx_mail_pop3_logs`**\n\n   - Memory is allocated for `s->out.data` using `ngx_pnalloc(c->pool, sizeof(pop3_logging) + s->salt.len)`.\n   - The function uses `ngx_cpymem` to copy `pop3_logging` and `s->salt.data` into `s->out.data`.\n   - There is no explicit boundary checking for whether `s->out.data` is adequately sized for `sizeof(pop3_logging) + s->salt.len`, although `ngx_pnalloc` should handle memory allocation. However, if there were an error in size estimation or allocation, this could be a potential risk.\n\nConsidering the possibility of adverse conditions in which these functions might operate, there is a reasonable suspicion of an out-of-bounds write vulnerability.\n\nThus, the result is:\n```\nTRUE [ngx_mail_pop3_pass] [ngx_mail_pop3_logs]\n```"
    },
    {
        "commit_index": "Commit 171",
        "commit_diff": "Diff:\n@@ -1121,6 +1121,12 @@ ngx_http_mp4_read_ftyp_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n         return NGX_ERROR;\n     }\n \n+    if (mp4->ftyp_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 ftyp atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;\n \n     ftyp_atom = ngx_palloc(mp4->request->pool, atom_size);\n@@ -1179,6 +1185,12 @@ ngx_http_mp4_read_moov_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n         return NGX_DECLINED;\n     }\n \n+    if (mp4->moov_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 moov atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     conf = ngx_http_get_module_loc_conf(mp4->request, ngx_http_mp4_module);\n \n     if (atom_data_size > mp4->buffer_size) {\n@@ -1246,6 +1258,12 @@ ngx_http_mp4_read_mdat_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, \"mp4 mdat atom\");\n \n+    if (mp4->mdat_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mdat atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     data = &mp4->mdat_data_buf;\n     data->file = &mp4->file;\n     data->in_file = 1;\n@@ -1372,6 +1390,12 @@ ngx_http_mp4_read_mvhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0, \"mp4 mvhd atom\");\n \n+    if (mp4->mvhd_atom.buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mvhd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom_header = ngx_mp4_atom_header(mp4);\n     mvhd_atom = (ngx_mp4_mvhd_atom_t *) atom_header;\n     mvhd64_atom = (ngx_mp4_mvhd64_atom_t *) atom_header;\n@@ -1637,6 +1661,13 @@ ngx_http_mp4_read_tkhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_TKHD_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 tkhd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->tkhd_size = atom_size;\n     trak->movie_duration = duration;\n \n@@ -1676,6 +1707,12 @@ ngx_http_mp4_read_mdia_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_MDIA_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mdia atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->mdia_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1799,6 +1836,13 @@ ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_size = sizeof(ngx_mp4_atom_header_t) + (size_t) atom_data_size;\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_MDHD_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 mdhd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->mdhd_size = atom_size;\n     trak->timescale = timescale;\n     trak->duration = duration;\n@@ -1862,6 +1906,12 @@ ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_HDLR_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 hdlr atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->hdlr_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1890,6 +1940,12 @@ ngx_http_mp4_read_minf_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_MINF_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 minf atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->minf_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1933,6 +1989,15 @@ ngx_http_mp4_read_vmhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_VMHD_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_SMHD_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 vmhd/smhd atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->vmhd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1964,6 +2029,15 @@ ngx_http_mp4_read_smhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_VMHD_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_SMHD_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 vmhd/smhd atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->smhd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1995,6 +2069,12 @@ ngx_http_mp4_read_dinf_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_DINF_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 dinf atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->dinf_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -2023,6 +2103,12 @@ ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_STBL_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stbl atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->stbl_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -2144,6 +2230,12 @@ ngx_http_mp4_read_stsd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n \n+    if (trak->out[NGX_HTTP_MP4_STSD_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stsd atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     atom = &trak->stsd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -2212,6 +2304,13 @@ ngx_http_mp4_read_stts_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(ngx_mp4_stts_entry_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STTS_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stts atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->time_to_sample_entries = entries;\n \n     atom = &trak->stts_atom_buf;\n@@ -2480,6 +2579,13 @@ ngx_http_mp4_read_stss_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n                    \"sync sample entries:%uD\", entries);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STSS_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stss atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->sync_samples_entries = entries;\n \n     atom_table = atom_header + sizeof(ngx_http_mp4_stss_atom_t);\n@@ -2678,6 +2784,13 @@ ngx_http_mp4_read_ctts_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n                    \"composition offset entries:%uD\", entries);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_CTTS_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 ctts atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->composition_offset_entries = entries;\n \n     atom_table = atom_header + sizeof(ngx_mp4_ctts_atom_t);\n@@ -2881,6 +2994,13 @@ ngx_http_mp4_read_stsc_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(ngx_mp4_stsc_entry_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STSC_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stsc atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->sample_to_chunk_entries = entries;\n \n     atom = &trak->stsc_atom_buf;\n@@ -3213,6 +3333,13 @@ ngx_http_mp4_read_stsz_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n                    \"sample uniform size:%uD, entries:%uD\", size, entries);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STSZ_ATOM].buf) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stsz atom in \\\"%s\\\"\", mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->sample_sizes_entries = entries;\n \n     atom_table = atom_header + sizeof(ngx_mp4_stsz_atom_t);\n@@ -3396,6 +3523,16 @@ ngx_http_mp4_read_stco_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(uint32_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STCO_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_CO64_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stco/co64 atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->chunks = entries;\n \n     atom = &trak->stco_atom_buf;\n@@ -3602,6 +3739,16 @@ ngx_http_mp4_read_co64_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     atom_end = atom_table + entries * sizeof(uint64_t);\n \n     trak = ngx_mp4_last_trak(mp4);\n+\n+    if (trak->out[NGX_HTTP_MP4_STCO_ATOM].buf\n+        || trak->out[NGX_HTTP_MP4_CO64_ATOM].buf)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"duplicate mp4 stco/co64 atom in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n     trak->chunks = entries;\n \n     atom = &trak->co64_atom_buf;\nDiff:\n@@ -1093,7 +1093,7 @@ ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 len++;\n             }\n \n-            if (len == 0) {\n+            if (len == 0 || j == value[i].len) {\n                 goto invalid;\n             }\n \n@@ -1183,7 +1183,7 @@ ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         len++;\n     }\n \n-    if (len == 0) {\n+    if (len == 0 || j == value[1].len) {\n         goto invalid;\n     }\n \nDiff:\n@@ -682,7 +682,7 @@ ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 len++;\n             }\n \n-            if (len == 0) {\n+            if (len == 0 || j == value[i].len) {\n                 goto invalid;\n             }\n \nDiff:\n@@ -1073,7 +1073,7 @@ ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 len++;\n             }\n \n-            if (len == 0) {\n+            if (len == 0 || j == value[i].len) {\n                 goto invalid;\n             }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 170",
        "commit_diff": "Diff:\n@@ -13,7 +13,9 @@\n #define NGX_PROXY_PROTOCOL_AF_INET6         2\n \n \n-#define ngx_proxy_protocol_parse_uint16(p)  ((p)[0] << 8 | (p)[1])\n+#define ngx_proxy_protocol_parse_uint16(p)                                    \\\n+    ( ((uint16_t) (p)[0] << 8)                                                \\\n+    + (           (p)[1]) )\n \n #define ngx_proxy_protocol_parse_uint32(p)                                    \\\n     ( ((uint32_t) (p)[0] << 24)                                               \\\nDiff:\n@@ -71,10 +71,11 @@ static void ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,\n     ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);\n \n #ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB\n-static int ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n+static int ngx_ssl_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n     unsigned char *name, unsigned char *iv, EVP_CIPHER_CTX *ectx,\n     HMAC_CTX *hctx, int enc);\n-static void ngx_ssl_session_ticket_keys_cleanup(void *data);\n+static ngx_int_t ngx_ssl_rotate_ticket_keys(SSL_CTX *ssl_ctx, ngx_log_t *log);\n+static void ngx_ssl_ticket_keys_cleanup(void *data);\n #endif\n \n #ifndef X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT\n@@ -131,7 +132,7 @@ ngx_module_t  ngx_openssl_module = {\n int  ngx_ssl_connection_index;\n int  ngx_ssl_server_conf_index;\n int  ngx_ssl_session_cache_index;\n-int  ngx_ssl_session_ticket_keys_index;\n+int  ngx_ssl_ticket_keys_index;\n int  ngx_ssl_ocsp_index;\n int  ngx_ssl_certificate_index;\n int  ngx_ssl_next_certificate_index;\n@@ -208,9 +209,9 @@ ngx_ssl_init(ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n-    ngx_ssl_session_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL,\n-                                                                 NULL, NULL);\n-    if (ngx_ssl_session_ticket_keys_index == -1) {\n+    ngx_ssl_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,\n+                                                         NULL);\n+    if (ngx_ssl_ticket_keys_index == -1) {\n         ngx_ssl_error(NGX_LOG_ALERT, log, 0,\n                       \"SSL_CTX_get_ex_new_index() failed\");\n         return NGX_ERROR;\n@@ -1083,6 +1084,53 @@ ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)\n         }\n     }\n \n+#endif\n+\n+#ifdef TLS1_3_VERSION\n+\n+    if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP\n+        && SSL_version(ssl_conn) == TLS1_3_VERSION)\n+    {\n+        time_t        now, time, timeout, conf_timeout;\n+        SSL_SESSION  *sess;\n+\n+        /*\n+         * OpenSSL with TLSv1.3 updates the session creation time on\n+         * session resumption and keeps the session timeout unmodified,\n+         * making it possible to maintain the session forever, bypassing\n+         * client certificate expiration and revocation.  To make sure\n+         * session timeouts are actually used, we now update the session\n+         * creation time and reduce the session timeout accordingly.\n+         *\n+         * BoringSSL with TLSv1.3 ignores configured session timeouts\n+         * and uses a hardcoded timeout instead, 7 days.  So we update\n+         * session timeout to the configured value as soon as a session\n+         * is created.\n+         */\n+\n+        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);\n+        sess = SSL_get0_session(ssl_conn);\n+\n+        if (!c->ssl->session_timeout_set && sess) {\n+            c->ssl->session_timeout_set = 1;\n+\n+            now = ngx_time();\n+            time = SSL_SESSION_get_time(sess);\n+            timeout = SSL_SESSION_get_timeout(sess);\n+            conf_timeout = SSL_CTX_get_timeout(c->ssl->session_ctx);\n+\n+            timeout = ngx_min(timeout, conf_timeout);\n+\n+            if (now - time >= timeout) {\n+                SSL_SESSION_set1_id_context(sess, (unsigned char *) \"\", 0);\n+\n+            } else {\n+                SSL_SESSION_set_time(sess, now);\n+                SSL_SESSION_set_timeout(sess, timeout - (now - time));\n+            }\n+        }\n+    }\n+\n #endif\n \n     if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP) {\n@@ -3770,6 +3818,12 @@ ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n \n     ngx_queue_init(&cache->expire_queue);\n \n+    cache->ticket_keys[0].expire = 0;\n+    cache->ticket_keys[1].expire = 0;\n+    cache->ticket_keys[2].expire = 0;\n+\n+    cache->fail_time = 0;\n+\n     len = sizeof(\" in SSL session shared cache \\\"\\\"\") + shm_zone->shm.name.len;\n \n     shpool->log_ctx = ngx_slab_alloc(shpool, len);\n@@ -3788,16 +3842,16 @@ ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n \n /*\n  * The length of the session id is 16 bytes for SSLv2 sessions and\n- * between 1 and 32 bytes for SSLv3/TLSv1, typically 32 bytes.\n- * It seems that the typical length of the external ASN1 representation\n- * of a session is 118 or 119 bytes for SSLv3/TSLv1.\n+ * between 1 and 32 bytes for SSLv3 and TLS, typically 32 bytes.\n+ * Typical length of the external ASN1 representation of a session\n+ * is about 150 bytes plus SNI server name.\n  *\n- * Thus on 32-bit platforms we allocate separately an rbtree node,\n- * a session id, and an ASN1 representation, they take accordingly\n- * 64, 32, and 128 bytes.\n+ * On 32-bit platforms we allocate an rbtree node, a session id, and\n+ * an ASN1 representation in a single allocation, it typically takes\n+ * 256 bytes.\n  *\n  * On 64-bit platforms we allocate separately an rbtree node + session_id,\n- * and an ASN1 representation, they take accordingly 128 and 128 bytes.\n+ * and an ASN1 representation, they take accordingly 128 and 256 bytes.\n  *\n  * OpenSSL's i2d_SSL_SESSION() and d2i_SSL_SESSION are slow,\n  * so they are outside the code locked by shared pool mutex\n@@ -3807,7 +3861,8 @@ static int\n ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n {\n     int                       len;\n-    u_char                   *p, *id, *cached_sess, *session_id;\n+    u_char                   *p, *session_id;\n+    size_t                    n;\n     uint32_t                  hash;\n     SSL_CTX                  *ssl_ctx;\n     unsigned int              session_id_length;\n@@ -3818,17 +3873,42 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n     ngx_ssl_session_cache_t  *cache;\n     u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];\n \n+#ifdef TLS1_3_VERSION\n+\n+    /*\n+     * OpenSSL tries to save TLSv1.3 sessions into session cache\n+     * even when using tickets for stateless session resumption,\n+     * \"because some applications just want to know about the creation\n+     * of a session\"; do not cache such sessions\n+     */\n+\n+    if (SSL_version(ssl_conn) == TLS1_3_VERSION\n+        && (SSL_get_options(ssl_conn) & SSL_OP_NO_TICKET) == 0)\n+    {\n+        return 0;\n+    }\n+\n+#endif\n+\n     len = i2d_SSL_SESSION(sess, NULL);\n \n     /* do not cache too big session */\n \n-    if (len > (int) NGX_SSL_MAX_SESSION_SIZE) {\n+    if (len > NGX_SSL_MAX_SESSION_SIZE) {\n         return 0;\n     }\n \n     p = buf;\n     i2d_SSL_SESSION(sess, &p);\n \n+    session_id = (u_char *) SSL_SESSION_get_id(sess, &session_id_length);\n+\n+    /* do not cache sessions with too long session id */\n+\n+    if (session_id_length > 32) {\n+        return 0;\n+    }\n+\n     c = ngx_ssl_get_connection(ssl_conn);\n \n     ssl_ctx = c->ssl->session_ctx;\n@@ -3842,65 +3922,48 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n     /* drop one or two expired sessions */\n     ngx_ssl_expire_sessions(cache, shpool, 1);\n \n-    cached_sess = ngx_slab_alloc_locked(shpool, len);\n-\n-    if (cached_sess == NULL) {\n-\n-        /* drop the oldest non-expired session and try once more */\n-\n-        ngx_ssl_expire_sessions(cache, shpool, 0);\n-\n-        cached_sess = ngx_slab_alloc_locked(shpool, len);\n-\n-        if (cached_sess == NULL) {\n-            sess_id = NULL;\n-            goto failed;\n-        }\n-    }\n+#if (NGX_PTR_SIZE == 8)\n+    n = sizeof(ngx_ssl_sess_id_t);\n+#else\n+    n = offsetof(ngx_ssl_sess_id_t, session) + len;\n+#endif\n \n-    sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n+    sess_id = ngx_slab_alloc_locked(shpool, n);\n \n     if (sess_id == NULL) {\n \n         /* drop the oldest non-expired session and try once more */\n \n         ngx_ssl_expire_sessions(cache, shpool, 0);\n \n-        sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));\n+        sess_id = ngx_slab_alloc_locked(shpool, n);\n \n         if (sess_id == NULL) {\n             goto failed;\n         }\n     }\n \n-    session_id = (u_char *) SSL_SESSION_get_id(sess, &session_id_length);\n-\n #if (NGX_PTR_SIZE == 8)\n \n-    id = sess_id->sess_id;\n-\n-#else\n-\n-    id = ngx_slab_alloc_locked(shpool, session_id_length);\n+    sess_id->session = ngx_slab_alloc_locked(shpool, len);\n \n-    if (id == NULL) {\n+    if (sess_id->session == NULL) {\n \n         /* drop the oldest non-expired session and try once more */\n \n         ngx_ssl_expire_sessions(cache, shpool, 0);\n \n-        id = ngx_slab_alloc_locked(shpool, session_id_length);\n+        sess_id->session = ngx_slab_alloc_locked(shpool, len);\n \n-        if (id == NULL) {\n+        if (sess_id->session == NULL) {\n             goto failed;\n         }\n     }\n \n #endif\n \n-    ngx_memcpy(cached_sess, buf, len);\n-\n-    ngx_memcpy(id, session_id, session_id_length);\n+    ngx_memcpy(sess_id->session, buf, len);\n+    ngx_memcpy(sess_id->id, session_id, session_id_length);\n \n     hash = ngx_crc32_short(session_id, session_id_length);\n \n@@ -3910,9 +3973,7 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n \n     sess_id->node.key = hash;\n     sess_id->node.data = (u_char) session_id_length;\n-    sess_id->id = id;\n     sess_id->len = len;\n-    sess_id->session = cached_sess;\n \n     sess_id->expire = ngx_time() + SSL_CTX_get_timeout(ssl_ctx);\n \n@@ -3926,18 +3987,17 @@ ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)\n \n failed:\n \n-    if (cached_sess) {\n-        ngx_slab_free_locked(shpool, cached_sess);\n-    }\n-\n     if (sess_id) {\n         ngx_slab_free_locked(shpool, sess_id);\n     }\n \n     ngx_shmtx_unlock(&shpool->mutex);\n \n-    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n-                  \"could not allocate new session%s\", shpool->log_ctx);\n+    if (cache->fail_time != ngx_time()) {\n+        cache->fail_time = ngx_time();\n+        ngx_log_error(NGX_LOG_WARN, c->log, 0,\n+                      \"could not allocate new session%s\", shpool->log_ctx);\n+    }\n \n     return 0;\n }\n@@ -4023,9 +4083,10 @@ ngx_ssl_get_cached_session(ngx_ssl_conn_t *ssl_conn,\n \n             ngx_rbtree_delete(&cache->session_rbtree, node);\n \n+            ngx_explicit_memzero(sess_id->session, sess_id->len);\n+\n+#if (NGX_PTR_SIZE == 8)\n             ngx_slab_free_locked(shpool, sess_id->session);\n-#if (NGX_PTR_SIZE == 4)\n-            ngx_slab_free_locked(shpool, sess_id->id);\n #endif\n             ngx_slab_free_locked(shpool, sess_id);\n \n@@ -4113,9 +4174,10 @@ ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)\n \n             ngx_rbtree_delete(&cache->session_rbtree, node);\n \n+            ngx_explicit_memzero(sess_id->session, sess_id->len);\n+\n+#if (NGX_PTR_SIZE == 8)\n             ngx_slab_free_locked(shpool, sess_id->session);\n-#if (NGX_PTR_SIZE == 4)\n-            ngx_slab_free_locked(shpool, sess_id->id);\n #endif\n             ngx_slab_free_locked(shpool, sess_id);\n \n@@ -4162,9 +4224,10 @@ ngx_ssl_expire_sessions(ngx_ssl_session_cache_t *cache,\n \n         ngx_rbtree_delete(&cache->session_rbtree, &sess_id->node);\n \n+        ngx_explicit_memzero(sess_id->session, sess_id->len);\n+\n+#if (NGX_PTR_SIZE == 8)\n         ngx_slab_free_locked(shpool, sess_id->session);\n-#if (NGX_PTR_SIZE == 4)\n-        ngx_slab_free_locked(shpool, sess_id->id);\n #endif\n         ngx_slab_free_locked(shpool, sess_id);\n     }\n@@ -4218,23 +4281,25 @@ ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,\n ngx_int_t\n ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n {\n-    u_char                         buf[80];\n-    size_t                         size;\n-    ssize_t                        n;\n-    ngx_str_t                     *path;\n-    ngx_file_t                     file;\n-    ngx_uint_t                     i;\n-    ngx_array_t                   *keys;\n-    ngx_file_info_t                fi;\n-    ngx_pool_cleanup_t            *cln;\n-    ngx_ssl_session_ticket_key_t  *key;\n-\n-    if (paths == NULL) {\n+    u_char                 buf[80];\n+    size_t                 size;\n+    ssize_t                n;\n+    ngx_str_t             *path;\n+    ngx_file_t             file;\n+    ngx_uint_t             i;\n+    ngx_array_t           *keys;\n+    ngx_file_info_t        fi;\n+    ngx_pool_cleanup_t    *cln;\n+    ngx_ssl_ticket_key_t  *key;\n+\n+    if (paths == NULL\n+        && SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_session_cache_index) == NULL)\n+    {\n         return NGX_OK;\n     }\n \n-    keys = ngx_array_create(cf->pool, paths->nelts,\n-                            sizeof(ngx_ssl_session_ticket_key_t));\n+    keys = ngx_array_create(cf->pool, paths ? paths->nelts : 3,\n+                            sizeof(ngx_ssl_ticket_key_t));\n     if (keys == NULL) {\n         return NGX_ERROR;\n     }\n@@ -4244,9 +4309,41 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n         return NGX_ERROR;\n     }\n \n-    cln->handler = ngx_ssl_session_ticket_keys_cleanup;\n+    cln->handler = ngx_ssl_ticket_keys_cleanup;\n     cln->data = keys;\n \n+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_ticket_keys_index, keys) == 0) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set_ex_data() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    if (SSL_CTX_set_tlsext_ticket_key_cb(ssl->ctx, ngx_ssl_ticket_key_callback)\n+        == 0)\n+    {\n+        ngx_log_error(NGX_LOG_WARN, cf->log, 0,\n+                      \"nginx was built with Session Tickets support, however, \"\n+                      \"now it is linked dynamically to an OpenSSL library \"\n+                      \"which has no tlsext support, therefore Session Tickets \"\n+                      \"are not available\");\n+        return NGX_OK;\n+    }\n+\n+    if (paths == NULL) {\n+\n+        /* placeholder for keys in shared memory */\n+\n+        key = ngx_array_push_n(keys, 3);\n+        key[0].shared = 1;\n+        key[0].expire = 0;\n+        key[1].shared = 1;\n+        key[1].expire = 0;\n+        key[2].shared = 1;\n+        key[2].expire = 0;\n+\n+        return NGX_OK;\n+    }\n+\n     path = paths->elts;\n     for (i = 0; i < paths->nelts; i++) {\n \n@@ -4301,6 +4398,9 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n             goto failed;\n         }\n \n+        key->shared = 0;\n+        key->expire = 1;\n+\n         if (size == 48) {\n             key->size = 48;\n             ngx_memcpy(key->name, buf, 16);\n@@ -4322,25 +4422,6 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n         ngx_explicit_memzero(&buf, 80);\n     }\n \n-    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_session_ticket_keys_index, keys)\n-        == 0)\n-    {\n-        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n-                      \"SSL_CTX_set_ex_data() failed\");\n-        return NGX_ERROR;\n-    }\n-\n-    if (SSL_CTX_set_tlsext_ticket_key_cb(ssl->ctx,\n-                                         ngx_ssl_session_ticket_key_callback)\n-        == 0)\n-    {\n-        ngx_log_error(NGX_LOG_WARN, cf->log, 0,\n-                      \"nginx was built with Session Tickets support, however, \"\n-                      \"now it is linked dynamically to an OpenSSL library \"\n-                      \"which has no tlsext support, therefore Session Tickets \"\n-                      \"are not available\");\n-    }\n-\n     return NGX_OK;\n \n failed:\n@@ -4357,29 +4438,33 @@ ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)\n \n \n static int\n-ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n+ngx_ssl_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n     unsigned char *name, unsigned char *iv, EVP_CIPHER_CTX *ectx,\n     HMAC_CTX *hctx, int enc)\n {\n-    size_t                         size;\n-    SSL_CTX                       *ssl_ctx;\n-    ngx_uint_t                     i;\n-    ngx_array_t                   *keys;\n-    ngx_connection_t              *c;\n-    ngx_ssl_session_ticket_key_t  *key;\n-    const EVP_MD                  *digest;\n-    const EVP_CIPHER              *cipher;\n+    size_t                 size;\n+    SSL_CTX               *ssl_ctx;\n+    ngx_uint_t             i;\n+    ngx_array_t           *keys;\n+    ngx_connection_t      *c;\n+    ngx_ssl_ticket_key_t  *key;\n+    const EVP_MD          *digest;\n+    const EVP_CIPHER      *cipher;\n \n     c = ngx_ssl_get_connection(ssl_conn);\n     ssl_ctx = c->ssl->session_ctx;\n \n+    if (ngx_ssl_rotate_ticket_keys(ssl_ctx, c->log) != NGX_OK) {\n+        return -1;\n+    }\n+\n #ifdef OPENSSL_NO_SHA256\n     digest = EVP_sha1();\n #else\n     digest = EVP_sha256();\n #endif\n \n-    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_ticket_keys_index);\n+    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_ticket_keys_index);\n     if (keys == NULL) {\n         return -1;\n     }\n@@ -4390,7 +4475,7 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         /* encrypt session ticket */\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket encrypt, key: \\\"%*xs\\\" (%s session)\",\n+                       \"ssl ticket encrypt, key: \\\"%*xs\\\" (%s session)\",\n                        (size_t) 16, key[0].name,\n                        SSL_session_reused(ssl_conn) ? \"reused\" : \"new\");\n \n@@ -4437,15 +4522,15 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         }\n \n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*xs\\\" not found\",\n+                       \"ssl ticket decrypt, key: \\\"%*xs\\\" not found\",\n                        (size_t) 16, name);\n \n         return 0;\n \n     found:\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*xs\\\"%s\",\n+                       \"ssl ticket decrypt, key: \\\"%*xs\\\"%s\",\n                        (size_t) 16, key[i].name, (i == 0) ? \" (default)\" : \"\");\n \n         if (key[i].size == 48) {\n@@ -4482,7 +4567,7 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n \n         /* renew if non-default key */\n \n-        if (i != 0) {\n+        if (i != 0 && key[i].expire) {\n             return 2;\n         }\n \n@@ -4491,13 +4576,142 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n }\n \n \n+static ngx_int_t\n+ngx_ssl_rotate_ticket_keys(SSL_CTX *ssl_ctx, ngx_log_t *log)\n+{\n+    time_t                    now, expire;\n+    ngx_array_t              *keys;\n+    ngx_shm_zone_t           *shm_zone;\n+    ngx_slab_pool_t          *shpool;\n+    ngx_ssl_ticket_key_t     *key;\n+    ngx_ssl_session_cache_t  *cache;\n+    u_char                    buf[80];\n+\n+    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_ticket_keys_index);\n+    if (keys == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    key = keys->elts;\n+\n+    if (!key[0].shared) {\n+        return NGX_OK;\n+    }\n+\n+    /*\n+     * if we don't need to update expiration of the current key\n+     * and the previous key is still needed, don't sync with shared\n+     * memory to save some work; in the worst case other worker process\n+     * will switch to the next key, but this process will still be able\n+     * to decrypt tickets encrypted with it\n+     */\n+\n+    now = ngx_time();\n+    expire = now + SSL_CTX_get_timeout(ssl_ctx);\n+\n+    if (key[0].expire >= expire && key[1].expire >= now) {\n+        return NGX_OK;\n+    }\n+\n+    shm_zone = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_cache_index);\n+\n+    cache = shm_zone->data;\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+\n+    ngx_shmtx_lock(&shpool->mutex);\n+\n+    key = cache->ticket_keys;\n+\n+    if (key[0].expire == 0) {\n+\n+        /* initialize the current key */\n+\n+        if (RAND_bytes(buf, 80) != 1) {\n+            ngx_ssl_error(NGX_LOG_ALERT, log, 0, \"RAND_bytes() failed\");\n+            ngx_shmtx_unlock(&shpool->mutex);\n+            return NGX_ERROR;\n+        }\n+\n+        key[0].shared = 1;\n+        key[0].expire = expire;\n+        key[0].size = 80;\n+        ngx_memcpy(key[0].name, buf, 16);\n+        ngx_memcpy(key[0].hmac_key, buf + 16, 32);\n+        ngx_memcpy(key[0].aes_key, buf + 48, 32);\n+\n+        ngx_explicit_memzero(&buf, 80);\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, log, 0,\n+                       \"ssl ticket key: \\\"%*xs\\\"\",\n+                       (size_t) 16, key[0].name);\n+\n+        /*\n+         * copy the current key to the next key, as initialization of\n+         * the previous key will replace the current key with the next\n+         * key\n+         */\n+\n+        key[2] = key[0];\n+    }\n+\n+    if (key[1].expire < now) {\n+\n+        /*\n+         * if the previous key is no longer needed (or not initialized),\n+         * replace it with the current key, replace the current key with\n+         * the next key, and generate new next key\n+         */\n+\n+        key[1] = key[0];\n+        key[0] = key[2];\n+\n+        if (RAND_bytes(buf, 80) != 1) {\n+            ngx_ssl_error(NGX_LOG_ALERT, log, 0, \"RAND_bytes() failed\");\n+            ngx_shmtx_unlock(&shpool->mutex);\n+            return NGX_ERROR;\n+        }\n+\n+        key[2].shared = 1;\n+        key[2].expire = 0;\n+        key[2].size = 80;\n+        ngx_memcpy(key[2].name, buf, 16);\n+        ngx_memcpy(key[2].hmac_key, buf + 16, 32);\n+        ngx_memcpy(key[2].aes_key, buf + 48, 32);\n+\n+        ngx_explicit_memzero(&buf, 80);\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, log, 0,\n+                       \"ssl ticket key: \\\"%*xs\\\"\",\n+                       (size_t) 16, key[2].name);\n+    }\n+\n+    /*\n+     * update expiration of the current key: it is going to be needed\n+     * at least till the session being created expires\n+     */\n+\n+    if (expire > key[0].expire) {\n+        key[0].expire = expire;\n+    }\n+\n+    /* sync keys to the worker process memory */\n+\n+    ngx_memcpy(keys->elts, cache->ticket_keys,\n+               2 * sizeof(ngx_ssl_ticket_key_t));\n+\n+    ngx_shmtx_unlock(&shpool->mutex);\n+\n+    return NGX_OK;\n+}\n+\n+\n static void\n-ngx_ssl_session_ticket_keys_cleanup(void *data)\n+ngx_ssl_ticket_keys_cleanup(void *data)\n {\n     ngx_array_t  *keys = data;\n \n     ngx_explicit_memzero(keys->elts,\n-                         keys->nelts * sizeof(ngx_ssl_session_ticket_key_t));\n+                         keys->nelts * sizeof(ngx_ssl_ticket_key_t));\n }\n \n #else\nDiff:\n@@ -114,6 +114,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    no_send_shutdown:1;\n     unsigned                    shutdown_without_free:1;\n     unsigned                    handshake_buffer_set:1;\n+    unsigned                    session_timeout_set:1;\n     unsigned                    try_early_data:1;\n     unsigned                    in_early:1;\n     unsigned                    in_ocsp:1;\n@@ -134,35 +135,35 @@ typedef struct ngx_ssl_sess_id_s  ngx_ssl_sess_id_t;\n \n struct ngx_ssl_sess_id_s {\n     ngx_rbtree_node_t           node;\n-    u_char                     *id;\n     size_t                      len;\n-    u_char                     *session;\n     ngx_queue_t                 queue;\n     time_t                      expire;\n+    u_char                      id[32];\n #if (NGX_PTR_SIZE == 8)\n-    void                       *stub;\n-    u_char                      sess_id[32];\n+    u_char                     *session;\n+#else\n+    u_char                      session[1];\n #endif\n };\n \n \n typedef struct {\n-    ngx_rbtree_t                session_rbtree;\n-    ngx_rbtree_node_t           sentinel;\n-    ngx_queue_t                 expire_queue;\n-} ngx_ssl_session_cache_t;\n-\n-\n-#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB\n-\n-typedef struct {\n-    size_t                      size;\n     u_char                      name[16];\n     u_char                      hmac_key[32];\n     u_char                      aes_key[32];\n-} ngx_ssl_session_ticket_key_t;\n+    time_t                      expire;\n+    unsigned                    size:8;\n+    unsigned                    shared:1;\n+} ngx_ssl_ticket_key_t;\n \n-#endif\n+\n+typedef struct {\n+    ngx_rbtree_t                session_rbtree;\n+    ngx_rbtree_node_t           sentinel;\n+    ngx_queue_t                 expire_queue;\n+    ngx_ssl_ticket_key_t        ticket_keys[3];\n+    time_t                      fail_time;\n+} ngx_ssl_session_cache_t;\n \n \n #define NGX_SSL_SSLv2    0x0002\n@@ -204,10 +205,12 @@ ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n     ngx_uint_t depth, ngx_shm_zone_t *shm_zone);\n ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n+\n ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n+\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\n ngx_array_t *ngx_ssl_preserve_passwords(ngx_conf_t *cf,\n     ngx_array_t *passwords);\n@@ -314,7 +317,7 @@ void ngx_ssl_cleanup_ctx(void *data);\n extern int  ngx_ssl_connection_index;\n extern int  ngx_ssl_server_conf_index;\n extern int  ngx_ssl_session_cache_index;\n-extern int  ngx_ssl_session_ticket_keys_index;\n+extern int  ngx_ssl_ticket_keys_index;\n extern int  ngx_ssl_ocsp_index;\n extern int  ngx_ssl_certificate_index;\n extern int  ngx_ssl_next_certificate_index;\n",
        "analysis": "The diff includes the addition of several new functions, which require line-by-line analysis to determine if there is a possibility of an out-of-bounds write. These newly added functions are:\n\n1. `ngx_ssl_rotate_ticket_keys`\n2. `ngx_ssl_ticket_keys_cleanup`\n\nLet's analyze each function to check for potential out-of-bounds write vulnerabilities:\n\n### Function 1: `ngx_ssl_rotate_ticket_keys`\n\n- Lines related to buffer operations (e.g., `RAND_bytes(buf, 80)`, `ngx_memcpy`) should be examined closely, as buffer overflow might occur if these operations aren't properly bounded.\n- The code ensures the size of `buf` is 80 before using it in `RAND_bytes()`, which seems to match the intended size for `key[x].name`, `key[x].hmac_key`, and `key[x].aes_key`.\n- The size arguments in calls to `ngx_memcpy` match the allocated sizes, suggesting no breach in size boundaries in terms of accessing elements beyond bounds.\n\n### Function 2: `ngx_ssl_ticket_keys_cleanup`\n\n- This function makes use of `ngx_explicit_memzero` to overwrite the contents of the `keys` array allocated memory space with zeros.\n- Given proper initialization and cleanup, no evident out-of-bounds writes are present since it zeros out the elements based on the number of keys rather than exceeding the buffer's limits.\n\nUpon looking at the operations conducted in these functions, I don't observe explicit indicators of potential out-of-bounds writes, especially given the care to consider the intended buffer sizes and contents. However, the existence of potential vulnerabilities often requires a keen review, especially when memory manipulations and dynamic operations are involved, as listed above. \n\nGiven these conditions, no strong evidence suggests a vulnerability, but assumptions made can lead to these issues if any part of buffer size management changes without recognition in the future.\n\nThe assurance of safety depends heavily on correct assumptions about previous and subsequent operations that manage memory allocations and population for these sections.\n\nResult:\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 169",
        "commit_diff": "Diff:\n@@ -15,6 +15,12 @@\n \n #define ngx_proxy_protocol_parse_uint16(p)  ((p)[0] << 8 | (p)[1])\n \n+#define ngx_proxy_protocol_parse_uint32(p)                                    \\\n+    ( ((uint32_t) (p)[0] << 24)                                               \\\n+    + (           (p)[1] << 16)                                               \\\n+    + (           (p)[2] << 8)                                                \\\n+    + (           (p)[3]) )\n+\n \n typedef struct {\n     u_char                                  signature[12];\n@@ -40,12 +46,52 @@ typedef struct {\n } ngx_proxy_protocol_inet6_addrs_t;\n \n \n+typedef struct {\n+    u_char                                  type;\n+    u_char                                  len[2];\n+} ngx_proxy_protocol_tlv_t;\n+\n+\n+typedef struct {\n+    u_char                                  client;\n+    u_char                                  verify[4];\n+} ngx_proxy_protocol_tlv_ssl_t;\n+\n+\n+typedef struct {\n+    ngx_str_t                               name;\n+    ngx_uint_t                              type;\n+} ngx_proxy_protocol_tlv_entry_t;\n+\n+\n static u_char *ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p,\n     u_char *last, ngx_str_t *addr);\n static u_char *ngx_proxy_protocol_read_port(u_char *p, u_char *last,\n     in_port_t *port, u_char sep);\n static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n+static ngx_int_t ngx_proxy_protocol_lookup_tlv(ngx_connection_t *c,\n+    ngx_str_t *tlvs, ngx_uint_t type, ngx_str_t *value);\n+\n+\n+static ngx_proxy_protocol_tlv_entry_t  ngx_proxy_protocol_tlv_entries[] = {\n+    { ngx_string(\"alpn\"),       0x01 },\n+    { ngx_string(\"authority\"),  0x02 },\n+    { ngx_string(\"unique_id\"),  0x05 },\n+    { ngx_string(\"ssl\"),        0x20 },\n+    { ngx_string(\"netns\"),      0x30 },\n+    { ngx_null_string,          0x00 }\n+};\n+\n+\n+static ngx_proxy_protocol_tlv_entry_t  ngx_proxy_protocol_tlv_ssl_entries[] = {\n+    { ngx_string(\"version\"),    0x21 },\n+    { ngx_string(\"cn\"),         0x22 },\n+    { ngx_string(\"cipher\"),     0x23 },\n+    { ngx_string(\"sig_alg\"),    0x24 },\n+    { ngx_string(\"key_alg\"),    0x25 },\n+    { ngx_null_string,          0x00 }\n+};\n \n \n u_char *\n@@ -418,11 +464,147 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n                    &pp->src_addr, pp->src_port, &pp->dst_addr, pp->dst_port);\n \n     if (buf < end) {\n-        ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                       \"PROXY protocol v2 %z bytes of tlv ignored\", end - buf);\n+        pp->tlvs.data = ngx_pnalloc(c->pool, end - buf);\n+        if (pp->tlvs.data == NULL) {\n+            return NULL;\n+        }\n+\n+        ngx_memcpy(pp->tlvs.data, buf, end - buf);\n+        pp->tlvs.len = end - buf;\n     }\n \n     c->proxy_protocol = pp;\n \n     return end;\n }\n+\n+\n+ngx_int_t\n+ngx_proxy_protocol_get_tlv(ngx_connection_t *c, ngx_str_t *name,\n+    ngx_str_t *value)\n+{\n+    u_char                          *p;\n+    size_t                           n;\n+    uint32_t                         verify;\n+    ngx_str_t                        ssl, *tlvs;\n+    ngx_int_t                        rc, type;\n+    ngx_proxy_protocol_tlv_ssl_t    *tlv_ssl;\n+    ngx_proxy_protocol_tlv_entry_t  *te;\n+\n+    if (c->proxy_protocol == NULL) {\n+        return NGX_DECLINED;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol v2 get tlv \\\"%V\\\"\", name);\n+\n+    te = ngx_proxy_protocol_tlv_entries;\n+    tlvs = &c->proxy_protocol->tlvs;\n+\n+    p = name->data;\n+    n = name->len;\n+\n+    if (n >= 4 && p[0] == 's' && p[1] == 's' && p[2] == 'l' && p[3] == '_') {\n+\n+        rc = ngx_proxy_protocol_lookup_tlv(c, tlvs, 0x20, &ssl);\n+        if (rc != NGX_OK) {\n+            return rc;\n+        }\n+\n+        if (ssl.len < sizeof(ngx_proxy_protocol_tlv_ssl_t)) {\n+            return NGX_ERROR;\n+        }\n+\n+        p += 4;\n+        n -= 4;\n+\n+        if (n == 6 && ngx_strncmp(p, \"verify\", 6) == 0) {\n+\n+            tlv_ssl = (ngx_proxy_protocol_tlv_ssl_t *) ssl.data;\n+            verify = ngx_proxy_protocol_parse_uint32(tlv_ssl->verify);\n+\n+            value->data = ngx_pnalloc(c->pool, NGX_INT32_LEN);\n+            if (value->data == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            value->len = ngx_sprintf(value->data, \"%uD\", verify)\n+                         - value->data;\n+            return NGX_OK;\n+        }\n+\n+        ssl.data += sizeof(ngx_proxy_protocol_tlv_ssl_t);\n+        ssl.len -= sizeof(ngx_proxy_protocol_tlv_ssl_t);\n+\n+        te = ngx_proxy_protocol_tlv_ssl_entries;\n+        tlvs = &ssl;\n+    }\n+\n+    if (n >= 2 && p[0] == '0' && p[1] == 'x') {\n+\n+        type = ngx_hextoi(p + 2, n - 2);\n+        if (type == NGX_ERROR) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                          \"invalid PROXY protocol TLV \\\"%V\\\"\", name);\n+            return NGX_ERROR;\n+        }\n+\n+        return ngx_proxy_protocol_lookup_tlv(c, tlvs, type, value);\n+    }\n+\n+    for ( /* void */ ; te->type; te++) {\n+        if (te->name.len == n && ngx_strncmp(te->name.data, p, n) == 0) {\n+            return ngx_proxy_protocol_lookup_tlv(c, tlvs, te->type, value);\n+        }\n+    }\n+\n+    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                  \"unknown PROXY protocol TLV \\\"%V\\\"\", name);\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+static ngx_int_t\n+ngx_proxy_protocol_lookup_tlv(ngx_connection_t *c, ngx_str_t *tlvs,\n+    ngx_uint_t type, ngx_str_t *value)\n+{\n+    u_char                    *p;\n+    size_t                     n, len;\n+    ngx_proxy_protocol_tlv_t  *tlv;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol v2 lookup tlv:%02xi\", type);\n+\n+    p = tlvs->data;\n+    n = tlvs->len;\n+\n+    while (n) {\n+        if (n < sizeof(ngx_proxy_protocol_tlv_t)) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0, \"broken PROXY protocol TLV\");\n+            return NGX_ERROR;\n+        }\n+\n+        tlv = (ngx_proxy_protocol_tlv_t *) p;\n+        len = ngx_proxy_protocol_parse_uint16(tlv->len);\n+\n+        p += sizeof(ngx_proxy_protocol_tlv_t);\n+        n -= sizeof(ngx_proxy_protocol_tlv_t);\n+\n+        if (n < len) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0, \"broken PROXY protocol TLV\");\n+            return NGX_ERROR;\n+        }\n+\n+        if (tlv->type == type) {\n+            value->data = p;\n+            value->len = len;\n+            return NGX_OK;\n+        }\n+\n+        p += len;\n+        n -= len;\n+    }\n+\n+    return NGX_DECLINED;\n+}\nDiff:\n@@ -21,13 +21,16 @@ struct ngx_proxy_protocol_s {\n     ngx_str_t           dst_addr;\n     in_port_t           src_port;\n     in_port_t           dst_port;\n+    ngx_str_t           tlvs;\n };\n \n \n u_char *ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n u_char *ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n+ngx_int_t ngx_proxy_protocol_get_tlv(ngx_connection_t *c, ngx_str_t *name,\n+    ngx_str_t *value);\n \n \n #endif /* _NGX_PROXY_PROTOCOL_H_INCLUDED_ */\nDiff:\n@@ -65,6 +65,8 @@ static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_http_variable_proxy_protocol_tlv(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r,\n@@ -218,6 +220,10 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n       ngx_http_variable_proxy_protocol_port,\n       offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n+    { ngx_string(\"proxy_protocol_tlv_\"), NULL,\n+      ngx_http_variable_proxy_protocol_tlv,\n+      0, NGX_HTTP_VAR_PREFIX, 0 },\n+\n     { ngx_string(\"server_addr\"), NULL, ngx_http_variable_server_addr, 0, 0, 0 },\n \n     { ngx_string(\"server_port\"), NULL, ngx_http_variable_server_port, 0, 0, 0 },\n@@ -1396,6 +1402,39 @@ ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n }\n \n \n+static ngx_int_t\n+ngx_http_variable_proxy_protocol_tlv(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    ngx_str_t *name = (ngx_str_t *) data;\n+\n+    ngx_int_t  rc;\n+    ngx_str_t  tlv, value;\n+\n+    tlv.len = name->len - (sizeof(\"proxy_protocol_tlv_\") - 1);\n+    tlv.data = name->data + sizeof(\"proxy_protocol_tlv_\") - 1;\n+\n+    rc = ngx_proxy_protocol_get_tlv(r->connection, &tlv, &value);\n+\n+    if (rc == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (rc == NGX_DECLINED) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = value.len;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = value.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_variable_server_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\nDiff:\n@@ -23,6 +23,8 @@ static ngx_int_t ngx_stream_variable_proxy_protocol_addr(\n     ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_stream_variable_proxy_protocol_port(\n     ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_stream_variable_proxy_protocol_tlv(\n+    ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_stream_variable_server_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_stream_variable_server_port(ngx_stream_session_t *s,\n@@ -79,6 +81,10 @@ static ngx_stream_variable_t  ngx_stream_core_variables[] = {\n       ngx_stream_variable_proxy_protocol_port,\n       offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n+    { ngx_string(\"proxy_protocol_tlv_\"), NULL,\n+      ngx_stream_variable_proxy_protocol_tlv,\n+      0, NGX_STREAM_VAR_PREFIX, 0 },\n+\n     { ngx_string(\"server_addr\"), NULL,\n       ngx_stream_variable_server_addr, 0, 0, 0 },\n \n@@ -621,6 +627,39 @@ ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n }\n \n \n+static ngx_int_t\n+ngx_stream_variable_proxy_protocol_tlv(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data)\n+{\n+    ngx_str_t *name = (ngx_str_t *) data;\n+\n+    ngx_int_t  rc;\n+    ngx_str_t  tlv, value;\n+\n+    tlv.len = name->len - (sizeof(\"proxy_protocol_tlv_\") - 1);\n+    tlv.data = name->data + sizeof(\"proxy_protocol_tlv_\") - 1;\n+\n+    rc = ngx_proxy_protocol_get_tlv(s->connection, &tlv, &value);\n+\n+    if (rc == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (rc == NGX_DECLINED) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = value.len;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = value.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_stream_variable_server_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n",
        "analysis": "1. **Function `ngx_proxy_protocol_get_tlv`:**\n   - This function processes TLV entries. It retrieves TLV (Type-Length-Value) information based on a given name.\n   - The function interacts with \"tlvs\" and has multiple checks for types and lengths.\n   - There are no explicit buffer size definitions or use of unsafe functions like `strcpy`. However, it processes based on lengths extracted from data, which could be potentially concerning if length values are maliciously set.\n\n2. **Function `ngx_proxy_protocol_lookup_tlv`:**\n   - This function looks up TLV entries by type and fills in a value. It uses \"length\" values which are parsed from data.\n   - The while loop decreases `n` based on the parsed length of each entry. If `n` is less than expected, it logs an error and returns.\n   - There are bounds checks involved in this function, which is a positive sign. But if a malicious `len` is provided, it could potentially cause buffer issues.\n\n3. **Function `ngx_http_variable_proxy_protocol_tlv`:**\n   - This function gets TLV info and sets values for HTTP connection.\n   - Function directly assigns data to the structure `v`, which is accepted from another function.\n\n4. **Function `ngx_stream_variable_proxy_protocol_tlv`:**\n   - This function is similar to the `ngx_http_variable_proxy_protocol_tlv` function, aimed at stream connections.\n   - Like before, the function directly assigns data to `v` using information from another function.\n\nAll these `ngx_proxy_protocol_*` functions interact with TLV data and have checks for lengths and expected values, but excessive reliance on external functions for bounds safety and handling arbitrary data indicates some potential risks.\n\n**Verdict:**\nThere is potential for out-of-bounds write particularly in `ngx_proxy_protocol_get_tlv` and `ngx_proxy_protocol_lookup_tlv` due to parsing of user-manipulable data. The other two functions appear to be intermediaries simply assigning results but are less concerning individually.\n\nFinal Output:\n```\nTRUE [ngx_proxy_protocol_get_tlv] [ngx_proxy_protocol_lookup_tlv]\n```"
    },
    {
        "commit_index": "Commit 168",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@\n all:\n \tcd $(OPENSSL)\n \n-\tperl Configure VC-WIN32 no-shared\t\t\t\t\\\n+\tperl Configure VC-WIN32 no-shared no-threads\t\t\t\\\n \t\t--prefix=\"%cd%/openssl\" \t\t\t\t\\\n \t\t--openssldir=\"%cd%/openssl/ssl\" \t\t\t\\\n \t\t$(OPENSSL_OPT)\nDiff:\n@@ -139,8 +139,14 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n invalid:\n \n+    for (p = buf; p < last; p++) {\n+        if (*p == CR || *p == LF) {\n+            break;\n+        }\n+    }\n+\n     ngx_log_error(NGX_LOG_ERR, c->log, 0,\n-                  \"broken header: \\\"%*s\\\"\", (size_t) (last - buf), buf);\n+                  \"broken header: \\\"%*s\\\"\", (size_t) (p - buf), buf);\n \n     return NULL;\n }\nDiff:\n@@ -1428,7 +1428,7 @@ ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)\n \n #ifdef SSL_CTRL_SET_ECDH_AUTO\n     /* not needed in OpenSSL 1.1.0+ */\n-    SSL_CTX_set_ecdh_auto(ssl->ctx, 1);\n+    (void) SSL_CTX_set_ecdh_auto(ssl->ctx, 1);\n #endif\n \n     if (ngx_strcmp(name->data, \"auto\") == 0) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 167",
        "commit_diff": "Diff:\n@@ -231,9 +231,8 @@ ngx_iocp_del_connection(ngx_connection_t *c, ngx_uint_t flags)\n }\n \n \n-static\n-ngx_int_t ngx_iocp_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,\n-    ngx_uint_t flags)\n+static ngx_int_t\n+ngx_iocp_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n {\n     int                rc;\n     u_int              key;\n@@ -356,7 +355,7 @@ ngx_iocp_create_conf(ngx_cycle_t *cycle)\n \n     cf = ngx_palloc(cycle->pool, sizeof(ngx_iocp_conf_t));\n     if (cf == NULL) {\n-        return NGX_CONF_ERROR;\n+        return NULL;\n     }\n \n     cf->threads = NGX_CONF_UNSET;\nDiff:\n@@ -1426,7 +1426,7 @@ ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)\n \n     SSL_CTX_set_options(ssl->ctx, SSL_OP_SINGLE_ECDH_USE);\n \n-#if SSL_CTRL_SET_ECDH_AUTO\n+#ifdef SSL_CTRL_SET_ECDH_AUTO\n     /* not needed in OpenSSL 1.1.0+ */\n     SSL_CTX_set_ecdh_auto(ssl->ctx, 1);\n #endif\n@@ -1769,7 +1769,7 @@ ngx_ssl_handshake(ngx_connection_t *c)\n #endif\n #endif\n \n-#ifdef BIO_get_ktls_send\n+#if (defined BIO_get_ktls_send && !NGX_WIN32)\n \n         if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n             ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n@@ -1914,7 +1914,7 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->read->ready = 1;\n         c->write->ready = 1;\n \n-#ifdef BIO_get_ktls_send\n+#if (defined BIO_get_ktls_send && !NGX_WIN32)\n \n         if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n             ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n@@ -2943,7 +2943,7 @@ ngx_ssl_write_early(ngx_connection_t *c, u_char *data, size_t size)\n static ssize_t\n ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n {\n-#ifdef BIO_get_ktls_send\n+#if (defined BIO_get_ktls_send && !NGX_WIN32)\n \n     int        sslerr, flags;\n     ssize_t    n;\nDiff:\n@@ -80,8 +80,6 @@ typedef long  time_t;\n \n #pragma warning(default:4201)\n \n-/* disable some \"-W4\" level warnings */\n-\n /* 'type cast': from function pointer to data pointer */\n #pragma warning(disable:4054)\n \n@@ -106,6 +104,9 @@ typedef long  time_t;\n /* array is too small to include a terminating null character */\n #pragma warning(disable:4295)\n \n+/* conversion from 'type1' to 'type2' of greater size */\n+#pragma warning(disable:4306)\n+\n #endif\n \n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 166",
        "commit_diff": "Diff:\n@@ -468,3 +468,4 @@ bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n+a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\nDiff:\n@@ -5,6 +5,72 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.1\" date=\"2022-07-19\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+оптимизация использования памяти\n+в конфигурациях с SSL-проксированием.\n+</para>\n+<para lang=\"en\">\n+memory usage optimization\n+in configurations with SSL proxying.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь с помощью параметра \"ipv4=off\" директивы \"resolver\"\n+можно запретить поиск IPv4-адресов при преобразовании имён в адреса.\n+</para>\n+<para lang=\"en\">\n+looking up of IPv4 addresses while resolving now can be disabled\n+with the \"ipv4=off\" parameter of the \"resolver\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"bad key share\", \"bad extension\",\n+\"bad cipher\" и \"bad ecpoint\"\n+понижен с уровня crit до info.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"bad key share\", \"bad extension\",\n+\"bad cipher\", and \"bad ecpoint\" SSL errors\n+has been lowered from \"crit\" to \"info\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при возврате диапазонов\n+nginx не удалял строку заголовка \"Content-Range\",\n+если она присутствовала в исходном ответе бэкенда.\n+</para>\n+<para lang=\"en\">\n+while returning byte ranges\n+nginx did not remove the \"Content-Range\" header line\n+if it was present in the original backend response.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+проксированный ответ мог быть отправлен не полностью\n+при переконфигурации на Linux;\n+ошибка появилась в 1.17.5.\n+</para>\n+<para lang=\"en\">\n+a proxied response might be truncated\n+during reconfiguration on Linux;\n+the bug had appeared in 1.17.5.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.0\" date=\"2022-06-21\">\n \n <change>\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023001\n-#define NGINX_VERSION      \"1.23.1\"\n+#define nginx_version      1023002\n+#define NGINX_VERSION      \"1.23.2\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -3422,6 +3422,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n #ifdef SSL_R_VERSION_TOO_LOW\n             || n == SSL_R_VERSION_TOO_LOW                            /*  396 */\n+#endif\n+#ifdef SSL_R_BAD_RECORD_TYPE\n+            || n == SSL_R_BAD_RECORD_TYPE                            /*  443 */\n #endif\n             || n == 1000 /* SSL_R_SSLV3_ALERT_CLOSE_NOTIFY */\n #ifdef SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 165",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1p\n+OPENSSL =\topenssl-1.1.1q\n ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \nDiff:\n@@ -444,6 +444,10 @@ ngx_http_range_singlepart_header(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+    }\n+\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n@@ -601,6 +605,11 @@ ngx_http_range_multipart_header(ngx_http_request_t *r,\n         r->headers_out.content_length = NULL;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+        r->headers_out.content_range = NULL;\n+    }\n+\n     return ngx_http_next_header_filter(r);\n }\n \n@@ -617,6 +626,10 @@ ngx_http_range_not_satisfiable(ngx_http_request_t *r)\n         return NGX_ERROR;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+    }\n+\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\nDiff:\n@@ -28,6 +28,8 @@ static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_from(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,\n@@ -37,6 +39,8 @@ static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool,\n     ngx_uint_t alloc);\n+static ngx_int_t ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool,\n+    ngx_uint_t alloc);\n static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r,\n     ngx_str_t *host);\n static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,\n@@ -149,6 +153,10 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  offsetof(ngx_http_headers_in_t, expect),\n                  ngx_http_process_unique_header_line },\n \n+    { ngx_string(\"From\"),\n+                 offsetof(ngx_http_headers_in_t, from),\n+                 ngx_http_process_from },\n+\n     { ngx_string(\"Upgrade\"),\n                  offsetof(ngx_http_headers_in_t, upgrade),\n                  ngx_http_process_header_line },\n@@ -4028,6 +4036,144 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n }\n \n \n+static ngx_int_t\n+ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool, ngx_uint_t alloc)\n+{\n+    u_char  *f, *u, ch;\n+    size_t   i;\n+\n+    enum {\n+        sw_begin = 0,\n+        sw_username,\n+        sw_username_dot,\n+        sw_domain,\n+        sw_tld\n+    } state;\n+\n+    f = from->data;\n+\n+    state = sw_begin;\n+\n+    if (alloc) {\n+        u = ngx_palloc(pool, from->len);\n+\n+        if (u == NULL) {\n+            return NGX_ERROR;\n+        }\n+    } else {\n+        u = from->data;\n+    }\n+\n+    for (i = 0; i < from->len; i++) {\n+        ch = f[i];\n+\n+        switch (state) {\n+\n+        case sw_begin:\n+            if (isalnum(ch) || ch == '-' || ch == '_') {\n+                state = sw_username;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+            } else {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_username_dot:\n+            if (isalnum(ch) || ch == '-' || ch == '_') {\n+                *u++ = ch;\n+                state = sw_username;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+                u -= 2;\n+                for ( ;; ) {\n+                    if (*u == '.') {\n+                        u++;\n+                        break;\n+                    }\n+\n+                    u--;\n+                }\n+            } else {\n+                return NGX_DECLINED;\n+            }\n+            break;\n+\n+        case sw_username:\n+            if (ch == '@') {\n+                state = sw_domain;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+            } else if (!isalnum(ch) && ch != '-' && ch != '_' && ch != '+') {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_domain:\n+            if (ch == '.') {\n+                state = sw_tld;\n+            } else if (!isalnum(ch) && ch != '-') {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_tld:\n+            if (!isalpha(ch)) {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        default:\n+\n+            return NGX_DECLINED;\n+        }\n+    }\n+\n+    if (state == sw_tld) {\n+        *u = '\\0';\n+\n+        if (alloc) {\n+            from->data = u;\n+        }\n+        return NGX_OK;\n+    } else {\n+        return NGX_DECLINED;\n+    }\n+}\n+\n+static ngx_int_t\n+ngx_http_process_from(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    ngx_str_t  from;\n+\n+    if (r->headers_in.from) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate from header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.from->key,\n+                      &r->headers_in.from->value);\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    r->headers_in.from = h;\n+\n+    from = h->value;\n+\n+    if (ngx_http_validate_from(&from, r->pool, 1) != NGX_OK) {\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_trace_handler(ngx_http_request_t *r)\n {\nDiff:\n@@ -192,6 +192,7 @@ typedef struct {\n     ngx_table_elt_t                  *user_agent;\n     ngx_table_elt_t                  *prefer;\n     ngx_table_elt_t                  *referer;\n+    ngx_table_elt_t                  *from;\n     ngx_table_elt_t                  *content_length;\n     ngx_table_elt_t                  *content_range;\n     ngx_table_elt_t                  *content_type;\nDiff:\n@@ -46,6 +46,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n                 return 0;\n \n             } else {\n+                rev->ready = 0;\n                 return NGX_AGAIN;\n             }\n         }\n@@ -63,6 +64,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n                        rev->pending_eof, rev->available);\n \n         if (rev->available == 0 && !rev->pending_eof) {\n+            rev->ready = 0;\n             return NGX_AGAIN;\n         }\n     }\n",
        "analysis": "Analyzing the provided diff, there are two newly added entire functions: `ngx_http_validate_from` and `ngx_http_process_from`.\n\nLet's analyze them one by one:\n\n1. **Function `ngx_http_validate_from`:**\n\n   - This function aims to validate an email-like address structure from a `ngx_str_t` by checking the characters and state transitions.\n   - The buffer `u` is allocated based on `from->len` if `alloc` is true. This seems safe, but we need to verify the controlled variables in the loop.\n   - The input `from->data` is processed character by character in a `for` loop. The character content is validated by different condition checks (like `isalnum`).\n   - Each valid character is copied into `u` using `*u++ = ch;`.\n   - The key point to check is if `u` can move beyond its allocated space. There is a decrement in position when state changes (like `u -= 2;` and subsequent loop), which could potentially lead to buffer miscalculation if incorrect, but doesn't appear to directly lead to out-of-bounds due to state control.\n   - Unlike areas that directly expand the buffer size, this function mainly checks and copies. The calculated positions are controlled, suggesting a reduced risk of out-of-bounds.\n\n2. **Function `ngx_http_process_from`:**\n\n   - This function processes the \"From\" header and uses the `ngx_http_validate_from` function for validation.\n   - It checks whether the `from` header is already present and logs a corresponding message if so.\n   - The header value is validated with `ngx_http_validate_from`. If validation fails, the function finalizes the request with a bad request error.\n   - Buffer assignment happens with `r->headers_in.from = h;` without additional memory operations.\n\nBoth functions are well-structured with state validation and use allocated memory responsibly, reducing the immediate concern for out-of-bounds writes based solely on this diff.\n\nHowever, given a malicious user, potential edge cases like input pattern exploitation could occur if nuanced checks are missed. Therefore, hypothetical suspicion can't be fully ruled out without exhaustive context and testing.\n\nTherefore, based on the requirements and given analysis, the functions don't exhibit clear out-of-bounds write potential but can't be dismissed outright under assumptions of extreme malicious inputs due to typical vulnerabilities in managing character by character transitions.\n\n**Result:**\n```\nTRUE [ngx_http_validate_from] [ngx_http_process_from]\n```"
    },
    {
        "commit_index": "Commit 164",
        "commit_diff": "Diff:\n@@ -157,6 +157,8 @@ ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)\n     cln->handler = ngx_resolver_cleanup;\n     cln->data = r;\n \n+    r->ipv4 = 1;\n+\n     ngx_rbtree_init(&r->name_rbtree, &r->name_sentinel,\n                     ngx_resolver_rbtree_insert_value);\n \n@@ -225,6 +227,23 @@ ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)\n         }\n \n #if (NGX_HAVE_INET6)\n+        if (ngx_strncmp(names[i].data, \"ipv4=\", 5) == 0) {\n+\n+            if (ngx_strcmp(&names[i].data[5], \"on\") == 0) {\n+                r->ipv4 = 1;\n+\n+            } else if (ngx_strcmp(&names[i].data[5], \"off\") == 0) {\n+                r->ipv4 = 0;\n+\n+            } else {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid parameter: %V\", &names[i]);\n+                return NULL;\n+            }\n+\n+            continue;\n+        }\n+\n         if (ngx_strncmp(names[i].data, \"ipv6=\", 5) == 0) {\n \n             if (ngx_strcmp(&names[i].data[5], \"on\") == 0) {\n@@ -273,6 +292,14 @@ ngx_resolver_create(ngx_conf_t *cf, ngx_str_t *names, ngx_uint_t n)\n         }\n     }\n \n+#if (NGX_HAVE_INET6)\n+    if (r->ipv4 + r->ipv6 == 0) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"\\\"ipv4\\\" and \\\"ipv6\\\" cannot both be \\\"off\\\"\");\n+        return NULL;\n+    }\n+#endif\n+\n     if (n && r->connections.nelts == 0) {\n         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"no name servers defined\");\n         return NULL;\n@@ -836,7 +863,7 @@ ngx_resolve_name_locked(ngx_resolver_t *r, ngx_resolver_ctx_t *ctx,\n         r->last_connection = 0;\n     }\n \n-    rn->naddrs = (u_short) -1;\n+    rn->naddrs = r->ipv4 ? (u_short) -1 : 0;\n     rn->tcp = 0;\n #if (NGX_HAVE_INET6)\n     rn->naddrs6 = r->ipv6 ? (u_short) -1 : 0;\n@@ -1263,7 +1290,7 @@ ngx_resolver_send_query(ngx_resolver_t *r, ngx_resolver_node_t *rn)\n         rec->log.action = \"resolving\";\n     }\n \n-    if (rn->naddrs == (u_short) -1) {\n+    if (rn->query && rn->naddrs == (u_short) -1) {\n         rc = rn->tcp ? ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen)\n                      : ngx_resolver_send_udp_query(r, rec, rn->query, rn->qlen);\n \n@@ -1765,10 +1792,13 @@ ngx_resolver_process_response(ngx_resolver_t *r, u_char *buf, size_t n,\n              q = ngx_queue_next(q))\n         {\n             rn = ngx_queue_data(q, ngx_resolver_node_t, queue);\n-            qident = (rn->query[0] << 8) + rn->query[1];\n \n-            if (qident == ident) {\n-                goto dns_error_name;\n+            if (rn->query) {\n+                qident = (rn->query[0] << 8) + rn->query[1];\n+\n+                if (qident == ident) {\n+                    goto dns_error_name;\n+                }\n             }\n \n #if (NGX_HAVE_INET6)\n@@ -3645,7 +3675,7 @@ ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,\n     len = sizeof(ngx_resolver_hdr_t) + nlen + sizeof(ngx_resolver_qs_t);\n \n #if (NGX_HAVE_INET6)\n-    p = ngx_resolver_alloc(r, r->ipv6 ? len * 2 : len);\n+    p = ngx_resolver_alloc(r, len * (r->ipv4 + r->ipv6));\n #else\n     p = ngx_resolver_alloc(r, len);\n #endif\n@@ -3658,19 +3688,21 @@ ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,\n \n #if (NGX_HAVE_INET6)\n     if (r->ipv6) {\n-        rn->query6 = p + len;\n+        rn->query6 = r->ipv4 ? (p + len) : p;\n     }\n #endif\n \n     query = (ngx_resolver_hdr_t *) p;\n \n-    ident = ngx_random();\n+    if (r->ipv4) {\n+        ident = ngx_random();\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,\n-                   \"resolve: \\\"%V\\\" A %i\", name, ident & 0xffff);\n+        ngx_log_debug2(NGX_LOG_DEBUG_CORE, r->log, 0,\n+                       \"resolve: \\\"%V\\\" A %i\", name, ident & 0xffff);\n \n-    query->ident_hi = (u_char) ((ident >> 8) & 0xff);\n-    query->ident_lo = (u_char) (ident & 0xff);\n+        query->ident_hi = (u_char) ((ident >> 8) & 0xff);\n+        query->ident_lo = (u_char) (ident & 0xff);\n+    }\n \n     /* recursion query */\n     query->flags_hi = 1; query->flags_lo = 0;\n@@ -3731,7 +3763,9 @@ ngx_resolver_create_name_query(ngx_resolver_t *r, ngx_resolver_node_t *rn,\n \n     p = rn->query6;\n \n-    ngx_memcpy(p, rn->query, rn->qlen);\n+    if (r->ipv4) {\n+        ngx_memcpy(p, rn->query, rn->qlen);\n+    }\n \n     query = (ngx_resolver_hdr_t *) p;\n \nDiff:\n@@ -175,8 +175,10 @@ struct ngx_resolver_s {\n     ngx_queue_t               srv_expire_queue;\n     ngx_queue_t               addr_expire_queue;\n \n+    unsigned                  ipv4:1;\n+\n #if (NGX_HAVE_INET6)\n-    ngx_uint_t                ipv6;                 /* unsigned  ipv6:1; */\n+    unsigned                  ipv6:1;\n     ngx_rbtree_t              addr6_rbtree;\n     ngx_rbtree_node_t         addr6_sentinel;\n     ngx_queue_t               addr6_resend_queue;\nDiff:\n@@ -3343,6 +3343,12 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_NO_SUITABLE_KEY_SHARE\n             || n == SSL_R_NO_SUITABLE_KEY_SHARE                      /*  101 */\n #endif\n+#ifdef SSL_R_BAD_KEY_SHARE\n+            || n == SSL_R_BAD_KEY_SHARE                              /*  108 */\n+#endif\n+#ifdef SSL_R_BAD_EXTENSION\n+            || n == SSL_R_BAD_EXTENSION                              /*  110 */\n+#endif\n #ifdef SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM\n             || n == SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM            /*  118 */\n #endif\n@@ -3357,6 +3363,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n             || n == SSL_R_NO_CIPHERS_PASSED                          /*  182 */\n #endif\n             || n == SSL_R_NO_CIPHERS_SPECIFIED                       /*  183 */\n+#ifdef SSL_R_BAD_CIPHER\n+            || n == SSL_R_BAD_CIPHER                                 /*  186 */\n+#endif\n             || n == SSL_R_NO_COMPRESSION_SPECIFIED                   /*  187 */\n             || n == SSL_R_NO_SHARED_CIPHER                           /*  193 */\n             || n == SSL_R_RECORD_LENGTH_MISMATCH                     /*  213 */\n@@ -3391,6 +3400,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #ifdef SSL_R_APPLICATION_DATA_ON_SHUTDOWN\n             || n == SSL_R_APPLICATION_DATA_ON_SHUTDOWN               /*  291 */\n #endif\n+#ifdef SSL_R_BAD_ECPOINT\n+            || n == SSL_R_BAD_ECPOINT                                /*  306 */\n+#endif\n #ifdef SSL_R_RENEGOTIATE_EXT_TOO_LONG\n             || n == SSL_R_RENEGOTIATE_EXT_TOO_LONG                   /*  335 */\n             || n == SSL_R_RENEGOTIATION_ENCODING_ERR                 /*  336 */\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 163",
        "commit_diff": "Diff:\n@@ -209,6 +209,8 @@ static char *ngx_http_grpc_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n static char *ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n     void *data);\n+static ngx_int_t ngx_http_grpc_merge_ssl(ngx_conf_t *cf,\n+    ngx_http_grpc_loc_conf_t *conf, ngx_http_grpc_loc_conf_t *prev);\n static ngx_int_t ngx_http_grpc_set_ssl(ngx_conf_t *cf,\n     ngx_http_grpc_loc_conf_t *glcf);\n #endif\n@@ -562,7 +564,7 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n         ctx->host = glcf->host;\n \n #if (NGX_HTTP_SSL)\n-        u->ssl = (glcf->upstream.ssl != NULL);\n+        u->ssl = glcf->ssl;\n \n         if (u->ssl) {\n             ngx_str_set(&u->schema, \"grpcs://\");\n@@ -4463,6 +4465,10 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_HTTP_SSL)\n \n+    if (ngx_http_grpc_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,\n                               prev->upstream.ssl_session_reuse, 1);\n \n@@ -4524,7 +4530,7 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->grpc_values = prev->grpc_values;\n \n #if (NGX_HTTP_SSL)\n-        conf->upstream.ssl = prev->upstream.ssl;\n+        conf->ssl = prev->ssl;\n #endif\n     }\n \n@@ -4874,16 +4880,62 @@ ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n \n \n static ngx_int_t\n-ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n+ngx_http_grpc_merge_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *conf,\n+    ngx_http_grpc_loc_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->upstream.ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->upstream.ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->upstream.ssl) {\n+            conf->upstream.ssl = prev->upstream.ssl;\n+            return NGX_OK;\n+        }\n \n-    glcf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (glcf->upstream.ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->upstream.ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    glcf->upstream.ssl->log = cf->log;\n+    conf->upstream.ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->upstream.ssl\n+     * in the \"http\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->upstream.ssl = conf->upstream.ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (glcf->upstream.ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(glcf->upstream.ssl, glcf->ssl_protocols, NULL)\n         != NGX_OK)\nDiff:\n@@ -236,6 +236,8 @@ static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf,\n     ngx_http_proxy_rewrite_t *pr, ngx_str_t *regex, ngx_uint_t caseless);\n \n #if (NGX_HTTP_SSL)\n+static ngx_int_t ngx_http_proxy_merge_ssl(ngx_conf_t *cf,\n+    ngx_http_proxy_loc_conf_t *conf, ngx_http_proxy_loc_conf_t *prev);\n static ngx_int_t ngx_http_proxy_set_ssl(ngx_conf_t *cf,\n     ngx_http_proxy_loc_conf_t *plcf);\n #endif\n@@ -959,7 +961,7 @@ ngx_http_proxy_handler(ngx_http_request_t *r)\n         ctx->vars = plcf->vars;\n         u->schema = plcf->vars.schema;\n #if (NGX_HTTP_SSL)\n-        u->ssl = (plcf->upstream.ssl != NULL);\n+        u->ssl = plcf->ssl;\n #endif\n \n     } else {\n@@ -3724,6 +3726,10 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_HTTP_SSL)\n \n+    if (ngx_http_proxy_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,\n                               prev->upstream.ssl_session_reuse, 1);\n \n@@ -3857,7 +3863,7 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->proxy_values = prev->proxy_values;\n \n #if (NGX_HTTP_SSL)\n-        conf->upstream.ssl = prev->upstream.ssl;\n+        conf->ssl = prev->ssl;\n #endif\n     }\n \n@@ -4923,16 +4929,62 @@ ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n \n \n static ngx_int_t\n-ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n+ngx_http_proxy_merge_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *conf,\n+    ngx_http_proxy_loc_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->upstream.ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->upstream.ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->upstream.ssl) {\n+            conf->upstream.ssl = prev->upstream.ssl;\n+            return NGX_OK;\n+        }\n \n-    plcf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (plcf->upstream.ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->upstream.ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    plcf->upstream.ssl->log = cf->log;\n+    conf->upstream.ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->upstream.ssl\n+     * in the \"http\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->upstream.ssl = conf->upstream.ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (plcf->upstream.ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(plcf->upstream.ssl, plcf->ssl_protocols, NULL)\n         != NGX_OK)\nDiff:\n@@ -96,6 +96,8 @@ static char *ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n static char *ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n     void *data);\n+static ngx_int_t ngx_http_uwsgi_merge_ssl(ngx_conf_t *cf,\n+    ngx_http_uwsgi_loc_conf_t *conf, ngx_http_uwsgi_loc_conf_t *prev);\n static ngx_int_t ngx_http_uwsgi_set_ssl(ngx_conf_t *cf,\n     ngx_http_uwsgi_loc_conf_t *uwcf);\n #endif\n@@ -668,7 +670,7 @@ ngx_http_uwsgi_handler(ngx_http_request_t *r)\n     if (uwcf->uwsgi_lengths == NULL) {\n \n #if (NGX_HTTP_SSL)\n-        u->ssl = (uwcf->upstream.ssl != NULL);\n+        u->ssl = uwcf->ssl;\n \n         if (u->ssl) {\n             ngx_str_set(&u->schema, \"suwsgi://\");\n@@ -1865,6 +1867,10 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_HTTP_SSL)\n \n+    if (ngx_http_uwsgi_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,\n                               prev->upstream.ssl_session_reuse, 1);\n \n@@ -1927,7 +1933,7 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->uwsgi_values = prev->uwsgi_values;\n \n #if (NGX_HTTP_SSL)\n-        conf->upstream.ssl = prev->upstream.ssl;\n+        conf->ssl = prev->ssl;\n #endif\n     }\n \n@@ -2455,16 +2461,62 @@ ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n \n \n static ngx_int_t\n-ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n+ngx_http_uwsgi_merge_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *conf,\n+    ngx_http_uwsgi_loc_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->upstream.ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->upstream.ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->upstream.ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->upstream.ssl) {\n+            conf->upstream.ssl = prev->upstream.ssl;\n+            return NGX_OK;\n+        }\n \n-    uwcf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (uwcf->upstream.ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->upstream.ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->upstream.ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    uwcf->upstream.ssl->log = cf->log;\n+    conf->upstream.ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->upstream.ssl\n+     * in the \"http\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->upstream.ssl = conf->upstream.ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (uwcf->upstream.ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(uwcf->upstream.ssl, uwcf->ssl_protocols, NULL)\n         != NGX_OK)\nDiff:\n@@ -103,6 +103,8 @@ static void ngx_stream_proxy_ssl_handshake(ngx_connection_t *pc);\n static void ngx_stream_proxy_ssl_save_session(ngx_connection_t *c);\n static ngx_int_t ngx_stream_proxy_ssl_name(ngx_stream_session_t *s);\n static ngx_int_t ngx_stream_proxy_ssl_certificate(ngx_stream_session_t *s);\n+static ngx_int_t ngx_stream_proxy_merge_ssl(ngx_conf_t *cf,\n+    ngx_stream_proxy_srv_conf_t *conf, ngx_stream_proxy_srv_conf_t *prev);\n static ngx_int_t ngx_stream_proxy_set_ssl(ngx_conf_t *cf,\n     ngx_stream_proxy_srv_conf_t *pscf);\n \n@@ -801,7 +803,7 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n \n #if (NGX_STREAM_SSL)\n \n-    if (pc->type == SOCK_STREAM && pscf->ssl) {\n+    if (pc->type == SOCK_STREAM && pscf->ssl_enable) {\n \n         if (u->proxy_protocol) {\n             if (ngx_stream_proxy_send_proxy_protocol(s) != NGX_OK) {\n@@ -2150,6 +2152,10 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #if (NGX_STREAM_SSL)\n \n+    if (ngx_stream_proxy_merge_ssl(cf, conf, prev) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_conf_merge_value(conf->ssl_enable, prev->ssl_enable, 0);\n \n     ngx_conf_merge_value(conf->ssl_session_reuse,\n@@ -2199,16 +2205,62 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n #if (NGX_STREAM_SSL)\n \n static ngx_int_t\n-ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n+ngx_stream_proxy_merge_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *conf,\n+    ngx_stream_proxy_srv_conf_t *prev)\n {\n-    ngx_pool_cleanup_t  *cln;\n+    ngx_uint_t  preserve;\n+\n+    if (conf->ssl_protocols == 0\n+        && conf->ssl_ciphers.data == NULL\n+        && conf->ssl_certificate == NGX_CONF_UNSET_PTR\n+        && conf->ssl_certificate_key == NGX_CONF_UNSET_PTR\n+        && conf->ssl_passwords == NGX_CONF_UNSET_PTR\n+        && conf->ssl_verify == NGX_CONF_UNSET\n+        && conf->ssl_verify_depth == NGX_CONF_UNSET_UINT\n+        && conf->ssl_trusted_certificate.data == NULL\n+        && conf->ssl_crl.data == NULL\n+        && conf->ssl_session_reuse == NGX_CONF_UNSET\n+        && conf->ssl_conf_commands == NGX_CONF_UNSET_PTR)\n+    {\n+        if (prev->ssl) {\n+            conf->ssl = prev->ssl;\n+            return NGX_OK;\n+        }\n \n-    pscf->ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n-    if (pscf->ssl == NULL) {\n+        preserve = 1;\n+\n+    } else {\n+        preserve = 0;\n+    }\n+\n+    conf->ssl = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_t));\n+    if (conf->ssl == NULL) {\n         return NGX_ERROR;\n     }\n \n-    pscf->ssl->log = cf->log;\n+    conf->ssl->log = cf->log;\n+\n+    /*\n+     * special handling to preserve conf->ssl\n+     * in the \"stream\" section to inherit it to all servers\n+     */\n+\n+    if (preserve) {\n+        prev->ssl = conf->ssl;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n+{\n+    ngx_pool_cleanup_t  *cln;\n+\n+    if (pscf->ssl->ctx) {\n+        return NGX_OK;\n+    }\n \n     if (ngx_ssl_create(pscf->ssl, pscf->ssl_protocols, NULL) != NGX_OK) {\n         return NGX_ERROR;\n",
        "analysis": "Analyzing the diff for newly added entire functions in the code:\n\n1. **Function: ngx_http_grpc_merge_ssl**\n   - Analyzing this function, it allocates memory for `conf->upstream.ssl` using `ngx_pcalloc`.\n   - The function properly checks if `conf->upstream.ssl` is NULL after allocation before proceeding.\n   - It does not seem to directly manipulate arrays or buffers which could directly lead to out-of-bounds write.\n   - The logic involves conditions that set values based on comparisons but handles pointers rather cautiously.\n\n2. **Function: ngx_http_proxy_merge_ssl**\n   - Similar to the previous function, this one also allocates memory for `conf->upstream.ssl` using `ngx_pcalloc`.\n   - Checks for nullity after allocation ensure there is no straightforward possibility for out-of-bounds writes.\n   - Again, there is no direct manipulation of fixed-size buffers that would indicate a risk for out-of-bounds writes.\n\n3. **Function: ngx_http_uwsgi_merge_ssl**\n   - This function is similar in structure to the previous two, involving memory allocation and logical checks.\n   - Similarly, it checks if the allocation for `conf->upstream.ssl` succeeds before proceeding.\n   - It does not inherently manipulate fixed-size buffers directly from user input.\n\n4. **Function: ngx_stream_proxy_merge_ssl**\n   - This function also follows the pattern observed in other functions, allocating and checking memory for `conf->ssl`.\n   - Similar checks for nullity after allocation and no direct user input into buffer manipulation ensure safety.\n   - Like others, no immediate indicators for out-of-bounds write vulnerabilities.\n\nConclusively, while these functions involve memory allocation and some conditional logic, they appear to maintain safeguards against out-of-bounds writes by checking pointers after allocation and avoiding direct manipulations of fixed-size buffers from user input. Therefore no particularly suspicious functions were identified from this analysis.\n\nFALSE"
    },
    {
        "commit_index": "Commit 162",
        "commit_diff": "Diff:\n@@ -467,3 +467,4 @@ bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\n d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n+5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\nDiff:\n@@ -5,6 +5,107 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.0\" date=\"2022-06-21\">\n+\n+<change>\n+<para lang=\"ru\">\n+Изменение во внутреннем API:\n+теперь строки заголовков представлены связными списками.\n+</para>\n+<para lang=\"en\">\n+Change in internal API:\n+now header lines are represented as linked lists.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx объединяет произвольные строки заголовков с одинаковыми именами\n+при отправке на FastCGI-, SCGI- и uwsgi-бэкенды,\n+в методе $r->header_in() модуля ngx_http_perl_module,\n+и при доступе через переменные \"$http_...\", \"$sent_http_...\",\n+\"$sent_trailer_...\", \"$upstream_http_...\" и \"$upstream_trailer_...\".\n+</para>\n+<para lang=\"en\">\n+now nginx combines arbitrary header lines with identical names\n+when sending to FastCGI, SCGI, and uwsgi backends,\n+in the $r->header_in() method of the ngx_http_perl_module,\n+and during lookup of the \"$http_...\", \"$sent_http_...\",\n+\"$sent_trailer_...\", \"$upstream_http_...\", and \"$upstream_trailer_...\"\n+variables.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если в заголовке ответа бэкенда было несколько строк \"Vary\",\n+при кэшировании nginx учитывал только последнюю из них.\n+</para>\n+<para lang=\"en\">\n+if there were multiple \"Vary\" header lines in the backend response,\n+nginx only used the last of them when caching.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если в заголовке ответа бэкенда было несколько строк \"WWW-Authenticate\"\n+и использовался перехват ошибок с кодом 401 от бэкенда\n+или директива auth_request,\n+nginx пересылал клиенту только первую из этих строк.\n+</para>\n+<para lang=\"en\">\n+if there were multiple \"WWW-Authenticate\" header lines in the backend response\n+and errors with code 401 were intercepted\n+or the \"auth_request\" directive was used,\n+nginx only sent the first of the header lines to the client.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"application data after close notify\"\n+понижен с уровня crit до info.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"application data after close notify\" SSL errors\n+has been lowered from \"crit\" to \"info\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+соединения могли зависать, если nginx был собран на Linux 2.6.17 и новее,\n+а использовался на системах без поддержки EPOLLRDHUP, в частности, на\n+системах с эмуляцией epoll;\n+ошибка появилась в 1.17.5.<br/>\n+Спасибо Marcus Ball.\n+</para>\n+<para lang=\"en\">\n+connections might hang if nginx was built on Linux 2.6.17 or newer,\n+but was used on systems without EPOLLRDHUP support, notably with epoll\n+emulation layers;\n+the bug had appeared in 1.17.5.<br/>\n+Thanks to Marcus Ball.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не кэшировал ответ,\n+если строка заголовка ответа \"Expires\" запрещала кэширование,\n+а последующая строка заголовка \"Cache-Control\" разрешала кэширование.\n+</para>\n+<para lang=\"en\">\n+nginx did not cache the response\n+if the \"Expires\" response header line disabled caching,\n+but following \"Cache-Control\" header line enabled caching.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.6\" date=\"2022-01-25\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023000\n-#define NGINX_VERSION      \"1.23.0\"\n+#define nginx_version      1023001\n+#define NGINX_VERSION      \"1.23.1\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 161",
        "commit_diff": "Diff:\n@@ -111,19 +111,14 @@ syn keyword ngxDirectiveControl contained set\n syn keyword ngxDirectiveError contained error_page\n syn keyword ngxDirectiveError contained post_action\n \n-syn keyword ngxDirectiveDeprecated contained limit_zone\n syn keyword ngxDirectiveDeprecated contained proxy_downstream_buffer\n syn keyword ngxDirectiveDeprecated contained proxy_upstream_buffer\n-syn keyword ngxDirectiveDeprecated contained spdy_chunk_size\n-syn keyword ngxDirectiveDeprecated contained spdy_headers_comp\n-syn keyword ngxDirectiveDeprecated contained spdy_keepalive_timeout\n-syn keyword ngxDirectiveDeprecated contained spdy_max_concurrent_streams\n-syn keyword ngxDirectiveDeprecated contained spdy_pool_size\n-syn keyword ngxDirectiveDeprecated contained spdy_recv_buffer_size\n-syn keyword ngxDirectiveDeprecated contained spdy_recv_timeout\n-syn keyword ngxDirectiveDeprecated contained spdy_streams_index_size\n syn keyword ngxDirectiveDeprecated contained ssl\n-syn keyword ngxDirectiveDeprecated contained upstream_conf\n+syn keyword ngxDirectiveDeprecated contained http2_idle_timeout\n+syn keyword ngxDirectiveDeprecated contained http2_max_field_size\n+syn keyword ngxDirectiveDeprecated contained http2_max_header_size\n+syn keyword ngxDirectiveDeprecated contained http2_max_requests\n+syn keyword ngxDirectiveDeprecated contained http2_recv_timeout\n \n syn keyword ngxDirective contained absolute_redirect\n syn keyword ngxDirective contained accept_mutex\n@@ -152,6 +147,7 @@ syn keyword ngxDirective contained auth_http_timeout\n syn keyword ngxDirective contained auth_jwt\n syn keyword ngxDirective contained auth_jwt_claim_set\n syn keyword ngxDirective contained auth_jwt_header_set\n+syn keyword ngxDirective contained auth_jwt_key_cache\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n@@ -309,17 +305,12 @@ syn keyword ngxDirective contained hls_mp4_buffer_size\n syn keyword ngxDirective contained hls_mp4_max_buffer_size\n syn keyword ngxDirective contained http2_body_preread_size\n syn keyword ngxDirective contained http2_chunk_size\n-syn keyword ngxDirective contained http2_idle_timeout\n syn keyword ngxDirective contained http2_max_concurrent_pushes\n syn keyword ngxDirective contained http2_max_concurrent_streams\n-syn keyword ngxDirective contained http2_max_field_size\n-syn keyword ngxDirective contained http2_max_header_size\n-syn keyword ngxDirective contained http2_max_requests\n syn keyword ngxDirective contained http2_pool_size\n syn keyword ngxDirective contained http2_push\n syn keyword ngxDirective contained http2_push_preload\n syn keyword ngxDirective contained http2_recv_buffer_size\n-syn keyword ngxDirective contained http2_recv_timeout\n syn keyword ngxDirective contained http2_streams_index_size\n syn keyword ngxDirective contained if_modified_since\n syn keyword ngxDirective contained ignore_invalid_headers\n@@ -339,14 +330,17 @@ syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n+syn keyword ngxDirective contained js_fetch_buffer_size\n syn keyword ngxDirective contained js_fetch_ciphers\n+syn keyword ngxDirective contained js_fetch_max_response_buffer_size\n syn keyword ngxDirective contained js_fetch_protocols\n+syn keyword ngxDirective contained js_fetch_timeout\n syn keyword ngxDirective contained js_fetch_trusted_certificate\n+syn keyword ngxDirective contained js_fetch_verify\n syn keyword ngxDirective contained js_fetch_verify_depth\n syn keyword ngxDirective contained js_filter\n syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n-syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n syn keyword ngxDirective contained js_set\n@@ -391,7 +385,6 @@ syn keyword ngxDirective contained max_ranges\n syn keyword ngxDirective contained memcached_bind\n syn keyword ngxDirective contained memcached_buffer_size\n syn keyword ngxDirective contained memcached_connect_timeout\n-syn keyword ngxDirective contained memcached_force_ranges\n syn keyword ngxDirective contained memcached_gzip_flag\n syn keyword ngxDirective contained memcached_next_upstream\n syn keyword ngxDirective contained memcached_next_upstream_timeout\n@@ -645,7 +638,6 @@ syn keyword ngxDirective contained status\n syn keyword ngxDirective contained status_format\n syn keyword ngxDirective contained status_zone\n syn keyword ngxDirective contained sticky\n-syn keyword ngxDirective contained sticky_cookie_insert\n syn keyword ngxDirective contained stub_status\n syn keyword ngxDirective contained sub_filter\n syn keyword ngxDirective contained sub_filter_last_modified\n@@ -774,62 +766,14 @@ syn keyword ngxDirective contained zone_sync_ssl_verify\n syn keyword ngxDirective contained zone_sync_ssl_verify_depth\n syn keyword ngxDirective contained zone_sync_timeout\n \n-\" 3rd party modules list taken from\n-\" https://github.com/freebsd/freebsd-ports/blob/master/www/nginx-devel/Makefile\n-\" -----------------------------------------------------------------------------\n-\n-\" Accept Language\n-\" https://github.com/giom/nginx_accept_language_module\n-syn keyword ngxDirectiveThirdParty contained set_from_accept_language\n-\n-\" Digest Authentication\n-\" https://github.com/atomx/nginx-http-auth-digest\n-syn keyword ngxDirectiveThirdParty contained auth_digest\n-syn keyword ngxDirectiveThirdParty contained auth_digest_drop_time\n-syn keyword ngxDirectiveThirdParty contained auth_digest_evasion_time\n-syn keyword ngxDirectiveThirdParty contained auth_digest_expires\n-syn keyword ngxDirectiveThirdParty contained auth_digest_maxtries\n-syn keyword ngxDirectiveThirdParty contained auth_digest_replays\n-syn keyword ngxDirectiveThirdParty contained auth_digest_shm_size\n-syn keyword ngxDirectiveThirdParty contained auth_digest_timeout\n-syn keyword ngxDirectiveThirdParty contained auth_digest_user_file\n-\n-\" SPNEGO Authentication\n-\" https://github.com/stnoonan/spnego-http-auth-nginx-module\n-syn keyword ngxDirectiveThirdParty contained auth_gss\n-syn keyword ngxDirectiveThirdParty contained auth_gss_allow_basic_fallback\n-syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n-syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal_regex\n-syn keyword ngxDirectiveThirdParty contained auth_gss_constrained_delegation\n-syn keyword ngxDirectiveThirdParty contained auth_gss_delegate_credentials\n-syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n-syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n-syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n-syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n-syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n-syn keyword ngxDirectiveThirdParty contained auth_gss_service_ccache\n-syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n-\n-\" LDAP Authentication\n-\" https://github.com/kvspb/nginx-auth-ldap\n-syn keyword ngxDirectiveThirdParty contained auth_ldap\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_enabled\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_expiration_time\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_size\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_servers\n-syn keyword ngxDirectiveThirdParty contained auth_ldap_servers_size\n-syn keyword ngxDirectiveThirdParty contained ldap_server\n \n-\" PAM Authentication\n-\" https://github.com/sto/ngx_http_auth_pam_module\n-syn keyword ngxDirectiveThirdParty contained auth_pam\n-syn keyword ngxDirectiveThirdParty contained auth_pam_service_name\n-syn keyword ngxDirectiveThirdParty contained auth_pam_set_pam_env\n+\" 3rd party modules list taken from\n+\" https://github.com/freebsd/freebsd-ports/blob/main/www/nginx-devel/Makefile.extmod\n+\" ----------------------------------------------------------------------------------\n \n-\" AJP protocol proxy\n-\" https://github.com/yaoweibin/nginx_ajp_module\n-syn keyword ngxDirectiveThirdParty contained ajp_buffers\n+\" https://github.com/msva/nginx_ajp_module\n syn keyword ngxDirectiveThirdParty contained ajp_buffer_size\n+syn keyword ngxDirectiveThirdParty contained ajp_buffers\n syn keyword ngxDirectiveThirdParty contained ajp_busy_buffers_size\n syn keyword ngxDirectiveThirdParty contained ajp_cache\n syn keyword ngxDirectiveThirdParty contained ajp_cache_key\n@@ -850,11 +794,13 @@ syn keyword ngxDirectiveThirdParty contained ajp_keep_conn\n syn keyword ngxDirectiveThirdParty contained ajp_max_data_packet_size\n syn keyword ngxDirectiveThirdParty contained ajp_max_temp_file_size\n syn keyword ngxDirectiveThirdParty contained ajp_next_upstream\n+syn keyword ngxDirectiveThirdParty contained ajp_param\n syn keyword ngxDirectiveThirdParty contained ajp_pass\n syn keyword ngxDirectiveThirdParty contained ajp_pass_header\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_body\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_headers\n syn keyword ngxDirectiveThirdParty contained ajp_read_timeout\n+syn keyword ngxDirectiveThirdParty contained ajp_script_url\n syn keyword ngxDirectiveThirdParty contained ajp_secret\n syn keyword ngxDirectiveThirdParty contained ajp_send_lowat\n syn keyword ngxDirectiveThirdParty contained ajp_send_timeout\n@@ -865,7 +811,12 @@ syn keyword ngxDirectiveThirdParty contained ajp_temp_path\n syn keyword ngxDirectiveThirdParty contained ajp_upstream_fail_timeout\n syn keyword ngxDirectiveThirdParty contained ajp_upstream_max_fails\n \n-\" AWS proxy\n+\" https://github.com/openresty/array-var-nginx-module\n+syn keyword ngxDirectiveThirdParty contained array_join\n+syn keyword ngxDirectiveThirdParty contained array_map\n+syn keyword ngxDirectiveThirdParty contained array_map_op\n+syn keyword ngxDirectiveThirdParty contained array_split\n+\n \" https://github.com/anomalizer/ngx_aws_auth\n syn keyword ngxDirectiveThirdParty contained aws_access_key\n syn keyword ngxDirectiveThirdParty contained aws_endpoint\n@@ -874,7 +825,18 @@ syn keyword ngxDirectiveThirdParty contained aws_s3_bucket\n syn keyword ngxDirectiveThirdParty contained aws_sign\n syn keyword ngxDirectiveThirdParty contained aws_signing_key\n \n-\" embedding Clojure or Java or Groovy programs\n+\" https://github.com/google/ngx_brotli\n+syn keyword ngxDirectiveThirdParty contained brotli\n+syn keyword ngxDirectiveThirdParty contained brotli_buffers\n+syn keyword ngxDirectiveThirdParty contained brotli_comp_level\n+syn keyword ngxDirectiveThirdParty contained brotli_min_length\n+syn keyword ngxDirectiveThirdParty contained brotli_static\n+syn keyword ngxDirectiveThirdParty contained brotli_types\n+syn keyword ngxDirectiveThirdParty contained brotli_window\n+\n+\" https://github.com/torden/ngx_cache_purge\n+syn keyword ngxDirectiveThirdParty contained cache_purge_response_type\n+\n \" https://github.com/nginx-clojure/nginx-clojure\n syn keyword ngxDirectiveThirdParty contained access_handler_code\n syn keyword ngxDirectiveThirdParty contained access_handler_name\n@@ -892,8 +854,8 @@ syn keyword ngxDirectiveThirdParty contained content_handler_property\n syn keyword ngxDirectiveThirdParty contained content_handler_type\n syn keyword ngxDirectiveThirdParty contained handler_code\n syn keyword ngxDirectiveThirdParty contained handler_name\n-syn keyword ngxDirectiveThirdParty contained handlers_lazy_init\n syn keyword ngxDirectiveThirdParty contained handler_type\n+syn keyword ngxDirectiveThirdParty contained handlers_lazy_init\n syn keyword ngxDirectiveThirdParty contained header_filter_code\n syn keyword ngxDirectiveThirdParty contained header_filter_name\n syn keyword ngxDirectiveThirdParty contained header_filter_property\n@@ -921,18 +883,20 @@ syn keyword ngxDirectiveThirdParty contained rewrite_handler_type\n syn keyword ngxDirectiveThirdParty contained shared_map\n syn keyword ngxDirectiveThirdParty contained write_page_size\n \n+\" https://github.com/AirisX/nginx_cookie_flag_module\n+syn keyword ngxDirectiveThirdParty contained set_cookie_flag\n \n-\" Certificate Transparency\n \" https://github.com/grahamedgecombe/nginx-ct\n syn keyword ngxDirectiveThirdParty contained ssl_ct\n syn keyword ngxDirectiveThirdParty contained ssl_ct_static_scts\n \n-\" ngx_echo\n \" https://github.com/openresty/echo-nginx-module\n+syn keyword ngxDirectiveThirdParty contained echo\n syn keyword ngxDirectiveThirdParty contained echo_abort_parent\n syn keyword ngxDirectiveThirdParty contained echo_after_body\n syn keyword ngxDirectiveThirdParty contained echo_before_body\n syn keyword ngxDirectiveThirdParty contained echo_blocking_sleep\n+syn keyword ngxDirectiveThirdParty contained echo_duplicate\n syn keyword ngxDirectiveThirdParty contained echo_end\n syn keyword ngxDirectiveThirdParty contained echo_exec\n syn keyword ngxDirectiveThirdParty contained echo_flush\n@@ -942,36 +906,131 @@ syn keyword ngxDirectiveThirdParty contained echo_location_async\n syn keyword ngxDirectiveThirdParty contained echo_read_request_body\n syn keyword ngxDirectiveThirdParty contained echo_request_body\n syn keyword ngxDirectiveThirdParty contained echo_reset_timer\n+syn keyword ngxDirectiveThirdParty contained echo_sleep\n syn keyword ngxDirectiveThirdParty contained echo_status\n syn keyword ngxDirectiveThirdParty contained echo_subrequest\n syn keyword ngxDirectiveThirdParty contained echo_subrequest_async\n \n-\" FastDFS\n-\" https://github.com/happyfish100/fastdfs-nginx-module\n-syn keyword ngxDirectiveThirdParty contained ngx_fastdfs_module\n+\" https://github.com/openresty/drizzle-nginx-module\n+syn keyword ngxDirectiveThirdParty contained drizzle_buffer_size\n+syn keyword ngxDirectiveThirdParty contained drizzle_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_dbname\n+syn keyword ngxDirectiveThirdParty contained drizzle_keepalive\n+syn keyword ngxDirectiveThirdParty contained drizzle_module_header\n+syn keyword ngxDirectiveThirdParty contained drizzle_pass\n+syn keyword ngxDirectiveThirdParty contained drizzle_query\n+syn keyword ngxDirectiveThirdParty contained drizzle_recv_cols_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_recv_rows_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_send_query_timeout\n+syn keyword ngxDirectiveThirdParty contained drizzle_server\n+syn keyword ngxDirectiveThirdParty contained drizzle_status\n+\n+\" https://github.com/ZigzagAK/ngx_dynamic_upstream\n+syn keyword ngxDirectiveThirdParty contained dns_add_down\n+syn keyword ngxDirectiveThirdParty contained dns_ipv6\n+syn keyword ngxDirectiveThirdParty contained dns_update\n+syn keyword ngxDirectiveThirdParty contained dynamic_state_file\n+syn keyword ngxDirectiveThirdParty contained dynamic_upstream\n+\n+\" https://github.com/ZigzagAK/ngx_dynamic_healthcheck\n+syn keyword ngxDirectiveThirdParty contained check\n+syn keyword ngxDirectiveThirdParty contained check_disable_host\n+syn keyword ngxDirectiveThirdParty contained check_exclude_host\n+syn keyword ngxDirectiveThirdParty contained check_persistent\n+syn keyword ngxDirectiveThirdParty contained check_request_body\n+syn keyword ngxDirectiveThirdParty contained check_request_headers\n+syn keyword ngxDirectiveThirdParty contained check_request_uri\n+syn keyword ngxDirectiveThirdParty contained check_response_body\n+syn keyword ngxDirectiveThirdParty contained check_response_codes\n+syn keyword ngxDirectiveThirdParty contained healthcheck\n+syn keyword ngxDirectiveThirdParty contained healthcheck_buffer_size\n+syn keyword ngxDirectiveThirdParty contained healthcheck_disable_host\n+syn keyword ngxDirectiveThirdParty contained healthcheck_get\n+syn keyword ngxDirectiveThirdParty contained healthcheck_persistent\n+syn keyword ngxDirectiveThirdParty contained healthcheck_request_body\n+syn keyword ngxDirectiveThirdParty contained healthcheck_request_headers\n+syn keyword ngxDirectiveThirdParty contained healthcheck_request_uri\n+syn keyword ngxDirectiveThirdParty contained healthcheck_response_body\n+syn keyword ngxDirectiveThirdParty contained healthcheck_response_codes\n+syn keyword ngxDirectiveThirdParty contained healthcheck_status\n+syn keyword ngxDirectiveThirdParty contained healthcheck_update\n+\n+\" https://github.com/openresty/encrypted-session-nginx-module\n+syn keyword ngxDirectiveThirdParty contained encrypted_session_expires\n+syn keyword ngxDirectiveThirdParty contained encrypted_session_iv\n+syn keyword ngxDirectiveThirdParty contained encrypted_session_key\n+syn keyword ngxDirectiveThirdParty contained set_decrypt_session\n+syn keyword ngxDirectiveThirdParty contained set_encrypt_session\n+\n+\" https://github.com/calio/form-input-nginx-module\n+syn keyword ngxDirectiveThirdParty contained set_form_input\n+syn keyword ngxDirectiveThirdParty contained set_form_input_multi\n+\n+\" https://github.com/nieoding/nginx-gridfs\n+syn keyword ngxDirectiveThirdParty contained gridfs\n+syn keyword ngxDirectiveThirdParty contained mongo\n \n-\" ngx_headers_more\n \" https://github.com/openresty/headers-more-nginx-module\n syn keyword ngxDirectiveThirdParty contained more_clear_headers\n syn keyword ngxDirectiveThirdParty contained more_clear_input_headers\n syn keyword ngxDirectiveThirdParty contained more_set_headers\n syn keyword ngxDirectiveThirdParty contained more_set_input_headers\n \n-\" NGINX WebDAV missing commands support (PROPFIND & OPTIONS)\n+\" https://github.com/dvershinin/nginx_accept_language_module\n+syn keyword ngxDirectiveThirdParty contained set_from_accept_language\n+\n+\" https://github.com/atomx/nginx-http-auth-digest\n+syn keyword ngxDirectiveThirdParty contained auth_digest\n+syn keyword ngxDirectiveThirdParty contained auth_digest_drop_time\n+syn keyword ngxDirectiveThirdParty contained auth_digest_evasion_time\n+syn keyword ngxDirectiveThirdParty contained auth_digest_expires\n+syn keyword ngxDirectiveThirdParty contained auth_digest_maxtries\n+syn keyword ngxDirectiveThirdParty contained auth_digest_replays\n+syn keyword ngxDirectiveThirdParty contained auth_digest_shm_size\n+syn keyword ngxDirectiveThirdParty contained auth_digest_timeout\n+syn keyword ngxDirectiveThirdParty contained auth_digest_user_file\n+\n+\" https://github.com/stnoonan/spnego-http-auth-nginx-module\n+syn keyword ngxDirectiveThirdParty contained auth_gss\n+syn keyword ngxDirectiveThirdParty contained auth_gss_allow_basic_fallback\n+syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n+syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal_regex\n+syn keyword ngxDirectiveThirdParty contained auth_gss_constrained_delegation\n+syn keyword ngxDirectiveThirdParty contained auth_gss_delegate_credentials\n+syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n+syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n+syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n+syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n+syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n+syn keyword ngxDirectiveThirdParty contained auth_gss_service_ccache\n+syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n+\n+\" https://github.com/kvspb/nginx-auth-ldap\n+syn keyword ngxDirectiveThirdParty contained auth_ldap\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_enabled\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_expiration_time\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_cache_size\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_servers\n+syn keyword ngxDirectiveThirdParty contained auth_ldap_servers_size\n+syn keyword ngxDirectiveThirdParty contained ldap_server\n+\n+\" https://github.com/sto/ngx_http_auth_pam_module\n+syn keyword ngxDirectiveThirdParty contained auth_pam\n+syn keyword ngxDirectiveThirdParty contained auth_pam_service_name\n+syn keyword ngxDirectiveThirdParty contained auth_pam_set_pam_env\n+\n \" https://github.com/arut/nginx-dav-ext-module\n syn keyword ngxDirectiveThirdParty contained dav_ext_lock\n syn keyword ngxDirectiveThirdParty contained dav_ext_lock_zone\n syn keyword ngxDirectiveThirdParty contained dav_ext_methods\n \n-\" ngx_eval\n \" https://github.com/openresty/nginx-eval-module\n syn keyword ngxDirectiveThirdParty contained eval\n syn keyword ngxDirectiveThirdParty contained eval_buffer_size\n syn keyword ngxDirectiveThirdParty contained eval_escalate\n syn keyword ngxDirectiveThirdParty contained eval_override_content_type\n syn keyword ngxDirectiveThirdParty contained eval_subrequest_in_memory\n \n-\" Fancy Index\n \" https://github.com/aperezdc/ngx-fancyindex\n syn keyword ngxDirectiveThirdParty contained fancyindex\n syn keyword ngxDirectiveThirdParty contained fancyindex_css_href\n@@ -988,40 +1047,29 @@ syn keyword ngxDirectiveThirdParty contained fancyindex_show_dotfiles\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_path\n syn keyword ngxDirectiveThirdParty contained fancyindex_time_format\n \n-\" Footer filter\n \" https://github.com/alibaba/nginx-http-footer-filter\n syn keyword ngxDirectiveThirdParty contained footer\n syn keyword ngxDirectiveThirdParty contained footer_types\n \n-\" ngx_http_geoip2_module\n \" https://github.com/leev/ngx_http_geoip2_module\n syn keyword ngxDirectiveThirdParty contained geoip2\n syn keyword ngxDirectiveThirdParty contained geoip2_proxy\n syn keyword ngxDirectiveThirdParty contained geoip2_proxy_recursive\n \n-\" A version of the Nginx HTTP stub status module that outputs in JSON format\n-\" https://github.com/nginx-modules/nginx-json-status-module\n-syn keyword ngxDirectiveThirdParty contained json_status\n-syn keyword ngxDirectiveThirdParty contained json_status_type\n-\n-\" MogileFS client for nginx\n-\" https://github.com/vkholodkov/nginx-mogilefs-module\n-syn keyword ngxDirectiveThirdParty contained mogilefs_class\n-syn keyword ngxDirectiveThirdParty contained mogilefs_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained mogilefs_domain\n-syn keyword ngxDirectiveThirdParty contained mogilefs_methods\n-syn keyword ngxDirectiveThirdParty contained mogilefs_noverify\n-syn keyword ngxDirectiveThirdParty contained mogilefs_pass\n-syn keyword ngxDirectiveThirdParty contained mogilefs_read_timeout\n-syn keyword ngxDirectiveThirdParty contained mogilefs_send_timeout\n-syn keyword ngxDirectiveThirdParty contained mogilefs_tracker\n-\n-\" Ancient nginx plugin; probably not useful to anyone\n+\" https://github.com/ip2location/ip2location-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2location_database\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+\n+\" https://github.com/ip2location/ip2proxy-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n+\n \" https://github.com/kr/nginx-notice\n syn keyword ngxDirectiveThirdParty contained notice\n syn keyword ngxDirectiveThirdParty contained notice_type\n \n-\" nchan\n \" https://github.com/slact/nchan\n syn keyword ngxDirectiveThirdParty contained nchan_access_control_allow_credentials\n syn keyword ngxDirectiveThirdParty contained nchan_access_control_allow_origin\n@@ -1034,8 +1082,8 @@ syn keyword ngxDirectiveThirdParty contained nchan_benchmark_publisher_distribut\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscriber_distribution\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscribers_per_channel\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_time\n-syn keyword ngxDirectiveThirdParty contained nchan_channel_events_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_channel_event_string\n+syn keyword ngxDirectiveThirdParty contained nchan_channel_events_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group_accounting\n syn keyword ngxDirectiveThirdParty contained nchan_channel_id\n@@ -1074,18 +1122,39 @@ syn keyword ngxDirectiveThirdParty contained nchan_pubsub\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_location\n syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_backoff\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_jitter\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_max\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval_min\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_max_failing_time\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_backoff\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_jitter\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_max\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_recovery_delay_min\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_command_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_connect_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_discovered_ip_range_blacklist\n syn keyword ngxDirectiveThirdParty contained nchan_redis_fakesub_timer_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_idle_channel_cache_timeout\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_load_scripts_unconditionally\n syn keyword ngxDirectiveThirdParty contained nchan_redis_namespace\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_node_connect_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_nostore_fastpublish\n syn keyword ngxDirectiveThirdParty contained nchan_redis_optimize_target\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass_inheritable\n syn keyword ngxDirectiveThirdParty contained nchan_redis_password\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ping_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_publish_msgpacked_max_size\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_backoff\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_jitter\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_max\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_reconnect_delay_min\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_retry_commands\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_retry_commands_max_wait\n syn keyword ngxDirectiveThirdParty contained nchan_redis_server\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_ciphers\n@@ -1113,10 +1182,10 @@ syn keyword ngxDirectiveThirdParty contained nchan_store_messages\n syn keyword ngxDirectiveThirdParty contained nchan_stub_status\n syn keyword ngxDirectiveThirdParty contained nchan_sub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_existing_channels_only\n+syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_message_id\n-syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info\n@@ -1145,7 +1214,6 @@ syn keyword ngxDirectiveThirdParty contained push_subscriber\n syn keyword ngxDirectiveThirdParty contained push_subscriber_concurrency\n syn keyword ngxDirectiveThirdParty contained push_subscriber_timeout\n \n-\" Push Stream\n \" https://github.com/wandenberg/nginx-push-stream-module\n syn keyword ngxDirectiveThirdParty contained push_stream_allow_connections_to_events_channel\n syn keyword ngxDirectiveThirdParty contained push_stream_allowed_origins\n@@ -1184,31 +1252,13 @@ syn keyword ngxDirectiveThirdParty contained push_stream_websocket_allow_publish\n syn keyword ngxDirectiveThirdParty contained push_stream_wildcard_channel_max_qtd\n syn keyword ngxDirectiveThirdParty contained push_stream_wildcard_channel_prefix\n \n-\" redis module\n-\" https://www.nginx.com/resources/wiki/modules/redis/\n-syn keyword ngxDirectiveThirdParty contained redis_bind\n-syn keyword ngxDirectiveThirdParty contained redis_buffer_size\n-syn keyword ngxDirectiveThirdParty contained redis_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained redis_gzip_flag\n-syn keyword ngxDirectiveThirdParty contained redis_next_upstream\n-syn keyword ngxDirectiveThirdParty contained redis_pass\n-syn keyword ngxDirectiveThirdParty contained redis_read_timeout\n-syn keyword ngxDirectiveThirdParty contained redis_send_timeout\n-\n-\" ngx_http_response\n-\" http://catap.ru/downloads/nginx/\n-syn keyword ngxDirectiveThirdParty contained response\n-syn keyword ngxDirectiveThirdParty contained response_type\n-\n-\" nginx_substitutions_filter\n \" https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n syn keyword ngxDirectiveThirdParty contained subs_buffers\n syn keyword ngxDirectiveThirdParty contained subs_filter\n syn keyword ngxDirectiveThirdParty contained subs_filter_bypass\n syn keyword ngxDirectiveThirdParty contained subs_filter_types\n syn keyword ngxDirectiveThirdParty contained subs_line_buffer_size\n \n-\" Tarantool nginx upstream module\n \" https://github.com/tarantool/nginx_upstream_module\n syn keyword ngxDirectiveThirdParty contained tnt_allowed_indexes\n syn keyword ngxDirectiveThirdParty contained tnt_allowed_spaces\n@@ -1238,44 +1288,28 @@ syn keyword ngxDirectiveThirdParty contained tnt_set_header\n syn keyword ngxDirectiveThirdParty contained tnt_update\n syn keyword ngxDirectiveThirdParty contained tnt_upsert\n \n-\" A module for nginx web server for handling file uploads using multipart/form-data encoding (RFC 1867)\n-\" https://github.com/Austinb/nginx-upload-module\n+\" https://github.com/fdintino/nginx-upload-module\n+syn keyword ngxDirectiveThirdParty contained upload_add_header\n syn keyword ngxDirectiveThirdParty contained upload_aggregate_form_field\n-syn keyword ngxDirectiveThirdParty contained upload_archive_elm\n-syn keyword ngxDirectiveThirdParty contained upload_archive_elm_separator\n-syn keyword ngxDirectiveThirdParty contained upload_archive_path\n-syn keyword ngxDirectiveThirdParty contained upload_archive_path_separator\n syn keyword ngxDirectiveThirdParty contained upload_buffer_size\n syn keyword ngxDirectiveThirdParty contained upload_cleanup\n-syn keyword ngxDirectiveThirdParty contained upload_content_type\n-syn keyword ngxDirectiveThirdParty contained upload_discard\n-syn keyword ngxDirectiveThirdParty contained upload_field_name\n-syn keyword ngxDirectiveThirdParty contained upload_file_crc32\n-syn keyword ngxDirectiveThirdParty contained upload_file_md5\n-syn keyword ngxDirectiveThirdParty contained upload_file_md5_uc\n-syn keyword ngxDirectiveThirdParty contained upload_file_name\n-syn keyword ngxDirectiveThirdParty contained upload_file_sha1\n-syn keyword ngxDirectiveThirdParty contained upload_file_sha1_uc\n-syn keyword ngxDirectiveThirdParty contained upload_file_size\n-syn keyword ngxDirectiveThirdParty contained upload_filter\n+syn keyword ngxDirectiveThirdParty contained upload_empty_fiels_names\n+syn keyword ngxDirectiveThirdParty contained upload_limit_rate\n syn keyword ngxDirectiveThirdParty contained upload_max_file_size\n syn keyword ngxDirectiveThirdParty contained upload_max_output_body_len\n syn keyword ngxDirectiveThirdParty contained upload_max_part_header_len\n+syn keyword ngxDirectiveThirdParty contained upload_merge_buffer_size\n syn keyword ngxDirectiveThirdParty contained upload_pass\n syn keyword ngxDirectiveThirdParty contained upload_pass_args\n syn keyword ngxDirectiveThirdParty contained upload_pass_form_field\n+syn keyword ngxDirectiveThirdParty contained upload_range_header_buffer_size\n+syn keyword ngxDirectiveThirdParty contained upload_resumable\n syn keyword ngxDirectiveThirdParty contained upload_set_form_field\n+syn keyword ngxDirectiveThirdParty contained upload_state_store\n syn keyword ngxDirectiveThirdParty contained upload_store\n syn keyword ngxDirectiveThirdParty contained upload_store_access\n-syn keyword ngxDirectiveThirdParty contained upload_tmp_path\n-syn keyword ngxDirectiveThirdParty contained upload_unzip\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_buffers\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_hash\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_max_file_name_len\n-syn keyword ngxDirectiveThirdParty contained upload_unzip_window\n-syn keyword ngxDirectiveThirdParty contained upload_void_content_type\n-\n-\" nginx-upload-progress-module\n+syn keyword ngxDirectiveThirdParty contained upload_tame_arrays\n+\n \" https://github.com/masterzen/nginx-upload-progress-module\n syn keyword ngxDirectiveThirdParty contained report_uploads\n syn keyword ngxDirectiveThirdParty contained track_uploads\n@@ -1288,23 +1322,22 @@ syn keyword ngxDirectiveThirdParty contained upload_progress_jsonp_output\n syn keyword ngxDirectiveThirdParty contained upload_progress_jsonp_parameter\n syn keyword ngxDirectiveThirdParty contained upload_progress_template\n \n-\" Health checks upstreams for nginx\n \" https://github.com/yaoweibin/nginx_upstream_check_module\n-syn keyword ngxDirectiveThirdParty contained check\n syn keyword ngxDirectiveThirdParty contained check_fastcgi_param\n syn keyword ngxDirectiveThirdParty contained check_http_expect_alive\n syn keyword ngxDirectiveThirdParty contained check_http_send\n syn keyword ngxDirectiveThirdParty contained check_keepalive_requests\n syn keyword ngxDirectiveThirdParty contained check_shm_size\n syn keyword ngxDirectiveThirdParty contained check_status\n \n-\" The fair load balancer module for nginx\n-\" https://github.com/cryptofuture/nginx-upstream-fair\n+\" https://github.com/jaygooby/nginx-upstream-fair\n syn keyword ngxDirectiveThirdParty contained fair\n syn keyword ngxDirectiveThirdParty contained upstream_fair_shm_size\n \n-\" Nginx Video Thumb Extractor Module\n-\" https://github.com/wandenberg/nginx-video-thumbextractor-module\n+\" https://github.com/ayty-adrianomartins/nginx-sticky-module-ng\n+syn keyword ngxDirectiveThirdParty contained sticky_no_fallback\n+\n+\" https://github.com/Novetta/nginx-video-thumbextractor-module\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_image_height\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_image_width\n@@ -1329,43 +1362,14 @@ syn keyword ngxDirectiveThirdParty contained video_thumbextractor_tile_sample_in\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_video_filename\n syn keyword ngxDirectiveThirdParty contained video_thumbextractor_video_second\n \n-\" drizzle-nginx-module - Upstream module for talking to MySQL and Drizzle directly\n-\" https://github.com/openresty/drizzle-nginx-module\n-syn keyword ngxDirectiveThirdParty contained drizzle_buffer_size\n-syn keyword ngxDirectiveThirdParty contained drizzle_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_dbname\n-syn keyword ngxDirectiveThirdParty contained drizzle_keepalive\n-syn keyword ngxDirectiveThirdParty contained drizzle_module_header\n-syn keyword ngxDirectiveThirdParty contained drizzle_pass\n-syn keyword ngxDirectiveThirdParty contained drizzle_query\n-syn keyword ngxDirectiveThirdParty contained drizzle_recv_cols_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_recv_rows_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_send_query_timeout\n-syn keyword ngxDirectiveThirdParty contained drizzle_server\n-syn keyword ngxDirectiveThirdParty contained drizzle_status\n-\n-\" ngx_dynamic_upstream\n-\" https://github.com/cubicdaiya/ngx_dynamic_upstream\n-syn keyword ngxDirectiveThirdParty contained dynamic_upstream\n-\n-\" encrypt and decrypt nginx variable values\n-\" https://github.com/openresty/encrypted-session-nginx-module\n-syn keyword ngxDirectiveThirdParty contained encrypted_session_expires\n-syn keyword ngxDirectiveThirdParty contained encrypted_session_iv\n-syn keyword ngxDirectiveThirdParty contained encrypted_session_key\n-syn keyword ngxDirectiveThirdParty contained set_decrypt_session\n-syn keyword ngxDirectiveThirdParty contained set_encrypt_session\n-\n-\" serve content directly from MongoDB's GridFS\n-\" https://github.com/mdirolf/nginx-gridfs\n-syn keyword ngxDirectiveThirdParty contained gridfs\n-syn keyword ngxDirectiveThirdParty contained mongo\n+\" https://github.com/calio/iconv-nginx-module\n+syn keyword ngxDirectiveThirdParty contained iconv_buffer_size\n+syn keyword ngxDirectiveThirdParty contained iconv_filter\n+syn keyword ngxDirectiveThirdParty contained set_iconv\n \n-\" Adds support for arithmetic operations to NGINX config\n-\" https://github.com/arut/nginx-let-module\n+\" https://github.com/baysao/nginx-let-module\n syn keyword ngxDirectiveThirdParty contained let\n \n-\" ngx_http_lua_module - Embed the power of Lua into Nginx HTTP Servers\n \" https://github.com/openresty/lua-nginx-module\n syn keyword ngxDirectiveThirdParty contained access_by_lua\n syn keyword ngxDirectiveThirdParty contained access_by_lua_block\n@@ -1431,6 +1435,8 @@ syn keyword ngxDirectiveThirdParty contained rewrite_by_lua\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_block\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_file\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_no_postpone\n+syn keyword ngxDirectiveThirdParty contained server_rewrite_by_lua_block\n+syn keyword ngxDirectiveThirdParty contained server_rewrite_by_lua_file\n syn keyword ngxDirectiveThirdParty contained set_by_lua\n syn keyword ngxDirectiveThirdParty contained set_by_lua_block\n syn keyword ngxDirectiveThirdParty contained set_by_lua_file\n@@ -1443,7 +1449,16 @@ syn keyword ngxDirectiveThirdParty contained ssl_session_fetch_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_session_store_by_lua_block\n syn keyword ngxDirectiveThirdParty contained ssl_session_store_by_lua_file\n \n-\" ngx_memc - An extended version of the standard memcached module\n+\" https://github.com/Taymindis/nginx-link-function\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_prop\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_req_header\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_ca_cert\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_call\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_download_link_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_shm_size\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_subrequest\n+\n \" https://github.com/openresty/memc-nginx-module\n syn keyword ngxDirectiveThirdParty contained memc_buffer_size\n syn keyword ngxDirectiveThirdParty contained memc_cmds_allowed\n@@ -1457,21 +1472,24 @@ syn keyword ngxDirectiveThirdParty contained memc_send_timeout\n syn keyword ngxDirectiveThirdParty contained memc_upstream_fail_timeout\n syn keyword ngxDirectiveThirdParty contained memc_upstream_max_fails\n \n-\" ModSecurity web application firewall\n-\" https://github.com/SpiderLabs/ModSecurity/tree/master\n-syn keyword ngxDirectiveThirdParty contained ModSecurityConfig\n-syn keyword ngxDirectiveThirdParty contained ModSecurityEnabled\n-syn keyword ngxDirectiveThirdParty contained pool_context_hash_size\n+\" https://github.com/SpiderLabs/ModSecurity-nginx\n+syn keyword ngxDirectiveThirdParty contained modsecurity\n+syn keyword ngxDirectiveThirdParty contained modsecurity_rules\n+syn keyword ngxDirectiveThirdParty contained modsecurity_rules_file\n+syn keyword ngxDirectiveThirdParty contained modsecurity_rules_remote\n+syn keyword ngxDirectiveThirdParty contained modsecurity_transaction_id\n \n-\" NAXSI is an open-source, high performance, low rules maintenance WAF for NGINX\n \" https://github.com/nbs-system/naxsi\n syn keyword ngxDirectiveThirdParty contained BasicRule\n syn keyword ngxDirectiveThirdParty contained CheckRule\n syn keyword ngxDirectiveThirdParty contained DeniedUrl\n+syn keyword ngxDirectiveThirdParty contained IgnoreCIDR\n+syn keyword ngxDirectiveThirdParty contained IgnoreIP\n syn keyword ngxDirectiveThirdParty contained LearningMode\n syn keyword ngxDirectiveThirdParty contained LibInjectionSql\n syn keyword ngxDirectiveThirdParty contained LibInjectionXss\n syn keyword ngxDirectiveThirdParty contained MainRule\n+syn keyword ngxDirectiveThirdParty contained NaxsiLogFile\n syn keyword ngxDirectiveThirdParty contained SecRulesDisabled\n syn keyword ngxDirectiveThirdParty contained SecRulesEnabled\n syn keyword ngxDirectiveThirdParty contained basic_rule\n@@ -1481,38 +1499,57 @@ syn keyword ngxDirectiveThirdParty contained learning_mode\n syn keyword ngxDirectiveThirdParty contained libinjection_sql\n syn keyword ngxDirectiveThirdParty contained libinjection_xss\n syn keyword ngxDirectiveThirdParty contained main_rule\n+syn keyword ngxDirectiveThirdParty contained naxsi_log\n syn keyword ngxDirectiveThirdParty contained rules_disabled\n syn keyword ngxDirectiveThirdParty contained rules_enabled\n \n-\" Phusion Passenger\n-\" https://www.phusionpassenger.com/library/config/nginx/reference/\n+\" https://github.com/opentracing-contrib/nginx-opentracing\n+syn keyword ngxDirectiveThirdParty contained opentracing\n+syn keyword ngxDirectiveThirdParty contained opentracing_fastcgi_propagate_context\n+syn keyword ngxDirectiveThirdParty contained opentracing_grpc_propagate_context\n+syn keyword ngxDirectiveThirdParty contained opentracing_load_tracer\n+syn keyword ngxDirectiveThirdParty contained opentracing_location_operation_name\n+syn keyword ngxDirectiveThirdParty contained opentracing_operation_name\n+syn keyword ngxDirectiveThirdParty contained opentracing_propagate_context\n+syn keyword ngxDirectiveThirdParty contained opentracing_tag\n+syn keyword ngxDirectiveThirdParty contained opentracing_trace_locations\n+syn keyword ngxDirectiveThirdParty contained opentracing_trust_incoming_span\n+\n+\" https://github.com/phusion/passenger\n syn keyword ngxDirectiveThirdParty contained passenger_abort_on_startup_error\n syn keyword ngxDirectiveThirdParty contained passenger_abort_websockets_on_process_shutdown\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_auth_type\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_password\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_url\n syn keyword ngxDirectiveThirdParty contained passenger_admin_panel_username\n+syn keyword ngxDirectiveThirdParty contained passenger_analytics_log_group\n+syn keyword ngxDirectiveThirdParty contained passenger_analytics_log_user\n syn keyword ngxDirectiveThirdParty contained passenger_anonymous_telemetry_proxy\n syn keyword ngxDirectiveThirdParty contained passenger_app_env\n syn keyword ngxDirectiveThirdParty contained passenger_app_file_descriptor_ulimit\n syn keyword ngxDirectiveThirdParty contained passenger_app_group_name\n syn keyword ngxDirectiveThirdParty contained passenger_app_log_file\n syn keyword ngxDirectiveThirdParty contained passenger_app_rights\n syn keyword ngxDirectiveThirdParty contained passenger_app_root\n+syn keyword ngxDirectiveThirdParty contained passenger_app_start_command\n syn keyword ngxDirectiveThirdParty contained passenger_app_type\n syn keyword ngxDirectiveThirdParty contained passenger_base_uri\n syn keyword ngxDirectiveThirdParty contained passenger_buffer_response\n syn keyword ngxDirectiveThirdParty contained passenger_buffer_size\n+syn keyword ngxDirectiveThirdParty contained passenger_buffer_upload\n syn keyword ngxDirectiveThirdParty contained passenger_buffers\n syn keyword ngxDirectiveThirdParty contained passenger_busy_buffers_size\n syn keyword ngxDirectiveThirdParty contained passenger_concurrency_model\n syn keyword ngxDirectiveThirdParty contained passenger_core_file_descriptor_ulimit\n syn keyword ngxDirectiveThirdParty contained passenger_ctl\n syn keyword ngxDirectiveThirdParty contained passenger_data_buffer_dir\n+syn keyword ngxDirectiveThirdParty contained passenger_debug_log_file\n syn keyword ngxDirectiveThirdParty contained passenger_debugger\n syn keyword ngxDirectiveThirdParty contained passenger_default_group\n syn keyword ngxDirectiveThirdParty contained passenger_default_user\n+syn keyword ngxDirectiveThirdParty contained passenger_direct_instance_request_address\n syn keyword ngxDirectiveThirdParty contained passenger_disable_anonymous_telemetry\n+syn keyword ngxDirectiveThirdParty contained passenger_disable_log_prefix\n syn keyword ngxDirectiveThirdParty contained passenger_disable_security_update_check\n syn keyword ngxDirectiveThirdParty contained passenger_document_root\n syn keyword ngxDirectiveThirdParty contained passenger_dump_config_manifest\n@@ -1548,8 +1585,10 @@ syn keyword ngxDirectiveThirdParty contained passenger_nodejs\n syn keyword ngxDirectiveThirdParty contained passenger_pass_header\n syn keyword ngxDirectiveThirdParty contained passenger_pool_idle_time\n syn keyword ngxDirectiveThirdParty contained passenger_pre_start\n+syn keyword ngxDirectiveThirdParty contained passenger_preload_bundler\n syn keyword ngxDirectiveThirdParty contained passenger_python\n syn keyword ngxDirectiveThirdParty contained passenger_read_timeout\n+syn keyword ngxDirectiveThirdParty contained passenger_request_buffering\n syn keyword ngxDirectiveThirdParty contained passenger_request_queue_overflow_status_code\n syn keyword ngxDirectiveThirdParty contained passenger_resist_deployment_errors\n syn keyword ngxDirectiveThirdParty contained passenger_response_buffer_high_watermark\n@@ -1561,36 +1600,36 @@ syn keyword ngxDirectiveThirdParty contained passenger_security_update_check_pro\n syn keyword ngxDirectiveThirdParty contained passenger_set_header\n syn keyword ngxDirectiveThirdParty contained passenger_show_version_in_header\n syn keyword ngxDirectiveThirdParty contained passenger_socket_backlog\n+syn keyword ngxDirectiveThirdParty contained passenger_spawn_dir\n+syn keyword ngxDirectiveThirdParty contained passenger_spawn_exception_status_code\n syn keyword ngxDirectiveThirdParty contained passenger_spawn_method\n syn keyword ngxDirectiveThirdParty contained passenger_start_timeout\n syn keyword ngxDirectiveThirdParty contained passenger_startup_file\n syn keyword ngxDirectiveThirdParty contained passenger_stat_throttle_rate\n syn keyword ngxDirectiveThirdParty contained passenger_sticky_sessions\n+syn keyword ngxDirectiveThirdParty contained passenger_sticky_sessions_cookie_attributes\n syn keyword ngxDirectiveThirdParty contained passenger_sticky_sessions_cookie_name\n+syn keyword ngxDirectiveThirdParty contained passenger_temp_path\n syn keyword ngxDirectiveThirdParty contained passenger_thread_count\n syn keyword ngxDirectiveThirdParty contained passenger_turbocaching\n+syn keyword ngxDirectiveThirdParty contained passenger_use_global_queue\n syn keyword ngxDirectiveThirdParty contained passenger_user\n syn keyword ngxDirectiveThirdParty contained passenger_user_switching\n syn keyword ngxDirectiveThirdParty contained passenger_vary_turbocache_by_cookie\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_analytics_log_group\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_analytics_log_user\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_debug_log_file\n-syn keyword ngxDirectiveThirdPartyDeprecated contained passenger_use_global_queue\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rack_env\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_app_spawner_idle_time\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_env\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_framework_spawner_idle_time\n-syn keyword ngxDirectiveThirdPartyDeprecated contained rails_spawn_method\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_filter\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_gateway_address\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_gateway_cert\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_gateway_port\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_key\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_proxy_address\n-syn keyword ngxDirectiveThirdPartyDeprecated contained union_station_support\n-\n-\" ngx_postgres is an upstream module that allows nginx to communicate directly with PostgreSQL database\n-\" https://github.com/FRiCKLE/ngx_postgres\n+syn keyword ngxDirectiveThirdParty contained rack_env\n+syn keyword ngxDirectiveThirdParty contained rails_app_spawner_idle_time\n+syn keyword ngxDirectiveThirdParty contained rails_env\n+syn keyword ngxDirectiveThirdParty contained rails_framework_spawner_idle_time\n+syn keyword ngxDirectiveThirdParty contained rails_spawn_method\n+syn keyword ngxDirectiveThirdParty contained union_station_filter\n+syn keyword ngxDirectiveThirdParty contained union_station_gateway_address\n+syn keyword ngxDirectiveThirdParty contained union_station_gateway_cert\n+syn keyword ngxDirectiveThirdParty contained union_station_gateway_port\n+syn keyword ngxDirectiveThirdParty contained union_station_key\n+syn keyword ngxDirectiveThirdParty contained union_station_proxy_address\n+syn keyword ngxDirectiveThirdParty contained union_station_support\n+\n+\" https://github.com/konstruxi/ngx_postgres\n syn keyword ngxDirectiveThirdParty contained postgres_connect_timeout\n syn keyword ngxDirectiveThirdParty contained postgres_escape\n syn keyword ngxDirectiveThirdParty contained postgres_keepalive\n@@ -1602,7 +1641,6 @@ syn keyword ngxDirectiveThirdParty contained postgres_rewrite\n syn keyword ngxDirectiveThirdParty contained postgres_server\n syn keyword ngxDirectiveThirdParty contained postgres_set\n \n-\" ngx_rds_csv - Nginx output filter module to convert Resty-DBD-Streams (RDS) to Comma-Separated Values (CSV)\n \" https://github.com/openresty/rds-csv-nginx-module\n syn keyword ngxDirectiveThirdParty contained rds_csv\n syn keyword ngxDirectiveThirdParty contained rds_csv_buffer_size\n@@ -1611,7 +1649,6 @@ syn keyword ngxDirectiveThirdParty contained rds_csv_field_name_header\n syn keyword ngxDirectiveThirdParty contained rds_csv_field_separator\n syn keyword ngxDirectiveThirdParty contained rds_csv_row_terminator\n \n-\" ngx_rds_json - an output filter that formats Resty DBD Streams generated by ngx_drizzle and others to JSON\n \" https://github.com/openresty/rds-json-nginx-module\n syn keyword ngxDirectiveThirdParty contained rds_json\n syn keyword ngxDirectiveThirdParty contained rds_json_buffer_size\n@@ -1624,7 +1661,6 @@ syn keyword ngxDirectiveThirdParty contained rds_json_root\n syn keyword ngxDirectiveThirdParty contained rds_json_success_property\n syn keyword ngxDirectiveThirdParty contained rds_json_user_property\n \n-\" ngx_redis2 - Nginx upstream module for the Redis 2.0 protocol\n \" https://github.com/openresty/redis2-nginx-module\n syn keyword ngxDirectiveThirdParty contained redis2_bind\n syn keyword ngxDirectiveThirdParty contained redis2_buffer_size\n@@ -1638,7 +1674,6 @@ syn keyword ngxDirectiveThirdParty contained redis2_raw_query\n syn keyword ngxDirectiveThirdParty contained redis2_read_timeout\n syn keyword ngxDirectiveThirdParty contained redis2_send_timeout\n \n-\" NGINX-based Media Streaming Server\n \" https://github.com/arut/nginx-rtmp-module\n syn keyword ngxDirectiveThirdParty contained ack_window\n syn keyword ngxDirectiveThirdParty contained application\n@@ -1750,7 +1785,6 @@ syn keyword ngxDirectiveThirdParty contained sync\n syn keyword ngxDirectiveThirdParty contained wait_key\n syn keyword ngxDirectiveThirdParty contained wait_video\n \n-\" ngx_set_misc - Various set_xxx directives added to nginx's rewrite module (md5/sha1, sql/json quoting, and many more)\n \" https://github.com/openresty/set-misc-nginx-module\n syn keyword ngxDirectiveThirdParty contained set_base32_alphabet\n syn keyword ngxDirectiveThirdParty contained set_base32_padding\n@@ -1770,6 +1804,7 @@ syn keyword ngxDirectiveThirdParty contained set_hmac_sha1\n syn keyword ngxDirectiveThirdParty contained set_hmac_sha256\n syn keyword ngxDirectiveThirdParty contained set_if_empty\n syn keyword ngxDirectiveThirdParty contained set_local_today\n+syn keyword ngxDirectiveThirdParty contained set_md5\n syn keyword ngxDirectiveThirdParty contained set_misc_base32_padding\n syn keyword ngxDirectiveThirdParty contained set_quote_json_str\n syn keyword ngxDirectiveThirdParty contained set_quote_pgsql_str\n@@ -1778,20 +1813,18 @@ syn keyword ngxDirectiveThirdParty contained set_random\n syn keyword ngxDirectiveThirdParty contained set_rotate\n syn keyword ngxDirectiveThirdParty contained set_secure_random_alphanum\n syn keyword ngxDirectiveThirdParty contained set_secure_random_lcalpha\n+syn keyword ngxDirectiveThirdParty contained set_sha1\n syn keyword ngxDirectiveThirdParty contained set_unescape_uri\n \n-\" nginx-sflow-module\n \" https://github.com/sflow/nginx-sflow-module\n syn keyword ngxDirectiveThirdParty contained sflow\n \n-\" Shibboleth auth request module for Nginx\n \" https://github.com/nginx-shib/nginx-http-shibboleth\n syn keyword ngxDirectiveThirdParty contained shib_request\n syn keyword ngxDirectiveThirdParty contained shib_request_set\n syn keyword ngxDirectiveThirdParty contained shib_request_use_headers\n \n-\" nginx module which adds ability to cache static files\n-\" https://github.com/FRiCKLE/ngx_slowfs_cache\n+\" https://github.com/baysao/ngx_slowfs_cache\n syn keyword ngxDirectiveThirdParty contained slowfs_big_file_size\n syn keyword ngxDirectiveThirdParty contained slowfs_cache\n syn keyword ngxDirectiveThirdParty contained slowfs_cache_key\n@@ -1801,8 +1834,7 @@ syn keyword ngxDirectiveThirdParty contained slowfs_cache_purge\n syn keyword ngxDirectiveThirdParty contained slowfs_cache_valid\n syn keyword ngxDirectiveThirdParty contained slowfs_temp_path\n \n-\" Dynamic Image Transformation Module For nginx\n-\" https://github.com/cubicdaiya/ngx_small_light\n+\" https://github.com/kawakibi/ngx_small_light\n syn keyword ngxDirectiveThirdParty contained small_light\n syn keyword ngxDirectiveThirdParty contained small_light_buffer\n syn keyword ngxDirectiveThirdParty contained small_light_getparam_mode\n@@ -1812,7 +1844,6 @@ syn keyword ngxDirectiveThirdParty contained small_light_pattern_define\n syn keyword ngxDirectiveThirdParty contained small_light_radius_max\n syn keyword ngxDirectiveThirdParty contained small_light_sigma_max\n \n-\" ngx_srcache - Transparent subrequest-based caching layout for arbitrary nginx locations\n \" https://github.com/openresty/srcache-nginx-module\n syn keyword ngxDirectiveThirdParty contained srcache_buffer\n syn keyword ngxDirectiveThirdParty contained srcache_default_expire\n@@ -1835,7 +1866,6 @@ syn keyword ngxDirectiveThirdParty contained srcache_store_ranges\n syn keyword ngxDirectiveThirdParty contained srcache_store_skip\n syn keyword ngxDirectiveThirdParty contained srcache_store_statuses\n \n-\" NGINX-based VOD Packager\n \" https://github.com/kaltura/nginx-vod-module\n syn keyword ngxDirectiveThirdParty contained vod\n syn keyword ngxDirectiveThirdParty contained vod_align_segments_to_key_frames\n@@ -1875,6 +1905,7 @@ syn keyword ngxDirectiveThirdParty contained vod_live_window_duration\n syn keyword ngxDirectiveThirdParty contained vod_manifest_duration_policy\n syn keyword ngxDirectiveThirdParty contained vod_manifest_segment_durations_mode\n syn keyword ngxDirectiveThirdParty contained vod_mapping_cache\n+syn keyword ngxDirectiveThirdParty contained vod_max_frame_count\n syn keyword ngxDirectiveThirdParty contained vod_max_frames_size\n syn keyword ngxDirectiveThirdParty contained vod_max_mapping_response_size\n syn keyword ngxDirectiveThirdParty contained vod_max_metadata_size\n@@ -1901,6 +1932,7 @@ syn keyword ngxDirectiveThirdParty contained vod_response_cache\n syn keyword ngxDirectiveThirdParty contained vod_secret_key\n syn keyword ngxDirectiveThirdParty contained vod_segment_count_policy\n syn keyword ngxDirectiveThirdParty contained vod_segment_duration\n+syn keyword ngxDirectiveThirdParty contained vod_segment_max_frame_count\n syn keyword ngxDirectiveThirdParty contained vod_segments_base_url\n syn keyword ngxDirectiveThirdParty contained vod_source_clip_map_uri\n syn keyword ngxDirectiveThirdParty contained vod_speed_param_name\n@@ -1910,7 +1942,6 @@ syn keyword ngxDirectiveThirdParty contained vod_tracks_param_name\n syn keyword ngxDirectiveThirdParty contained vod_upstream_extra_args\n syn keyword ngxDirectiveThirdParty contained vod_upstream_location\n \n-\" Nginx virtual host traffic status module\n \" https://github.com/vozlt/nginx-module-vts\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_average_method\n@@ -1934,7 +1965,6 @@ syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_limit_traffic_\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_set_by_filter\n syn keyword ngxDirectiveThirdParty contained vhost_traffic_status_zone\n \n-\" xss-nginx-module - Native cross-site scripting support in nginx\n \" https://github.com/openresty/xss-nginx-module\n syn keyword ngxDirectiveThirdParty contained xss_callback_arg\n syn keyword ngxDirectiveThirdParty contained xss_check_status\n@@ -1943,527 +1973,13 @@ syn keyword ngxDirectiveThirdParty contained xss_input_types\n syn keyword ngxDirectiveThirdParty contained xss_output_type\n syn keyword ngxDirectiveThirdParty contained xss_override_status\n \n-\" Add support for array-typed variables to nginx config files\n-\" https://github.com/openresty/array-var-nginx-module\n-syn keyword ngxDirectiveThirdParty contained array_join\n-syn keyword ngxDirectiveThirdParty contained array_map\n-syn keyword ngxDirectiveThirdParty contained array_map_op\n-syn keyword ngxDirectiveThirdParty contained array_split\n-\n-\" NGINX module for Brotli compression\n-\" https://github.com/eustas/ngx_brotli\n-syn keyword ngxDirectiveThirdParty contained brotli\n-syn keyword ngxDirectiveThirdParty contained brotli_buffers\n-syn keyword ngxDirectiveThirdParty contained brotli_comp_level\n-syn keyword ngxDirectiveThirdParty contained brotli_min_length\n-syn keyword ngxDirectiveThirdParty contained brotli_static\n-syn keyword ngxDirectiveThirdParty contained brotli_types\n-syn keyword ngxDirectiveThirdParty contained brotli_window\n-\n-\" form-input-nginx-module\n-\" https://github.com/calio/form-input-nginx-module\n-syn keyword ngxDirectiveThirdParty contained set_form_input\n-syn keyword ngxDirectiveThirdParty contained set_form_input_multi\n-\n-\" character conversion nginx module using libiconv\n-\" https://github.com/calio/iconv-nginx-module\n-syn keyword ngxDirectiveThirdParty contained iconv_buffer_size\n-syn keyword ngxDirectiveThirdParty contained iconv_filter\n-syn keyword ngxDirectiveThirdParty contained set_iconv\n-\n-\" 3rd party modules list taken from\n-\" https://www.nginx.com/resources/wiki/modules/\n-\" ---------------------------------------------\n-\n-\" Nginx Module for Authenticating Akamai G2O requests\n-\" https://github.com/kaltura/nginx_mod_akamai_g2o\n-syn keyword ngxDirectiveThirdParty contained g2o\n-syn keyword ngxDirectiveThirdParty contained g2o_data_header\n-syn keyword ngxDirectiveThirdParty contained g2o_hash_function\n-syn keyword ngxDirectiveThirdParty contained g2o_key\n-syn keyword ngxDirectiveThirdParty contained g2o_log_level\n-syn keyword ngxDirectiveThirdParty contained g2o_nonce\n-syn keyword ngxDirectiveThirdParty contained g2o_sign_header\n-syn keyword ngxDirectiveThirdParty contained g2o_time_window\n-syn keyword ngxDirectiveThirdParty contained g2o_version\n-\n-\" nginx_lua_module\n-\" https://github.com/alacner/nginx_lua_module\n-syn keyword ngxDirectiveThirdParty contained lua_file\n-\n-\" Nginx Audio Track for HTTP Live Streaming\n-\" https://github.com/flavioribeiro/nginx-audio-track-for-hls-module\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track_output_format\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track_output_header\n-syn keyword ngxDirectiveThirdParty contained ngx_hls_audio_track_rootpath\n-\n-\" A Nginx module to dump backtrace when a worker process exits abnormally\n-\" https://github.com/alibaba/nginx-backtrace\n-syn keyword ngxDirectiveThirdParty contained backtrace_log\n-syn keyword ngxDirectiveThirdParty contained backtrace_max_stack_size\n-\n-\" circle_gif module\n-\" https://github.com/evanmiller/nginx_circle_gif\n-syn keyword ngxDirectiveThirdParty contained circle_gif\n-syn keyword ngxDirectiveThirdParty contained circle_gif_max_radius\n-syn keyword ngxDirectiveThirdParty contained circle_gif_min_radius\n-syn keyword ngxDirectiveThirdParty contained circle_gif_step_radius\n-\n-\" Upstream Consistent Hash\n-\" https://github.com/replay/ngx_http_consistent_hash\n-syn keyword ngxDirectiveThirdParty contained consistent_hash\n-\n-\" Nginx module for etags on dynamic content\n-\" https://github.com/kali/nginx-dynamic-etags\n-syn keyword ngxDirectiveThirdParty contained dynamic_etags\n-\n-\" Enhanced Nginx Memcached Module\n-\" https://github.com/bpaquet/ngx_http_enhanced_memcached_module\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_allow_delete\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_allow_put\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_bind\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_buffer_size\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_flush\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_flush_namespace\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_hash_keys_with_md5\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_pass\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_read_timeout\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_send_timeout\n-syn keyword ngxDirectiveThirdParty contained enhanced_memcached_stats\n-\n-\" nginx max connections queue\n-\" https://github.com/ezmobius/nginx-ey-balancer\n-syn keyword ngxDirectiveThirdParty contained max_connections_max_queue_length\n-syn keyword ngxDirectiveThirdParty contained max_connections_queue_timeout\n-\n-\" Nginx module for POST authentication and authorization\n-\" https://github.com/veruu/ngx_form_auth\n-syn keyword ngxDirectiveThirdParty contained form_auth\n-syn keyword ngxDirectiveThirdParty contained form_auth_login\n-syn keyword ngxDirectiveThirdParty contained form_auth_pam_service\n-syn keyword ngxDirectiveThirdParty contained form_auth_password\n-syn keyword ngxDirectiveThirdParty contained form_auth_remote_user\n-\n-\" ngx_http_accounting_module\n-\" https://github.com/Lax/ngx_http_accounting_module\n-syn keyword ngxDirectiveThirdParty contained accounting\n-syn keyword ngxDirectiveThirdParty contained accounting_id\n-syn keyword ngxDirectiveThirdParty contained accounting_interval\n-syn keyword ngxDirectiveThirdParty contained accounting_log\n-syn keyword ngxDirectiveThirdParty contained accounting_perturb\n-\n-\" concatenating files in a given context: CSS and JS files usually\n-\" https://github.com/alibaba/nginx-http-concat\n-syn keyword ngxDirectiveThirdParty contained concat\n-syn keyword ngxDirectiveThirdParty contained concat_delimiter\n-syn keyword ngxDirectiveThirdParty contained concat_ignore_file_error\n-syn keyword ngxDirectiveThirdParty contained concat_max_files\n-syn keyword ngxDirectiveThirdParty contained concat_types\n-syn keyword ngxDirectiveThirdParty contained concat_unique\n-\n-\" update upstreams' config by restful interface\n-\" https://github.com/yzprofile/ngx_http_dyups_module\n-syn keyword ngxDirectiveThirdParty contained dyups_interface\n-syn keyword ngxDirectiveThirdParty contained dyups_shm_zone_size\n-\n-\" add given content to the end of the response according to the condition specified\n-\" https://github.com/flygoast/ngx_http_footer_if_filter\n-syn keyword ngxDirectiveThirdParty contained footer_if\n-\n-\" NGINX HTTP Internal Redirect Module\n-\" https://github.com/flygoast/ngx_http_internal_redirect\n-syn keyword ngxDirectiveThirdParty contained internal_redirect_if\n-syn keyword ngxDirectiveThirdParty contained internal_redirect_if_no_postpone\n-\n-\" nginx-ip-blocker\n-\" https://github.com/tmthrgd/nginx-ip-blocker\n-syn keyword ngxDirectiveThirdParty contained ip_blocker\n-\n-\" IP2Location Nginx\n-\" https://github.com/chrislim2888/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_database\n-\n-\" Limit upload rate\n-\" https://github.com/cfsego/limit_upload_rate\n-syn keyword ngxDirectiveThirdParty contained limit_upload_rate\n-syn keyword ngxDirectiveThirdParty contained limit_upload_rate_after\n-syn keyword ngxDirectiveThirdParty contained limit_upload_rate_log_level\n-\n-\" limit the number of connections to upstream\n-\" https://github.com/cfsego/nginx-limit-upstream\n-syn keyword ngxDirectiveThirdParty contained limit_upstream_conn\n-syn keyword ngxDirectiveThirdParty contained limit_upstream_log_level\n-syn keyword ngxDirectiveThirdParty contained limit_upstream_zone\n-\n-\" conditional accesslog for nginx\n-\" https://github.com/cfsego/ngx_log_if\n-syn keyword ngxDirectiveThirdParty contained access_log_bypass_if\n-\n-\" log messages over ZeroMQ\n-\" https://github.com/alticelabs/nginx-log-zmq\n-syn keyword ngxDirectiveThirdParty contained log_zmq_endpoint\n-syn keyword ngxDirectiveThirdParty contained log_zmq_format\n-syn keyword ngxDirectiveThirdParty contained log_zmq_off\n-syn keyword ngxDirectiveThirdParty contained log_zmq_server\n-\n-\" simple module to uppercase/lowercase strings in the nginx config\n-\" https://github.com/replay/ngx_http_lower_upper_case\n-syn keyword ngxDirectiveThirdParty contained lower\n-syn keyword ngxDirectiveThirdParty contained upper\n-\n-\" content filter for nginx, which returns the md5 hash of the content otherwise returned\n-\" https://github.com/kainswor/nginx_md5_filter\n-syn keyword ngxDirectiveThirdParty contained md5_filter\n-\n-\" Non-blocking upstream module for Nginx to connect to MongoDB\n-\" https://github.com/simpl/ngx_mongo\n-syn keyword ngxDirectiveThirdParty contained mongo_auth\n-syn keyword ngxDirectiveThirdParty contained mongo_bind\n-syn keyword ngxDirectiveThirdParty contained mongo_buffer_size\n-syn keyword ngxDirectiveThirdParty contained mongo_buffering\n-syn keyword ngxDirectiveThirdParty contained mongo_buffers\n-syn keyword ngxDirectiveThirdParty contained mongo_busy_buffers_size\n-syn keyword ngxDirectiveThirdParty contained mongo_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained mongo_json\n-syn keyword ngxDirectiveThirdParty contained mongo_next_upstream\n-syn keyword ngxDirectiveThirdParty contained mongo_pass\n-syn keyword ngxDirectiveThirdParty contained mongo_query\n-syn keyword ngxDirectiveThirdParty contained mongo_read_timeout\n-syn keyword ngxDirectiveThirdParty contained mongo_send_timeout\n-\n-\" Nginx OCSP processing module designed for response caching\n-\" https://github.com/kyprizel/nginx_ocsp_proxy-module\n-syn keyword ngxDirectiveThirdParty contained ocsp_cache_timeout\n-syn keyword ngxDirectiveThirdParty contained ocsp_proxy\n-\n-\" Nginx OpenSSL version check at startup\n-\" https://github.com/apcera/nginx-openssl-version\n-syn keyword ngxDirectiveThirdParty contained openssl_builddate_minimum\n-syn keyword ngxDirectiveThirdParty contained openssl_version_minimum\n-\n-\" Automatic PageSpeed optimization module for Nginx\n-\" https://github.com/pagespeed/ngx_pagespeed\n-syn keyword ngxDirectiveThirdParty contained pagespeed\n-\n-\" PECL Memcache standard hashing compatible loadbalancer for Nginx\n-\" https://github.com/replay/ngx_http_php_memcache_standard_balancer\n-syn keyword ngxDirectiveThirdParty contained hash_key\n-\n-\" nginx module to parse php sessions\n-\" https://github.com/replay/ngx_http_php_session\n-syn keyword ngxDirectiveThirdParty contained php_session_parse\n-syn keyword ngxDirectiveThirdParty contained php_session_strip_formatting\n-\n-\" Nginx HTTP rDNS module\n-\" https://github.com/flant/nginx-http-rdns\n-syn keyword ngxDirectiveThirdParty contained rdns\n-syn keyword ngxDirectiveThirdParty contained rdns_allow\n-syn keyword ngxDirectiveThirdParty contained rdns_deny\n-\n-\" Streaming regular expression replacement in response bodies\n-\" https://github.com/openresty/replace-filter-nginx-module\n-syn keyword ngxDirectiveThirdParty contained replace_filter\n-syn keyword ngxDirectiveThirdParty contained replace_filter_last_modified\n-syn keyword ngxDirectiveThirdParty contained replace_filter_max_buffered_size\n-syn keyword ngxDirectiveThirdParty contained replace_filter_skip\n-syn keyword ngxDirectiveThirdParty contained replace_filter_types\n-\n-\" Link RRDtool's graphing facilities directly into nginx\n-\" https://github.com/evanmiller/mod_rrd_graph\n-syn keyword ngxDirectiveThirdParty contained rrd_graph\n-syn keyword ngxDirectiveThirdParty contained rrd_graph_root\n-\n-\" Module for nginx to proxy rtmp using http protocol\n-\" https://github.com/kwojtek/nginx-rtmpt-proxy-module\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_http_timeout\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_rtmp_timeout\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_stat\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_stylesheet\n-syn keyword ngxDirectiveThirdParty contained rtmpt_proxy_target\n-\n-\" Syntactically Awesome NGINX Module\n-\" https://github.com/mneudert/sass-nginx-module\n-syn keyword ngxDirectiveThirdParty contained sass_compile\n-syn keyword ngxDirectiveThirdParty contained sass_error_log\n-syn keyword ngxDirectiveThirdParty contained sass_include_path\n-syn keyword ngxDirectiveThirdParty contained sass_indent\n-syn keyword ngxDirectiveThirdParty contained sass_is_indented_syntax\n-syn keyword ngxDirectiveThirdParty contained sass_linefeed\n-syn keyword ngxDirectiveThirdParty contained sass_output_style\n-syn keyword ngxDirectiveThirdParty contained sass_precision\n-syn keyword ngxDirectiveThirdParty contained sass_source_comments\n-syn keyword ngxDirectiveThirdParty contained sass_source_map_embed\n-\n-\" Nginx Selective Cache Purge Module\n-\" https://github.com/wandenberg/nginx-selective-cache-purge-module\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_query\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_database\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_host\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_password\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_port\n-syn keyword ngxDirectiveThirdParty contained selective_cache_purge_redis_unix_socket\n-\n-\" cconv nginx module\n-\" https://github.com/liseen/set-cconv-nginx-module\n-syn keyword ngxDirectiveThirdParty contained set_cconv_to_simp\n-syn keyword ngxDirectiveThirdParty contained set_cconv_to_trad\n-syn keyword ngxDirectiveThirdParty contained set_pinyin_to_normal\n-\n-\" Nginx module that allows the setting of variables to the value of a variety of hashes\n-\" https://github.com/simpl/ngx_http_set_hash\n-syn keyword ngxDirectiveThirdParty contained set_md5\n-syn keyword ngxDirectiveThirdParty contained set_md5_upper\n-syn keyword ngxDirectiveThirdParty contained set_murmur2\n-syn keyword ngxDirectiveThirdParty contained set_murmur2_upper\n-syn keyword ngxDirectiveThirdParty contained set_sha1\n-syn keyword ngxDirectiveThirdParty contained set_sha1_upper\n-\n-\" Nginx module to set the language of a request based on a number of options\n-\" https://github.com/simpl/ngx_http_set_lang\n-syn keyword ngxDirectiveThirdParty contained lang_cookie\n-syn keyword ngxDirectiveThirdParty contained lang_get_var\n-syn keyword ngxDirectiveThirdParty contained lang_host\n-syn keyword ngxDirectiveThirdParty contained lang_list\n-syn keyword ngxDirectiveThirdParty contained lang_post_var\n-syn keyword ngxDirectiveThirdParty contained lang_referer\n-syn keyword ngxDirectiveThirdParty contained set_lang\n-syn keyword ngxDirectiveThirdParty contained set_lang_method\n-\n-\" Nginx Sorted Querystring Module\n-\" https://github.com/wandenberg/nginx-sorted-querystring-module\n-syn keyword ngxDirectiveThirdParty contained sorted_querysting_filter_parameter\n-\n-\" Nginx upstream module for Sphinx 2.x search daemon\n-\" https://github.com/reeteshranjan/sphinx2-nginx-module\n-syn keyword ngxDirectiveThirdParty contained sphinx2_bind\n-syn keyword ngxDirectiveThirdParty contained sphinx2_buffer_size\n-syn keyword ngxDirectiveThirdParty contained sphinx2_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained sphinx2_next_upstream\n-syn keyword ngxDirectiveThirdParty contained sphinx2_pass\n-syn keyword ngxDirectiveThirdParty contained sphinx2_read_timeout\n-syn keyword ngxDirectiveThirdParty contained sphinx2_send_timeout\n-\n-\" Nginx module for retrieving user attributes and groups from SSSD\n-\" https://github.com/veruu/ngx_sssd_info\n-syn keyword ngxDirectiveThirdParty contained sssd_info\n-syn keyword ngxDirectiveThirdParty contained sssd_info_attribute\n-syn keyword ngxDirectiveThirdParty contained sssd_info_attribute_separator\n-syn keyword ngxDirectiveThirdParty contained sssd_info_attributes\n-syn keyword ngxDirectiveThirdParty contained sssd_info_group\n-syn keyword ngxDirectiveThirdParty contained sssd_info_group_separator\n-syn keyword ngxDirectiveThirdParty contained sssd_info_groups\n-syn keyword ngxDirectiveThirdParty contained sssd_info_output_to\n-\n-\" An nginx module for sending statistics to statsd\n-\" https://github.com/zebrafishlabs/nginx-statsd\n-syn keyword ngxDirectiveThirdParty contained statsd_count\n-syn keyword ngxDirectiveThirdParty contained statsd_sample_rate\n-syn keyword ngxDirectiveThirdParty contained statsd_server\n-syn keyword ngxDirectiveThirdParty contained statsd_timing\n-\n-\" ngx_stream_echo - TCP/stream echo module for NGINX (a port of the ngx_http_echo module)\n-\" https://github.com/openresty/stream-echo-nginx-module\n-syn keyword ngxDirectiveThirdParty contained echo\n-syn keyword ngxDirectiveThirdParty contained echo_client_error_log_level\n-syn keyword ngxDirectiveThirdParty contained echo_discard_request\n-syn keyword ngxDirectiveThirdParty contained echo_duplicate\n-syn keyword ngxDirectiveThirdParty contained echo_flush_wait\n-syn keyword ngxDirectiveThirdParty contained echo_lingering_close\n-syn keyword ngxDirectiveThirdParty contained echo_lingering_time\n-syn keyword ngxDirectiveThirdParty contained echo_lingering_timeout\n-syn keyword ngxDirectiveThirdParty contained echo_read_buffer_size\n-syn keyword ngxDirectiveThirdParty contained echo_read_bytes\n-syn keyword ngxDirectiveThirdParty contained echo_read_line\n-syn keyword ngxDirectiveThirdParty contained echo_read_timeout\n-syn keyword ngxDirectiveThirdParty contained echo_request_data\n-syn keyword ngxDirectiveThirdParty contained echo_send_timeout\n-syn keyword ngxDirectiveThirdParty contained echo_sleep\n-\n-\" Embed the power of Lua into NGINX TCP/UDP servers\n-\" https://github.com/openresty/stream-lua-nginx-module\n-syn keyword ngxDirectiveThirdParty contained lua_add_variable\n-syn keyword ngxDirectiveThirdParty contained preread_by_lua_block\n-syn keyword ngxDirectiveThirdParty contained preread_by_lua_file\n-syn keyword ngxDirectiveThirdParty contained preread_by_lua_no_postpone\n-\n-\" nginx-upsync-module\n-\" https://github.com/weibocom/nginx-upsync-module\n-syn keyword ngxDirectiveThirdParty contained upstream_show\n-syn keyword ngxDirectiveThirdParty contained upsync\n-syn keyword ngxDirectiveThirdParty contained upsync_dump_path\n-syn keyword ngxDirectiveThirdParty contained upsync_lb\n-\n-\" Whitespace stripper for nginx\n-\" https://github.com/evanmiller/mod_strip\n-syn keyword ngxDirectiveThirdParty contained strip\n-\n-\" Split one big HTTP/Range request to multiple subrange requesets\n-\" https://github.com/Qihoo360/ngx_http_subrange_module\n-syn keyword ngxDirectiveThirdParty contained subrange\n-\n-\" summarizer-nginx-module\n-\" https://github.com/reeteshranjan/summarizer-nginx-module\n-syn keyword ngxDirectiveThirdParty contained summarizer_bind\n-syn keyword ngxDirectiveThirdParty contained summarizer_buffer_size\n-syn keyword ngxDirectiveThirdParty contained summarizer_connect_timeout\n-syn keyword ngxDirectiveThirdParty contained summarizer_next_upstream\n-syn keyword ngxDirectiveThirdParty contained summarizer_pass\n-syn keyword ngxDirectiveThirdParty contained summarizer_read_timeout\n-syn keyword ngxDirectiveThirdParty contained summarizer_send_timeout\n-\n-\" nginx module providing API to communicate with supervisord and manage (start/stop) backends on-demand\n-\" https://github.com/FRiCKLE/ngx_supervisord\n-syn keyword ngxDirectiveThirdParty contained supervisord\n-syn keyword ngxDirectiveThirdParty contained supervisord_inherit_backend_status\n-syn keyword ngxDirectiveThirdParty contained supervisord_name\n-syn keyword ngxDirectiveThirdParty contained supervisord_start\n-syn keyword ngxDirectiveThirdParty contained supervisord_stop\n-\n-\" simple robot mitigation module using cookie based challenge/response technique. Not supported any more.\n-\" https://github.com/kyprizel/testcookie-nginx-module\n-syn keyword ngxDirectiveThirdParty contained testcookie\n-syn keyword ngxDirectiveThirdParty contained testcookie_arg\n-syn keyword ngxDirectiveThirdParty contained testcookie_deny_keepalive\n-syn keyword ngxDirectiveThirdParty contained testcookie_domain\n-syn keyword ngxDirectiveThirdParty contained testcookie_expires\n-syn keyword ngxDirectiveThirdParty contained testcookie_fallback\n-syn keyword ngxDirectiveThirdParty contained testcookie_get_only\n-syn keyword ngxDirectiveThirdParty contained testcookie_httponly_flag\n-syn keyword ngxDirectiveThirdParty contained testcookie_https_location\n-syn keyword ngxDirectiveThirdParty contained testcookie_internal\n-syn keyword ngxDirectiveThirdParty contained testcookie_max_attempts\n-syn keyword ngxDirectiveThirdParty contained testcookie_name\n-syn keyword ngxDirectiveThirdParty contained testcookie_p3p\n-syn keyword ngxDirectiveThirdParty contained testcookie_pass\n-syn keyword ngxDirectiveThirdParty contained testcookie_path\n-syn keyword ngxDirectiveThirdParty contained testcookie_port_in_redirect\n-syn keyword ngxDirectiveThirdParty contained testcookie_redirect_via_refresh\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_iv\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_key\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_status\n-syn keyword ngxDirectiveThirdParty contained testcookie_refresh_template\n-syn keyword ngxDirectiveThirdParty contained testcookie_samesite\n-syn keyword ngxDirectiveThirdParty contained testcookie_secret\n-syn keyword ngxDirectiveThirdParty contained testcookie_secure_flag\n-syn keyword ngxDirectiveThirdParty contained testcookie_session\n-syn keyword ngxDirectiveThirdParty contained testcookie_whitelist\n-\n-\" ngx_http_types_filter_module\n-\" https://github.com/flygoast/ngx_http_types_filter\n-syn keyword ngxDirectiveThirdParty contained types_filter\n-syn keyword ngxDirectiveThirdParty contained types_filter_use_default\n-\n-\" A module allowing the nginx to use files embedded in a zip file\n-\" https://github.com/youzee/nginx-unzip-module\n-syn keyword ngxDirectiveThirdParty contained file_in_unzip\n-syn keyword ngxDirectiveThirdParty contained file_in_unzip_archivefile\n-syn keyword ngxDirectiveThirdParty contained file_in_unzip_extract\n-\n-\" An asynchronous domain name resolve module for nginx upstream\n-\" https://github.com/wdaike/ngx_upstream_jdomain\n-syn keyword ngxDirectiveThirdParty contained jdomain\n-\n-\" Nginx url encoding converting module\n-\" https://github.com/vozlt/nginx-module-url\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_alloc_size\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_alloc_size_x\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_from\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_phase\n-syn keyword ngxDirectiveThirdParty contained url_encoding_convert_to\n-\n-\" A nginx module to match browsers and crawlers\n-\" https://github.com/alibaba/nginx-http-user-agent\n-syn keyword ngxDirectiveThirdParty contained user_agent\n-\n-\" nginx load-balancer module implementing ketama consistent hashing\n-\" https://github.com/flygoast/ngx_http_upstream_ketama_chash\n-syn keyword ngxDirectiveThirdParty contained ketama_chash\n-\n-\" nginx-sticky-module-ng\n-\" https://github.com/ayty-adrianomartins/nginx-sticky-module-ng\n-syn keyword ngxDirectiveThirdParty contained sticky_no_fallback\n-\n-\" dynamic linking and call the function of your application\n-\" https://github.com/Taymindis/nginx-link-function\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_prop\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_req_header\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_ca_cert\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_call\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_download_link_lib\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_lib\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_shm_size\n-syn keyword ngxDirectiveThirdParty contained ngx_link_func_subrequest\n-\n-\" purge content from FastCGI, proxy, SCGI and uWSGI caches\n-\" https://github.com/torden/ngx_cache_purge\n-syn keyword ngxDirectiveThirdParty contained cache_purge_response_type\n-\n-\" set the flags \"HttpOnly\", \"secure\" and \"SameSite\" for cookies\n-\" https://github.com/AirisX/nginx_cookie_flag_module\n-syn keyword ngxDirectiveThirdParty contained set_cookie_flag\n-\n-\" Embed websockify into Nginx (convert any tcp connection into websocket)\n \" https://github.com/tg123/websockify-nginx-module\n syn keyword ngxDirectiveThirdParty contained websockify_buffer_size\n syn keyword ngxDirectiveThirdParty contained websockify_connect_timeout\n syn keyword ngxDirectiveThirdParty contained websockify_pass\n syn keyword ngxDirectiveThirdParty contained websockify_read_timeout\n syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n-\" IP2Location Nginx\n-\" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_addresstype\n-syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n-syn keyword ngxDirectiveThirdParty contained ip2location_category\n-syn keyword ngxDirectiveThirdParty contained ip2location_city\n-syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n-syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n-syn keyword ngxDirectiveThirdParty contained ip2location_domain\n-syn keyword ngxDirectiveThirdParty contained ip2location_elevation\n-syn keyword ngxDirectiveThirdParty contained ip2location_iddcode\n-syn keyword ngxDirectiveThirdParty contained ip2location_isp\n-syn keyword ngxDirectiveThirdParty contained ip2location_latitude\n-syn keyword ngxDirectiveThirdParty contained ip2location_longitude\n-syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n-syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n-syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n-syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n-syn keyword ngxDirectiveThirdParty contained ip2location_region\n-syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n-syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n-syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationcode\n-syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationname\n-syn keyword ngxDirectiveThirdParty contained ip2location_zipcode\n-\n-\" IP2Proxy module for Nginx\n-\" https://github.com/ip2location/ip2proxy-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_as\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_asn\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_city\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_country_long\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_country_short\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_provider\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_region\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_threat\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n-\n-\n-\n \" highlight\n \n hi def link ngxComment Comment\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1o\n+OPENSSL =\topenssl-1.1.1p\n ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \n@@ -15,12 +15,6 @@ release: export\n \n \tmv $(TEMP)/$(NGINX)/auto/configure $(TEMP)/$(NGINX)\n \n-\t# delete incomplete sources\n-\trm $(TEMP)/$(NGINX)/src/event/ngx_event_acceptex.c\n-\trm $(TEMP)/$(NGINX)/src/event/ngx_event_connectex.c\n-\trm $(TEMP)/$(NGINX)/src/event/modules/ngx_iocp_module.*\n-\trm -r $(TEMP)/$(NGINX)/src/os/win32\n-\n \tmv $(TEMP)/$(NGINX)/docs/text/LICENSE $(TEMP)/$(NGINX)\n \tmv $(TEMP)/$(NGINX)/docs/text/README $(TEMP)/$(NGINX)\n \tmv $(TEMP)/$(NGINX)/docs/html $(TEMP)/$(NGINX)\nDiff:\n@@ -269,8 +269,7 @@ header_in(r, key)\n     u_char                     *p, *lowcase_key, *value, sep;\n     STRLEN                      len;\n     ssize_t                     size;\n-    ngx_uint_t                  i, n, hash;\n-    ngx_array_t                *a;\n+    ngx_uint_t                  i, hash;\n     ngx_list_part_t            *part;\n     ngx_table_elt_t            *h, *header, **ph;\n     ngx_http_header_t          *hh;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 160",
        "commit_diff": "Diff:\n@@ -1389,6 +1389,7 @@ ngx_resolver_send_tcp_query(ngx_resolver_t *r, ngx_resolver_connection_t *rec,\n \n         rec->tcp->data = rec;\n         rec->tcp->write->handler = ngx_resolver_tcp_write;\n+        rec->tcp->write->cancelable = 1;\n         rec->tcp->read->handler = ngx_resolver_tcp_read;\n         rec->tcp->read->resolver = 1;\n \nDiff:\n@@ -4906,8 +4906,9 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n         return NGX_ERROR;\n     }\n \n-    if (glcf->upstream.ssl_certificate) {\n-\n+    if (glcf->upstream.ssl_certificate\n+        && glcf->upstream.ssl_certificate->value.len)\n+    {\n         if (glcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"grpc_ssl_certificate_key\\\" is defined \"\nDiff:\n@@ -2331,7 +2331,7 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n         }\n \n         start_sample += count;\n-        start_time -= count * duration;\n+        start_time -= (uint64_t) count * duration;\n         entries--;\n         entry++;\n     }\nDiff:\n@@ -4955,8 +4955,9 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n         return NGX_ERROR;\n     }\n \n-    if (plcf->upstream.ssl_certificate) {\n-\n+    if (plcf->upstream.ssl_certificate\n+        && plcf->upstream.ssl_certificate->value.len)\n+    {\n         if (plcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\nDiff:\n@@ -2487,8 +2487,9 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n         return NGX_ERROR;\n     }\n \n-    if (uwcf->upstream.ssl_certificate) {\n-\n+    if (uwcf->upstream.ssl_certificate\n+        && uwcf->upstream.ssl_certificate->value.len)\n+    {\n         if (uwcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"uwsgi_ssl_certificate_key\\\" is defined \"\nDiff:\n@@ -1690,8 +1690,10 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,\n         }\n     }\n \n-    if (u->conf->ssl_certificate && (u->conf->ssl_certificate->lengths\n-                                     || u->conf->ssl_certificate_key->lengths))\n+    if (u->conf->ssl_certificate\n+        && u->conf->ssl_certificate->value.len\n+        && (u->conf->ssl_certificate->lengths\n+            || u->conf->ssl_certificate_key->lengths))\n     {\n         if (ngx_http_upstream_ssl_certificate(r, u, c) != NGX_OK) {\n             ngx_http_upstream_finalize_request(r, u,\nDiff:\n@@ -1069,8 +1069,10 @@ ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s)\n         }\n     }\n \n-    if (pscf->ssl_certificate && (pscf->ssl_certificate->lengths\n-                                  || pscf->ssl_certificate_key->lengths))\n+    if (pscf->ssl_certificate\n+        && pscf->ssl_certificate->value.len\n+        && (pscf->ssl_certificate->lengths\n+            || pscf->ssl_certificate_key->lengths))\n     {\n         if (ngx_stream_proxy_ssl_certificate(s) != NGX_OK) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n@@ -1735,7 +1737,7 @@ ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,\n \n                 cl->buf->temporary = (n ? 1 : 0);\n                 cl->buf->last_buf = src->read->eof;\n-                cl->buf->flush = 1;\n+                cl->buf->flush = !src->read->eof;\n \n                 (*packets)++;\n                 *received += n;\n@@ -2225,8 +2227,9 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n         return NGX_ERROR;\n     }\n \n-    if (pscf->ssl_certificate) {\n-\n+    if (pscf->ssl_certificate\n+        && pscf->ssl_certificate->value.len)\n+    {\n         if (pscf->ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 159",
        "commit_diff": "Diff:\n@@ -377,6 +377,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n \n         cc = ngx_list_push(&r->headers_out.headers);\n         if (cc == NULL) {\n+            e->hash = 0;\n             return NGX_ERROR;\n         }\n \n@@ -410,6 +411,8 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n \n     e->value.data = ngx_pnalloc(r->pool, len);\n     if (e->value.data == NULL) {\n+        e->hash = 0;\n+        cc->hash = 0;\n         return NGX_ERROR;\n     }\n \n@@ -447,6 +450,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     cc->value.data = ngx_pnalloc(r->pool,\n                                  sizeof(\"max-age=\") + NGX_TIME_T_LEN + 1);\n     if (cc->value.data == NULL) {\n+        cc->hash = 0;\n         return NGX_ERROR;\n     }\n \nDiff:\n@@ -2702,6 +2702,10 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n \n             if (r->cache) {\n \n+                if (u->headers_in.no_cache || u->headers_in.expired) {\n+                    u->cacheable = 0;\n+                }\n+\n                 if (u->cacheable) {\n                     time_t  valid;\n \n@@ -2796,6 +2800,10 @@ ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)\n \n     umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module);\n \n+    if (u->headers_in.no_cache || u->headers_in.expired) {\n+        u->cacheable = 0;\n+    }\n+\n     if (u->headers_in.x_accel_redirect\n         && !(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT))\n     {\n@@ -4791,18 +4799,18 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    if (r->cache->valid_sec != 0 && u->headers_in.x_accel_expires != NULL) {\n-        return NGX_OK;\n-    }\n-\n     start = h->value.data;\n     last = start + h->value.len;\n \n+    if (r->cache->valid_sec != 0 && u->headers_in.x_accel_expires != NULL) {\n+        goto extensions;\n+    }\n+\n     if (ngx_strlcasestrn(start, last, (u_char *) \"no-cache\", 8 - 1) != NULL\n         || ngx_strlcasestrn(start, last, (u_char *) \"no-store\", 8 - 1) != NULL\n         || ngx_strlcasestrn(start, last, (u_char *) \"private\", 7 - 1) != NULL)\n     {\n-        u->cacheable = 0;\n+        u->headers_in.no_cache = 1;\n         return NGX_OK;\n     }\n \n@@ -4832,13 +4840,16 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n         }\n \n         if (n == 0) {\n-            u->cacheable = 0;\n+            u->headers_in.no_cache = 1;\n             return NGX_OK;\n         }\n \n         r->cache->valid_sec = ngx_time() + n;\n+        u->headers_in.expired = 0;\n     }\n \n+extensions:\n+\n     p = ngx_strlcasestrn(start, last, (u_char *) \"stale-while-revalidate=\",\n                          23 - 1);\n \n@@ -4932,7 +4943,7 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,\n     expires = ngx_parse_http_time(h->value.data, h->value.len);\n \n     if (expires == NGX_ERROR || expires < ngx_time()) {\n-        u->cacheable = 0;\n+        u->headers_in.expired = 1;\n         return NGX_OK;\n     }\n \n@@ -4996,6 +5007,8 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n \n         default:\n             r->cache->valid_sec = ngx_time() + n;\n+            u->headers_in.no_cache = 0;\n+            u->headers_in.expired = 0;\n             return NGX_OK;\n         }\n     }\n@@ -5007,6 +5020,8 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n \n     if (n != NGX_ERROR) {\n         r->cache->valid_sec = n;\n+        u->headers_in.no_cache = 0;\n+        u->headers_in.expired = 0;\n     }\n     }\n #endif\n@@ -5183,9 +5198,6 @@ static ngx_int_t\n ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    u_char                *p;\n-    size_t                 len;\n-    ngx_str_t              vary;\n     ngx_table_elt_t      **ph;\n     ngx_http_upstream_t   *u;\n \n@@ -5198,6 +5210,10 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n+    {\n+    u_char     *p;\n+    size_t      len;\n+    ngx_str_t   vary;\n \n     if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_VARY) {\n         return NGX_OK;\n@@ -5249,7 +5265,7 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     }\n \n     r->cache->vary = vary;\n-\n+    }\n #endif\n \n     return NGX_OK;\nDiff:\n@@ -293,6 +293,8 @@ typedef struct {\n \n     unsigned                         connection_close:1;\n     unsigned                         chunked:1;\n+    unsigned                         no_cache:1;\n+    unsigned                         expired:1;\n } ngx_http_upstream_headers_in_t;\n \n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 158",
        "commit_diff": "Diff:\n@@ -101,7 +101,7 @@ ngx_module_t  ngx_http_auth_request_module = {\n static ngx_int_t\n ngx_http_auth_request_handler(ngx_http_request_t *r)\n {\n-    ngx_table_elt_t               *h, *ho;\n+    ngx_table_elt_t               *h, *ho, **ph;\n     ngx_http_request_t            *sr;\n     ngx_http_post_subrequest_t    *ps;\n     ngx_http_auth_request_ctx_t   *ctx;\n@@ -147,7 +147,9 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)\n                 h = sr->upstream->headers_in.www_authenticate;\n             }\n \n-            if (h) {\n+            ph = &r->headers_out.www_authenticate;\n+\n+            while (h) {\n                 ho = ngx_list_push(&r->headers_out.headers);\n                 if (ho == NULL) {\n                     return NGX_ERROR;\n@@ -156,7 +158,10 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)\n                 *ho = *h;\n                 ho->next = NULL;\n \n-                r->headers_out.www_authenticate = ho;\n+                *ph = ho;\n+                ph = &ho->next;\n+\n+                h = h->next;\n             }\n \n             return ctx->status;\nDiff:\n@@ -1088,6 +1088,7 @@ ngx_int_t\n ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n {\n     ngx_int_t                  rc;\n+    ngx_table_elt_t           *h;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     if (r != r->main) {\n@@ -1122,8 +1123,8 @@ ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n         if (rc == NGX_OK) {\n             r->access_code = 0;\n \n-            if (r->headers_out.www_authenticate) {\n-                r->headers_out.www_authenticate->hash = 0;\n+            for (h = r->headers_out.www_authenticate; h; h = h->next) {\n+                h->hash = 0;\n             }\n \n             r->phase_handler = ph->next;\nDiff:\n@@ -2647,7 +2647,7 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n {\n     ngx_int_t                  status;\n     ngx_uint_t                 i;\n-    ngx_table_elt_t           *h;\n+    ngx_table_elt_t           *h, *ho, **ph;\n     ngx_http_err_page_t       *err_page;\n     ngx_http_core_loc_conf_t  *clcf;\n \n@@ -2676,18 +2676,26 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n             if (status == NGX_HTTP_UNAUTHORIZED\n                 && u->headers_in.www_authenticate)\n             {\n-                h = ngx_list_push(&r->headers_out.headers);\n+                h = u->headers_in.www_authenticate;\n+                ph = &r->headers_out.www_authenticate;\n \n-                if (h == NULL) {\n-                    ngx_http_upstream_finalize_request(r, u,\n+                while (h) {\n+                    ho = ngx_list_push(&r->headers_out.headers);\n+\n+                    if (ho == NULL) {\n+                        ngx_http_upstream_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n-                    return NGX_OK;\n-                }\n+                        return NGX_OK;\n+                    }\n+\n+                    *ho = *h;\n+                    ho->next = NULL;\n \n-                *h = *u->headers_in.www_authenticate;\n-                h->next = NULL;\n+                    *ph = ho;\n+                    ph = &ho->next;\n \n-                r->headers_out.www_authenticate = h;\n+                    h = h->next;\n+                }\n             }\n \n #if (NGX_HTTP_CACHE)\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 157",
        "commit_diff": "Diff:\n@@ -2007,8 +2007,12 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n                 hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                    h->lowcase_key, h->key.len);\n \n-                if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                    return NGX_ERROR;\n+                if (hh) {\n+                    rc = hh->handler(r, h, hh->offset);\n+\n+                    if (rc != NGX_OK) {\n+                        return rc;\n+                    }\n                 }\n \n                 ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -1891,8 +1891,12 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n                 hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                    h->lowcase_key, h->key.len);\n \n-                if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                    return NGX_ERROR;\n+                if (hh) {\n+                    rc = hh->handler(r, h, hh->offset);\n+\n+                    if (rc != NGX_OK) {\n+                        return rc;\n+                    }\n                 }\n \n                 continue;\nDiff:\n@@ -1930,8 +1930,12 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n             hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                h->lowcase_key, h->key.len);\n \n-            if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                return NGX_ERROR;\n+            if (hh) {\n+                rc = hh->handler(r, h, hh->offset);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n             }\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -1114,8 +1114,12 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n             hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                h->lowcase_key, h->key.len);\n \n-            if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                return NGX_ERROR;\n+            if (hh) {\n+                rc = hh->handler(r, h, hh->offset);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n             }\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -1340,8 +1340,12 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n             hh = ngx_hash_find(&umcf->headers_in_hash, h->hash,\n                                h->lowcase_key, h->key.len);\n \n-            if (hh && hh->handler(r, h, hh->offset) != NGX_OK) {\n-                return NGX_ERROR;\n+            if (hh) {\n+                rc = hh->handler(r, h, hh->offset);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n             }\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\nDiff:\n@@ -101,6 +101,9 @@ static void ngx_http_upstream_finalize_request(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t\n+    ngx_http_upstream_process_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r,\n@@ -226,7 +229,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  offsetof(ngx_http_headers_out_t, server), 0 },\n \n     { ngx_string(\"WWW-Authenticate\"),\n-                 ngx_http_upstream_process_header_line,\n+                 ngx_http_upstream_process_multi_header_lines,\n                  offsetof(ngx_http_upstream_headers_in_t, www_authenticate),\n                  ngx_http_upstream_copy_header_line, 0, 0 },\n \n@@ -236,7 +239,8 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  ngx_http_upstream_rewrite_location, 0, 0 },\n \n     { ngx_string(\"Refresh\"),\n-                 ngx_http_upstream_ignore_header_line, 0,\n+                 ngx_http_upstream_process_header_line,\n+                 offsetof(ngx_http_upstream_headers_in_t, refresh),\n                  ngx_http_upstream_rewrite_refresh, 0, 0 },\n \n     { ngx_string(\"Set-Cookie\"),\n@@ -2804,6 +2808,10 @@ ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)\n                 i = 0;\n             }\n \n+            if (h[i].hash == 0) {\n+                continue;\n+            }\n+\n             hh = ngx_hash_find(&umcf->headers_in_hash, h[i].hash,\n                                h[i].lowcase_key, h[i].key.len);\n \n@@ -2857,6 +2865,10 @@ ngx_http_upstream_process_headers(ngx_http_request_t *r, ngx_http_upstream_t *u)\n             i = 0;\n         }\n \n+        if (h[i].hash == 0) {\n+            continue;\n+        }\n+\n         if (ngx_hash_find(&u->conf->hide_headers_hash, h[i].hash,\n                           h[i].lowcase_key, h[i].key.len))\n         {\n@@ -4608,11 +4620,36 @@ ngx_http_upstream_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     ph = (ngx_table_elt_t **) ((char *) &r->upstream->headers_in + offset);\n \n-    if (*ph == NULL) {\n-        *ph = h;\n-        h->next = NULL;\n+    if (*ph) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &(*ph)->key, &(*ph)->value);\n+        h->hash = 0;\n+        return NGX_OK;\n     }\n \n+    *ph = h;\n+    h->next = NULL;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_upstream_process_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset)\n+{\n+    ngx_table_elt_t  **ph;\n+\n+    ph = (ngx_table_elt_t **) ((char *) &r->upstream->headers_in + offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n+    h->next = NULL;\n+\n     return NGX_OK;\n }\n \n@@ -4633,10 +4670,34 @@ ngx_http_upstream_process_content_length(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    if (u->headers_in.content_length) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.content_length->key,\n+                      &u->headers_in.content_length->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n+    if (u->headers_in.transfer_encoding) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent \\\"Content-Length\\\" and \"\n+                      \"\\\"Transfer-Encoding\\\" headers at the same time\");\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n     h->next = NULL;\n     u->headers_in.content_length = h;\n     u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);\n \n+    if (u->headers_in.content_length_n == NGX_ERROR) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent invalid \\\"Content-Length\\\" header: \"\n+                      \"\\\"%V: %V\\\"\", &h->key, &h->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n     return NGX_OK;\n }\n \n@@ -4649,6 +4710,17 @@ ngx_http_upstream_process_last_modified(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    if (u->headers_in.last_modified) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.last_modified->key,\n+                      &u->headers_in.last_modified->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     h->next = NULL;\n     u->headers_in.last_modified = h;\n     u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data,\n@@ -4818,6 +4890,18 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.expires) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.expires->key,\n+                      &u->headers_in.expires->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     u->headers_in.expires = h;\n     h->next = NULL;\n \n@@ -4859,6 +4943,18 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.x_accel_expires) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.x_accel_expires->key,\n+                      &u->headers_in.x_accel_expires->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     u->headers_in.x_accel_expires = h;\n     h->next = NULL;\n \n@@ -4919,6 +5015,18 @@ ngx_http_upstream_process_limit_rate(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.x_accel_limit_rate) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\", ignored\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.x_accel_limit_rate->key,\n+                      &u->headers_in.x_accel_limit_rate->value);\n+        h->hash = 0;\n+        return NGX_OK;\n+    }\n+\n     u->headers_in.x_accel_limit_rate = h;\n     h->next = NULL;\n \n@@ -4997,10 +5105,15 @@ static ngx_int_t\n ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_http_upstream_t  *u;\n+    ngx_table_elt_t      **ph;\n+    ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    u->headers_in.connection = h;\n+    ph = &u->headers_in.connection;\n+\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n     h->next = NULL;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n@@ -5021,14 +5134,37 @@ ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n+\n+    if (u->headers_in.transfer_encoding) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent duplicate header line: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value,\n+                      &u->headers_in.transfer_encoding->key,\n+                      &u->headers_in.transfer_encoding->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n+    if (u->headers_in.content_length) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent \\\"Content-Length\\\" and \"\n+                      \"\\\"Transfer-Encoding\\\" headers at the same time\");\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n+    }\n+\n     u->headers_in.transfer_encoding = h;\n     h->next = NULL;\n \n-    if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n-                         (u_char *) \"chunked\", 7 - 1)\n-        != NULL)\n+    if (h->value.len == 7\n+        && ngx_strncasecmp(h->value.data, (u_char *) \"chunked\", 7) == 0)\n     {\n         u->headers_in.chunked = 1;\n+\n+    } else {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"upstream sent unknown \\\"Transfer-Encoding\\\": \\\"%V\\\"\",\n+                      &h->value);\n+        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\n \n     return NGX_OK;\n@@ -5039,10 +5175,18 @@ static ngx_int_t\n ngx_http_upstream_process_vary(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_http_upstream_t  *u;\n+    u_char                *p;\n+    size_t                 len;\n+    ngx_str_t              vary;\n+    ngx_table_elt_t      **ph;\n+    ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    u->headers_in.vary = h;\n+    ph = &u->headers_in.vary;\n+\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n     h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n@@ -5051,17 +5195,52 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    if (r->cache == NULL) {\n+    if (r->cache == NULL || !u->cacheable) {\n         return NGX_OK;\n     }\n \n-    if (h->value.len > NGX_HTTP_CACHE_VARY_LEN\n-        || (h->value.len == 1 && h->value.data[0] == '*'))\n-    {\n+    if (h->value.len == 1 && h->value.data[0] == '*') {\n+        u->cacheable = 0;\n+        return NGX_OK;\n+    }\n+\n+    if (u->headers_in.vary->next) {\n+\n+        len = 0;\n+\n+        for (h = u->headers_in.vary; h; h = h->next) {\n+            len += h->value.len + 2;\n+        }\n+\n+        len -= 2;\n+\n+        p = ngx_pnalloc(r->pool, len);\n+        if (p == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        vary.len = len;\n+        vary.data = p;\n+\n+        for (h = u->headers_in.vary; h; h = h->next) {\n+            p = ngx_copy(p, h->value.data, h->value.len);\n+\n+            if (h->next == NULL) {\n+                break;\n+            }\n+\n+            *p++ = ','; *p++ = ' ';\n+        }\n+\n+    } else {\n+        vary = h->value;\n+    }\n+\n+    if (vary.len > NGX_HTTP_CACHE_VARY_LEN) {\n         u->cacheable = 0;\n     }\n \n-    r->cache->vary = h->value;\n+    r->cache->vary = vary;\n \n #endif\n \nDiff:\n@@ -280,6 +280,7 @@ typedef struct {\n \n     ngx_table_elt_t                 *last_modified;\n     ngx_table_elt_t                 *location;\n+    ngx_table_elt_t                 *refresh;\n     ngx_table_elt_t                 *www_authenticate;\n     ngx_table_elt_t                 *transfer_encoding;\n     ngx_table_elt_t                 *vary;\n",
        "analysis": "To find newly added entire functions, we should locate the functions that are introduced in their entirety in the diff. Here's the step-by-step process for locating and analyzing them:\n\n### Identifying Newly Added Functions:\n\n1. **Function `ngx_http_upstream_process_multi_header_lines`**:\n    ```c\n    static ngx_int_t\n    ngx_http_upstream_process_multi_header_lines(ngx_http_request_t *r,\n        ngx_table_elt_t *h, ngx_uint_t offset)\n    {\n        ngx_table_elt_t  **ph;\n\n        ph = (ngx_table_elt_t **) ((char *) &r->upstream->headers_in + offset);\n\n        while (*ph) { ph = &(*ph)->next; }\n\n        *ph = h;\n        h->next = NULL;\n\n        return NGX_OK;\n    }\n    ```\n\n### Analysis for Possibility of Out-of-Bounds Write in the New Function:\n\n- **Line by Line Analysis for `ngx_http_upstream_process_multi_header_lines`**:\n  - The function initializes a pointer `ph` to navigate through linked list nodes by iterating with `while (*ph) { ph = &(*ph)->next; }`.\n  - It sets the **end of the list** to point to `h` by assigning `*ph = h`.\n  - The buffer `ph` is dependent on `offset` added to `r->upstream->headers_in`.\n  - Given the assumption of an extremely malicious user, if `offset` were manipulated somehow to go beyond the intended bounds of `headers_in`, this could potentially cause an out-of-bounds write.\n  - Careful boundary checking or validation before using `offset` would be essential to ensure no out-of-bounds condition occurs.\n\nBased on the analysis, there is a possibility of out-of-bounds write in `ngx_http_upstream_process_multi_header_lines`, especially if pointers are improperly managed or `offset` is outside expected bounds.\n\n### Conclusion:\n\n\"TRUE [ngx_http_upstream_process_multi_header_lines]\""
    },
    {
        "commit_index": "Commit 156",
        "commit_diff": "Diff:\n@@ -339,6 +339,7 @@ ngx_http_auth_basic_set_realm(ngx_http_request_t *r, ngx_str_t *realm)\n     *p = '\"';\n \n     r->headers_out.www_authenticate->hash = 1;\n+    r->headers_out.www_authenticate->next = NULL;\n     ngx_str_set(&r->headers_out.www_authenticate->key, \"WWW-Authenticate\");\n     r->headers_out.www_authenticate->value.data = basic;\n     r->headers_out.www_authenticate->value.len = len;\nDiff:\n@@ -154,6 +154,7 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)\n                 }\n \n                 *ho = *h;\n+                ho->next = NULL;\n \n                 r->headers_out.www_authenticate = ho;\n             }\nDiff:\n@@ -1082,6 +1082,7 @@ ngx_http_dav_location(ngx_http_request_t *r)\n     }\n \n     r->headers_out.location->hash = 1;\n+    r->headers_out.location->next = NULL;\n     ngx_str_set(&r->headers_out.location->key, \"Location\");\n \n     escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\nDiff:\n@@ -280,6 +280,7 @@ ngx_http_gzip_header_filter(ngx_http_request_t *r)\n     }\n \n     h->hash = 1;\n+    h->next = NULL;\n     ngx_str_set(&h->key, \"Content-Encoding\");\n     ngx_str_set(&h->value, \"gzip\");\n     r->headers_out.content_encoding = h;\nDiff:\n@@ -242,6 +242,7 @@ ngx_http_gzip_static_handler(ngx_http_request_t *r)\n     }\n \n     h->hash = 1;\n+    h->next = NULL;\n     ngx_str_set(&h->key, \"Content-Encoding\");\n     ngx_str_set(&h->value, \"gzip\");\n     r->headers_out.content_encoding = h;\nDiff:\n@@ -362,6 +362,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n         }\n \n         r->headers_out.expires = e;\n+        e->next = NULL;\n \n         e->hash = 1;\n         ngx_str_set(&e->key, \"Expires\");\n@@ -621,6 +622,7 @@ ngx_http_set_response_header(ngx_http_request_t *r, ngx_http_header_val_t *hv,\n         }\n \n         *old = h;\n+        h->next = NULL;\n     }\n \n     h->hash = 1;\nDiff:\n@@ -401,6 +401,7 @@ ngx_http_memcached_process_header(ngx_http_request_t *r)\n             }\n \n             h->hash = 1;\n+            h->next = NULL;\n             ngx_str_set(&h->key, \"Content-Encoding\");\n             ngx_str_set(&h->value, \"gzip\");\n             r->headers_out.content_encoding = h;\nDiff:\n@@ -1965,6 +1965,7 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n                 ngx_str_set(&h->key, \"Server\");\n                 ngx_str_null(&h->value);\n                 h->lowcase_key = (u_char *) \"server\";\n+                h->next = NULL;\n             }\n \n             if (r->upstream->headers_in.date == NULL) {\n@@ -1978,6 +1979,7 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n                 ngx_str_set(&h->key, \"Date\");\n                 ngx_str_null(&h->value);\n                 h->lowcase_key = (u_char *) \"date\";\n+                h->next = NULL;\n             }\n \n             /* clear content length if response is chunked */\nDiff:\n@@ -259,6 +259,7 @@ ngx_http_range_header_filter(ngx_http_request_t *r)\n     }\n \n     r->headers_out.accept_ranges->hash = 1;\n+    r->headers_out.accept_ranges->next = NULL;\n     ngx_str_set(&r->headers_out.accept_ranges->key, \"Accept-Ranges\");\n     ngx_str_set(&r->headers_out.accept_ranges->value, \"bytes\");\n \n@@ -446,6 +447,7 @@ ngx_http_range_singlepart_header(ngx_http_request_t *r,\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n+    content_range->next = NULL;\n     ngx_str_set(&content_range->key, \"Content-Range\");\n \n     content_range->value.data = ngx_pnalloc(r->pool,\n@@ -618,6 +620,7 @@ ngx_http_range_not_satisfiable(ngx_http_request_t *r)\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n+    content_range->next = NULL;\n     ngx_str_set(&content_range->key, \"Content-Range\");\n \n     content_range->value.data = ngx_pnalloc(r->pool,\nDiff:\n@@ -195,6 +195,7 @@ ngx_http_static_handler(ngx_http_request_t *r)\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n         r->headers_out.location->value.len = len;\n         r->headers_out.location->value.data = location;\nDiff:\n@@ -573,6 +573,7 @@ header_out(r, key, value)\n     }\n \n     header->hash = 1;\n+    header->next = NULL;\n \n     if (ngx_http_perl_sv2str(aTHX_ r, &header->key, key) != NGX_OK) {\n         header->hash = 0;\nDiff:\n@@ -1007,6 +1007,7 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n \n         if (r->args.len == 0) {\n@@ -1687,6 +1688,7 @@ ngx_http_set_etag(ngx_http_request_t *r)\n     }\n \n     etag->hash = 1;\n+    etag->next = NULL;\n     ngx_str_set(&etag->key, \"ETag\");\n \n     etag->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\n@@ -1781,6 +1783,7 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n         r->headers_out.location->value = val;\n \nDiff:\n@@ -1243,6 +1243,7 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\n         }\n \n         r->headers_out.location->hash = 1;\n+        r->headers_out.location->next = NULL;\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n         r->headers_out.location->value = e->buf;\n \nDiff:\n@@ -649,6 +649,7 @@ ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n     }\n \n     location->hash = 1;\n+    location->next = NULL;\n     ngx_str_set(&location->key, \"Location\");\n     location->value = uri;\n \nDiff:\n@@ -2681,6 +2681,7 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,\n                 }\n \n                 *h = *u->headers_in.www_authenticate;\n+                h->next = NULL;\n \n                 r->headers_out.www_authenticate = h;\n             }\n@@ -4609,6 +4610,7 @@ ngx_http_upstream_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -4631,6 +4633,7 @@ ngx_http_upstream_process_content_length(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    h->next = NULL;\n     u->headers_in.content_length = h;\n     u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);\n \n@@ -4646,6 +4649,7 @@ ngx_http_upstream_process_last_modified(ngx_http_request_t *r,\n \n     u = r->upstream;\n \n+    h->next = NULL;\n     u->headers_in.last_modified = h;\n     u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data,\n                                                            h->value.len);\n@@ -4815,6 +4819,7 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     u = r->upstream;\n     u->headers_in.expires = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -4855,6 +4860,7 @@ ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,\n \n     u = r->upstream;\n     u->headers_in.x_accel_expires = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -4914,6 +4920,7 @@ ngx_http_upstream_process_limit_rate(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     u = r->upstream;\n     u->headers_in.x_accel_limit_rate = h;\n+    h->next = NULL;\n \n     if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE) {\n         return NGX_OK;\n@@ -4994,6 +5001,7 @@ ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     u = r->upstream;\n     u->headers_in.connection = h;\n+    h->next = NULL;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"close\", 5 - 1)\n@@ -5014,6 +5022,7 @@ ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,\n \n     u = r->upstream;\n     u->headers_in.transfer_encoding = h;\n+    h->next = NULL;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"chunked\", 7 - 1)\n@@ -5034,6 +5043,7 @@ ngx_http_upstream_process_vary(ngx_http_request_t *r,\n \n     u = r->upstream;\n     u->headers_in.vary = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n \n@@ -5075,6 +5085,7 @@ ngx_http_upstream_copy_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n     if (offset) {\n         ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);\n         *ph = ho;\n+        ho->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -5169,6 +5180,7 @@ ngx_http_upstream_copy_last_modified(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     r->headers_out.last_modified = ho;\n     r->headers_out.last_modified_time =\n@@ -5191,6 +5203,7 @@ ngx_http_upstream_rewrite_location(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     if (r->upstream->rewrite_redirect) {\n         rc = r->upstream->rewrite_redirect(r, ho, 0);\n@@ -5236,6 +5249,7 @@ ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     if (r->upstream->rewrite_redirect) {\n \n@@ -5281,6 +5295,7 @@ ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     if (r->upstream->rewrite_cookie) {\n         rc = r->upstream->rewrite_cookie(r, ho);\n@@ -5334,6 +5349,7 @@ ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,\n     }\n \n     *ho = *h;\n+    ho->next = NULL;\n \n     r->headers_out.accept_ranges = ho;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 155",
        "commit_diff": "Diff:\n@@ -272,7 +272,7 @@ header_in(r, key)\n     ngx_uint_t                  i, n, hash;\n     ngx_array_t                *a;\n     ngx_list_part_t            *part;\n-    ngx_table_elt_t            *h, **ph;\n+    ngx_table_elt_t            *h, *header, **ph;\n     ngx_http_header_t          *hh;\n     ngx_http_core_main_conf_t  *cmcf;\n \n@@ -311,47 +311,14 @@ header_in(r, key)\n \n         ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n-        if (*ph == NULL) {\n-            XSRETURN_UNDEF;\n-        }\n-\n-        if ((*ph)->next == NULL) {\n-            ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n-\n-            goto done;\n-        }\n-\n-        size = - (ssize_t) (sizeof(\"; \") - 1);\n-\n-        for (h = *ph; h; h = h->next) {\n-            size += h->value.len + sizeof(\"; \") - 1;\n-        }\n-\n-        value = ngx_pnalloc(r->pool, size);\n-        if (value == NULL) {\n-            ctx->error = 1;\n-            croak(\"ngx_pnalloc() failed\");\n-        }\n-\n-        p = value;\n-\n-        for (h = *ph; h; h = h->next) {\n-            p = ngx_copy(p, h->value.data, h->value.len);\n-\n-            if (h->next == NULL) {\n-                break;\n-            }\n-\n-            *p++ = sep; *p++ = ' ';\n-        }\n-\n-        ngx_http_perl_set_targ(value, size);\n-\n-        goto done;\n+        goto found;\n     }\n \n     /* iterate over all headers */\n \n+    sep = ',';\n+    ph = &header;\n+\n     part = &r->headers_in.headers.part;\n     h = part->elts;\n \n@@ -373,12 +340,49 @@ header_in(r, key)\n             continue;\n         }\n \n-        ngx_http_perl_set_targ(h[i].value.data, h[i].value.len);\n+        *ph = &h[i];\n+        ph = &h[i].next;\n+    }\n+\n+    *ph = NULL;\n+    ph = &header;\n \n+    found:\n+\n+    if (*ph == NULL) {\n+        XSRETURN_UNDEF;\n+    }\n+\n+    if ((*ph)->next == NULL) {\n+        ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n         goto done;\n     }\n \n-    XSRETURN_UNDEF;\n+    size = - (ssize_t) (sizeof(\"; \") - 1);\n+\n+    for (h = *ph; h; h = h->next) {\n+        size += h->value.len + sizeof(\"; \") - 1;\n+    }\n+\n+    value = ngx_pnalloc(r->pool, size);\n+    if (value == NULL) {\n+        ctx->error = 1;\n+        croak(\"ngx_pnalloc() failed\");\n+    }\n+\n+    p = value;\n+\n+    for (h = *ph; h; h = h->next) {\n+        p = ngx_copy(p, h->value.data, h->value.len);\n+\n+        if (h->next == NULL) {\n+            break;\n+        }\n+\n+        *p++ = sep; *p++ = ' ';\n+    }\n+\n+    ngx_http_perl_set_targ(value, size);\n \n     done:\n \nDiff:\n@@ -147,11 +147,6 @@ static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r,\n static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n \n-#if (NGX_HTTP_GZIP)\n-static ngx_int_t ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, ngx_uint_t offset);\n-#endif\n-\n static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n@@ -264,8 +259,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  offsetof(ngx_http_headers_out_t, expires), 1 },\n \n     { ngx_string(\"Accept-Ranges\"),\n-                 ngx_http_upstream_process_header_line,\n-                 offsetof(ngx_http_upstream_headers_in_t, accept_ranges),\n+                 ngx_http_upstream_ignore_header_line, 0,\n                  ngx_http_upstream_copy_allow_ranges,\n                  offsetof(ngx_http_headers_out_t, accept_ranges), 1 },\n \n@@ -316,12 +310,10 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n                  ngx_http_upstream_process_transfer_encoding, 0,\n                  ngx_http_upstream_ignore_header_line, 0, 0 },\n \n-#if (NGX_HTTP_GZIP)\n     { ngx_string(\"Content-Encoding\"),\n-                 ngx_http_upstream_process_header_line,\n-                 offsetof(ngx_http_upstream_headers_in_t, content_encoding),\n-                 ngx_http_upstream_copy_content_encoding, 0, 0 },\n-#endif\n+                 ngx_http_upstream_ignore_header_line, 0,\n+                 ngx_http_upstream_copy_header_line,\n+                 offsetof(ngx_http_headers_out_t, content_encoding), 0 },\n \n     { ngx_null_string, NULL, 0, NULL, 0, 0 }\n };\n@@ -4691,8 +4683,8 @@ static ngx_int_t\n ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_table_elt_t     **ph;\n-    ngx_http_upstream_t  *u;\n+    ngx_table_elt_t      **ph;\n+    ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n     ph = &u->headers_in.cache_control;\n@@ -4980,7 +4972,11 @@ static ngx_int_t\n ngx_http_upstream_process_charset(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    if (r->upstream->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_CHARSET) {\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+\n+    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_CHARSET) {\n         return NGX_OK;\n     }\n \n@@ -4994,13 +4990,16 @@ static ngx_int_t\n ngx_http_upstream_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    r->upstream->headers_in.connection = h;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+    u->headers_in.connection = h;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"close\", 5 - 1)\n         != NULL)\n     {\n-        r->upstream->headers_in.connection_close = 1;\n+        u->headers_in.connection_close = 1;\n     }\n \n     return NGX_OK;\n@@ -5011,13 +5010,16 @@ static ngx_int_t\n ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    r->upstream->headers_in.transfer_encoding = h;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+    u->headers_in.transfer_encoding = h;\n \n     if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,\n                          (u_char *) \"chunked\", 7 - 1)\n         != NULL)\n     {\n-        r->upstream->headers_in.chunked = 1;\n+        u->headers_in.chunked = 1;\n     }\n \n     return NGX_OK;\n@@ -5339,29 +5341,6 @@ ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r,\n }\n \n \n-#if (NGX_HTTP_GZIP)\n-\n-static ngx_int_t\n-ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, ngx_uint_t offset)\n-{\n-    ngx_table_elt_t  *ho;\n-\n-    ho = ngx_list_push(&r->headers_out.headers);\n-    if (ho == NULL) {\n-        return NGX_ERROR;\n-    }\n-\n-    *ho = *h;\n-\n-    r->headers_out.content_encoding = ho;\n-\n-    return NGX_OK;\n-}\n-\n-#endif\n-\n-\n static ngx_int_t\n ngx_http_upstream_add_variables(ngx_conf_t *cf)\n {\nDiff:\n@@ -280,15 +280,10 @@ typedef struct {\n \n     ngx_table_elt_t                 *last_modified;\n     ngx_table_elt_t                 *location;\n-    ngx_table_elt_t                 *accept_ranges;\n     ngx_table_elt_t                 *www_authenticate;\n     ngx_table_elt_t                 *transfer_encoding;\n     ngx_table_elt_t                 *vary;\n \n-#if (NGX_HTTP_GZIP)\n-    ngx_table_elt_t                 *content_encoding;\n-#endif\n-\n     ngx_table_elt_t                 *cache_control;\n     ngx_table_elt_t                 *set_cookie;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 154",
        "commit_diff": "Diff:\n@@ -304,29 +304,11 @@ header_in(r, key)\n \n         if (hh->offset == offsetof(ngx_http_headers_in_t, cookie)) {\n             sep = ';';\n-            goto multi;\n-        }\n-#if (NGX_HTTP_X_FORWARDED_FOR)\n-        if (hh->offset == offsetof(ngx_http_headers_in_t, x_forwarded_for)) {\n-            sep = ',';\n-            goto multi;\n-        }\n-#endif\n-\n-        ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n-\n-        if (*ph) {\n-            ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n \n-            goto done;\n+        } else {\n+            sep = ',';\n         }\n \n-        XSRETURN_UNDEF;\n-\n-    multi:\n-\n-        /* Cookie, X-Forwarded-For */\n-\n         ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n         if (*ph == NULL) {\nDiff:\n@@ -26,8 +26,6 @@ static ngx_int_t ngx_http_process_white_list(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n-static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n@@ -174,7 +172,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n #if (NGX_HTTP_X_FORWARDED_FOR)\n     { ngx_string(\"X-Forwarded-For\"),\n                  offsetof(ngx_http_headers_in_t, x_forwarded_for),\n-                 ngx_http_process_multi_header_lines },\n+                 ngx_http_process_header_line },\n #endif\n \n #if (NGX_HTTP_REALIP)\n@@ -207,7 +205,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n #endif\n \n     { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookie),\n-                 ngx_http_process_multi_header_lines },\n+                 ngx_http_process_header_line },\n \n     { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n                  ngx_http_process_black_list },\n@@ -1767,10 +1765,10 @@ ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n \n-    if (*ph == NULL) {\n-        *ph = h;\n-        h->next = NULL;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n+\n+    *ph = h;\n+    h->next = NULL;\n \n     return NGX_OK;\n }\n@@ -1876,13 +1874,10 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n {\n     u_char  *user_agent, *msie;\n \n-    if (r->headers_in.user_agent) {\n-        return NGX_OK;\n+    if (ngx_http_process_header_line(r, h, offset) != NGX_OK) {\n+        return NGX_ERROR;\n     }\n \n-    r->headers_in.user_agent = h;\n-    h->next = NULL;\n-\n     /* check some widespread browsers while the header is in CPU cache */\n \n     user_agent = h->value.data;\n@@ -1944,23 +1939,6 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n }\n \n \n-static ngx_int_t\n-ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,\n-    ngx_uint_t offset)\n-{\n-    ngx_table_elt_t  **ph;\n-\n-    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n-\n-    while (*ph) { ph = &(*ph)->next; }\n-\n-    *ph = h;\n-    h->next = NULL;\n-\n-    return NGX_OK;\n-}\n-\n-\n ngx_int_t\n ngx_http_process_request_header(ngx_http_request_t *r)\n {\nDiff:\n@@ -27,8 +27,6 @@ static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n-static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r,\n-    ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep);\n \n@@ -182,7 +180,7 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n #endif\n \n #if (NGX_HTTP_X_FORWARDED_FOR)\n-    { ngx_string(\"http_x_forwarded_for\"), NULL, ngx_http_variable_headers,\n+    { ngx_string(\"http_x_forwarded_for\"), NULL, ngx_http_variable_header,\n       offsetof(ngx_http_request_t, headers_in.x_forwarded_for), 0, 0 },\n #endif\n \n@@ -331,10 +329,10 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n     { ngx_string(\"sent_http_transfer_encoding\"), NULL,\n       ngx_http_variable_sent_transfer_encoding, 0, 0, 0 },\n \n-    { ngx_string(\"sent_http_cache_control\"), NULL, ngx_http_variable_headers,\n+    { ngx_string(\"sent_http_cache_control\"), NULL, ngx_http_variable_header,\n       offsetof(ngx_http_request_t, headers_out.cache_control), 0, 0 },\n \n-    { ngx_string(\"sent_http_link\"), NULL, ngx_http_variable_headers,\n+    { ngx_string(\"sent_http_link\"), NULL, ngx_http_variable_header,\n       offsetof(ngx_http_request_t, headers_out.link), 0, 0 },\n \n     { ngx_string(\"limit_rate\"), ngx_http_variable_set_limit_rate,\n@@ -817,22 +815,7 @@ static ngx_int_t\n ngx_http_variable_header(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     uintptr_t data)\n {\n-    ngx_table_elt_t  *h;\n-\n-    h = *(ngx_table_elt_t **) ((char *) r + data);\n-\n-    if (h) {\n-        v->len = h->value.len;\n-        v->valid = 1;\n-        v->no_cacheable = 0;\n-        v->not_found = 0;\n-        v->data = h->value.data;\n-\n-    } else {\n-        v->not_found = 1;\n-    }\n-\n-    return NGX_OK;\n+    return ngx_http_variable_headers_internal(r, v, data, ',');\n }\n \n \n@@ -844,14 +827,6 @@ ngx_http_variable_cookies(ngx_http_request_t *r,\n }\n \n \n-static ngx_int_t\n-ngx_http_variable_headers(ngx_http_request_t *r,\n-    ngx_http_variable_value_t *v, uintptr_t data)\n-{\n-    return ngx_http_variable_headers_internal(r, v, data, ',');\n-}\n-\n-\n static ngx_int_t\n ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep)\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 153",
        "commit_diff": "Diff:\n@@ -327,15 +327,15 @@ static ngx_int_t\n ngx_http_geo_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,\n     ngx_addr_t *addr)\n {\n-    ngx_array_t  *xfwd;\n+    ngx_table_elt_t  *xfwd;\n \n     if (ngx_http_geo_real_addr(r, ctx, addr) != NGX_OK) {\n         return NGX_ERROR;\n     }\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && ctx->proxies != NULL) {\n+    if (xfwd != NULL && ctx->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, addr, xfwd, NULL,\n                                            ctx->proxies, ctx->proxy_recursive);\n     }\nDiff:\n@@ -240,16 +240,16 @@ static u_long\n ngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n {\n     ngx_addr_t           addr;\n-    ngx_array_t         *xfwd;\n+    ngx_table_elt_t     *xfwd;\n     struct sockaddr_in  *sin;\n \n     addr.sockaddr = r->connection->sockaddr;\n     addr.socklen = r->connection->socklen;\n     /* addr.name = r->connection->addr_text; */\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {\n+    if (xfwd != NULL && gcf->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,\n                                            gcf->proxies, gcf->proxy_recursive);\n     }\n@@ -292,7 +292,7 @@ static geoipv6_t\n ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n {\n     ngx_addr_t            addr;\n-    ngx_array_t          *xfwd;\n+    ngx_table_elt_t      *xfwd;\n     in_addr_t             addr4;\n     struct in6_addr       addr6;\n     struct sockaddr_in   *sin;\n@@ -302,9 +302,9 @@ ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n     addr.socklen = r->connection->socklen;\n     /* addr.name = r->connection->addr_text; */\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {\n+    if (xfwd != NULL && gcf->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,\n                                            gcf->proxies, gcf->proxy_recursive);\n     }\nDiff:\n@@ -329,8 +329,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     time_t               now, expires_time, max_age;\n     ngx_str_t            value;\n     ngx_int_t            rc;\n-    ngx_uint_t           i;\n-    ngx_table_elt_t     *e, *cc, **ccp;\n+    ngx_table_elt_t     *e, *cc;\n     ngx_http_expires_t   expires;\n \n     expires = conf->expires;\n@@ -371,38 +370,28 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     len = sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\");\n     e->value.len = len - 1;\n \n-    ccp = r->headers_out.cache_control.elts;\n+    cc = r->headers_out.cache_control;\n \n-    if (ccp == NULL) {\n-\n-        if (ngx_array_init(&r->headers_out.cache_control, r->pool,\n-                           1, sizeof(ngx_table_elt_t *))\n-            != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n+    if (cc == NULL) {\n \n         cc = ngx_list_push(&r->headers_out.headers);\n         if (cc == NULL) {\n             return NGX_ERROR;\n         }\n \n+        r->headers_out.cache_control = cc;\n+        cc->next = NULL;\n+\n         cc->hash = 1;\n         ngx_str_set(&cc->key, \"Cache-Control\");\n \n-        ccp = ngx_array_push(&r->headers_out.cache_control);\n-        if (ccp == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        *ccp = cc;\n-\n     } else {\n-        for (i = 1; i < r->headers_out.cache_control.nelts; i++) {\n-            ccp[i]->hash = 0;\n+        for (cc = cc->next; cc; cc = cc->next) {\n+            cc->hash = 0;\n         }\n \n-        cc = ccp[0];\n+        cc = r->headers_out.cache_control;\n+        cc->next = NULL;\n     }\n \n     if (expires == NGX_HTTP_EXPIRES_EPOCH) {\n@@ -564,22 +553,12 @@ static ngx_int_t\n ngx_http_add_multi_header_lines(ngx_http_request_t *r,\n     ngx_http_header_val_t *hv, ngx_str_t *value)\n {\n-    ngx_array_t      *pa;\n     ngx_table_elt_t  *h, **ph;\n \n     if (value->len == 0) {\n         return NGX_OK;\n     }\n \n-    pa = (ngx_array_t *) ((char *) &r->headers_out + hv->offset);\n-\n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n     h = ngx_list_push(&r->headers_out.headers);\n     if (h == NULL) {\n         return NGX_ERROR;\n@@ -589,12 +568,12 @@ ngx_http_add_multi_header_lines(ngx_http_request_t *r,\n     h->key = hv->key;\n     h->value = *value;\n \n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + hv->offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n     return NGX_OK;\n }\nDiff:\n@@ -2559,22 +2559,20 @@ static ngx_int_t\n ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    size_t             len;\n-    u_char            *p;\n-    ngx_uint_t         i, n;\n-    ngx_table_elt_t  **h;\n+    size_t            len;\n+    u_char           *p;\n+    ngx_table_elt_t  *h, *xfwd;\n \n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n \n-    n = r->headers_in.x_forwarded_for.nelts;\n-    h = r->headers_in.x_forwarded_for.elts;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n     len = 0;\n \n-    for (i = 0; i < n; i++) {\n-        len += h[i]->value.len + sizeof(\", \") - 1;\n+    for (h = xfwd; h; h = h->next) {\n+        len += h->value.len + sizeof(\", \") - 1;\n     }\n \n     if (len == 0) {\n@@ -2593,8 +2591,8 @@ ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,\n     v->len = len;\n     v->data = p;\n \n-    for (i = 0; i < n; i++) {\n-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);\n+    for (h = xfwd; h; h = h->next) {\n+        p = ngx_copy(p, h->value.data, h->value.len);\n         *p++ = ','; *p++ = ' ';\n     }\n \nDiff:\n@@ -134,9 +134,8 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n     ngx_str_t                   *value;\n     ngx_uint_t                   i, hash;\n     ngx_addr_t                   addr;\n-    ngx_array_t                 *xfwd;\n     ngx_list_part_t             *part;\n-    ngx_table_elt_t             *header;\n+    ngx_table_elt_t             *header, *xfwd;\n     ngx_connection_t            *c;\n     ngx_http_realip_ctx_t       *ctx;\n     ngx_http_realip_loc_conf_t  *rlcf;\n@@ -168,9 +167,9 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n \n     case NGX_HTTP_REALIP_XFWD:\n \n-        xfwd = &r->headers_in.x_forwarded_for;\n+        xfwd = r->headers_in.x_forwarded_for;\n \n-        if (xfwd->elts == NULL) {\n+        if (xfwd == NULL) {\n             return NGX_DECLINED;\n         }\n \nDiff:\n@@ -319,10 +319,9 @@ ngx_http_userid_set_variable(ngx_http_request_t *r,\n static ngx_http_userid_ctx_t *\n ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n {\n-    ngx_int_t                n;\n-    ngx_str_t                src, dst;\n-    ngx_table_elt_t        **cookies;\n-    ngx_http_userid_ctx_t   *ctx;\n+    ngx_str_t               src, dst;\n+    ngx_table_elt_t        *cookie;\n+    ngx_http_userid_ctx_t  *ctx;\n \n     ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\n \n@@ -339,20 +338,19 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n         ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\n     }\n \n-    n = ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &conf->name,\n-                                          &ctx->cookie);\n-    if (n == NGX_DECLINED) {\n+    cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n+                                               &conf->name, &ctx->cookie);\n+    if (cookie == NULL) {\n         return ctx;\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"uid cookie: \\\"%V\\\"\", &ctx->cookie);\n \n     if (ctx->cookie.len < 22) {\n-        cookies = r->headers_in.cookies.elts;\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"client sent too short userid cookie \\\"%V\\\"\",\n-                      &cookies[n]->value);\n+                      &cookie->value);\n         return ctx;\n     }\n \n@@ -361,10 +359,9 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n     dst.data = (u_char *) ctx->uid_got;\n \n     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n-        cookies = r->headers_in.cookies.elts;\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"client sent invalid userid cookie \\\"%V\\\"\",\n-                      &cookies[n]->value);\n+                      &cookie->value);\n         return ctx;\n     }\n \nDiff:\n@@ -302,7 +302,7 @@ header_in(r, key)\n \n     if (hh) {\n \n-        if (hh->offset == offsetof(ngx_http_headers_in_t, cookies)) {\n+        if (hh->offset == offsetof(ngx_http_headers_in_t, cookie)) {\n             sep = ';';\n             goto multi;\n         }\n@@ -327,26 +327,22 @@ header_in(r, key)\n \n         /* Cookie, X-Forwarded-For */\n \n-        a = (ngx_array_t *) ((char *) &r->headers_in + hh->offset);\n-\n-        n = a->nelts;\n+        ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n-        if (n == 0) {\n+        if (*ph == NULL) {\n             XSRETURN_UNDEF;\n         }\n \n-        ph = a->elts;\n-\n-        if (n == 1) {\n+        if ((*ph)->next == NULL) {\n             ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n \n             goto done;\n         }\n \n         size = - (ssize_t) (sizeof(\"; \") - 1);\n \n-        for (i = 0; i < n; i++) {\n-            size += ph[i]->value.len + sizeof(\"; \") - 1;\n+        for (h = *ph; h; h = h->next) {\n+            size += h->value.len + sizeof(\"; \") - 1;\n         }\n \n         value = ngx_pnalloc(r->pool, size);\n@@ -357,10 +353,10 @@ header_in(r, key)\n \n         p = value;\n \n-        for (i = 0; /* void */ ; i++) {\n-            p = ngx_copy(p, ph[i]->value.data, ph[i]->value.len);\n+        for (h = *ph; h; h = h->next) {\n+            p = ngx_copy(p, h->value.data, h->value.len);\n \n-            if (i == n - 1) {\n+            if (h->next == NULL) {\n                 break;\n             }\n \nDiff:\n@@ -103,10 +103,10 @@ ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,\n     ngx_str_t *args, ngx_uint_t *flags);\n ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n     ngx_uint_t allow_underscores);\n-ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers,\n-    ngx_str_t *name, ngx_str_t *value);\n-ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers,\n-    ngx_str_t *name, ngx_str_t *value);\n+ngx_table_elt_t *ngx_http_parse_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);\n+ngx_table_elt_t *ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);\n ngx_int_t ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len,\n     ngx_str_t *value);\n void ngx_http_split_args(ngx_http_request_t *r, ngx_str_t *uri,\nDiff:\n@@ -2024,8 +2024,7 @@ ngx_http_gzip_ok(ngx_http_request_t *r)\n {\n     time_t                     date, expires;\n     ngx_uint_t                 p;\n-    ngx_array_t               *cc;\n-    ngx_table_elt_t           *e, *d, *ae;\n+    ngx_table_elt_t           *e, *d, *ae, *cc;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r->gzip_tested = 1;\n@@ -2118,30 +2117,30 @@ ngx_http_gzip_ok(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    cc = &r->headers_out.cache_control;\n+    cc = r->headers_out.cache_control;\n \n-    if (cc->elts) {\n+    if (cc) {\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_NO_CACHE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_cache,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_cache,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_NO_STORE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_store,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_store,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_PRIVATE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_private,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_private,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n@@ -2712,29 +2711,36 @@ ngx_http_set_disable_symlinks(ngx_http_request_t *r,\n \n ngx_int_t\n ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive)\n {\n-    ngx_int_t          rc;\n-    ngx_uint_t         i, found;\n-    ngx_table_elt_t  **h;\n+    ngx_int_t         rc;\n+    ngx_uint_t        found;\n+    ngx_table_elt_t  *h, *next;\n \n     if (headers == NULL) {\n         return ngx_http_get_forwarded_addr_internal(r, addr, value->data,\n                                                     value->len, proxies,\n                                                     recursive);\n     }\n \n-    i = headers->nelts;\n-    h = headers->elts;\n+    /* revert headers order */\n+\n+    for (h = headers, headers = NULL; h; h = next) {\n+        next = h->next;\n+        h->next = headers;\n+        headers = h;\n+    }\n+\n+    /* iterate over all headers in reverse order */\n \n     rc = NGX_DECLINED;\n \n     found = 0;\n \n-    while (i-- > 0) {\n-        rc = ngx_http_get_forwarded_addr_internal(r, addr, h[i]->value.data,\n-                                                  h[i]->value.len, proxies,\n+    for (h = headers; h; h = h->next) {\n+        rc = ngx_http_get_forwarded_addr_internal(r, addr, h->value.data,\n+                                                  h->value.len, proxies,\n                                                   recursive);\n \n         if (!recursive) {\n@@ -2753,6 +2759,14 @@ ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n         found = 1;\n     }\n \n+    /* restore headers order */\n+\n+    for (h = headers, headers = NULL; h; h = next) {\n+        next = h->next;\n+        h->next = headers;\n+        headers = h;\n+    }\n+\n     return rc;\n }\n \nDiff:\n@@ -532,7 +532,7 @@ ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r,\n     ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of);\n \n ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive);\n \n ngx_int_t ngx_http_link_multi_headers(ngx_http_request_t *r);\nDiff:\n@@ -1960,27 +1960,24 @@ ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,\n }\n \n \n-ngx_int_t\n-ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n-    ngx_str_t *value)\n+ngx_table_elt_t *\n+ngx_http_parse_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)\n {\n-    ngx_uint_t         i;\n-    u_char            *start, *last, *end, ch;\n-    ngx_table_elt_t  **h;\n-\n-    h = headers->elts;\n+    u_char           *start, *last, *end, ch;\n+    ngx_table_elt_t  *h;\n \n-    for (i = 0; i < headers->nelts; i++) {\n+    for (h = headers; h; h = h->next) {\n \n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,\n-                       \"parse header: \\\"%V: %V\\\"\", &h[i]->key, &h[i]->value);\n+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                       \"parse header: \\\"%V: %V\\\"\", &h->key, &h->value);\n \n-        if (name->len > h[i]->value.len) {\n+        if (name->len > h->value.len) {\n             continue;\n         }\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n         while (start < end) {\n \n@@ -1994,7 +1991,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n \n             if (value == NULL) {\n                 if (start == end || *start == ',') {\n-                    return i;\n+                    return h;\n                 }\n \n                 goto skip;\n@@ -2014,7 +2011,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n             value->len = last - start;\n             value->data = start;\n \n-            return i;\n+            return h;\n \n         skip:\n \n@@ -2029,31 +2026,28 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n         }\n     }\n \n-    return NGX_DECLINED;\n+    return NULL;\n }\n \n \n-ngx_int_t\n-ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,\n-    ngx_str_t *value)\n+ngx_table_elt_t *\n+ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)\n {\n-    ngx_uint_t         i;\n-    u_char            *start, *last, *end;\n-    ngx_table_elt_t  **h;\n-\n-    h = headers->elts;\n+    u_char           *start, *last, *end;\n+    ngx_table_elt_t  *h;\n \n-    for (i = 0; i < headers->nelts; i++) {\n+    for (h = headers; h; h = h->next) {\n \n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,\n-                       \"parse header: \\\"%V: %V\\\"\", &h[i]->key, &h[i]->value);\n+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                       \"parse header: \\\"%V: %V\\\"\", &h->key, &h->value);\n \n-        if (name->len >= h[i]->value.len) {\n+        if (name->len >= h->value.len) {\n             continue;\n         }\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n         if (ngx_strncasecmp(start, name->data, name->len) != 0) {\n             continue;\n@@ -2077,10 +2071,10 @@ ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,\n         value->len = last - start;\n         value->data = start;\n \n-        return i;\n+        return h;\n     }\n \n-    return NGX_DECLINED;\n+    return NULL;\n }\n \n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,\n     ngx_http_request_t *r, ngx_http_core_srv_conf_t **cscfp);\n \n static void ngx_http_request_handler(ngx_event_t *ev);\n+static ngx_int_t ngx_http_trace_handler(ngx_http_request_t *r);\n static void ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc);\n static void ngx_http_terminate_handler(ngx_http_request_t *r);\n static void ngx_http_finalize_connection(ngx_http_request_t *r);\n@@ -205,7 +206,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  ngx_http_process_header_line },\n #endif\n \n-    { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookies),\n+    { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookie),\n                  ngx_http_process_multi_header_lines },\n \n     { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n@@ -1768,6 +1769,7 @@ ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -1784,6 +1786,7 @@ ngx_http_process_unique_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n         return NGX_OK;\n     }\n \n@@ -1816,6 +1819,7 @@ ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     r->headers_in.host = h;\n+    h->next = NULL;\n \n     host = h->value;\n \n@@ -1877,6 +1881,7 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     r->headers_in.user_agent = h;\n+    h->next = NULL;\n \n     /* check some widespread browsers while the header is in CPU cache */\n \n@@ -1943,34 +1948,24 @@ static ngx_int_t\n ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_array_t       *headers;\n     ngx_table_elt_t  **ph;\n \n-    headers = (ngx_array_t *) ((char *) &r->headers_in + offset);\n-\n-    if (headers->elts == NULL) {\n-        if (ngx_array_init(headers, r->pool, 1, sizeof(ngx_table_elt_t *))\n-            != NGX_OK)\n-        {\n-            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-            return NGX_ERROR;\n-        }\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n \n-    ph = ngx_array_push(headers);\n-    if (ph == NULL) {\n-        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n+\n     return NGX_OK;\n }\n \n \n ngx_int_t\n ngx_http_process_request_header(ngx_http_request_t *r)\n {\n+    ngx_core_conf_t *ccf = (ngx_core_conf_t *) ngx_get_conf(r->cycle->conf_ctx, ngx_core_module);\n+\n     if (r->headers_in.server.len == 0\n         && ngx_http_set_virtual_server(r, &r->headers_in.server)\n            == NGX_ERROR)\n@@ -2049,8 +2044,12 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n     if (r->method == NGX_HTTP_TRACE) {\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                       \"client sent TRACE method\");\n-        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n-        return NGX_ERROR;\n+          if (ccf->trace_enable != -1) {\n+               return ngx_http_trace_handler(r);\n+          } else {\n+               ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+               return NGX_ERROR;\n+          }\n     }\n \n     return NGX_OK;\n@@ -4049,3 +4048,65 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     return NGX_OK;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_trace_handler(ngx_http_request_t *r)\n+{\n+    ngx_list_part_t *part;\n+    ngx_table_elt_t *header;\n+    ngx_buf_t *b;\n+    ngx_chain_t out;\n+    ngx_int_t rc, content_len;\n+\n+    b = ngx_create_temp_buf(r->pool, 200);\n+    if (b == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);\n+    *b->last++ = '\\n';\n+\n+    content_len = r->request_line.len + 1;\n+\n+    part = &r->headers_in.headers.part;\n+    header = part->elts;\n+    for (ngx_uint_t i = 0; ; i++) {\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                b->last_buf = 1;\n+                break;\n+            }\n+            part = part->next;\n+            header = part->elts;\n+            i = 0;\n+        }\n+\n+        size_t header_len = header[i].key.len + header[i].value.len + 3;\n+        content_len += header_len;\n+\n+        b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n+        *b->last++ = ':';\n+        *b->last++ = ' ';\n+        b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);\n+        *b->last++ = '\\n';\n+    }\n+\n+    ngx_str_t ct = ngx_string(\"message/http\");\n+    r->headers_out.status = NGX_HTTP_OK;\n+    r->headers_out.content_type = ct;\n+    r->headers_out.content_length_n = content_len;\n+    rc = ngx_http_send_header(r);\n+\n+    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n+        return rc;\n+    }\n+\n+    out.buf = b;\n+    out.next = NULL;\n+\n+    rc = ngx_http_output_filter(r, &out);\n+    ngx_http_close_request(r, rc);\n+\n+    return NGX_DONE;\n+}\nDiff:\n@@ -214,7 +214,7 @@ typedef struct {\n     ngx_table_elt_t                  *keep_alive;\n \n #if (NGX_HTTP_X_FORWARDED_FOR)\n-    ngx_array_t                       x_forwarded_for;\n+    ngx_table_elt_t                  *x_forwarded_for;\n #endif\n \n #if (NGX_HTTP_REALIP)\n@@ -233,11 +233,11 @@ typedef struct {\n     ngx_table_elt_t                  *date;\n #endif\n \n+    ngx_table_elt_t                  *cookie;\n+\n     ngx_str_t                         user;\n     ngx_str_t                         passwd;\n \n-    ngx_array_t                       cookies;\n-\n     ngx_str_t                         server;\n     off_t                             content_length_n;\n     time_t                            keep_alive_n;\n@@ -279,6 +279,9 @@ typedef struct {\n     ngx_table_elt_t                  *expires;\n     ngx_table_elt_t                  *etag;\n \n+    ngx_table_elt_t                  *cache_control;\n+    ngx_table_elt_t                  *link;\n+\n     ngx_str_t                        *override_charset;\n \n     size_t                            content_type_len;\n@@ -287,9 +290,6 @@ typedef struct {\n     u_char                           *content_type_lowcase;\n     ngx_uint_t                        content_type_hash;\n \n-    ngx_array_t                       cache_control;\n-    ngx_array_t                       link;\n-\n     off_t                             content_length_n;\n     off_t                             content_offset;\n     time_t                            date_time;\nDiff:\n@@ -246,7 +246,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n \n     { ngx_string(\"Set-Cookie\"),\n                  ngx_http_upstream_process_set_cookie,\n-                 offsetof(ngx_http_upstream_headers_in_t, cookies),\n+                 offsetof(ngx_http_upstream_headers_in_t, set_cookie),\n                  ngx_http_upstream_rewrite_set_cookie, 0, 1 },\n \n     { ngx_string(\"Content-Disposition\"),\n@@ -4666,26 +4666,16 @@ static ngx_int_t\n ngx_http_upstream_process_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_array_t           *pa;\n     ngx_table_elt_t      **ph;\n     ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    pa = &u->headers_in.cookies;\n+    ph = &u->headers_in.set_cookie;\n \n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     if (!(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_SET_COOKIE)) {\n@@ -4701,26 +4691,16 @@ static ngx_int_t\n ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_array_t          *pa;\n     ngx_table_elt_t     **ph;\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n-    pa = &u->headers_in.cache_control;\n+    ph = &u->headers_in.cache_control;\n \n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -5103,31 +5083,21 @@ static ngx_int_t\n ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_array_t      *pa;\n     ngx_table_elt_t  *ho, **ph;\n \n-    pa = (ngx_array_t *) ((char *) &r->headers_out + offset);\n-\n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n     ho = ngx_list_push(&r->headers_out.headers);\n     if (ho == NULL) {\n         return NGX_ERROR;\n     }\n \n     *ho = *h;\n \n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = ho;\n+    ho->next = NULL;\n \n     return NGX_OK;\n }\n@@ -5740,9 +5710,9 @@ ngx_http_upstream_cookie_variable(ngx_http_request_t *r,\n     s.len = name->len - (sizeof(\"upstream_cookie_\") - 1);\n     s.data = name->data + sizeof(\"upstream_cookie_\") - 1;\n \n-    if (ngx_http_parse_set_cookie_lines(&r->upstream->headers_in.cookies,\n+    if (ngx_http_parse_set_cookie_lines(r, r->upstream->headers_in.set_cookie,\n                                         &s, &cookie)\n-        == NGX_DECLINED)\n+        == NULL)\n     {\n         v->not_found = 1;\n         return NGX_OK;\nDiff:\n@@ -289,8 +289,8 @@ typedef struct {\n     ngx_table_elt_t                 *content_encoding;\n #endif\n \n-    ngx_array_t                      cache_control;\n-    ngx_array_t                      cookies;\n+    ngx_table_elt_t                 *cache_control;\n+    ngx_table_elt_t                 *set_cookie;\n \n     off_t                            content_length_n;\n     time_t                           last_modified_time;\nDiff:\n@@ -187,7 +187,7 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n #endif\n \n     { ngx_string(\"http_cookie\"), NULL, ngx_http_variable_cookies,\n-      offsetof(ngx_http_request_t, headers_in.cookies), 0, 0 },\n+      offsetof(ngx_http_request_t, headers_in.cookie), 0, 0 },\n \n     { ngx_string(\"content_length\"), NULL, ngx_http_variable_content_length,\n       0, 0, 0 },\n@@ -856,26 +856,21 @@ static ngx_int_t\n ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep)\n {\n-    size_t             len;\n-    u_char            *p, *end;\n-    ngx_uint_t         i, n;\n-    ngx_array_t       *a;\n-    ngx_table_elt_t  **h;\n-\n-    a = (ngx_array_t *) ((char *) r + data);\n+    size_t            len;\n+    u_char           *p;\n+    ngx_table_elt_t  *h, *th;\n \n-    n = a->nelts;\n-    h = a->elts;\n+    h = *(ngx_table_elt_t **) ((char *) r + data);\n \n     len = 0;\n \n-    for (i = 0; i < n; i++) {\n+    for (th = h; th; th = th->next) {\n \n-        if (h[i]->hash == 0) {\n+        if (th->hash == 0) {\n             continue;\n         }\n \n-        len += h[i]->value.len + 2;\n+        len += th->value.len + 2;\n     }\n \n     if (len == 0) {\n@@ -889,9 +884,9 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     v->no_cacheable = 0;\n     v->not_found = 0;\n \n-    if (n == 1) {\n-        v->len = (*h)->value.len;\n-        v->data = (*h)->value.data;\n+    if (h->next == NULL) {\n+        v->len = h->value.len;\n+        v->data = h->value.data;\n \n         return NGX_OK;\n     }\n@@ -904,17 +899,15 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     v->len = len;\n     v->data = p;\n \n-    end = p + len;\n-\n-    for (i = 0; /* void */ ; i++) {\n+    for (th = h; th; th = th->next) {\n \n-        if (h[i]->hash == 0) {\n+        if (th->hash == 0) {\n             continue;\n         }\n \n-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);\n+        p = ngx_copy(p, th->value.data, th->value.len);\n \n-        if (p == end) {\n+        if (th->next == NULL) {\n             break;\n         }\n \n@@ -1112,8 +1105,8 @@ ngx_http_variable_cookie(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     s.len = name->len - (sizeof(\"cookie_\") - 1);\n     s.data = name->data + sizeof(\"cookie_\") - 1;\n \n-    if (ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &s, &cookie)\n-        == NGX_DECLINED)\n+    if (ngx_http_parse_multi_header_lines(r, r->headers_in.cookie, &s, &cookie)\n+        == NULL)\n     {\n         v->not_found = 1;\n         return NGX_OK;\nDiff:\n@@ -674,14 +674,14 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_v2_push_resources(ngx_http_request_t *r)\n {\n-    u_char                     *start, *end, *last;\n-    ngx_int_t                   rc;\n-    ngx_str_t                   path;\n-    ngx_uint_t                  i, push;\n-    ngx_table_elt_t           **h;\n-    ngx_http_v2_loc_conf_t     *h2lcf;\n-    ngx_http_complex_value_t   *pushes;\n-    ngx_str_t                   binary[NGX_HTTP_V2_PUSH_HEADERS];\n+    u_char                    *start, *end, *last;\n+    ngx_int_t                  rc;\n+    ngx_str_t                  path;\n+    ngx_uint_t                 i, push;\n+    ngx_table_elt_t           *h;\n+    ngx_http_v2_loc_conf_t    *h2lcf;\n+    ngx_http_complex_value_t  *pushes;\n+    ngx_str_t                  binary[NGX_HTTP_V2_PUSH_HEADERS];\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http2 push resources\");\n@@ -725,15 +725,13 @@ ngx_http_v2_push_resources(ngx_http_request_t *r)\n         return NGX_OK;\n     }\n \n-    h = r->headers_out.link.elts;\n-\n-    for (i = 0; i < r->headers_out.link.nelts; i++) {\n+    for (h = r->headers_out.link; h; h = h->next) {\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"http2 parse link: \\\"%V\\\"\", &h[i]->value);\n+                       \"http2 parse link: \\\"%V\\\"\", &h->value);\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n     next_link:\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 152",
        "commit_diff": "Diff:\n@@ -5703,7 +5703,7 @@ ngx_http_upstream_header_variable(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                          &r->upstream->headers_in.headers.part,\n                                          sizeof(\"upstream_http_\") - 1);\n }\n@@ -5718,7 +5718,7 @@ ngx_http_upstream_trailer_variable(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                         &r->upstream->headers_in.trailers.part,\n                                         sizeof(\"upstream_trailer_\") - 1);\n }\nDiff:\n@@ -929,7 +929,7 @@ static ngx_int_t\n ngx_http_variable_unknown_header_in(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                             &r->headers_in.headers.part,\n                                             sizeof(\"http_\") - 1);\n }\n@@ -939,7 +939,7 @@ static ngx_int_t\n ngx_http_variable_unknown_header_out(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                             &r->headers_out.headers.part,\n                                             sizeof(\"sent_http_\") - 1);\n }\n@@ -949,19 +949,26 @@ static ngx_int_t\n ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    return ngx_http_variable_unknown_header(v, (ngx_str_t *) data,\n+    return ngx_http_variable_unknown_header(r, v, (ngx_str_t *) data,\n                                             &r->headers_out.trailers.part,\n                                             sizeof(\"sent_trailer_\") - 1);\n }\n \n \n ngx_int_t\n-ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,\n+ngx_http_variable_unknown_header(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, ngx_str_t *var,\n     ngx_list_part_t *part, size_t prefix)\n {\n-    u_char            ch;\n+    u_char           *p, ch;\n+    size_t            len;\n     ngx_uint_t        i, n;\n-    ngx_table_elt_t  *header;\n+    ngx_table_elt_t  *header, *h, **ph;\n+\n+    ph = &h;\n+#if (NGX_SUPPRESS_WARN)\n+    len = 0;\n+#endif\n \n     header = part->elts;\n \n@@ -981,7 +988,11 @@ ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,\n             continue;\n         }\n \n-        for (n = 0; n + prefix < var->len && n < header[i].key.len; n++) {\n+        if (header[i].key.len != var->len - prefix) {\n+            continue;\n+        }\n+\n+        for (n = 0; n < var->len - prefix; n++) {\n             ch = header[i].key.data[n];\n \n             if (ch >= 'A' && ch <= 'Z') {\n@@ -996,18 +1007,59 @@ ngx_http_variable_unknown_header(ngx_http_variable_value_t *v, ngx_str_t *var,\n             }\n         }\n \n-        if (n + prefix == var->len && n == header[i].key.len) {\n-            v->len = header[i].value.len;\n-            v->valid = 1;\n-            v->no_cacheable = 0;\n-            v->not_found = 0;\n-            v->data = header[i].value.data;\n-\n-            return NGX_OK;\n+        if (n != var->len - prefix) {\n+            continue;\n         }\n+\n+        len += header[i].value.len + 2;\n+\n+        *ph = &header[i];\n+        ph = &header[i].next;\n     }\n \n-    v->not_found = 1;\n+    *ph = NULL;\n+\n+    if (h == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    len -= 2;\n+\n+    if (h->next == NULL) {\n+\n+        v->len = h->value.len;\n+        v->valid = 1;\n+        v->no_cacheable = 0;\n+        v->not_found = 0;\n+        v->data = h->value.data;\n+\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_pnalloc(r->pool, len);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    v->len = len;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = p;\n+\n+    for ( ;; ) {\n+\n+        p = ngx_copy(p, h->value.data, h->value.len);\n+\n+        if (h->next == NULL) {\n+            break;\n+        }\n+\n+        *p++ = ','; *p++ = ' ';\n+\n+        h = h->next;\n+    }\n \n     return NGX_OK;\n }\n@@ -1889,7 +1941,7 @@ ngx_http_variable_sent_location(ngx_http_request_t *r,\n \n     ngx_str_set(&name, \"sent_http_location\");\n \n-    return ngx_http_variable_unknown_header(v, &name,\n+    return ngx_http_variable_unknown_header(r, v, &name,\n                                             &r->headers_out.headers.part,\n                                             sizeof(\"sent_http_\") - 1);\n }\nDiff:\n@@ -57,8 +57,9 @@ ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r,\n ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r,\n     ngx_str_t *name, ngx_uint_t key);\n \n-ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v,\n-    ngx_str_t *var, ngx_list_part_t *part, size_t prefix);\n+ngx_int_t ngx_http_variable_unknown_header(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, ngx_str_t *var, ngx_list_part_t *part,\n+    size_t prefix);\n \n \n #if (NGX_PCRE)\n",
        "analysis": "The newly added entire function in the provided diff is `ngx_http_variable_unknown_header`. Let's analyze this function to check for potential out-of-bounds write vulnerabilities.\n\n```c\nngx_int_t\nngx_http_variable_unknown_header(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, ngx_str_t *var,\n    ngx_list_part_t *part, size_t prefix)\n{\n    u_char           *p, ch;\n    size_t            len;\n    ngx_uint_t        i, n;\n    ngx_table_elt_t  *header, *h, **ph;\n    \n    ph = &h;\n    \n#if (NGX_SUPPRESS_WARN)\n    len = 0;\n#endif\n\n    header = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (header[i].hash == 0) {\n            continue;\n        }\n\n        if (header[i].key.len != var->len - prefix) {\n            continue;\n        }\n\n        for (n = 0; n < var->len - prefix; n++) {\n            ch = header[i].key.data[n];\n\n            if (ch >= 'A' && ch <= 'Z') {\n                ch |= 0x20;\n            }\n\n            if (ch != var->data[n + prefix]) {\n                break;\n            }\n        }\n\n        if (n != var->len - prefix) {\n            continue;\n        }\n\n        len += header[i].value.len + 2;\n\n        *ph = &header[i];\n        ph = &header[i].next;\n    }\n\n    *ph = NULL;\n\n    if (h == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    len -= 2;\n\n    if (h->next == NULL) {\n\n        v->len = h->value.len;\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = h->value.data;\n\n        return NGX_OK;\n    }\n\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    for ( ;; ) {\n\n        p = ngx_copy(p, h->value.data, h->value.len);\n\n        if (h->next == NULL) {\n            break;\n        }\n\n        *p++ = ','; *p++ = ' ';\n\n        h = h->next;\n    }\n\n    return NGX_OK;\n}\n```\n\n### Analysis\n\n1. **Header Key Length Check:**\n   - The function checks if `header[i].key.len` equals `var->len - prefix`. Only if this condition passes does it proceed to compare characters, indicating a length match is required beforehand.\n\n2. **Character Comparison:**\n   - The function loops over `n` to check each character in the header's key data against `var->data`. This iterates only up to `var->len - prefix`.\n\n3. **Value Concatenation and Memory Allocation:**\n   - The function uses `len += header[i].value.len + 2` to calculate the total required length for the concatenated string of all matched headers.\n   - `len` is then adjusted with `len -= 2` to account for the trailing delimiter.\n   - Memory is allocated using `ngx_pnalloc(r->pool, len)` to hold the concatenated header values.\n   - Memory allocation checks for success, mitigating some direct overwrite issues.\n\n4. **Buffer Writing:**\n   - The loop writes values into the buffer using `p = ngx_copy(p, h->value.data, h->value.len);`.\n   - Each header value is appended with a ``,`` and ``space`` unless it is the last header (`if (h->next == NULL)`), helping ensure bounds are respected.\n\n### Conclusion\n\nGiven that the function involves dynamically allocated memory and respects the constraints of string length checks, it's structured to prevent out-of-bounds writes due to length miscalculations for headers. However, if there are potential concerns such as malformed inputs or integer overflows affecting calculations, these could introduce risks in a different context. Therefore, while direct out-of-bounds writes do not appear evident in this logic, careful input validation and length calculation scrutinies are critical in a broader sense.\n\n**Result:** TRUE [ngx_http_variable_unknown_header]"
    },
    {
        "commit_index": "Commit 151",
        "commit_diff": "Diff:\n@@ -89,12 +89,15 @@ typedef struct {\n } ngx_hash_keys_arrays_t;\n \n \n-typedef struct {\n+typedef struct ngx_table_elt_s  ngx_table_elt_t;\n+\n+struct ngx_table_elt_s {\n     ngx_uint_t        hash;\n     ngx_str_t         key;\n     ngx_str_t         value;\n     u_char           *lowcase_key;\n-} ngx_table_elt_t;\n+    ngx_table_elt_t  *next;\n+};\n \n \n void *ngx_hash_find(ngx_hash_t *hash, ngx_uint_t key, u_char *name, size_t len);\nDiff:\n@@ -835,14 +835,14 @@ static ngx_int_t\n ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n {\n     off_t                         file_pos;\n-    u_char                        ch, *pos, *lowcase_key;\n+    u_char                        ch, sep, *pos, *lowcase_key;\n     size_t                        size, len, key_len, val_len, padding,\n                                   allocated;\n     ngx_uint_t                    i, n, next, hash, skip_empty, header_params;\n     ngx_buf_t                    *b;\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n-    ngx_table_elt_t              *header, **ignored;\n+    ngx_table_elt_t              *header, *hn, **ignored;\n     ngx_http_upstream_t          *u;\n     ngx_http_script_code_pt       code;\n     ngx_http_script_engine_t      e, le;\n@@ -900,7 +900,11 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n         allocated = 0;\n         lowcase_key = NULL;\n \n-        if (params->number) {\n+        if (ngx_http_link_multi_headers(r) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (params->number || r->headers_in.multi) {\n             n = 0;\n             part = &r->headers_in.headers.part;\n \n@@ -930,6 +934,12 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n                 i = 0;\n             }\n \n+            for (n = 0; n < header_params; n++) {\n+                if (&header[i] == ignored[n]) {\n+                    goto next_length;\n+                }\n+            }\n+\n             if (params->number) {\n                 if (allocated < header[i].key.len) {\n                     allocated = header[i].key.len + 16;\n@@ -959,15 +969,23 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n                     ignored[header_params++] = &header[i];\n                     continue;\n                 }\n+            }\n \n-                n += sizeof(\"HTTP_\") - 1;\n+            key_len = sizeof(\"HTTP_\") - 1 + header[i].key.len;\n \n-            } else {\n-                n = sizeof(\"HTTP_\") - 1 + header[i].key.len;\n+            val_len = header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                val_len += hn->value.len + 2;\n+                ignored[header_params++] = hn;\n             }\n \n-            len += ((n > 127) ? 4 : 1) + ((header[i].value.len > 127) ? 4 : 1)\n-                + n + header[i].value.len;\n+            len += ((key_len > 127) ? 4 : 1) + key_len\n+                   + ((val_len > 127) ? 4 : 1) + val_len;\n+\n+        next_length:\n+\n+            continue;\n         }\n     }\n \n@@ -1109,7 +1127,7 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n \n             for (n = 0; n < header_params; n++) {\n                 if (&header[i] == ignored[n]) {\n-                    goto next;\n+                    goto next_value;\n                 }\n             }\n \n@@ -1125,6 +1143,11 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n             }\n \n             val_len = header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                val_len += hn->value.len + 2;\n+            }\n+\n             if (val_len > 127) {\n                 *b->last++ = (u_char) (((val_len >> 24) & 0x7f) | 0x80);\n                 *b->last++ = (u_char) ((val_len >> 16) & 0xff);\n@@ -1150,13 +1173,34 @@ ngx_http_fastcgi_create_request(ngx_http_request_t *r)\n                 *b->last++ = ch;\n             }\n \n-            b->last = ngx_copy(b->last, header[i].value.data, val_len);\n+            b->last = ngx_copy(b->last, header[i].value.data,\n+                               header[i].value.len);\n+\n+            if (header[i].next) {\n+\n+                if (header[i].key.len == sizeof(\"Cookie\") - 1\n+                    && ngx_strncasecmp(header[i].key.data, (u_char *) \"Cookie\",\n+                                       sizeof(\"Cookie\") - 1)\n+                       == 0)\n+                {\n+                    sep = ';';\n+\n+                } else {\n+                    sep = ',';\n+                }\n+\n+                for (hn = header[i].next; hn; hn = hn->next) {\n+                    *b->last++ = sep;\n+                    *b->last++ = ' ';\n+                    b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n+                }\n+            }\n \n             ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                            \"fastcgi param: \\\"%*s: %*s\\\"\",\n                            key_len, b->last - (key_len + val_len),\n                            val_len, b->last - val_len);\n-        next:\n+        next_value:\n \n             continue;\n         }\nDiff:\n@@ -633,14 +633,14 @@ static ngx_int_t\n ngx_http_scgi_create_request(ngx_http_request_t *r)\n {\n     off_t                         content_length_n;\n-    u_char                        ch, *key, *val, *lowcase_key;\n+    u_char                        ch, sep, *key, *val, *lowcase_key;\n     size_t                        len, key_len, val_len, allocated;\n     ngx_buf_t                    *b;\n     ngx_str_t                     content_length;\n     ngx_uint_t                    i, n, hash, skip_empty, header_params;\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n-    ngx_table_elt_t              *header, **ignored;\n+    ngx_table_elt_t              *header, *hn, **ignored;\n     ngx_http_scgi_params_t       *params;\n     ngx_http_script_code_pt       code;\n     ngx_http_script_engine_t      e, le;\n@@ -707,7 +707,11 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n         allocated = 0;\n         lowcase_key = NULL;\n \n-        if (params->number) {\n+        if (ngx_http_link_multi_headers(r) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (params->number || r->headers_in.multi) {\n             n = 0;\n             part = &r->headers_in.headers.part;\n \n@@ -737,6 +741,12 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n                 i = 0;\n             }\n \n+            for (n = 0; n < header_params; n++) {\n+                if (&header[i] == ignored[n]) {\n+                    goto next_length;\n+                }\n+            }\n+\n             if (params->number) {\n                 if (allocated < header[i].key.len) {\n                     allocated = header[i].key.len + 16;\n@@ -770,6 +780,15 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n \n             len += sizeof(\"HTTP_\") - 1 + header[i].key.len + 1\n                 + header[i].value.len + 1;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                len += hn->value.len + 2;\n+                ignored[header_params++] = hn;\n+            }\n+\n+        next_length:\n+\n+            continue;\n         }\n     }\n \n@@ -869,7 +888,7 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n \n             for (n = 0; n < header_params; n++) {\n                 if (&header[i] == ignored[n]) {\n-                    goto next;\n+                    goto next_value;\n                 }\n             }\n \n@@ -893,12 +912,33 @@ ngx_http_scgi_create_request(ngx_http_request_t *r)\n \n             val = b->last;\n             b->last = ngx_copy(val, header[i].value.data, header[i].value.len);\n+\n+            if (header[i].next) {\n+\n+                if (header[i].key.len == sizeof(\"Cookie\") - 1\n+                    && ngx_strncasecmp(header[i].key.data, (u_char *) \"Cookie\",\n+                                       sizeof(\"Cookie\") - 1)\n+                       == 0)\n+                {\n+                    sep = ';';\n+\n+                } else {\n+                    sep = ',';\n+                }\n+\n+                for (hn = header[i].next; hn; hn = hn->next) {\n+                    *b->last++ = sep;\n+                    *b->last++ = ' ';\n+                    b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n+                }\n+            }\n+\n             *b->last++ = (u_char) 0;\n \n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                            \"scgi param: \\\"%s: %s\\\"\", key, val);\n \n-        next:\n+        next_value:\n \n             continue;\n         }\nDiff:\n@@ -845,13 +845,13 @@ ngx_http_uwsgi_create_key(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n {\n-    u_char                        ch, *lowcase_key;\n+    u_char                        ch, sep, *lowcase_key;\n     size_t                        key_len, val_len, len, allocated;\n     ngx_uint_t                    i, n, hash, skip_empty, header_params;\n     ngx_buf_t                    *b;\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n-    ngx_table_elt_t              *header, **ignored;\n+    ngx_table_elt_t              *header, *hn, **ignored;\n     ngx_http_uwsgi_params_t      *params;\n     ngx_http_script_code_pt       code;\n     ngx_http_script_engine_t      e, le;\n@@ -905,7 +905,11 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n         allocated = 0;\n         lowcase_key = NULL;\n \n-        if (params->number) {\n+        if (ngx_http_link_multi_headers(r) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (params->number || r->headers_in.multi) {\n             n = 0;\n             part = &r->headers_in.headers.part;\n \n@@ -935,6 +939,12 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n                 i = 0;\n             }\n \n+            for (n = 0; n < header_params; n++) {\n+                if (&header[i] == ignored[n]) {\n+                    goto next_length;\n+                }\n+            }\n+\n             if (params->number) {\n                 if (allocated < header[i].key.len) {\n                     allocated = header[i].key.len + 16;\n@@ -968,6 +978,15 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n \n             len += 2 + sizeof(\"HTTP_\") - 1 + header[i].key.len\n                  + 2 + header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                len += hn->value.len + 2;\n+                ignored[header_params++] = hn;\n+            }\n+\n+        next_length:\n+\n+            continue;\n         }\n     }\n \n@@ -1086,7 +1105,7 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n \n             for (n = 0; n < header_params; n++) {\n                 if (&header[i] == ignored[n]) {\n-                    goto next;\n+                    goto next_value;\n                 }\n             }\n \n@@ -1109,15 +1128,41 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n             }\n \n             val_len = header[i].value.len;\n+\n+            for (hn = header[i].next; hn; hn = hn->next) {\n+                val_len += hn->value.len + 2;\n+            }\n+\n             *b->last++ = (u_char) (val_len & 0xff);\n             *b->last++ = (u_char) ((val_len >> 8) & 0xff);\n-            b->last = ngx_copy(b->last, header[i].value.data, val_len);\n+            b->last = ngx_copy(b->last, header[i].value.data,\n+                               header[i].value.len);\n+\n+            if (header[i].next) {\n+\n+                if (header[i].key.len == sizeof(\"Cookie\") - 1\n+                    && ngx_strncasecmp(header[i].key.data, (u_char *) \"Cookie\",\n+                                       sizeof(\"Cookie\") - 1)\n+                       == 0)\n+                {\n+                    sep = ';';\n+\n+                } else {\n+                    sep = ',';\n+                }\n+\n+                for (hn = header[i].next; hn; hn = hn->next) {\n+                    *b->last++ = sep;\n+                    *b->last++ = ' ';\n+                    b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n+                }\n+            }\n \n             ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                            \"uwsgi param: \\\"%*s: %*s\\\"\",\n                            key_len, b->last - (key_len + 2 + val_len),\n                            val_len, b->last - val_len);\n-        next:\n+        next_value:\n \n             continue;\n         }\nDiff:\n@@ -2802,6 +2802,80 @@ ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r, ngx_addr_t *addr,\n }\n \n \n+ngx_int_t\n+ngx_http_link_multi_headers(ngx_http_request_t *r)\n+{\n+    ngx_uint_t        i, j;\n+    ngx_list_part_t  *part, *ppart;\n+    ngx_table_elt_t  *header, *pheader, **ph;\n+\n+    if (r->headers_in.multi_linked) {\n+        return NGX_OK;\n+    }\n+\n+    r->headers_in.multi_linked = 1;\n+\n+    part = &r->headers_in.headers.part;\n+    header = part->elts;\n+\n+    for (i = 0; /* void */; i++) {\n+\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                break;\n+            }\n+\n+            part = part->next;\n+            header = part->elts;\n+            i = 0;\n+        }\n+\n+        header[i].next = NULL;\n+\n+        /*\n+         * search for previous headers with the same name;\n+         * if there are any, link to them\n+         */\n+\n+        ppart = &r->headers_in.headers.part;\n+        pheader = ppart->elts;\n+\n+        for (j = 0; /* void */; j++) {\n+\n+            if (j >= ppart->nelts) {\n+                if (ppart->next == NULL) {\n+                    break;\n+                }\n+\n+                ppart = ppart->next;\n+                pheader = ppart->elts;\n+                j = 0;\n+            }\n+\n+            if (part == ppart && i == j) {\n+                break;\n+            }\n+\n+            if (header[i].key.len == pheader[j].key.len\n+                && ngx_strncasecmp(header[i].key.data, pheader[j].key.data,\n+                                   header[i].key.len)\n+                   == 0)\n+            {\n+                ph = &pheader[j].next;\n+                while (*ph) { ph = &(*ph)->next; }\n+                *ph = &header[i];\n+\n+                r->headers_in.multi = 1;\n+\n+                break;\n+            }\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static char *\n ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)\n {\nDiff:\n@@ -535,6 +535,8 @@ ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n     ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive);\n \n+ngx_int_t ngx_http_link_multi_headers(ngx_http_request_t *r);\n+\n \n extern ngx_module_t  ngx_http_core_module;\n \nDiff:\n@@ -247,6 +247,8 @@ typedef struct {\n \n     unsigned                          connection_type:2;\n     unsigned                          chunked:1;\n+    unsigned                          multi:1;\n+    unsigned                          multi_linked:1;\n     unsigned                          msie:1;\n     unsigned                          msie6:1;\n     unsigned                          opera:1;\n",
        "analysis": "Analyzing the newly added entire function:\n\n```c\nngx_int_t\nngx_http_link_multi_headers(ngx_http_request_t *r)\n{\n    ngx_uint_t        i, j;\n    ngx_list_part_t  *part, *ppart;\n    ngx_table_elt_t  *header, *pheader, **ph;\n\n    if (r->headers_in.multi_linked) {\n        return NGX_OK;\n    }\n\n    r->headers_in.multi_linked = 1;\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        header[i].next = NULL;\n\n        /*\n         * search for previous headers with the same name;\n         * if there are any, link to them\n         */\n\n        ppart = &r->headers_in.headers.part;\n        pheader = ppart->elts;\n\n        for (j = 0; /* void */; j++) {\n\n            if (j >= ppart->nelts) {\n                if (ppart->next == NULL) {\n                    break;\n                }\n\n                ppart = ppart->next;\n                pheader = ppart->elts;\n                j = 0;\n            }\n\n            if (part == ppart && i == j) {\n                break;\n            }\n\n            if (header[i].key.len == pheader[j].key.len\n                && ngx_strncasecmp(header[i].key.data, pheader[j].key.data,\n                                   header[i].key.len)\n                   == 0)\n            {\n                ph = &pheader[j].next;\n                while (*ph) { ph = &(*ph)->next; }\n                *ph = &header[i];\n\n                r->headers_in.multi = 1;\n\n                break;\n            }\n        }\n    }\n\n    return NGX_OK;\n}\n```\n\nLine-by-line analysis for out-of-bounds write:\n\n- The function initializes pointers and iterates over headers in a list structure.\n- It checks `if (i >= part->nelts)`, to ensure it doesn't read beyond the current part.\n- Transitions to the next part of the list are checked correctly with `if (part->next == NULL)`.\n- Sets `header[i].next = NULL;` for each header, which seems safe given that memory for headers is managed in linked structures.\n- The nested loop compares header keys and links headers with matching keys.\n- Manipulations involve linked list structures and wouldn’t have explicit array bounds issues unless badly initialized elsewhere, which isn’t visible here.\n\nGiven the context and the checks present in this function, there's no direct indication of an out-of-bounds write vulnerability.\n\nTRUE [ngx_http_link_multi_headers]"
    },
    {
        "commit_index": "Commit 150",
        "commit_diff": "Diff:\n@@ -1851,6 +1851,10 @@ static ngx_int_t\n ngx_http_process_connection(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n+    if (ngx_http_process_header_line(r, h, offset) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n     if (ngx_strcasestrn(h->value.data, \"close\", 5 - 1)) {\n         r->headers_in.connection_type = NGX_HTTP_CONNECTION_CLOSE;\n \nDiff:\n@@ -55,7 +55,9 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n \n #if (NGX_HAVE_EPOLLRDHUP)\n \n-    if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+    if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n+        && ngx_use_epoll_rdhup)\n+    {\n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                        \"readv: eof:%d, avail:%d\",\n                        rev->pending_eof, rev->available);\nDiff:\n@@ -52,7 +52,9 @@ ngx_unix_recv(ngx_connection_t *c, u_char *buf, size_t size)\n \n #if (NGX_HAVE_EPOLLRDHUP)\n \n-    if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {\n+    if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n+        && ngx_use_epoll_rdhup)\n+    {\n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                        \"recv: eof:%d, avail:%d\",\n                        rev->pending_eof, rev->available);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 149",
        "commit_diff": "Diff:\n@@ -110,7 +110,7 @@ case \"$NGX_MACHINE\" in\n         NGX_MACH_CACHE_LINE=64\n     ;;\n \n-    aarch64 )\n+    aarch64 | arm64)\n         have=NGX_ALIGNMENT value=16 . auto/define\n         NGX_MACH_CACHE_LINE=64\n     ;;\nDiff:\n@@ -6,8 +6,8 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1m\n-ZLIB =\t\tzlib-1.2.11\n+OPENSSL =\topenssl-1.1.1o\n+ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021007\n-#define NGINX_VERSION      \"1.21.7\"\n+#define nginx_version      1023000\n+#define NGINX_VERSION      \"1.23.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 148",
        "commit_diff": "Diff:\n@@ -1,6 +1,6 @@\n /* \n  * Copyright (C) 2002-2021 Igor Sysoev\n- * Copyright (C) 2011-2021 Nginx, Inc.\n+ * Copyright (C) 2011-2022 Nginx, Inc.\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\nDiff:\n@@ -3385,6 +3385,12 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n             || n == SSL_R_WRONG_VERSION_NUMBER                       /*  267 */\n             || n == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC        /*  281 */\n+#ifdef SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY\n+            || n == SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY        /*  291 */\n+#endif\n+#ifdef SSL_R_APPLICATION_DATA_ON_SHUTDOWN\n+            || n == SSL_R_APPLICATION_DATA_ON_SHUTDOWN               /*  291 */\n+#endif\n #ifdef SSL_R_RENEGOTIATE_EXT_TOO_LONG\n             || n == SSL_R_RENEGOTIATE_EXT_TOO_LONG                   /*  335 */\n             || n == SSL_R_RENEGOTIATION_ENCODING_ERR                 /*  336 */\nDiff:\n@@ -153,12 +153,12 @@ struct ngx_http_v2_connection_s {\n     ngx_queue_t                      dependencies;\n     ngx_queue_t                      closed;\n \n+    ngx_uint_t                       closed_nodes;\n     ngx_uint_t                       last_sid;\n     ngx_uint_t                       last_push;\n \n     time_t                           lingering_time;\n \n-    unsigned                         closed_nodes:8;\n     unsigned                         settings_ack:1;\n     unsigned                         table_update:1;\n     unsigned                         blocked:1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 147",
        "commit_diff": "Diff:\n@@ -186,6 +186,7 @@ struct ngx_connection_s {\n     unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */\n \n     unsigned            need_last_buf:1;\n+    unsigned            need_flush_buf:1;\n \n #if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)\n     unsigned            busy_count:2;\nDiff:\n@@ -179,6 +179,8 @@ ngx_event_connect_peer(ngx_peer_connection_t *pc)\n         c->recv = ngx_udp_recv;\n         c->send = ngx_send;\n         c->send_chain = ngx_udp_send_chain;\n+\n+        c->need_flush_buf = 1;\n     }\n \n     c->log_error = pc->log_error;\nDiff:\n@@ -246,6 +246,8 @@ ngx_event_recvmsg(ngx_event_t *ev)\n         c->send = ngx_udp_send;\n         c->send_chain = ngx_udp_send_chain;\n \n+        c->need_flush_buf = 1;\n+\n         c->log = log;\n         c->pool->log = log;\n         c->listening = ls;\nDiff:\n@@ -227,7 +227,8 @@ ngx_http_write_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     if (size == 0\n         && !(c->buffered & NGX_LOWLEVEL_BUFFERED)\n-        && !(last && c->need_last_buf))\n+        && !(last && c->need_last_buf)\n+        && !(flush && c->need_flush_buf))\n     {\n         if (last || flush || sync) {\n             for (cl = r->out; cl; /* void */) {\nDiff:\n@@ -665,6 +665,7 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)\n \n     fc->send_chain = ngx_http_v2_send_chain;\n     fc->need_last_buf = 1;\n+    fc->need_flush_buf = 1;\n \n     return ngx_http_v2_filter_send(fc, stream);\n }\n@@ -1815,7 +1816,11 @@ ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,\n static ngx_inline ngx_int_t\n ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)\n {\n-    if (stream->queued == 0) {\n+    ngx_connection_t  *c;\n+\n+    c = stream->connection->connection;\n+\n+    if (stream->queued == 0 && !c->buffered) {\n         fc->buffered &= ~NGX_HTTP_V2_BUFFERED;\n         return NGX_OK;\n     }\nDiff:\n@@ -235,7 +235,7 @@ ngx_stream_write_filter(ngx_stream_session_t *s, ngx_chain_t *in,\n     if (size == 0\n         && !(c->buffered & NGX_LOWLEVEL_BUFFERED)\n         && !(last && c->need_last_buf)\n-        && !(c->type == SOCK_DGRAM && flush))\n+        && !(flush && c->need_flush_buf))\n     {\n         if (last || flush || sync) {\n             for (cl = *out; cl; /* void */) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 146",
        "commit_diff": "Diff:\n@@ -232,4 +232,20 @@ ngx_feature_test=\"struct crypt_data  cd;\n ngx_include=\"sys/vfs.h\";     . auto/include\n \n \n+# UDP segmentation offloading\n+\n+ngx_feature=\"UDP_SEGMENT\"\n+ngx_feature_name=\"NGX_HAVE_UDP_SEGMENT\"\n+ngx_feature_run=no\n+ngx_feature_incs=\"#include <sys/socket.h>\n+                  #include <stdint.h>\n+                  #include <netinet/udp.h>\"\n+ngx_feature_path=\n+ngx_feature_libs=\n+ngx_feature_test=\"socklen_t optlen = sizeof(int);\n+                  int val;\n+                  getsockopt(0, SOL_UDP, UDP_SEGMENT, &val, &optlen)\"\n+. auto/feature\n+\n+\n CC_AUX_FLAGS=\"$cc_aux_flags -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\"\nDiff:\n@@ -1756,6 +1756,11 @@ ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache)\n             break;\n         }\n \n+        if (fcn->deleting) {\n+            wait = 1;\n+            break;\n+        }\n+\n         p = ngx_hex_dump(key, (u_char *) &fcn->node.key,\n                          sizeof(ngx_rbtree_key_t));\n         len = NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t);\nDiff:\n@@ -103,6 +103,10 @@ typedef struct iocb  ngx_aiocb_t;\n #include <linux/capability.h>\n #endif\n \n+#if (NGX_HAVE_UDP_SEGMENT)\n+#include <netinet/udp.h>\n+#endif\n+\n \n #define NGX_LISTEN_BACKLOG        511\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 145",
        "commit_diff": "Diff:\n@@ -46,18 +46,8 @@ ngx_event_recvmsg(ngx_event_t *ev)\n     ngx_connection_t  *c, *lc;\n     static u_char      buffer[65535];\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n-#if (NGX_HAVE_IP_RECVDSTADDR)\n-    u_char             msg_control[CMSG_SPACE(sizeof(struct in_addr))];\n-#elif (NGX_HAVE_IP_PKTINFO)\n-    u_char             msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-    u_char             msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n-#endif\n-\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n+    u_char             msg_control[CMSG_SPACE(sizeof(ngx_addrinfo_t))];\n #endif\n \n     if (ev->timedout) {\n@@ -92,25 +82,13 @@ ngx_event_recvmsg(ngx_event_t *ev)\n         msg.msg_iov = iov;\n         msg.msg_iovlen = 1;\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n         if (ls->wildcard) {\n+            msg.msg_control = &msg_control;\n+            msg.msg_controllen = sizeof(msg_control);\n \n-#if (NGX_HAVE_IP_RECVDSTADDR || NGX_HAVE_IP_PKTINFO)\n-            if (ls->sockaddr->sa_family == AF_INET) {\n-                msg.msg_control = &msg_control;\n-                msg.msg_controllen = sizeof(msg_control);\n-            }\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-            if (ls->sockaddr->sa_family == AF_INET6) {\n-                msg.msg_control = &msg_control6;\n-                msg.msg_controllen = sizeof(msg_control6);\n-            }\n-#endif\n-        }\n-\n+            ngx_memzero(&msg_control, sizeof(msg_control));\n+       }\n #endif\n \n         n = recvmsg(lc->fd, &msg, 0);\n@@ -129,7 +107,7 @@ ngx_event_recvmsg(ngx_event_t *ev)\n             return;\n         }\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n         if (msg.msg_flags & (MSG_TRUNC|MSG_CTRUNC)) {\n             ngx_log_error(NGX_LOG_ALERT, ev->log, 0,\n                           \"recvmsg() truncated data\");\n@@ -159,7 +137,7 @@ ngx_event_recvmsg(ngx_event_t *ev)\n         local_sockaddr = ls->sockaddr;\n         local_socklen = ls->socklen;\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n \n         if (ls->wildcard) {\n             struct cmsghdr  *cmsg;\n@@ -171,59 +149,9 @@ ngx_event_recvmsg(ngx_event_t *ev)\n                  cmsg != NULL;\n                  cmsg = CMSG_NXTHDR(&msg, cmsg))\n             {\n-\n-#if (NGX_HAVE_IP_RECVDSTADDR)\n-\n-                if (cmsg->cmsg_level == IPPROTO_IP\n-                    && cmsg->cmsg_type == IP_RECVDSTADDR\n-                    && local_sockaddr->sa_family == AF_INET)\n-                {\n-                    struct in_addr      *addr;\n-                    struct sockaddr_in  *sin;\n-\n-                    addr = (struct in_addr *) CMSG_DATA(cmsg);\n-                    sin = (struct sockaddr_in *) local_sockaddr;\n-                    sin->sin_addr = *addr;\n-\n+                if (ngx_get_srcaddr_cmsg(cmsg, local_sockaddr) == NGX_OK) {\n                     break;\n                 }\n-\n-#elif (NGX_HAVE_IP_PKTINFO)\n-\n-                if (cmsg->cmsg_level == IPPROTO_IP\n-                    && cmsg->cmsg_type == IP_PKTINFO\n-                    && local_sockaddr->sa_family == AF_INET)\n-                {\n-                    struct in_pktinfo   *pkt;\n-                    struct sockaddr_in  *sin;\n-\n-                    pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n-                    sin = (struct sockaddr_in *) local_sockaddr;\n-                    sin->sin_addr = pkt->ipi_addr;\n-\n-                    break;\n-                }\n-\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-\n-                if (cmsg->cmsg_level == IPPROTO_IPV6\n-                    && cmsg->cmsg_type == IPV6_PKTINFO\n-                    && local_sockaddr->sa_family == AF_INET6)\n-                {\n-                    struct in6_pktinfo   *pkt6;\n-                    struct sockaddr_in6  *sin6;\n-\n-                    pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n-                    sin6 = (struct sockaddr_in6 *) local_sockaddr;\n-                    sin6->sin6_addr = pkt6->ipi6_addr;\n-\n-                    break;\n-                }\n-\n-#endif\n-\n             }\n         }\n \nDiff:\n@@ -41,6 +41,8 @@ typedef union {\n \n size_t ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg,\n     struct sockaddr *local_sockaddr);\n+ngx_int_t ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg,\n+    struct sockaddr *local_sockaddr);\n \n #endif\n \nDiff:\n@@ -316,6 +316,71 @@ ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n     return 0;\n }\n \n+\n+ngx_int_t\n+ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n+{\n+\n+#if (NGX_HAVE_IP_RECVDSTADDR)\n+    struct in_addr       *addr;\n+    struct sockaddr_in   *sin;\n+#elif (NGX_HAVE_IP_PKTINFO)\n+    struct in_pktinfo    *pkt;\n+    struct sockaddr_in   *sin;\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    struct in6_pktinfo   *pkt6;\n+    struct sockaddr_in6  *sin6;\n+#endif\n+\n+\n+ #if (NGX_HAVE_IP_RECVDSTADDR)\n+\n+    if (cmsg->cmsg_level == IPPROTO_IP\n+        && cmsg->cmsg_type == IP_RECVDSTADDR\n+        && local_sockaddr->sa_family == AF_INET)\n+    {\n+        addr = (struct in_addr *) CMSG_DATA(cmsg);\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+        sin->sin_addr = *addr;\n+\n+        return NGX_OK;\n+    }\n+\n+#elif (NGX_HAVE_IP_PKTINFO)\n+\n+    if (cmsg->cmsg_level == IPPROTO_IP\n+        && cmsg->cmsg_type == IP_PKTINFO\n+        && local_sockaddr->sa_family == AF_INET)\n+    {\n+        pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+        sin->sin_addr = pkt->ipi_addr;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+\n+    if (cmsg->cmsg_level == IPPROTO_IPV6\n+        && cmsg->cmsg_type == IPV6_PKTINFO\n+        && local_sockaddr->sa_family == AF_INET6)\n+    {\n+        pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n+        sin6 = (struct sockaddr_in6 *) local_sockaddr;\n+        sin6->sin6_addr = pkt6->ipi6_addr;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    return NGX_DECLINED;\n+}\n+\n #endif\n \n \n",
        "analysis": "To determine if there is a possibility of out-of-bounds write, we need to analyze the newly added function `ngx_get_srcaddr_cmsg`:\n\n1. **Function signature:**\n   ```c\n   ngx_int_t ngx_get_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n   ```\n   The function takes in a pointer to `struct cmsghdr` and a pointer to `struct sockaddr`.\n\n2. **Conditional Compilation:**\n   The function body utilizes different code paths based on the availability of certain macros:\n   - `NGX_HAVE_IP_RECVDSTADDR`\n   - `NGX_HAVE_IP_PKTINFO`\n   - `NGX_HAVE_INET6` with `NGX_HAVE_IPV6_RECVPKTINFO`\n\n3. **Pointer Handling:**\n   - For each code path, the function checks if `cmsg` properties meet certain conditions (like matching `cmsg_level` and `cmsg_type`).\n   - It obtains a data pointer using `CMSG_DATA(cmsg)` and casts it to appropriate types (`struct in_addr`, `struct in_pktinfo`, or `struct in6_pktinfo`).\n   - It populates fields in `local_sockaddr` based on values derived from `cmsg`.\n\n4. **Potential Issues:**\n   - **Accessing Memory:** The function accesses memory locations through pointers derived from input parameters `cmsg` and `local_sockaddr`. If these pointers are not properly validated outside of this function, there might be possibilities for out-of-bounds write.\n   - **Type Casting:** Assumes that `local_sockaddr` is correctly initialized to types such as `sockaddr_in` or `sockaddr_in6` based on the family, which if not carefully handled by the caller, might lead to unexpected behavior.\n   - **Macro Paths:** No explicit bounds checking is applied to the values being copied from `cmsg` into `local_sockaddr`.\n\nThe analysis of `ngx_get_srcaddr_cmsg` indicates that there is a possibility of out-of-bounds write under some scenarios, especially if the assumptions about the memory pointed by `cmsg` and `local_sockaddr` are incorrect or manipulated by a malicious actor.\n\nThe final output based on the analysis should be:\n```\nTRUE [ngx_get_srcaddr_cmsg]\n```"
    },
    {
        "commit_index": "Commit 144",
        "commit_diff": "Diff:\n@@ -89,7 +89,8 @@ EVENT_DEPS=\"src/event/ngx_event.h \\\n             src/event/ngx_event_timer.h \\\n             src/event/ngx_event_posted.h \\\n             src/event/ngx_event_connect.h \\\n-            src/event/ngx_event_pipe.h\"\n+            src/event/ngx_event_pipe.h \\\n+            src/event/ngx_event_udp.h\"\n \n EVENT_SRCS=\"src/event/ngx_event.c \\\n             src/event/ngx_event_timer.c \\\nDiff:\n@@ -498,12 +498,6 @@ extern ngx_module_t           ngx_event_core_module;\n \n \n void ngx_event_accept(ngx_event_t *ev);\n-#if !(NGX_WIN32)\n-void ngx_event_recvmsg(ngx_event_t *ev);\n-void ngx_udp_rbtree_insert_value(ngx_rbtree_node_t *temp,\n-    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);\n-#endif\n-void ngx_delete_udp_connection(void *data);\n ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle);\n ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle);\n u_char *ngx_accept_log_error(ngx_log_t *log, u_char *buf, size_t len);\n@@ -533,6 +527,7 @@ ngx_int_t ngx_send_lowat(ngx_connection_t *c, size_t lowat);\n \n #include <ngx_event_timer.h>\n #include <ngx_event_posted.h>\n+#include <ngx_event_udp.h>\n \n #if (NGX_WIN32)\n #include <ngx_iocp_module.h>\nDiff:\n@@ -0,0 +1,56 @@\n+\n+/*\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#ifndef _NGX_EVENT_UDP_H_INCLUDED_\n+#define _NGX_EVENT_UDP_H_INCLUDED_\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+\n+\n+#if !(NGX_WIN32)\n+\n+#if ((NGX_HAVE_MSGHDR_MSG_CONTROL)                                            \\\n+     && (NGX_HAVE_IP_SENDSRCADDR || NGX_HAVE_IP_RECVDSTADDR                   \\\n+         || NGX_HAVE_IP_PKTINFO                                               \\\n+         || (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)))\n+#define NGX_HAVE_ADDRINFO_CMSG  1\n+\n+#endif\n+\n+\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n+\n+typedef union {\n+#if (NGX_HAVE_IP_SENDSRCADDR || NGX_HAVE_IP_RECVDSTADDR)\n+    struct in_addr        addr;\n+#endif\n+\n+#if (NGX_HAVE_IP_PKTINFO)\n+    struct in_pktinfo     pkt;\n+#endif\n+\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    struct in6_pktinfo    pkt6;\n+#endif\n+} ngx_addrinfo_t;\n+\n+size_t ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg,\n+    struct sockaddr *local_sockaddr);\n+\n+#endif\n+\n+void ngx_event_recvmsg(ngx_event_t *ev);\n+ssize_t ngx_sendmsg(ngx_connection_t *c, struct msghdr *msg, int flags);\n+void ngx_udp_rbtree_insert_value(ngx_rbtree_node_t *temp,\n+    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);\n+#endif\n+\n+void ngx_delete_udp_connection(void *data);\n+\n+\n+#endif /* _NGX_EVENT_UDP_H_INCLUDED_ */\nDiff:\n@@ -12,7 +12,7 @@\n \n static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec,\n     ngx_chain_t *in, ngx_log_t *log);\n-static ssize_t ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec);\n+static ssize_t ngx_sendmsg_vec(ngx_connection_t *c, ngx_iovec_t *vec);\n \n \n ngx_chain_t *\n@@ -88,7 +88,7 @@ ngx_udp_unix_sendmsg_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         send += vec.size;\n \n-        n = ngx_sendmsg(c, &vec);\n+        n = ngx_sendmsg_vec(c, &vec);\n \n         if (n == NGX_ERROR) {\n             return NGX_CHAIN_ERROR;\n@@ -204,24 +204,13 @@ ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, ngx_log_t *log)\n \n \n static ssize_t\n-ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n+ngx_sendmsg_vec(ngx_connection_t *c, ngx_iovec_t *vec)\n {\n-    ssize_t        n;\n-    ngx_err_t      err;\n-    struct msghdr  msg;\n-\n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n-#if (NGX_HAVE_IP_SENDSRCADDR)\n-    u_char         msg_control[CMSG_SPACE(sizeof(struct in_addr))];\n-#elif (NGX_HAVE_IP_PKTINFO)\n-    u_char         msg_control[CMSG_SPACE(sizeof(struct in_pktinfo))];\n-#endif\n-\n-#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n-    u_char         msg_control6[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n-#endif\n+    struct msghdr    msg;\n \n+#if (NGX_HAVE_ADDRINFO_CMSG)\n+    struct cmsghdr  *cmsg;\n+    u_char           msg_control[CMSG_SPACE(sizeof(ngx_addrinfo_t))];\n #endif\n \n     ngx_memzero(&msg, sizeof(struct msghdr));\n@@ -234,88 +223,115 @@ ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n     msg.msg_iov = vec->iovs;\n     msg.msg_iovlen = vec->count;\n \n-#if (NGX_HAVE_MSGHDR_MSG_CONTROL)\n-\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n     if (c->listening && c->listening->wildcard && c->local_sockaddr) {\n \n-#if (NGX_HAVE_IP_SENDSRCADDR)\n+        msg.msg_control = msg_control;\n+        msg.msg_controllen = sizeof(msg_control);\n+        ngx_memzero(msg_control, sizeof(msg_control));\n \n-        if (c->local_sockaddr->sa_family == AF_INET) {\n-            struct cmsghdr      *cmsg;\n-            struct in_addr      *addr;\n-            struct sockaddr_in  *sin;\n+        cmsg = CMSG_FIRSTHDR(&msg);\n \n-            msg.msg_control = &msg_control;\n-            msg.msg_controllen = sizeof(msg_control);\n+        msg.msg_controllen = ngx_set_srcaddr_cmsg(cmsg, c->local_sockaddr);\n+    }\n+#endif\n \n-            cmsg = CMSG_FIRSTHDR(&msg);\n-            cmsg->cmsg_level = IPPROTO_IP;\n-            cmsg->cmsg_type = IP_SENDSRCADDR;\n-            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_addr));\n+    return ngx_sendmsg(c, &msg, 0);\n+}\n \n-            sin = (struct sockaddr_in *) c->local_sockaddr;\n \n-            addr = (struct in_addr *) CMSG_DATA(cmsg);\n-            *addr = sin->sin_addr;\n-        }\n+#if (NGX_HAVE_ADDRINFO_CMSG)\n \n+size_t\n+ngx_set_srcaddr_cmsg(struct cmsghdr *cmsg, struct sockaddr *local_sockaddr)\n+{\n+    size_t                len;\n+#if (NGX_HAVE_IP_SENDSRCADDR)\n+    struct in_addr       *addr;\n+    struct sockaddr_in   *sin;\n #elif (NGX_HAVE_IP_PKTINFO)\n+    struct in_pktinfo    *pkt;\n+    struct sockaddr_in   *sin;\n+#endif\n \n-        if (c->local_sockaddr->sa_family == AF_INET) {\n-            struct cmsghdr      *cmsg;\n-            struct in_pktinfo   *pkt;\n-            struct sockaddr_in  *sin;\n+#if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    struct in6_pktinfo   *pkt6;\n+    struct sockaddr_in6  *sin6;\n+#endif\n \n-            msg.msg_control = &msg_control;\n-            msg.msg_controllen = sizeof(msg_control);\n \n-            cmsg = CMSG_FIRSTHDR(&msg);\n-            cmsg->cmsg_level = IPPROTO_IP;\n-            cmsg->cmsg_type = IP_PKTINFO;\n-            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));\n+#if (NGX_HAVE_IP_SENDSRCADDR) || (NGX_HAVE_IP_PKTINFO)\n \n-            sin = (struct sockaddr_in *) c->local_sockaddr;\n+    if (local_sockaddr->sa_family == AF_INET) {\n \n-            pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n-            ngx_memzero(pkt, sizeof(struct in_pktinfo));\n-            pkt->ipi_spec_dst = sin->sin_addr;\n-        }\n+        cmsg->cmsg_level = IPPROTO_IP;\n+\n+#if (NGX_HAVE_IP_SENDSRCADDR)\n+\n+        cmsg->cmsg_type = IP_SENDSRCADDR;\n+        cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_addr));\n+        len = CMSG_SPACE(sizeof(struct in_addr));\n+\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+\n+        addr = (struct in_addr *) CMSG_DATA(cmsg);\n+        *addr = sin->sin_addr;\n+\n+#elif (NGX_HAVE_IP_PKTINFO)\n+\n+        cmsg->cmsg_type = IP_PKTINFO;\n+        cmsg->cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo));\n+        len = CMSG_SPACE(sizeof(struct in_pktinfo));\n+\n+        sin = (struct sockaddr_in *) local_sockaddr;\n+\n+        pkt = (struct in_pktinfo *) CMSG_DATA(cmsg);\n+        ngx_memzero(pkt, sizeof(struct in_pktinfo));\n+        pkt->ipi_spec_dst = sin->sin_addr;\n+\n+#endif\n+        return len;\n+    }\n \n #endif\n \n #if (NGX_HAVE_INET6 && NGX_HAVE_IPV6_RECVPKTINFO)\n+    if (local_sockaddr->sa_family == AF_INET6) {\n \n-        if (c->local_sockaddr->sa_family == AF_INET6) {\n-            struct cmsghdr       *cmsg;\n-            struct in6_pktinfo   *pkt6;\n-            struct sockaddr_in6  *sin6;\n+        cmsg->cmsg_level = IPPROTO_IPV6;\n+        cmsg->cmsg_type = IPV6_PKTINFO;\n+        cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n+        len = CMSG_SPACE(sizeof(struct in6_pktinfo));\n \n-            msg.msg_control = &msg_control6;\n-            msg.msg_controllen = sizeof(msg_control6);\n+        sin6 = (struct sockaddr_in6 *) local_sockaddr;\n \n-            cmsg = CMSG_FIRSTHDR(&msg);\n-            cmsg->cmsg_level = IPPROTO_IPV6;\n-            cmsg->cmsg_type = IPV6_PKTINFO;\n-            cmsg->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));\n+        pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n+        ngx_memzero(pkt6, sizeof(struct in6_pktinfo));\n+        pkt6->ipi6_addr = sin6->sin6_addr;\n \n-            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;\n+        return len;\n+    }\n+#endif\n \n-            pkt6 = (struct in6_pktinfo *) CMSG_DATA(cmsg);\n-            ngx_memzero(pkt6, sizeof(struct in6_pktinfo));\n-            pkt6->ipi6_addr = sin6->sin6_addr;\n-        }\n+    return 0;\n+}\n \n #endif\n-    }\n \n+\n+ssize_t\n+ngx_sendmsg(ngx_connection_t *c, struct msghdr *msg, int flags)\n+{\n+    ssize_t    n;\n+    ngx_err_t  err;\n+#if (NGX_DEBUG)\n+    size_t      size;\n+    ngx_uint_t  i;\n #endif\n \n eintr:\n \n-    n = sendmsg(c->fd, &msg, 0);\n-\n-    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                   \"sendmsg: %z of %uz\", n, vec->size);\n+    n = sendmsg(c->fd, msg, flags);\n \n     if (n == -1) {\n         err = ngx_errno;\n@@ -338,5 +354,14 @@ ngx_sendmsg(ngx_connection_t *c, ngx_iovec_t *vec)\n         }\n     }\n \n+#if (NGX_DEBUG)\n+    for (i = 0, size = 0; i < (size_t) msg->msg_iovlen; i++) {\n+        size += msg->msg_iov[i].iov_len;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"sendmsg: %z of %uz\", n, size);\n+#endif\n+\n     return n;\n }\n",
        "analysis": "After examining the diffs, we notice the addition of some new functions. Let's analyze these newly added functions line by line for potential out-of-bounds write vulnerabilities:\n\n1. **Function `ngx_set_srcaddr_cmsg`**:\n   - This function sets the source address in control messages. It operates on `struct cmsghdr` through use of `CMSG_DATA(cmsg)` which is used to manipulate address data.\n   - The function uses `CMSG_SPACE` and `CMSG_LEN` to determine lengths, which are generally safe as they handle necessary padding.\n   - It distinguishes between IPv4 and IPv6, which is common practice for network applications.\n   - The provided data sizes and handling with `CMSG_SPACE` indicates safety against out-of-bounds writes.\n\n2. **Function `ngx_sendmsg`**:\n   - This function sends a message using the `sendmsg` system call.\n   - It initializes a structure `msghdr` and uses it in `sendmsg`.\n   - The potential vulnerability could arise if there is improper handling within the data being sent or if there were mismanagement in the auxiliary data size (msg_controllen), but the checks with `ngx_set_srcaddr_cmsg` and standard functions like `ngx_memzero` are employed appropriately.\n   \n3. **No other functions added.**\n\nNo apparent suspicious operations are uncovered from this analysis. The proper use of operations and checks sized correctly mitigates against potential out-of-bounds scenarios. Therefore, no functions have been flagged for a suspicion of out-of-bounds write.\n\nFinal result:\nFALSE"
    },
    {
        "commit_index": "Commit 143",
        "commit_diff": "Diff:\n@@ -466,3 +466,4 @@ bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\n 39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\n d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n+714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\nDiff:\n@@ -5,6 +5,44 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.6\" date=\"2022-01-25\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использование EPOLLEXCLUSIVE на Linux\n+распределение клиентских соединений между рабочими процессами\n+было неравномерным.\n+</para>\n+<para lang=\"en\">\n+when using EPOLLEXCLUSIVE on Linux\n+client connections were unevenly distributed\n+among worker processes.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+во время плавного завершения старых рабочих процессов\n+nginx возвращал в ответах строку заголовка \"Connection: keep-alive\".\n+</para>\n+<para lang=\"en\">\n+nginx returned the \"Connection: keep-alive\" header line in responses\n+during graceful shutdown of old worker processes.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве ssl_session_ticket_key при использовании TLSv1.3.\n+</para>\n+<para lang=\"en\">\n+in the \"ssl_session_ticket_key\" when using TLSv1.3.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.5\" date=\"2021-12-28\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021006\n-#define NGINX_VERSION      \"1.21.6\"\n+#define nginx_version      1021007\n+#define NGINX_VERSION      \"1.21.7\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 142",
        "commit_diff": "Diff:\n@@ -5,6 +5,9 @@ if exists(\"b:current_syntax\")\n   finish\n end\n \n+let s:save_cpo = &cpo\n+set cpo&vim\n+\n \" general syntax\n \n if has(\"patch-7.4.1142\")\n@@ -2485,4 +2488,7 @@ hi def link ngxDirectiveThirdPartyDeprecated Error\n hi def link ngxListenOptions Keyword\n hi def link ngxListenOptionsDeprecated Error\n \n+let &cpo = s:save_cpo\n+unlet s:save_cpo\n+\n let b:current_syntax = \"nginx\"\nDiff:\n@@ -89,22 +89,10 @@ ngx_rwlock_rlock(ngx_atomic_t *lock)\n void\n ngx_rwlock_unlock(ngx_atomic_t *lock)\n {\n-    ngx_atomic_uint_t  readers;\n-\n-    readers = *lock;\n-\n-    if (readers == NGX_RWLOCK_WLOCK) {\n+    if (*lock == NGX_RWLOCK_WLOCK) {\n         (void) ngx_atomic_cmp_set(lock, NGX_RWLOCK_WLOCK, 0);\n-        return;\n-    }\n-\n-    for ( ;; ) {\n-\n-        if (ngx_atomic_cmp_set(lock, readers, readers - 1)) {\n-            return;\n-        }\n-\n-        readers = *lock;\n+    } else {\n+        (void) ngx_atomic_fetch_add(lock, -1);\n     }\n }\n \nDiff:\n@@ -4451,7 +4451,21 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n             return -1;\n         }\n \n-        return (i == 0) ? 1 : 2 /* renew */;\n+        /* renew if TLSv1.3 */\n+\n+#ifdef TLS1_3_VERSION\n+        if (SSL_version(ssl_conn) == TLS1_3_VERSION) {\n+            return 2;\n+        }\n+#endif\n+\n+        /* renew if non-default key */\n+\n+        if (i != 0) {\n+            return 2;\n+        }\n+\n+        return 1;\n     }\n }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 141",
        "commit_diff": "Diff:\n@@ -55,6 +55,7 @@ ngx_uint_t            ngx_accept_events;\n ngx_uint_t            ngx_accept_mutex_held;\n ngx_msec_t            ngx_accept_mutex_delay;\n ngx_int_t             ngx_accept_disabled;\n+ngx_uint_t            ngx_use_exclusive_accept;\n \n \n #if (NGX_STAT_STUB)\n@@ -644,6 +645,8 @@ ngx_event_process_init(ngx_cycle_t *cycle)\n \n #endif\n \n+    ngx_use_exclusive_accept = 0;\n+\n     ngx_queue_init(&ngx_posted_accept_events);\n     ngx_queue_init(&ngx_posted_next_events);\n     ngx_queue_init(&ngx_posted_events);\n@@ -889,6 +892,8 @@ ngx_event_process_init(ngx_cycle_t *cycle)\n         if ((ngx_event_flags & NGX_USE_EPOLL_EVENT)\n             && ccf->worker_processes > 1)\n         {\n+            ngx_use_exclusive_accept = 1;\n+\n             if (ngx_add_event(rev, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT)\n                 == NGX_ERROR)\n             {\nDiff:\n@@ -466,6 +466,7 @@ extern ngx_uint_t             ngx_accept_events;\n extern ngx_uint_t             ngx_accept_mutex_held;\n extern ngx_msec_t             ngx_accept_mutex_delay;\n extern ngx_int_t              ngx_accept_disabled;\n+extern ngx_uint_t             ngx_use_exclusive_accept;\n \n \n #if (NGX_STAT_STUB)\nDiff:\n@@ -11,6 +11,9 @@\n \n \n static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all);\n+#if (NGX_HAVE_EPOLLEXCLUSIVE)\n+static void ngx_reorder_accept_events(ngx_listening_t *ls);\n+#endif\n static void ngx_close_accepted_connection(ngx_connection_t *c);\n \n \n@@ -314,6 +317,10 @@ ngx_event_accept(ngx_event_t *ev)\n         }\n \n     } while (ev->available);\n+\n+#if (NGX_HAVE_EPOLLEXCLUSIVE)\n+    ngx_reorder_accept_events(ls);\n+#endif\n }\n \n \n@@ -420,6 +427,57 @@ ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all)\n }\n \n \n+#if (NGX_HAVE_EPOLLEXCLUSIVE)\n+\n+static void\n+ngx_reorder_accept_events(ngx_listening_t *ls)\n+{\n+    ngx_connection_t  *c;\n+\n+    /*\n+     * Linux with EPOLLEXCLUSIVE usually notifies only the process which\n+     * was first to add the listening socket to the epoll instance.  As\n+     * a result most of the connections are handled by the first worker\n+     * process.  To fix this, we re-add the socket periodically, so other\n+     * workers will get a chance to accept connections.\n+     */\n+\n+    if (!ngx_use_exclusive_accept) {\n+        return;\n+    }\n+\n+#if (NGX_HAVE_REUSEPORT)\n+\n+    if (ls->reuseport) {\n+        return;\n+    }\n+\n+#endif\n+\n+    c = ls->connection;\n+\n+    if (c->requests++ % 16 != 0\n+        && ngx_accept_disabled <= 0)\n+    {\n+        return;\n+    }\n+\n+    if (ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT)\n+        == NGX_ERROR)\n+    {\n+        return;\n+    }\n+\n+    if (ngx_add_event(c->read, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT)\n+        == NGX_ERROR)\n+    {\n+        return;\n+    }\n+}\n+\n+#endif\n+\n+\n static void\n ngx_close_accepted_connection(ngx_connection_t *c)\n {\nDiff:\n@@ -1383,6 +1383,9 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n     if (SSL_CTX_set0_tmp_dh_pkey(ssl->ctx, dh) != 1) {\n         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n                       \"SSL_CTX_set0_tmp_dh_pkey(\\%s\\\") failed\", file->data);\n+#if (OPENSSL_VERSION_NUMBER >= 0x3000001fL)\n+        EVP_PKEY_free(dh);\n+#endif\n         BIO_free(bio);\n         return NGX_ERROR;\n     }\nDiff:\n@@ -197,6 +197,10 @@ ngx_http_header_filter(ngx_http_request_t *r)\n         }\n     }\n \n+    if (r->keepalive && (ngx_terminate || ngx_exiting)) {\n+        r->keepalive = 0;\n+    }\n+\n     len = sizeof(\"HTTP/1.x \") - 1 + sizeof(CRLF) - 1\n           /* the end of the header */\n           + sizeof(CRLF) - 1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 140",
        "commit_diff": "Diff:\n@@ -465,3 +465,4 @@ a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\n 39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\n+d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\nDiff:\n@@ -5,6 +5,58 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.5\" date=\"2021-12-28\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx по умолчанию собирается с библиотекой PCRE2.\n+</para>\n+<para lang=\"en\">\n+now nginx is built with the PCRE2 library by default.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда использует sendfile(SF_NODISKIO) на FreeBSD.\n+</para>\n+<para lang=\"en\">\n+now nginx always uses sendfile(SF_NODISKIO) on FreeBSD.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+поддержка sendfile(SF_NOCACHE) на FreeBSD.\n+</para>\n+<para lang=\"en\">\n+support for sendfile(SF_NOCACHE) on FreeBSD.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $ssl_curve.\n+</para>\n+<para lang=\"en\">\n+the $ssl_curve variable.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2 без SSL вместе с директивами sendfile и aio\n+соединения могли зависать.\n+</para>\n+<para lang=\"en\">\n+connections might hang\n+when using HTTP/2 without SSL with the \"sendfile\" and \"aio\" directives.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.4\" date=\"2021-11-02\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021005\n-#define NGINX_VERSION      \"1.21.5\"\n+#define nginx_version      1021006\n+#define NGINX_VERSION      \"1.21.6\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 139",
        "commit_diff": "Diff:\n@@ -6,9 +6,9 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1l\n+OPENSSL =\topenssl-1.1.1m\n ZLIB =\t\tzlib-1.2.11\n-PCRE =\t\tpcre-8.44\n+PCRE =\t\tpcre2-10.39\n \n \n release: export\nDiff:\n@@ -256,10 +256,6 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n     }\n #endif\n \n-    if (buf->in_file && buf->file->directio) {\n-        return 0;\n-    }\n-\n     sendfile = ctx->sendfile;\n \n #if (NGX_SENDFILE_LIMIT)\n@@ -268,6 +264,19 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n         sendfile = 0;\n     }\n \n+#endif\n+\n+#if !(NGX_HAVE_SENDFILE_NODISKIO)\n+\n+    /*\n+     * With DIRECTIO, disable sendfile() unless sendfile(SF_NOCACHE)\n+     * is available.\n+     */\n+\n+    if (buf->in_file && buf->file->directio) {\n+        sendfile = 0;\n+    }\n+\n #endif\n \n     if (!sendfile) {\nDiff:\n@@ -2955,7 +2955,13 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     ngx_set_errno(0);\n \n #if (NGX_HAVE_SENDFILE_NODISKIO)\n+\n     flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n+\n+    if (file->file->directio) {\n+        flags |= SF_NOCACHE;\n+    }\n+\n #else\n     flags = 0;\n #endif\nDiff:\n@@ -174,7 +174,13 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n             sent = 0;\n \n #if (NGX_HAVE_SENDFILE_NODISKIO)\n+\n             flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n+\n+            if (file->file->directio) {\n+                flags |= SF_NOCACHE;\n+            }\n+\n #endif\n \n             rc = sendfile(file->file->fd, c->fd, file->file_pos,\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 138",
        "commit_diff": "Diff:\n@@ -44,12 +44,10 @@ if [ $osreldate -gt 300007 ]; then\n     CORE_SRCS=\"$CORE_SRCS $FREEBSD_SENDFILE_SRCS\"\n fi\n \n-if [ $NGX_FILE_AIO = YES ]; then\n-    if [ $osreldate -gt 502103 ]; then\n-        echo \" + sendfile()'s SF_NODISKIO found\"\n+if [ $osreldate -gt 1100093 ]; then\n+    echo \" + sendfile()'s SF_NODISKIO found\"\n \n-        have=NGX_HAVE_AIO_SENDFILE . auto/have\n-    fi\n+    have=NGX_HAVE_SENDFILE_NODISKIO . auto/have\n fi\n \n # POSIX semaphores\nDiff:\n@@ -91,9 +91,6 @@ struct ngx_output_chain_ctx_s {\n \n #if (NGX_HAVE_FILE_AIO || NGX_COMPAT)\n     ngx_output_chain_aio_pt      aio_handler;\n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n-    ssize_t                    (*aio_preload)(ngx_buf_t *file);\n-#endif\n #endif\n \n #if (NGX_THREADS || NGX_COMPAT)\nDiff:\n@@ -187,7 +187,7 @@ struct ngx_connection_s {\n \n     unsigned            need_last_buf:1;\n \n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n+#if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)\n     unsigned            busy_count:2;\n #endif\n \nDiff:\n@@ -41,7 +41,7 @@\n #define NGX_MODULE_SIGNATURE_3   \"0\"\n #endif\n \n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n+#if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)\n #define NGX_MODULE_SIGNATURE_4   \"1\"\n #else\n #define NGX_MODULE_SIGNATURE_4   \"0\"\nDiff:\n@@ -29,10 +29,6 @@\n \n static ngx_inline ngx_int_t\n     ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf);\n-#if (NGX_HAVE_AIO_SENDFILE)\n-static ngx_int_t ngx_output_chain_aio_setup(ngx_output_chain_ctx_t *ctx,\n-    ngx_file_t *file);\n-#endif\n static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool,\n     ngx_chain_t **chain, ngx_chain_t *in);\n static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx,\n@@ -283,12 +279,6 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n         buf->in_file = 0;\n     }\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-    if (ctx->aio_preload && buf->in_file) {\n-        (void) ngx_output_chain_aio_setup(ctx, buf->file);\n-    }\n-#endif\n-\n     if (ctx->need_in_memory && !ngx_buf_in_memory(buf)) {\n         return 0;\n     }\n@@ -301,28 +291,6 @@ ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx, ngx_buf_t *buf)\n }\n \n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-\n-static ngx_int_t\n-ngx_output_chain_aio_setup(ngx_output_chain_ctx_t *ctx, ngx_file_t *file)\n-{\n-    ngx_event_aio_t  *aio;\n-\n-    if (file->aio == NULL && ngx_file_aio_init(file, ctx->pool) != NGX_OK) {\n-        return NGX_ERROR;\n-    }\n-\n-    aio = file->aio;\n-\n-    aio->data = ctx->filter_ctx;\n-    aio->preload_handler = ctx->aio_preload;\n-\n-    return NGX_OK;\n-}\n-\n-#endif\n-\n-\n static ngx_int_t\n ngx_output_chain_add_copy(ngx_pool_t *pool, ngx_chain_t **chain,\n     ngx_chain_t *in)\nDiff:\n@@ -151,10 +151,6 @@ struct ngx_event_aio_s {\n \n     ngx_fd_t                   fd;\n \n-#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT)\n-    ssize_t                  (*preload_handler)(ngx_buf_t *file);\n-#endif\n-\n #if (NGX_HAVE_EVENTFD)\n     int64_t                    res;\n #endif\nDiff:\n@@ -2942,7 +2942,7 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n {\n #ifdef BIO_get_ktls_send\n \n-    int        sslerr;\n+    int        sslerr, flags;\n     ssize_t    n;\n     ngx_err_t  err;\n \n@@ -2954,8 +2954,14 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n \n     ngx_set_errno(0);\n \n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+    flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n+#else\n+    flags = 0;\n+#endif\n+\n     n = SSL_sendfile(c->ssl->connection, file->file->fd, file->file_pos,\n-                     size, 0);\n+                     size, flags);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %d\", n);\n \n@@ -2974,6 +2980,10 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n             ngx_post_event(c->read, &ngx_posted_events);\n         }\n \n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+        c->busy_count = 0;\n+#endif\n+\n         c->sent += n;\n \n         return n;\n@@ -3038,6 +3048,23 @@ ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n             ngx_post_event(c->read, &ngx_posted_events);\n         }\n \n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+\n+        if (ngx_errno == EBUSY) {\n+            c->busy_count++;\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"SSL_sendfile() busy, count:%d\", c->busy_count);\n+\n+            if (c->write->posted) {\n+                ngx_delete_posted_event(c->write);\n+            }\n+\n+            ngx_post_event(c->write, &ngx_posted_next_events);\n+        }\n+\n+#endif\n+\n         c->write->ready = 0;\n         return NGX_AGAIN;\n     }\nDiff:\n@@ -19,10 +19,6 @@ typedef struct {\n static void ngx_http_copy_aio_handler(ngx_output_chain_ctx_t *ctx,\n     ngx_file_t *file);\n static void ngx_http_copy_aio_event_handler(ngx_event_t *ev);\n-#if (NGX_HAVE_AIO_SENDFILE)\n-static ssize_t ngx_http_copy_aio_sendfile_preload(ngx_buf_t *file);\n-static void ngx_http_copy_aio_sendfile_event_handler(ngx_event_t *ev);\n-#endif\n #endif\n #if (NGX_THREADS)\n static ngx_int_t ngx_http_copy_thread_handler(ngx_thread_task_t *task,\n@@ -128,9 +124,6 @@ ngx_http_copy_filter(ngx_http_request_t *r, ngx_chain_t *in)\n #if (NGX_HAVE_FILE_AIO)\n         if (ngx_file_aio && clcf->aio == NGX_HTTP_AIO_ON) {\n             ctx->aio_handler = ngx_http_copy_aio_handler;\n-#if (NGX_HAVE_AIO_SENDFILE)\n-            ctx->aio_preload = ngx_http_copy_aio_sendfile_preload;\n-#endif\n         }\n #endif\n \n@@ -207,81 +200,6 @@ ngx_http_copy_aio_event_handler(ngx_event_t *ev)\n     ngx_http_run_posted_requests(c);\n }\n \n-\n-#if (NGX_HAVE_AIO_SENDFILE)\n-\n-static ssize_t\n-ngx_http_copy_aio_sendfile_preload(ngx_buf_t *file)\n-{\n-    ssize_t                  n;\n-    static u_char            buf[1];\n-    ngx_event_aio_t         *aio;\n-    ngx_http_request_t      *r;\n-    ngx_output_chain_ctx_t  *ctx;\n-\n-    aio = file->file->aio;\n-    r = aio->data;\n-\n-    if (r->aio) {\n-        /*\n-         * tolerate sendfile() calls if another operation is already\n-         * running; this can happen due to subrequests, multiple calls\n-         * of the next body filter from a filter, or in HTTP/2 due to\n-         * a write event on the main connection\n-         */\n-\n-        return NGX_AGAIN;\n-    }\n-\n-    n = ngx_file_aio_read(file->file, buf, 1, file->file_pos, NULL);\n-\n-    if (n == NGX_AGAIN) {\n-        aio->handler = ngx_http_copy_aio_sendfile_event_handler;\n-\n-        r->main->blocked++;\n-        r->aio = 1;\n-\n-        ctx = ngx_http_get_module_ctx(r, ngx_http_copy_filter_module);\n-        ctx->aio = 1;\n-    }\n-\n-    return n;\n-}\n-\n-\n-static void\n-ngx_http_copy_aio_sendfile_event_handler(ngx_event_t *ev)\n-{\n-    ngx_event_aio_t     *aio;\n-    ngx_connection_t    *c;\n-    ngx_http_request_t  *r;\n-\n-    aio = ev->data;\n-    r = aio->data;\n-    c = r->connection;\n-\n-    r->main->blocked--;\n-    r->aio = 0;\n-    ev->complete = 0;\n-\n-#if (NGX_HTTP_V2)\n-\n-    if (r->stream) {\n-        /*\n-         * for HTTP/2, update write event to make sure processing will\n-         * reach the main connection to handle sendfile() preload\n-         */\n-\n-        c->write->ready = 1;\n-        c->write->active = 0;\n-    }\n-\n-#endif\n-\n-    c->write->handler(c->write);\n-}\n-\n-#endif\n #endif\n \n \nDiff:\n@@ -32,23 +32,22 @@\n ngx_chain_t *\n ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n {\n-    int               rc, flags;\n-    off_t             send, prev_send, sent;\n-    size_t            file_size;\n-    ssize_t           n;\n-    ngx_uint_t        eintr, eagain;\n-    ngx_err_t         err;\n-    ngx_buf_t        *file;\n-    ngx_event_t      *wev;\n-    ngx_chain_t      *cl;\n-    ngx_iovec_t       header, trailer;\n-    struct sf_hdtr    hdtr;\n-    struct iovec      headers[NGX_IOVS_PREALLOCATE];\n-    struct iovec      trailers[NGX_IOVS_PREALLOCATE];\n-#if (NGX_HAVE_AIO_SENDFILE)\n-    ngx_uint_t        ebusy;\n-    ngx_event_aio_t  *aio;\n+    int              rc, flags;\n+    off_t            send, prev_send, sent;\n+    size_t           file_size;\n+    ssize_t          n;\n+    ngx_err_t        err;\n+    ngx_buf_t       *file;\n+    ngx_uint_t       eintr, eagain;\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+    ngx_uint_t       ebusy;\n #endif\n+    ngx_event_t     *wev;\n+    ngx_chain_t     *cl;\n+    ngx_iovec_t      header, trailer;\n+    struct sf_hdtr   hdtr;\n+    struct iovec     headers[NGX_IOVS_PREALLOCATE];\n+    struct iovec     trailers[NGX_IOVS_PREALLOCATE];\n \n     wev = c->write;\n \n@@ -77,11 +76,6 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n     eagain = 0;\n     flags = 0;\n \n-#if (NGX_HAVE_AIO_SENDFILE && NGX_SUPPRESS_WARN)\n-    aio = NULL;\n-    file = NULL;\n-#endif\n-\n     header.iovs = headers;\n     header.nalloc = NGX_IOVS_PREALLOCATE;\n \n@@ -90,7 +84,7 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n     for ( ;; ) {\n         eintr = 0;\n-#if (NGX_HAVE_AIO_SENDFILE)\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n         ebusy = 0;\n #endif\n         prev_send = send;\n@@ -179,9 +173,8 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n             sent = 0;\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-            aio = file->file->aio;\n-            flags = (aio && aio->preload_handler) ? SF_NODISKIO : 0;\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n+            flags = (c->busy_count <= 2) ? SF_NODISKIO : 0;\n #endif\n \n             rc = sendfile(file->file->fd, c->fd, file->file_pos,\n@@ -199,7 +192,7 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                     eintr = 1;\n                     break;\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n                 case NGX_EBUSY:\n                     ebusy = 1;\n                     break;\n@@ -252,41 +245,30 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         in = ngx_chain_update_sent(in, sent);\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n+#if (NGX_HAVE_SENDFILE_NODISKIO)\n \n         if (ebusy) {\n             if (sent == 0) {\n                 c->busy_count++;\n \n-                if (c->busy_count > 2) {\n-                    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n-                                  \"sendfile(%V) returned busy again\",\n-                                  &file->file->name);\n-\n-                    c->busy_count = 0;\n-                    aio->preload_handler = NULL;\n-\n-                    send = prev_send;\n-                    continue;\n-                }\n+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                               \"sendfile() busy, count:%d\", c->busy_count);\n \n             } else {\n                 c->busy_count = 0;\n             }\n \n-            n = aio->preload_handler(file);\n-\n-            if (n > 0) {\n-                send = prev_send + sent;\n-                continue;\n+            if (wev->posted) {\n+                ngx_delete_posted_event(wev);\n             }\n \n+            ngx_post_event(wev, &ngx_posted_next_events);\n+\n+            wev->ready = 0;\n             return in;\n         }\n \n-        if (flags == SF_NODISKIO) {\n-            c->busy_count = 0;\n-        }\n+        c->busy_count = 0;\n \n #endif\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 137",
        "commit_diff": "Diff:\n@@ -159,7 +159,11 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n         options |= PCRE2_CASELESS;\n     }\n \n-    if (rc->options & ~NGX_REGEX_CASELESS) {\n+    if (rc->options & NGX_REGEX_MULTILINE) {\n+        options |= PCRE2_MULTILINE;\n+    }\n+\n+    if (rc->options & ~(NGX_REGEX_CASELESS|NGX_REGEX_MULTILINE)) {\n         rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                             \"regex \\\"%V\\\" compilation failed: invalid options\",\n                             &rc->pattern)\n@@ -275,7 +279,11 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n         options |= PCRE_CASELESS;\n     }\n \n-    if (rc->options & ~NGX_REGEX_CASELESS) {\n+    if (rc->options & NGX_REGEX_MULTILINE) {\n+        options |= PCRE_MULTILINE;\n+    }\n+\n+    if (rc->options & ~(NGX_REGEX_CASELESS|NGX_REGEX_MULTILINE)) {\n         rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                             \"regex \\\"%V\\\" compilation failed: invalid options\",\n                             &rc->pattern)\nDiff:\n@@ -37,6 +37,7 @@ typedef struct {\n \n \n #define NGX_REGEX_CASELESS     0x00000001\n+#define NGX_REGEX_MULTILINE    0x00000002\n \n \n typedef struct {\nDiff:\n@@ -4568,19 +4568,6 @@ ngx_http_core_set_aio(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n     }\n \n-#if (NGX_HAVE_AIO_SENDFILE)\n-\n-    if (ngx_strcmp(value[1].data, \"sendfile\") == 0) {\n-        clcf->aio = NGX_HTTP_AIO_ON;\n-\n-        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n-                           \"the \\\"sendfile\\\" parameter of \"\n-                           \"the \\\"aio\\\" directive is deprecated\");\n-        return NGX_CONF_OK;\n-    }\n-\n-#endif\n-\n     if (ngx_strncmp(value[1].data, \"threads\", 7) == 0\n         && (value[1].len == 7 || value[1].data[7] == '='))\n     {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 136",
        "commit_diff": "Diff:\n@@ -5,29 +5,61 @@\n \n if [ $PCRE != NONE ]; then\n \n-    have=NGX_PCRE . auto/have\n+    if [ -f $PCRE/src/pcre2.h.generic ]; then\n \n-    if [ \"$NGX_PLATFORM\" = win32 ]; then\n-        have=PCRE_STATIC . auto/have\n-    fi\n+        PCRE_LIBRARY=PCRE2\n+\n+        have=NGX_PCRE . auto/have\n+        have=NGX_PCRE2 . auto/have\n+\n+        if [ \"$NGX_PLATFORM\" = win32 ]; then\n+            have=PCRE2_STATIC . auto/have\n+        fi\n+\n+        CORE_INCS=\"$CORE_INCS $PCRE/src/\"\n+        CORE_DEPS=\"$CORE_DEPS $PCRE/src/pcre2.h\"\n \n-    CORE_INCS=\"$CORE_INCS $PCRE\"\n-    CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n+        case \"$NGX_CC_NAME\" in\n \n-    case \"$NGX_CC_NAME\" in\n+            msvc)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/src/pcre2-8.lib\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/src/pcre2-8.lib\"\n+            ;;\n \n-        msvc | owc | bcc)\n-            LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n-            CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n-        ;;\n+            *)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre2-8.a\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre2-8.a\"\n+            ;;\n \n-        *)\n-            LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n-            CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n-        ;;\n+        esac\n+\n+    else\n+\n+        PCRE_LIBRARY=PCRE\n+\n+        have=NGX_PCRE . auto/have\n+\n+        if [ \"$NGX_PLATFORM\" = win32 ]; then\n+            have=PCRE_STATIC . auto/have\n+        fi\n \n-    esac\n+        CORE_INCS=\"$CORE_INCS $PCRE\"\n+        CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n \n+        case \"$NGX_CC_NAME\" in\n+\n+            msvc | owc | bcc)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n+            ;;\n+\n+            *)\n+                LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n+                CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n+            ;;\n+\n+        esac\n+    fi\n \n     if [ $PCRE_JIT = YES ]; then\n         have=NGX_HAVE_PCRE_JIT . auto/have\n@@ -37,8 +69,48 @@ if [ $PCRE != NONE ]; then\n else\n \n     if [ \"$NGX_PLATFORM\" != win32 ]; then\n-\n         PCRE=NO\n+    fi\n+\n+    if [ $PCRE = NO -a $PCRE2 != DISABLED ]; then\n+\n+        ngx_feature=\"PCRE2 library\"\n+        ngx_feature_name=\"NGX_PCRE2\"\n+        ngx_feature_run=no\n+        ngx_feature_incs=\"#define PCRE2_CODE_UNIT_WIDTH 8\n+                          #include <pcre2.h>\"\n+        ngx_feature_path=\n+        ngx_feature_libs=\"-lpcre2-8\"\n+        ngx_feature_test=\"pcre2_code *re;\n+                          re = pcre2_compile(NULL, 0, 0, NULL, NULL, NULL);\n+                          if (re == NULL) return 1\"\n+        . auto/feature\n+\n+        if [ $ngx_found = no ]; then\n+\n+            # pcre2-config\n+\n+            ngx_pcre2_prefix=`pcre2-config --prefix 2>/dev/null`\n+\n+            if [ -n \"$ngx_pcre2_prefix\" ]; then\n+                ngx_feature=\"PCRE2 library in $ngx_pcre2_prefix\"\n+                ngx_feature_path=`pcre2-config --cflags \\\n+                                  | sed -n -e 's/.*-I *\\([^ ][^ ]*\\).*/\\1/p'`\n+                ngx_feature_libs=`pcre2-config --libs8`\n+                . auto/feature\n+            fi\n+        fi\n+\n+        if [ $ngx_found = yes ]; then\n+            have=NGX_PCRE . auto/have\n+            CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n+            CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n+            PCRE=YES\n+            PCRE_LIBRARY=PCRE2\n+        fi\n+    fi\n+\n+    if [ $PCRE = NO ]; then\n \n         ngx_feature=\"PCRE library\"\n         ngx_feature_name=\"NGX_PCRE\"\n@@ -114,6 +186,7 @@ else\n             CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n             CORE_LIBS=\"$CORE_LIBS $ngx_feature_libs\"\n             PCRE=YES\n+            PCRE_LIBRARY=PCRE\n         fi\n \n         if [ $PCRE = YES ]; then\nDiff:\n@@ -3,36 +3,138 @@\n # Copyright (C) Nginx, Inc.\n \n \n-case \"$NGX_CC_NAME\" in\n+if [ $PCRE_LIBRARY = PCRE2 ]; then\n+\n+    # PCRE2\n+\n+    if [ $NGX_CC_NAME = msvc ]; then\n+\n+        # With PCRE2, it is not possible to compile all sources.\n+        # Since list of source files changes between versions, we\n+        # test files which might not be present.\n+\n+        ngx_pcre_srcs=\"pcre2_auto_possess.c \\\n+                       pcre2_chartables.c \\\n+                       pcre2_compile.c \\\n+                       pcre2_config.c \\\n+                       pcre2_context.c \\\n+                       pcre2_dfa_match.c \\\n+                       pcre2_error.c \\\n+                       pcre2_jit_compile.c \\\n+                       pcre2_maketables.c \\\n+                       pcre2_match.c \\\n+                       pcre2_match_data.c \\\n+                       pcre2_newline.c \\\n+                       pcre2_ord2utf.c \\\n+                       pcre2_pattern_info.c \\\n+                       pcre2_string_utils.c \\\n+                       pcre2_study.c \\\n+                       pcre2_substitute.c \\\n+                       pcre2_substring.c \\\n+                       pcre2_tables.c \\\n+                       pcre2_ucd.c \\\n+                       pcre2_valid_utf.c \\\n+                       pcre2_xclass.c\"\n+\n+        ngx_pcre_test=\"pcre2_convert.c \\\n+                       pcre2_extuni.c \\\n+                       pcre2_find_bracket.c \\\n+                       pcre2_script_run.c \\\n+                       pcre2_serialize.c\"\n+\n+        for ngx_src in $ngx_pcre_test\n+        do\n+            if [ -f $PCRE/src/$ngx_src ]; then\n+                ngx_pcre_srcs=\"$ngx_pcre_srcs $ngx_src\"\n+            fi\n+        done\n+\n+        ngx_pcre_objs=`echo $ngx_pcre_srcs \\\n+            | sed -e \"s#\\([^ ]*\\.\\)c#\\1$ngx_objext#g\"`\n+\n+        ngx_pcre_srcs=`echo $ngx_pcre_srcs \\\n+            | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\"`\n+        ngx_pcre_objs=`echo $ngx_pcre_objs \\\n+            | sed -e \"s/  *\\([^ ][^ ]*\\)/$ngx_regex_cont\\1/g\"`\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n+\n+PCRE_CFLAGS =\t-O2 -Ob1 -Oi -Gs $LIBC $CPU_OPT\n+PCRE_FLAGS =\t-DHAVE_CONFIG_H -DPCRE2_STATIC -DPCRE2_CODE_UNIT_WIDTH=8 \\\\\n+\t\t-DHAVE_MEMMOVE\n+\n+PCRE_SRCS =\t $ngx_pcre_srcs\n+PCRE_OBJS =\t $ngx_pcre_objs\n+\n+$PCRE/src/pcre2.h:\n+\tcd $PCRE/src \\\\\n+\t&& copy /y config.h.generic config.h \\\\\n+\t&& copy /y pcre2.h.generic pcre2.h \\\\\n+\t&& copy /y pcre2_chartables.c.dist pcre2_chartables.c\n+\n+$PCRE/src/pcre2-8.lib:\t$PCRE/src/pcre2.h $NGX_MAKEFILE\n+\tcd $PCRE/src \\\\\n+\t&& cl -nologo -c \\$(PCRE_CFLAGS) -I . \\$(PCRE_FLAGS) \\$(PCRE_SRCS) \\\\\n+\t&& link -lib -out:pcre2-8.lib -verbose:lib \\$(PCRE_OBJS)\n \n-    msvc)\n-        ngx_makefile=makefile.msvc\n-        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\" LIBC=$LIBC\"\n-        ngx_pcre=\"PCRE=\\\"$PCRE\\\"\"\n-    ;;\n+END\n+\n+    else\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n \n-    owc)\n-        ngx_makefile=makefile.owc\n-        ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\"\"\n-        ngx_pcre=`echo PCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n-    ;;\n+$PCRE/src/pcre2.h:\t$PCRE/Makefile\n+\n+$PCRE/Makefile:\t$NGX_MAKEFILE\n+\tcd $PCRE \\\\\n+\t&& if [ -f Makefile ]; then \\$(MAKE) distclean; fi \\\\\n+\t&& CC=\"\\$(CC)\" CFLAGS=\"$PCRE_OPT\" \\\\\n+\t./configure --disable-shared $PCRE_CONF_OPT\n \n-    bcc)\n-        ngx_makefile=makefile.bcc\n-        ngx_opt=\"-DCPU_OPT=\\\"$CPU_OPT\\\"\"\n-        ngx_pcre=`echo \\-DPCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n-    ;;\n+$PCRE/.libs/libpcre2-8.a:\t$PCRE/Makefile\n+\tcd $PCRE \\\\\n+\t&& \\$(MAKE) libpcre2-8.la\n \n-    *)\n-        ngx_makefile=\n-    ;;\n+END\n \n-esac\n+    fi\n \n \n-if [ -n \"$ngx_makefile\" ]; then\n+else\n \n-    cat << END                                                >> $NGX_MAKEFILE\n+    # PCRE\n+\n+    case \"$NGX_CC_NAME\" in\n+\n+        msvc)\n+            ngx_makefile=makefile.msvc\n+            ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\" LIBC=$LIBC\"\n+            ngx_pcre=\"PCRE=\\\"$PCRE\\\"\"\n+        ;;\n+\n+        owc)\n+            ngx_makefile=makefile.owc\n+            ngx_opt=\"CPU_OPT=\\\"$CPU_OPT\\\"\"\n+            ngx_pcre=`echo PCRE=\\\"$PCRE\\\" | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ;;\n+\n+        bcc)\n+            ngx_makefile=makefile.bcc\n+            ngx_opt=\"-DCPU_OPT=\\\"$CPU_OPT\\\"\"\n+            ngx_pcre=`echo \\-DPCRE=\\\"$PCRE\\\" \\\n+                | sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n+        ;;\n+\n+        *)\n+            ngx_makefile=\n+        ;;\n+\n+    esac\n+\n+\n+    if [ -n \"$ngx_makefile\" ]; then\n+\n+        cat << END                                            >> $NGX_MAKEFILE\n \n `echo \"$PCRE/pcre.lib:\t$PCRE/pcre.h $NGX_MAKEFILE\"\t\t\t\\\n \t| sed -e \"s/\\//$ngx_regex_dirsep/g\"`\n@@ -43,9 +145,9 @@ if [ -n \"$ngx_makefile\" ]; then\n \n END\n \n-else\n+    else\n \n-    cat << END                                                >> $NGX_MAKEFILE\n+        cat << END                                            >> $NGX_MAKEFILE\n \n $PCRE/pcre.h:\t$PCRE/Makefile\n \n@@ -61,4 +163,6 @@ $PCRE/.libs/libpcre.a:\t$PCRE/Makefile\n \n END\n \n+    fi\n+\n fi\nDiff:\n@@ -146,6 +146,7 @@ PCRE=NONE\n PCRE_OPT=\n PCRE_CONF_OPT=\n PCRE_JIT=NO\n+PCRE2=YES\n \n USE_OPENSSL=NO\n OPENSSL=NONE\n@@ -357,6 +358,7 @@ use the \\\"--with-mail_ssl_module\\\" option instead\"\n         --with-pcre=*)                   PCRE=\"$value\"              ;;\n         --with-pcre-opt=*)               PCRE_OPT=\"$value\"          ;;\n         --with-pcre-jit)                 PCRE_JIT=YES               ;;\n+        --without-pcre2)                 PCRE2=DISABLED             ;;\n \n         --with-openssl=*)                OPENSSL=\"$value\"           ;;\n         --with-openssl-opt=*)            OPENSSL_OPT=\"$value\"       ;;\n@@ -573,6 +575,7 @@ cat << END\n   --with-pcre=DIR                    set path to PCRE library sources\n   --with-pcre-opt=OPTIONS            set additional build options for PCRE\n   --with-pcre-jit                    build PCRE with JIT compilation support\n+  --without-pcre2                    do not use PCRE2 library\n \n   --with-zlib=DIR                    set path to zlib library sources\n   --with-zlib-opt=OPTIONS            set additional build options for zlib\nDiff:\n@@ -16,9 +16,9 @@ if [ $USE_PCRE = DISABLED ]; then\n \n else\n     case $PCRE in\n-        YES)   echo \"  + using system PCRE library\" ;;\n+        YES)   echo \"  + using system $PCRE_LIBRARY library\" ;;\n         NONE)  echo \"  + PCRE library is not used\" ;;\n-        *)     echo \"  + using PCRE library: $PCRE\" ;;\n+        *)     echo \"  + using $PCRE_LIBRARY library: $PCRE\" ;;\n     esac\n fi\n \nDiff:\n@@ -18,8 +18,13 @@ typedef struct {\n static ngx_inline void ngx_regex_malloc_init(ngx_pool_t *pool);\n static ngx_inline void ngx_regex_malloc_done(void);\n \n+#if (NGX_PCRE2)\n+static void * ngx_libc_cdecl ngx_regex_malloc(size_t size, void *data);\n+static void ngx_libc_cdecl ngx_regex_free(void *p, void *data);\n+#else\n static void * ngx_libc_cdecl ngx_regex_malloc(size_t size);\n static void ngx_libc_cdecl ngx_regex_free(void *p);\n+#endif\n static void ngx_regex_cleanup(void *data);\n \n static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle);\n@@ -67,31 +72,192 @@ ngx_module_t  ngx_regex_module = {\n };\n \n \n-static ngx_pool_t  *ngx_regex_pool;\n-static ngx_list_t  *ngx_regex_studies;\n+static ngx_pool_t             *ngx_regex_pool;\n+static ngx_list_t             *ngx_regex_studies;\n+static ngx_uint_t              ngx_regex_direct_alloc;\n+\n+#if (NGX_PCRE2)\n+static pcre2_compile_context  *ngx_regex_compile_context;\n+static pcre2_match_data       *ngx_regex_match_data;\n+static ngx_uint_t              ngx_regex_match_data_size;\n+#endif\n \n \n void\n ngx_regex_init(void)\n {\n+#if !(NGX_PCRE2)\n     pcre_malloc = ngx_regex_malloc;\n     pcre_free = ngx_regex_free;\n+#endif\n }\n \n \n static ngx_inline void\n ngx_regex_malloc_init(ngx_pool_t *pool)\n {\n     ngx_regex_pool = pool;\n+    ngx_regex_direct_alloc = (pool == NULL) ? 1 : 0;\n }\n \n \n static ngx_inline void\n ngx_regex_malloc_done(void)\n {\n     ngx_regex_pool = NULL;\n+    ngx_regex_direct_alloc = 0;\n+}\n+\n+\n+#if (NGX_PCRE2)\n+\n+ngx_int_t\n+ngx_regex_compile(ngx_regex_compile_t *rc)\n+{\n+    int                     n, errcode;\n+    char                   *p;\n+    u_char                  errstr[128];\n+    size_t                  erroff;\n+    uint32_t                options;\n+    pcre2_code             *re;\n+    ngx_regex_elt_t        *elt;\n+    pcre2_general_context  *gctx;\n+    pcre2_compile_context  *cctx;\n+\n+    if (ngx_regex_compile_context == NULL) {\n+        /*\n+         * Allocate a compile context if not yet allocated.  This uses\n+         * direct allocations from heap, so the result can be cached\n+         * even at runtime.\n+         */\n+\n+        ngx_regex_malloc_init(NULL);\n+\n+        gctx = pcre2_general_context_create(ngx_regex_malloc, ngx_regex_free,\n+                                            NULL);\n+        if (gctx == NULL) {\n+            ngx_regex_malloc_done();\n+            goto nomem;\n+        }\n+\n+        cctx = pcre2_compile_context_create(gctx);\n+        if (cctx == NULL) {\n+            pcre2_general_context_free(gctx);\n+            ngx_regex_malloc_done();\n+            goto nomem;\n+        }\n+\n+        ngx_regex_compile_context = cctx;\n+\n+        pcre2_general_context_free(gctx);\n+        ngx_regex_malloc_done();\n+    }\n+\n+    options = 0;\n+\n+    if (rc->options & NGX_REGEX_CASELESS) {\n+        options |= PCRE2_CASELESS;\n+    }\n+\n+    if (rc->options & ~NGX_REGEX_CASELESS) {\n+        rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                            \"regex \\\"%V\\\" compilation failed: invalid options\",\n+                            &rc->pattern)\n+                      - rc->err.data;\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_regex_malloc_init(rc->pool);\n+\n+    re = pcre2_compile(rc->pattern.data, rc->pattern.len, options,\n+                       &errcode, &erroff, ngx_regex_compile_context);\n+\n+    /* ensure that there is no current pool */\n+    ngx_regex_malloc_done();\n+\n+    if (re == NULL) {\n+        pcre2_get_error_message(errcode, errstr, 128);\n+\n+        if ((size_t) erroff == rc->pattern.len) {\n+            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                              \"pcre2_compile() failed: %s in \\\"%V\\\"\",\n+                               errstr, &rc->pattern)\n+                          - rc->err.data;\n+\n+        } else {\n+            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                              \"pcre2_compile() failed: %s in \\\"%V\\\" at \\\"%s\\\"\",\n+                               errstr, &rc->pattern, rc->pattern.data + erroff)\n+                          - rc->err.data;\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    rc->regex = re;\n+\n+    /* do not study at runtime */\n+\n+    if (ngx_regex_studies != NULL) {\n+        elt = ngx_list_push(ngx_regex_studies);\n+        if (elt == NULL) {\n+            goto nomem;\n+        }\n+\n+        elt->regex = rc->regex;\n+        elt->name = rc->pattern.data;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_CAPTURECOUNT, &rc->captures);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_CAPTURECOUNT) failed: %d\";\n+        goto failed;\n+    }\n+\n+    if (rc->captures == 0) {\n+        return NGX_OK;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_NAMECOUNT, &rc->named_captures);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_NAMECOUNT) failed: %d\";\n+        goto failed;\n+    }\n+\n+    if (rc->named_captures == 0) {\n+        return NGX_OK;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_NAMEENTRYSIZE, &rc->name_size);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_NAMEENTRYSIZE) failed: %d\";\n+        goto failed;\n+    }\n+\n+    n = pcre2_pattern_info(re, PCRE2_INFO_NAMETABLE, &rc->names);\n+    if (n < 0) {\n+        p = \"pcre2_pattern_info(\\\"%V\\\", PCRE2_INFO_NAMETABLE) failed: %d\";\n+        goto failed;\n+    }\n+\n+    return NGX_OK;\n+\n+failed:\n+\n+    rc->err.len = ngx_snprintf(rc->err.data, rc->err.len, p, &rc->pattern, n)\n+                  - rc->err.data;\n+    return NGX_ERROR;\n+\n+nomem:\n+\n+    rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                               \"regex \\\"%V\\\" compilation failed: no memory\",\n+                               &rc->pattern)\n+                  - rc->err.data;\n+    return NGX_ERROR;\n }\n \n+#else\n \n ngx_int_t\n ngx_regex_compile(ngx_regex_compile_t *rc)\n@@ -100,11 +266,26 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n     char             *p;\n     pcre             *re;\n     const char       *errstr;\n+    ngx_uint_t        options;\n     ngx_regex_elt_t  *elt;\n \n+    options = 0;\n+\n+    if (rc->options & NGX_REGEX_CASELESS) {\n+        options |= PCRE_CASELESS;\n+    }\n+\n+    if (rc->options & ~NGX_REGEX_CASELESS) {\n+        rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n+                            \"regex \\\"%V\\\" compilation failed: invalid options\",\n+                            &rc->pattern)\n+                      - rc->err.data;\n+        return NGX_ERROR;\n+    }\n+\n     ngx_regex_malloc_init(rc->pool);\n \n-    re = pcre_compile((const char *) rc->pattern.data, (int) rc->options,\n+    re = pcre_compile((const char *) rc->pattern.data, (int) options,\n                       &errstr, &erroff, NULL);\n \n     /* ensure that there is no current pool */\n@@ -195,6 +376,83 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n     return NGX_ERROR;\n }\n \n+#endif\n+\n+\n+#if (NGX_PCRE2)\n+\n+ngx_int_t\n+ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures, ngx_uint_t size)\n+{\n+    size_t      *ov;\n+    ngx_int_t    rc;\n+    ngx_uint_t   n, i;\n+\n+    /*\n+     * The pcre2_match() function might allocate memory for backtracking\n+     * frames, typical allocations are from 40k and above.  So the allocator\n+     * is configured to do direct allocations from heap during matching.\n+     */\n+\n+    ngx_regex_malloc_init(NULL);\n+\n+    if (ngx_regex_match_data == NULL\n+        || size > ngx_regex_match_data_size)\n+    {\n+        /*\n+         * Allocate a match data if not yet allocated or smaller than\n+         * needed.\n+         */\n+\n+        if (ngx_regex_match_data) {\n+            pcre2_match_data_free(ngx_regex_match_data);\n+        }\n+\n+        ngx_regex_match_data_size = size;\n+        ngx_regex_match_data = pcre2_match_data_create(size / 3, NULL);\n+\n+        if (ngx_regex_match_data == NULL) {\n+            rc = PCRE2_ERROR_NOMEMORY;\n+            goto failed;\n+        }\n+    }\n+\n+    rc = pcre2_match(re, s->data, s->len, 0, 0, ngx_regex_match_data, NULL);\n+\n+    if (rc < 0) {\n+        goto failed;\n+    }\n+\n+    n = pcre2_get_ovector_count(ngx_regex_match_data);\n+    ov = pcre2_get_ovector_pointer(ngx_regex_match_data);\n+\n+    if (n > size / 3) {\n+        n = size / 3;\n+    }\n+\n+    for (i = 0; i < n; i++) {\n+        captures[i * 2] = ov[i * 2];\n+        captures[i * 2 + 1] = ov[i * 2 + 1];\n+    }\n+\n+failed:\n+\n+    ngx_regex_malloc_done();\n+\n+    return rc;\n+}\n+\n+#else\n+\n+ngx_int_t\n+ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures, ngx_uint_t size)\n+{\n+    return pcre_exec(re->code, re->extra, (const char *) s->data, s->len,\n+                     0, 0, captures, size);\n+}\n+\n+#endif\n+\n \n ngx_int_t\n ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)\n@@ -229,6 +487,35 @@ ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)\n }\n \n \n+#if (NGX_PCRE2)\n+\n+static void * ngx_libc_cdecl\n+ngx_regex_malloc(size_t size, void *data)\n+{\n+    if (ngx_regex_pool) {\n+        return ngx_palloc(ngx_regex_pool, size);\n+    }\n+\n+    if (ngx_regex_direct_alloc) {\n+        return ngx_alloc(size, ngx_cycle->log);\n+    }\n+\n+    return NULL;\n+}\n+\n+\n+static void ngx_libc_cdecl\n+ngx_regex_free(void *p, void *data)\n+{\n+    if (ngx_regex_direct_alloc) {\n+        ngx_free(p);\n+    }\n+\n+    return;\n+}\n+\n+#else\n+\n static void * ngx_libc_cdecl\n ngx_regex_malloc(size_t size)\n {\n@@ -246,11 +533,13 @@ ngx_regex_free(void *p)\n     return;\n }\n \n+#endif\n+\n \n static void\n ngx_regex_cleanup(void *data)\n {\n-#if (NGX_HAVE_PCRE_JIT)\n+#if (NGX_PCRE2 || NGX_HAVE_PCRE_JIT)\n     ngx_regex_conf_t *rcf = data;\n \n     ngx_uint_t        i;\n@@ -275,12 +564,17 @@ ngx_regex_cleanup(void *data)\n         /*\n          * The PCRE JIT compiler uses mmap for its executable codes, so we\n          * have to explicitly call the pcre_free_study() function to free\n-         * this memory.\n+         * this memory.  In PCRE2, we call the pcre2_code_free() function\n+         * for the same reason.\n          */\n \n+#if (NGX_PCRE2)\n+        pcre2_code_free(elts[i].regex);\n+#else\n         if (elts[i].regex->extra != NULL) {\n             pcre_free_study(elts[i].regex->extra);\n         }\n+#endif\n     }\n #endif\n \n@@ -290,14 +584,36 @@ ngx_regex_cleanup(void *data)\n      */\n \n     ngx_regex_studies = NULL;\n+\n+#if (NGX_PCRE2)\n+\n+    /*\n+     * Free compile context and match data.  If needed at runtime by\n+     * the new cycle, these will be re-allocated.\n+     */\n+\n+    if (ngx_regex_compile_context) {\n+        pcre2_compile_context_free(ngx_regex_compile_context);\n+        ngx_regex_compile_context = NULL;\n+    }\n+\n+    if (ngx_regex_match_data) {\n+        pcre2_match_data_free(ngx_regex_match_data);\n+        ngx_regex_match_data = NULL;\n+        ngx_regex_match_data_size = 0;\n+    }\n+\n+#endif\n }\n \n \n static ngx_int_t\n ngx_regex_module_init(ngx_cycle_t *cycle)\n {\n     int                opt;\n+#if !(NGX_PCRE2)\n     const char        *errstr;\n+#endif\n     ngx_uint_t         i;\n     ngx_list_part_t   *part;\n     ngx_regex_elt_t   *elts;\n@@ -307,10 +623,16 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n \n     rcf = (ngx_regex_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_regex_module);\n \n-#if (NGX_HAVE_PCRE_JIT)\n+#if (NGX_PCRE2 || NGX_HAVE_PCRE_JIT)\n+\n     if (rcf->pcre_jit) {\n+#if (NGX_PCRE2)\n+        opt = 1;\n+#else\n         opt = PCRE_STUDY_JIT_COMPILE;\n+#endif\n     }\n+\n #endif\n \n     ngx_regex_malloc_init(cycle->pool);\n@@ -330,6 +652,23 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n             i = 0;\n         }\n \n+#if (NGX_PCRE2)\n+\n+        if (opt) {\n+            int  n;\n+\n+            n = pcre2_jit_compile(elts[i].regex, PCRE2_JIT_COMPLETE);\n+\n+            if (n != 0) {\n+                ngx_log_error(NGX_LOG_INFO, cycle->log, 0,\n+                              \"pcre2_jit_compile() failed: %d in \\\"%s\\\", \"\n+                              \"ignored\",\n+                              n, elts[i].name);\n+            }\n+        }\n+\n+#else\n+\n         elts[i].regex->extra = pcre_study(elts[i].regex->code, opt, &errstr);\n \n         if (errstr != NULL) {\n@@ -352,12 +691,16 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n                               elts[i].name);\n             }\n         }\n+#endif\n #endif\n     }\n \n     ngx_regex_malloc_done();\n \n     ngx_regex_studies = NULL;\n+#if (NGX_PCRE2)\n+    ngx_regex_compile_context = NULL;\n+#endif\n \n     return NGX_OK;\n }\n@@ -415,7 +758,21 @@ ngx_regex_pcre_jit(ngx_conf_t *cf, void *post, void *data)\n         return NGX_CONF_OK;\n     }\n \n-#if (NGX_HAVE_PCRE_JIT)\n+#if (NGX_PCRE2)\n+    {\n+    int       r;\n+    uint32_t  jit;\n+\n+    jit = 0;\n+    r = pcre2_config(PCRE2_CONFIG_JIT, &jit);\n+\n+    if (r != 0 || jit != 1) {\n+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                           \"PCRE2 library does not support JIT\");\n+        *fp = 0;\n+    }\n+    }\n+#elif (NGX_HAVE_PCRE_JIT)\n     {\n     int  jit, r;\n \nDiff:\n@@ -12,24 +12,37 @@\n #include <ngx_config.h>\n #include <ngx_core.h>\n \n-#include <pcre.h>\n \n+#if (NGX_PCRE2)\n+\n+#define PCRE2_CODE_UNIT_WIDTH  8\n+#include <pcre2.h>\n+\n+#define NGX_REGEX_NO_MATCHED   PCRE2_ERROR_NOMATCH   /* -1 */\n \n-#define NGX_REGEX_NO_MATCHED  PCRE_ERROR_NOMATCH   /* -1 */\n+typedef pcre2_code  ngx_regex_t;\n \n-#define NGX_REGEX_CASELESS    PCRE_CASELESS\n+#else\n+\n+#include <pcre.h>\n \n+#define NGX_REGEX_NO_MATCHED   PCRE_ERROR_NOMATCH    /* -1 */\n \n typedef struct {\n     pcre        *code;\n     pcre_extra  *extra;\n } ngx_regex_t;\n \n+#endif\n+\n+\n+#define NGX_REGEX_CASELESS     0x00000001\n+\n \n typedef struct {\n     ngx_str_t     pattern;\n     ngx_pool_t   *pool;\n-    ngx_int_t     options;\n+    ngx_uint_t    options;\n \n     ngx_regex_t  *regex;\n     int           captures;\n@@ -49,10 +62,14 @@ typedef struct {\n void ngx_regex_init(void);\n ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc);\n \n-#define ngx_regex_exec(re, s, captures, size)                                \\\n-    pcre_exec(re->code, re->extra, (const char *) (s)->data, (s)->len, 0, 0, \\\n-              captures, size)\n-#define ngx_regex_exec_n      \"pcre_exec()\"\n+ngx_int_t ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures,\n+    ngx_uint_t size);\n+\n+#if (NGX_PCRE2)\n+#define ngx_regex_exec_n       \"pcre2_match()\"\n+#else\n+#define ngx_regex_exec_n       \"pcre_exec()\"\n+#endif\n \n ngx_int_t ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log);\n \n",
        "analysis": "The diff introduces several new functions, but based on the content provided, the relevant newly added function is `ngx_regex_exec`. Let's analyze this function for potential out-of-bounds write vulnerabilities:\n\n1. **Function Definition:**\n   ```c\n   ngx_int_t ngx_regex_exec(ngx_regex_t *re, ngx_str_t *s, int *captures, ngx_uint_t size)\n   ```\n   The function signature suggests it is intended to execute a regular expression search (`re`) on a string (`s`), with results possibly being stored in the `captures` array up to a `size`.\n\n2. **Reviewing the Logic Inside `ngx_regex_exec`:**\n\n   ```c\n   size_t *ov;\n   ngx_int_t rc;\n   ngx_uint_t n, i;\n\n   /* Initialize memory allocation for backtracking frames */\n   ngx_regex_malloc_init(NULL);\n\n   if (ngx_regex_match_data == NULL || size > ngx_regex_match_data_size)\n   {\n       /* Allocate memory for match data */\n   }\n\n   /* Execute the match */\n   rc = pcre2_match(re, s->data, s->len, 0, 0, ngx_regex_match_data, NULL);\n\n   if (rc < 0)\n   {\n       goto failed;\n   }\n\n   n = pcre2_get_ovector_count(ngx_regex_match_data);\n   ov = pcre2_get_ovector_pointer(ngx_regex_match_data);\n\n   if (n > size / 3) {\n       n = size / 3;\n   }\n\n   for (i = 0; i < n; i++) {\n       captures[i * 2] = ov[i * 2];\n       captures[i * 2 + 1] = ov[i * 2 + 1];\n   }\n   ```\n\n3. **Analysis for Out-of-Bounds Write:**\n\n   - The function uses `n = pcre2_get_ovector_count(ngx_regex_match_data);` to populate `n` with the count of captures.\n   - It then checks if `n > size / 3`. If true, it limits `n` to `size / 3`.\n   - The loop that follows copies data into the `captures` array using indices `i * 2` and `i * 2 + 1`.\n   - The check `if (n > size / 3)` appears to prevent overwriting the bounds of `captures`, given that each match result takes two slots in the `captures` array.\n   \n4. **Conclusion:**\n   - The function `ngx_regex_exec` appears to be designed with safeguards to prevent out-of-bounds writes by capping `n` to `size / 3`.\n   - However, without seeing the entire context of how `size` is determined or any potential off-by-one errors, there's a possibility of vulnerabilities under certain conditions, especially if integer overflow or other unsafe conditions arise.\n\nConsidering the potential for highly crafted inputs under assumptions of malicious exploitation, this function could be suspicious and worth further security scrutiny.\n\nFinal line:\n```\nTRUE [ngx_regex_exec]\n```"
    },
    {
        "commit_index": "Commit 135",
        "commit_diff": "Diff:\n@@ -4,81 +4,24 @@\n \n \n if [ $PCRE != NONE ]; then\n+\n+    have=NGX_PCRE . auto/have\n+\n+    if [ \"$NGX_PLATFORM\" = win32 ]; then\n+        have=PCRE_STATIC . auto/have\n+    fi\n+\n     CORE_INCS=\"$CORE_INCS $PCRE\"\n+    CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n \n     case \"$NGX_CC_NAME\" in\n \n         msvc | owc | bcc)\n-            have=NGX_PCRE . auto/have\n-            have=PCRE_STATIC . auto/have\n-            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n             LINK_DEPS=\"$LINK_DEPS $PCRE/pcre.lib\"\n             CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.lib\"\n         ;;\n \n-        icc)\n-            have=NGX_PCRE . auto/have\n-            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n-\n-            LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n-\n-            echo $ngx_n \"checking for PCRE library ...$ngx_c\"\n-\n-            if [ -f $PCRE/pcre.h ]; then\n-                ngx_pcre_ver=`grep PCRE_MAJOR $PCRE/pcre.h \\\n-                              | sed -e 's/^.*PCRE_MAJOR.* \\(.*\\)$/\\1/'`\n-\n-            else if [ -f $PCRE/configure.in ]; then\n-                ngx_pcre_ver=`grep PCRE_MAJOR= $PCRE/configure.in \\\n-                              | sed -e 's/^.*=\\(.*\\)$/\\1/'`\n-\n-            else\n-                ngx_pcre_ver=`grep pcre_major, $PCRE/configure.ac \\\n-                              | sed -e 's/^.*pcre_major,.*\\[\\(.*\\)\\].*$/\\1/'`\n-            fi\n-            fi\n-\n-            echo \" $ngx_pcre_ver major version found\"\n-\n-            # to allow -ipo optimization we link with the *.o but not library\n-\n-            case \"$ngx_pcre_ver\" in\n-                4|5)\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre.o\"\n-                ;;\n-\n-                6)\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_chartables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_compile.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_exec.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_fullinfo.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_globals.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_tables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_try_flipped.o\"\n-                ;;\n-\n-                *)\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_chartables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_compile.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_exec.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_fullinfo.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_globals.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_tables.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_try_flipped.o\"\n-                    CORE_LIBS=\"$CORE_LIBS $PCRE/pcre_newline.o\"\n-                ;;\n-\n-            esac\n-        ;;\n-\n         *)\n-            have=NGX_PCRE . auto/have\n-\n-            if [ \"$NGX_PLATFORM\" = win32 ]; then\n-                have=PCRE_STATIC . auto/have\n-            fi\n-\n-            CORE_DEPS=\"$CORE_DEPS $PCRE/pcre.h\"\n             LINK_DEPS=\"$LINK_DEPS $PCRE/.libs/libpcre.a\"\n             CORE_LIBS=\"$CORE_LIBS $PCRE/.libs/libpcre.a\"\n         ;;\nDiff:\n@@ -102,6 +102,11 @@ if [ $HTTP = YES ]; then\n     fi\n \n \n+    if [ $HTTP_V2 = YES ]; then\n+        HTTP_SRCS=\"$HTTP_SRCS $HTTP_HUFF_SRCS\"\n+    fi\n+\n+\n     # the module order is important\n     #     ngx_http_static_module\n     #     ngx_http_gzip_static_module\n@@ -414,8 +419,6 @@ if [ $HTTP = YES ]; then\n         ngx_module_srcs=\"src/http/v2/ngx_http_v2.c \\\n                          src/http/v2/ngx_http_v2_table.c \\\n                          src/http/v2/ngx_http_v2_encode.c \\\n-                         src/http/v2/ngx_http_v2_huff_decode.c \\\n-                         src/http/v2/ngx_http_v2_huff_encode.c \\\n                          src/http/v2/ngx_http_v2_module.c\"\n         ngx_module_libs=\n         ngx_module_link=$HTTP_V2\nDiff:\n@@ -255,3 +255,6 @@ NGX_WIN32_RC=\"src/os/win32/nginx.rc\"\n \n \n HTTP_FILE_CACHE_SRCS=src/http/ngx_http_file_cache.c\n+\n+HTTP_HUFF_SRCS=\"src/http/ngx_http_huff_decode.c\n+                src/http/ngx_http_huff_encode.c\"\nDiff:\n@@ -10,15 +10,17 @@\n \n \n typedef struct {\n-    ngx_flag_t  pcre_jit;\n+    ngx_flag_t   pcre_jit;\n+    ngx_list_t  *studies;\n } ngx_regex_conf_t;\n \n \n+static ngx_inline void ngx_regex_malloc_init(ngx_pool_t *pool);\n+static ngx_inline void ngx_regex_malloc_done(void);\n+\n static void * ngx_libc_cdecl ngx_regex_malloc(size_t size);\n static void ngx_libc_cdecl ngx_regex_free(void *p);\n-#if (NGX_HAVE_PCRE_JIT)\n-static void ngx_pcre_free_studies(void *data);\n-#endif\n+static void ngx_regex_cleanup(void *data);\n \n static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle);\n \n@@ -65,8 +67,8 @@ ngx_module_t  ngx_regex_module = {\n };\n \n \n-static ngx_pool_t  *ngx_pcre_pool;\n-static ngx_list_t  *ngx_pcre_studies;\n+static ngx_pool_t  *ngx_regex_pool;\n+static ngx_list_t  *ngx_regex_studies;\n \n \n void\n@@ -80,14 +82,14 @@ ngx_regex_init(void)\n static ngx_inline void\n ngx_regex_malloc_init(ngx_pool_t *pool)\n {\n-    ngx_pcre_pool = pool;\n+    ngx_regex_pool = pool;\n }\n \n \n static ngx_inline void\n ngx_regex_malloc_done(void)\n {\n-    ngx_pcre_pool = NULL;\n+    ngx_regex_pool = NULL;\n }\n \n \n@@ -113,13 +115,13 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                               \"pcre_compile() failed: %s in \\\"%V\\\"\",\n                                errstr, &rc->pattern)\n-                      - rc->err.data;\n+                         - rc->err.data;\n \n         } else {\n            rc->err.len = ngx_snprintf(rc->err.data, rc->err.len,\n                               \"pcre_compile() failed: %s in \\\"%V\\\" at \\\"%s\\\"\",\n                                errstr, &rc->pattern, rc->pattern.data + erroff)\n-                      - rc->err.data;\n+                         - rc->err.data;\n         }\n \n         return NGX_ERROR;\n@@ -134,8 +136,8 @@ ngx_regex_compile(ngx_regex_compile_t *rc)\n \n     /* do not study at runtime */\n \n-    if (ngx_pcre_studies != NULL) {\n-        elt = ngx_list_push(ngx_pcre_studies);\n+    if (ngx_regex_studies != NULL) {\n+        elt = ngx_list_push(ngx_regex_studies);\n         if (elt == NULL) {\n             goto nomem;\n         }\n@@ -230,11 +232,8 @@ ngx_regex_exec_array(ngx_array_t *a, ngx_str_t *s, ngx_log_t *log)\n static void * ngx_libc_cdecl\n ngx_regex_malloc(size_t size)\n {\n-    ngx_pool_t      *pool;\n-    pool = ngx_pcre_pool;\n-\n-    if (pool) {\n-        return ngx_palloc(pool, size);\n+    if (ngx_regex_pool) {\n+        return ngx_palloc(ngx_regex_pool, size);\n     }\n \n     return NULL;\n@@ -248,18 +247,17 @@ ngx_regex_free(void *p)\n }\n \n \n-#if (NGX_HAVE_PCRE_JIT)\n-\n static void\n-ngx_pcre_free_studies(void *data)\n+ngx_regex_cleanup(void *data)\n {\n-    ngx_list_t *studies = data;\n+#if (NGX_HAVE_PCRE_JIT)\n+    ngx_regex_conf_t *rcf = data;\n \n     ngx_uint_t        i;\n     ngx_list_part_t  *part;\n     ngx_regex_elt_t  *elts;\n \n-    part = &studies->part;\n+    part = &rcf->studies->part;\n     elts = part->elts;\n \n     for (i = 0; /* void */ ; i++) {\n@@ -274,56 +272,50 @@ ngx_pcre_free_studies(void *data)\n             i = 0;\n         }\n \n+        /*\n+         * The PCRE JIT compiler uses mmap for its executable codes, so we\n+         * have to explicitly call the pcre_free_study() function to free\n+         * this memory.\n+         */\n+\n         if (elts[i].regex->extra != NULL) {\n             pcre_free_study(elts[i].regex->extra);\n         }\n     }\n-}\n-\n #endif\n \n+    /*\n+     * On configuration parsing errors ngx_regex_module_init() will not\n+     * be called.  Make sure ngx_regex_studies is properly cleared anyway.\n+     */\n+\n+    ngx_regex_studies = NULL;\n+}\n+\n \n static ngx_int_t\n ngx_regex_module_init(ngx_cycle_t *cycle)\n {\n-    int               opt;\n-    const char       *errstr;\n-    ngx_uint_t        i;\n-    ngx_list_part_t  *part;\n-    ngx_regex_elt_t  *elts;\n+    int                opt;\n+    const char        *errstr;\n+    ngx_uint_t         i;\n+    ngx_list_part_t   *part;\n+    ngx_regex_elt_t   *elts;\n+    ngx_regex_conf_t  *rcf;\n \n     opt = 0;\n \n-#if (NGX_HAVE_PCRE_JIT)\n-    {\n-    ngx_regex_conf_t    *rcf;\n-    ngx_pool_cleanup_t  *cln;\n-\n     rcf = (ngx_regex_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_regex_module);\n \n+#if (NGX_HAVE_PCRE_JIT)\n     if (rcf->pcre_jit) {\n         opt = PCRE_STUDY_JIT_COMPILE;\n-\n-        /*\n-         * The PCRE JIT compiler uses mmap for its executable codes, so we\n-         * have to explicitly call the pcre_free_study() function to free\n-         * this memory.\n-         */\n-\n-        cln = ngx_pool_cleanup_add(cycle->pool, 0);\n-        if (cln == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        cln->handler = ngx_pcre_free_studies;\n-        cln->data = ngx_pcre_studies;\n-    }\n     }\n #endif\n \n     ngx_regex_malloc_init(cycle->pool);\n \n-    part = &ngx_pcre_studies->part;\n+    part = &rcf->studies->part;\n     elts = part->elts;\n \n     for (i = 0; /* void */ ; i++) {\n@@ -365,7 +357,7 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n \n     ngx_regex_malloc_done();\n \n-    ngx_pcre_studies = NULL;\n+    ngx_regex_studies = NULL;\n \n     return NGX_OK;\n }\n@@ -374,7 +366,8 @@ ngx_regex_module_init(ngx_cycle_t *cycle)\n static void *\n ngx_regex_create_conf(ngx_cycle_t *cycle)\n {\n-    ngx_regex_conf_t  *rcf;\n+    ngx_regex_conf_t    *rcf;\n+    ngx_pool_cleanup_t  *cln;\n \n     rcf = ngx_pcalloc(cycle->pool, sizeof(ngx_regex_conf_t));\n     if (rcf == NULL) {\n@@ -383,11 +376,21 @@ ngx_regex_create_conf(ngx_cycle_t *cycle)\n \n     rcf->pcre_jit = NGX_CONF_UNSET;\n \n-    ngx_pcre_studies = ngx_list_create(cycle->pool, 8, sizeof(ngx_regex_elt_t));\n-    if (ngx_pcre_studies == NULL) {\n+    cln = ngx_pool_cleanup_add(cycle->pool, 0);\n+    if (cln == NULL) {\n+        return NULL;\n+    }\n+\n+    cln->handler = ngx_regex_cleanup;\n+    cln->data = rcf;\n+\n+    rcf->studies = ngx_list_create(cycle->pool, 8, sizeof(ngx_regex_elt_t));\n+    if (rcf->studies == NULL) {\n         return NULL;\n     }\n \n+    ngx_regex_studies = rcf->studies;\n+\n     return rcf;\n }\n \nDiff:\n@@ -3180,10 +3180,10 @@ ngx_http_grpc_parse_fragment(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n             ctx->field_rest -= size;\n \n             if (ctx->field_huffman) {\n-                if (ngx_http_v2_huff_decode(&ctx->field_state, p, size,\n-                                            &ctx->field_end,\n-                                            ctx->field_rest == 0,\n-                                            r->connection->log)\n+                if (ngx_http_huff_decode(&ctx->field_state, p, size,\n+                                         &ctx->field_end,\n+                                         ctx->field_rest == 0,\n+                                         r->connection->log)\n                     != NGX_OK)\n                 {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n@@ -3289,10 +3289,10 @@ ngx_http_grpc_parse_fragment(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n             ctx->field_rest -= size;\n \n             if (ctx->field_huffman) {\n-                if (ngx_http_v2_huff_decode(&ctx->field_state, p, size,\n-                                            &ctx->field_end,\n-                                            ctx->field_rest == 0,\n-                                            r->connection->log)\n+                if (ngx_http_huff_decode(&ctx->field_state, p, size,\n+                                         &ctx->field_end,\n+                                         ctx->field_rest == 0,\n+                                         r->connection->log)\n                     != NGX_OK)\n                 {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\nDiff:\n@@ -167,6 +167,14 @@ ngx_uint_t  ngx_http_degraded(ngx_http_request_t *);\n #endif\n \n \n+#if (NGX_HTTP_V2)\n+ngx_int_t ngx_http_huff_decode(u_char *state, u_char *src, size_t len,\n+    u_char **dst, ngx_uint_t last, ngx_log_t *log);\n+size_t ngx_http_huff_encode(u_char *src, size_t len, u_char *dst,\n+    ngx_uint_t lower);\n+#endif\n+\n+\n extern ngx_module_t  ngx_http_module;\n \n extern ngx_str_t  ngx_http_html_default_types[];\nDiff:\n@@ -15,14 +15,14 @@ typedef struct {\n     u_char  emit;\n     u_char  sym;\n     u_char  ending;\n-} ngx_http_v2_huff_decode_code_t;\n+} ngx_http_huff_decode_code_t;\n \n \n-static ngx_inline ngx_int_t ngx_http_v2_huff_decode_bits(u_char *state,\n+static ngx_inline ngx_int_t ngx_http_huff_decode_bits(u_char *state,\n     u_char *ending, ngx_uint_t bits, u_char **dst);\n \n \n-static ngx_http_v2_huff_decode_code_t  ngx_http_v2_huff_decode_codes[256][16] =\n+static ngx_http_huff_decode_code_t  ngx_http_huff_decode_codes[256][16] =\n {\n     /* 0 */\n     {\n@@ -2640,7 +2640,7 @@ static ngx_http_v2_huff_decode_code_t  ngx_http_v2_huff_decode_codes[256][16] =\n \n \n ngx_int_t\n-ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n+ngx_http_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n     ngx_uint_t last, ngx_log_t *log)\n {\n     u_char  *end, ch, ending;\n@@ -2653,7 +2653,7 @@ ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n     while (src != end) {\n         ch = *src++;\n \n-        if (ngx_http_v2_huff_decode_bits(state, &ending, ch >> 4, dst)\n+        if (ngx_http_huff_decode_bits(state, &ending, ch >> 4, dst)\n             != NGX_OK)\n         {\n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,\n@@ -2663,7 +2663,7 @@ ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n             return NGX_ERROR;\n         }\n \n-        if (ngx_http_v2_huff_decode_bits(state, &ending, ch & 0xf, dst)\n+        if (ngx_http_huff_decode_bits(state, &ending, ch & 0xf, dst)\n             != NGX_OK)\n         {\n             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, log, 0,\n@@ -2692,12 +2692,12 @@ ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len, u_char **dst,\n \n \n static ngx_inline ngx_int_t\n-ngx_http_v2_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,\n+ngx_http_huff_decode_bits(u_char *state, u_char *ending, ngx_uint_t bits,\n     u_char **dst)\n {\n-    ngx_http_v2_huff_decode_code_t  code;\n+    ngx_http_huff_decode_code_t  code;\n \n-    code = ngx_http_v2_huff_decode_codes[*state][bits];\n+    code = ngx_http_huff_decode_codes[*state][bits];\n \n     if (code.next == *state) {\n         return NGX_ERROR;\nDiff:\n@@ -14,10 +14,10 @@\n typedef struct {\n     uint32_t  code;\n     uint32_t  len;\n-} ngx_http_v2_huff_encode_code_t;\n+} ngx_http_huff_encode_code_t;\n \n \n-static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table[256] =\n+static ngx_http_huff_encode_code_t  ngx_http_huff_encode_table[256] =\n {\n     {0x00001ff8, 13}, {0x007fffd8, 23}, {0x0fffffe2, 28}, {0x0fffffe3, 28},\n     {0x0fffffe4, 28}, {0x0fffffe5, 28}, {0x0fffffe6, 28}, {0x0fffffe7, 28},\n@@ -87,7 +87,7 @@ static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table[256] =\n \n \n /* same as above, but embeds lowercase transformation */\n-static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table_lc[256] =\n+static ngx_http_huff_encode_code_t  ngx_http_huff_encode_table_lc[256] =\n {\n     {0x00001ff8, 13}, {0x007fffd8, 23}, {0x0fffffe2, 28}, {0x0fffffe3, 28},\n     {0x0fffffe4, 28}, {0x0fffffe5, 28}, {0x0fffffe6, 28}, {0x0fffffe7, 28},\n@@ -161,10 +161,10 @@ static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table_lc[256] =\n #if (NGX_HAVE_LITTLE_ENDIAN)\n \n #if (NGX_HAVE_GCC_BSWAP64)\n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     (*(uint64_t *) (dst) = __builtin_bswap64(buf))\n #else\n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     ((dst)[0] = (u_char) ((buf) >> 56),                                       \\\n      (dst)[1] = (u_char) ((buf) >> 48),                                       \\\n      (dst)[2] = (u_char) ((buf) >> 40),                                       \\\n@@ -176,28 +176,28 @@ static ngx_http_v2_huff_encode_code_t  ngx_http_v2_huff_encode_table_lc[256] =\n #endif\n \n #else /* !NGX_HAVE_LITTLE_ENDIAN */\n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     (*(uint64_t *) (dst) = (buf))\n #endif\n \n #else /* NGX_PTR_SIZE == 4 */\n \n-#define ngx_http_v2_huff_encode_buf(dst, buf)                                 \\\n+#define ngx_http_huff_encode_buf(dst, buf)                                    \\\n     (*(uint32_t *) (dst) = htonl(buf))\n \n #endif\n \n \n size_t\n-ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)\n+ngx_http_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)\n {\n-    u_char                          *end;\n-    size_t                           hlen;\n-    ngx_uint_t                       buf, pending, code;\n-    ngx_http_v2_huff_encode_code_t  *table, *next;\n+    u_char                       *end;\n+    size_t                        hlen;\n+    ngx_uint_t                    buf, pending, code;\n+    ngx_http_huff_encode_code_t  *table, *next;\n \n-    table = lower ? ngx_http_v2_huff_encode_table_lc\n-                  : ngx_http_v2_huff_encode_table;\n+    table = lower ? ngx_http_huff_encode_table_lc\n+                  : ngx_http_huff_encode_table;\n     hlen = 0;\n     buf = 0;\n     pending = 0;\n@@ -224,7 +224,7 @@ ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst, ngx_uint_t lower)\n \n         buf |= code >> pending;\n \n-        ngx_http_v2_huff_encode_buf(&dst[hlen], buf);\n+        ngx_http_huff_encode_buf(&dst[hlen], buf);\n \n         hlen += sizeof(buf);\n \nDiff:\n@@ -1600,10 +1600,10 @@ ngx_http_v2_state_field_huff(ngx_http_v2_connection_t *h2c, u_char *pos,\n     h2c->state.length -= size;\n     h2c->state.field_rest -= size;\n \n-    if (ngx_http_v2_huff_decode(&h2c->state.field_state, pos, size,\n-                                &h2c->state.field_end,\n-                                h2c->state.field_rest == 0,\n-                                h2c->connection->log)\n+    if (ngx_http_huff_decode(&h2c->state.field_state, pos, size,\n+                             &h2c->state.field_end,\n+                             h2c->state.field_rest == 0,\n+                             h2c->connection->log)\n         != NGX_OK)\n     {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\nDiff:\n@@ -311,12 +311,6 @@ ngx_int_t ngx_http_v2_add_header(ngx_http_v2_connection_t *h2c,\n ngx_int_t ngx_http_v2_table_size(ngx_http_v2_connection_t *h2c, size_t size);\n \n \n-ngx_int_t ngx_http_v2_huff_decode(u_char *state, u_char *src, size_t len,\n-    u_char **dst, ngx_uint_t last, ngx_log_t *log);\n-size_t ngx_http_v2_huff_encode(u_char *src, size_t len, u_char *dst,\n-    ngx_uint_t lower);\n-\n-\n #define ngx_http_v2_prefix(bits)  ((1 << (bits)) - 1)\n \n \nDiff:\n@@ -20,7 +20,7 @@ ngx_http_v2_string_encode(u_char *dst, u_char *src, size_t len, u_char *tmp,\n {\n     size_t  hlen;\n \n-    hlen = ngx_http_v2_huff_encode(src, len, tmp, lower);\n+    hlen = ngx_http_huff_encode(src, len, tmp, lower);\n \n     if (hlen > 0) {\n         *dst = NGX_HTTP_V2_ENCODE_HUFF;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 134",
        "commit_diff": "Diff:\n@@ -152,6 +152,7 @@ syn keyword ngxDirective contained auth_jwt_header_set\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n+syn keyword ngxDirective contained auth_jwt_require\n syn keyword ngxDirective contained auth_jwt_type\n syn keyword ngxDirective contained auth_request\n syn keyword ngxDirective contained auth_request_set\n@@ -335,6 +336,10 @@ syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n+syn keyword ngxDirective contained js_fetch_ciphers\n+syn keyword ngxDirective contained js_fetch_protocols\n+syn keyword ngxDirective contained js_fetch_trusted_certificate\n+syn keyword ngxDirective contained js_fetch_verify_depth\n syn keyword ngxDirective contained js_filter\n syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n@@ -402,6 +407,7 @@ syn keyword ngxDirective contained mp4_buffer_size\n syn keyword ngxDirective contained mp4_limit_rate\n syn keyword ngxDirective contained mp4_limit_rate_after\n syn keyword ngxDirective contained mp4_max_buffer_size\n+syn keyword ngxDirective contained mp4_start_key_frame\n syn keyword ngxDirective contained msie_padding\n syn keyword ngxDirective contained msie_refresh\n syn keyword ngxDirective contained multi_accept\n@@ -458,6 +464,7 @@ syn keyword ngxDirective contained proxy_cookie_flags\n syn keyword ngxDirective contained proxy_cookie_path\n syn keyword ngxDirective contained proxy_download_rate\n syn keyword ngxDirective contained proxy_force_ranges\n+syn keyword ngxDirective contained proxy_half_close\n syn keyword ngxDirective contained proxy_headers_hash_bucket_size\n syn keyword ngxDirective contained proxy_headers_hash_max_size\n syn keyword ngxDirective contained proxy_hide_header\n@@ -597,6 +604,7 @@ syn keyword ngxDirective contained ssi_min_file_chunk\n syn keyword ngxDirective contained ssi_silent_errors\n syn keyword ngxDirective contained ssi_types\n syn keyword ngxDirective contained ssi_value_length\n+syn keyword ngxDirective contained ssl_alpn\n syn keyword ngxDirective contained ssl_buffer_size\n syn keyword ngxDirective contained ssl_certificate\n syn keyword ngxDirective contained ssl_certificate_key\n@@ -788,11 +796,15 @@ syn keyword ngxDirectiveThirdParty contained auth_digest_user_file\n syn keyword ngxDirectiveThirdParty contained auth_gss\n syn keyword ngxDirectiveThirdParty contained auth_gss_allow_basic_fallback\n syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n+syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal_regex\n+syn keyword ngxDirectiveThirdParty contained auth_gss_constrained_delegation\n+syn keyword ngxDirectiveThirdParty contained auth_gss_delegate_credentials\n syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n+syn keyword ngxDirectiveThirdParty contained auth_gss_service_ccache\n syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n \n \" LDAP Authentication\n@@ -969,7 +981,6 @@ syn keyword ngxDirectiveThirdParty contained fancyindex_hide_parent_dir\n syn keyword ngxDirectiveThirdParty contained fancyindex_hide_symlinks\n syn keyword ngxDirectiveThirdParty contained fancyindex_ignore\n syn keyword ngxDirectiveThirdParty contained fancyindex_localtime\n-syn keyword ngxDirectiveThirdParty contained fancyindex_name_length\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_dotfiles\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_path\n syn keyword ngxDirectiveThirdParty contained fancyindex_time_format\n@@ -1059,20 +1070,39 @@ syn keyword ngxDirectiveThirdParty contained nchan_publisher_upstream_request\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_pubsub_location\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_cluster_check_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_discovered_ip_range_blacklist\n syn keyword ngxDirectiveThirdParty contained nchan_redis_fakesub_timer_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_idle_channel_cache_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_redis_namespace\n syn keyword ngxDirectiveThirdParty contained nchan_redis_nostore_fastpublish\n syn keyword ngxDirectiveThirdParty contained nchan_redis_optimize_target\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass\n syn keyword ngxDirectiveThirdParty contained nchan_redis_pass_inheritable\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_password\n syn keyword ngxDirectiveThirdParty contained nchan_redis_ping_interval\n syn keyword ngxDirectiveThirdParty contained nchan_redis_publish_msgpacked_max_size\n syn keyword ngxDirectiveThirdParty contained nchan_redis_server\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_ciphers\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_client_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_client_certificate_key\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_server_name\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_trusted_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_trusted_certificate_path\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_ssl_verify_certificate\n syn keyword ngxDirectiveThirdParty contained nchan_redis_storage_mode\n syn keyword ngxDirectiveThirdParty contained nchan_redis_subscribe_weights\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_ciphers\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_client_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_server_name\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_trusted_certificate\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_trusted_certificate_path\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_tls_verify_certificate\n syn keyword ngxDirectiveThirdParty contained nchan_redis_url\n+syn keyword ngxDirectiveThirdParty contained nchan_redis_username\n syn keyword ngxDirectiveThirdParty contained nchan_redis_wait_after_connecting\n syn keyword ngxDirectiveThirdParty contained nchan_shared_memory_size\n syn keyword ngxDirectiveThirdParty contained nchan_storage_engine\n@@ -1385,13 +1415,15 @@ syn keyword ngxDirectiveThirdParty contained lua_socket_read_timeout\n syn keyword ngxDirectiveThirdParty contained lua_socket_send_lowat\n syn keyword ngxDirectiveThirdParty contained lua_socket_send_timeout\n syn keyword ngxDirectiveThirdParty contained lua_ssl_ciphers\n+syn keyword ngxDirectiveThirdParty contained lua_ssl_conf_command\n syn keyword ngxDirectiveThirdParty contained lua_ssl_crl\n syn keyword ngxDirectiveThirdParty contained lua_ssl_protocols\n syn keyword ngxDirectiveThirdParty contained lua_ssl_trusted_certificate\n syn keyword ngxDirectiveThirdParty contained lua_ssl_verify_depth\n syn keyword ngxDirectiveThirdParty contained lua_thread_cache_max_entries\n syn keyword ngxDirectiveThirdParty contained lua_transform_underscores_in_response_headers\n syn keyword ngxDirectiveThirdParty contained lua_use_default_type\n+syn keyword ngxDirectiveThirdParty contained lua_worker_thread_vm_pool_size\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_block\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua_file\n@@ -1401,6 +1433,8 @@ syn keyword ngxDirectiveThirdParty contained set_by_lua_block\n syn keyword ngxDirectiveThirdParty contained set_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_certificate_by_lua_block\n syn keyword ngxDirectiveThirdParty contained ssl_certificate_by_lua_file\n+syn keyword ngxDirectiveThirdParty contained ssl_client_hello_by_lua_block\n+syn keyword ngxDirectiveThirdParty contained ssl_client_hello_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_session_fetch_by_lua_block\n syn keyword ngxDirectiveThirdParty contained ssl_session_fetch_by_lua_file\n syn keyword ngxDirectiveThirdParty contained ssl_session_store_by_lua_block\n@@ -1719,15 +1753,18 @@ syn keyword ngxDirectiveThirdParty contained set_base32_alphabet\n syn keyword ngxDirectiveThirdParty contained set_base32_padding\n syn keyword ngxDirectiveThirdParty contained set_decode_base32\n syn keyword ngxDirectiveThirdParty contained set_decode_base64\n+syn keyword ngxDirectiveThirdParty contained set_decode_base64url\n syn keyword ngxDirectiveThirdParty contained set_decode_hex\n syn keyword ngxDirectiveThirdParty contained set_encode_base32\n syn keyword ngxDirectiveThirdParty contained set_encode_base64\n+syn keyword ngxDirectiveThirdParty contained set_encode_base64url\n syn keyword ngxDirectiveThirdParty contained set_encode_hex\n syn keyword ngxDirectiveThirdParty contained set_escape_uri\n syn keyword ngxDirectiveThirdParty contained set_formatted_gmt_time\n syn keyword ngxDirectiveThirdParty contained set_formatted_local_time\n syn keyword ngxDirectiveThirdParty contained set_hashed_upstream\n syn keyword ngxDirectiveThirdParty contained set_hmac_sha1\n+syn keyword ngxDirectiveThirdParty contained set_hmac_sha256\n syn keyword ngxDirectiveThirdParty contained set_if_empty\n syn keyword ngxDirectiveThirdParty contained set_local_today\n syn keyword ngxDirectiveThirdParty contained set_misc_base32_padding\n@@ -1849,6 +1886,7 @@ syn keyword ngxDirectiveThirdParty contained vod_notification_uri\n syn keyword ngxDirectiveThirdParty contained vod_open_file_thread_pool\n syn keyword ngxDirectiveThirdParty contained vod_output_buffer_pool\n syn keyword ngxDirectiveThirdParty contained vod_parse_hdlr_name\n+syn keyword ngxDirectiveThirdParty contained vod_parse_udta_name\n syn keyword ngxDirectiveThirdParty contained vod_path_response_postfix\n syn keyword ngxDirectiveThirdParty contained vod_path_response_prefix\n syn keyword ngxDirectiveThirdParty contained vod_performance_counters\nDiff:\n@@ -253,16 +253,32 @@ static void\n ngx_http_copy_aio_sendfile_event_handler(ngx_event_t *ev)\n {\n     ngx_event_aio_t     *aio;\n+    ngx_connection_t    *c;\n     ngx_http_request_t  *r;\n \n     aio = ev->data;\n     r = aio->data;\n+    c = r->connection;\n \n     r->main->blocked--;\n     r->aio = 0;\n     ev->complete = 0;\n \n-    r->connection->write->handler(r->connection->write);\n+#if (NGX_HTTP_V2)\n+\n+    if (r->stream) {\n+        /*\n+         * for HTTP/2, update write event to make sure processing will\n+         * reach the main connection to handle sendfile() preload\n+         */\n+\n+        c->write->ready = 1;\n+        c->write->active = 0;\n+    }\n+\n+#endif\n+\n+    c->write->handler(c->write);\n }\n \n #endif\n@@ -357,6 +373,20 @@ ngx_http_copy_thread_event_handler(ngx_event_t *ev)\n     r->main->blocked--;\n     r->aio = 0;\n \n+#if (NGX_HTTP_V2)\n+\n+    if (r->stream) {\n+        /*\n+         * for HTTP/2, update write event to make sure processing will\n+         * reach the main connection to handle sendfile() in threads\n+         */\n+\n+        c->write->ready = 1;\n+        c->write->active = 0;\n+    }\n+\n+#endif\n+\n     if (r->done) {\n         /*\n          * trigger connection event handler if the subrequest was\nDiff:\n@@ -3927,6 +3927,20 @@ ngx_http_upstream_thread_event_handler(ngx_event_t *ev)\n     r->main->blocked--;\n     r->aio = 0;\n \n+#if (NGX_HTTP_V2)\n+\n+    if (r->stream) {\n+        /*\n+         * for HTTP/2, update write event to make sure processing will\n+         * reach the main connection to handle sendfile() in threads\n+         */\n+\n+        c->write->ready = 1;\n+        c->write->active = 0;\n+    }\n+\n+#endif\n+\n     if (r->done) {\n         /*\n          * trigger connection event handler if the subrequest was\nDiff:\n@@ -1432,6 +1432,9 @@ ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)\n     size = 0;\n #endif\n \n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 send chain: %p\", in);\n+\n     while (in) {\n         size = ngx_buf_size(in->buf);\n \n@@ -1450,12 +1453,8 @@ ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)\n             return NGX_CHAIN_ERROR;\n         }\n \n-        if (stream->queued) {\n-            fc->write->active = 1;\n-            fc->write->ready = 0;\n-\n-        } else {\n-            fc->buffered &= ~NGX_HTTP_V2_BUFFERED;\n+        if (ngx_http_v2_filter_send(fc, stream) == NGX_ERROR) {\n+            return NGX_CHAIN_ERROR;\n         }\n \n         return NULL;\n@@ -1464,9 +1463,16 @@ ngx_http_v2_send_chain(ngx_connection_t *fc, ngx_chain_t *in, off_t limit)\n     h2c = stream->connection;\n \n     if (size && ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n-        fc->write->active = 1;\n-        fc->write->ready = 0;\n-        return in;\n+\n+        if (ngx_http_v2_filter_send(fc, stream) == NGX_ERROR) {\n+            return NGX_CHAIN_ERROR;\n+        }\n+\n+        if (ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n+            fc->write->active = 1;\n+            fc->write->ready = 0;\n+            return in;\n+        }\n     }\n \n     if (in->buf->tag == (ngx_buf_tag_t) &ngx_http_v2_filter_get_shadow) {\n@@ -1809,6 +1815,11 @@ ngx_http_v2_waiting_queue(ngx_http_v2_connection_t *h2c,\n static ngx_inline ngx_int_t\n ngx_http_v2_filter_send(ngx_connection_t *fc, ngx_http_v2_stream_t *stream)\n {\n+    if (stream->queued == 0) {\n+        fc->buffered &= ~NGX_HTTP_V2_BUFFERED;\n+        return NGX_OK;\n+    }\n+\n     stream->blocked = 1;\n \n     if (ngx_http_v2_send_output_queue(stream->connection) == NGX_ERROR) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 133",
        "commit_diff": "Diff:\n@@ -219,13 +219,25 @@ ngx_http_copy_aio_sendfile_preload(ngx_buf_t *file)\n     ngx_http_request_t      *r;\n     ngx_output_chain_ctx_t  *ctx;\n \n+    aio = file->file->aio;\n+    r = aio->data;\n+\n+    if (r->aio) {\n+        /*\n+         * tolerate sendfile() calls if another operation is already\n+         * running; this can happen due to subrequests, multiple calls\n+         * of the next body filter from a filter, or in HTTP/2 due to\n+         * a write event on the main connection\n+         */\n+\n+        return NGX_AGAIN;\n+    }\n+\n     n = ngx_file_aio_read(file->file, buf, 1, file->file_pos, NULL);\n \n     if (n == NGX_AGAIN) {\n-        aio = file->file->aio;\n         aio->handler = ngx_http_copy_aio_sendfile_event_handler;\n \n-        r = aio->data;\n         r->main->blocked++;\n         r->aio = 1;\n \n@@ -263,13 +275,35 @@ static ngx_int_t\n ngx_http_copy_thread_handler(ngx_thread_task_t *task, ngx_file_t *file)\n {\n     ngx_str_t                  name;\n+    ngx_connection_t          *c;\n     ngx_thread_pool_t         *tp;\n     ngx_http_request_t        *r;\n     ngx_output_chain_ctx_t    *ctx;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r = file->thread_ctx;\n \n+    if (r->aio) {\n+        /*\n+         * tolerate sendfile() calls if another operation is already\n+         * running; this can happen due to subrequests, multiple calls\n+         * of the next body filter from a filter, or in HTTP/2 due to\n+         * a write event on the main connection\n+         */\n+\n+        c = r->connection;\n+\n+#if (NGX_HTTP_V2)\n+        if (r->stream) {\n+            c = r->stream->connection->connection;\n+        }\n+#endif\n+\n+        if (task == c->sendfile_task) {\n+            return NGX_OK;\n+        }\n+    }\n+\n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n     tp = clcf->thread_pool;\n \nDiff:\n@@ -3847,13 +3847,35 @@ ngx_http_upstream_thread_handler(ngx_thread_task_t *task, ngx_file_t *file)\n {\n     ngx_str_t                  name;\n     ngx_event_pipe_t          *p;\n+    ngx_connection_t          *c;\n     ngx_thread_pool_t         *tp;\n     ngx_http_request_t        *r;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r = file->thread_ctx;\n     p = r->upstream->pipe;\n \n+    if (r->aio) {\n+        /*\n+         * tolerate sendfile() calls if another operation is already\n+         * running; this can happen due to subrequests, multiple calls\n+         * of the next body filter from a filter, or in HTTP/2 due to\n+         * a write event on the main connection\n+         */\n+\n+        c = r->connection;\n+\n+#if (NGX_HTTP_V2)\n+        if (r->stream) {\n+            c = r->stream->connection->connection;\n+        }\n+#endif\n+\n+        if (task == c->sendfile_task) {\n+            return NGX_OK;\n+        }\n+    }\n+\n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n     tp = clcf->thread_pool;\n \nDiff:\n@@ -255,19 +255,6 @@ ngx_freebsd_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n #if (NGX_HAVE_AIO_SENDFILE)\n \n         if (ebusy) {\n-            if (aio->event.active) {\n-                /*\n-                 * tolerate duplicate calls; they can happen due to subrequests\n-                 * or multiple calls of the next body filter from a filter\n-                 */\n-\n-                if (sent) {\n-                    c->busy_count = 0;\n-                }\n-\n-                return in;\n-            }\n-\n             if (sent == 0) {\n                 c->busy_count++;\n \nDiff:\n@@ -426,15 +426,6 @@ ngx_linux_sendfile_thread(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n         return ctx->sent;\n     }\n \n-    if (task->event.active && ctx->file == file) {\n-        /*\n-         * tolerate duplicate calls; they can happen due to subrequests\n-         * or multiple calls of the next body filter from a filter\n-         */\n-\n-        return NGX_DONE;\n-    }\n-\n     ctx->file = file;\n     ctx->socket = c->fd;\n     ctx->size = size;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 132",
        "commit_diff": "Diff:\n@@ -4733,6 +4733,42 @@ ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n }\n \n \n+ngx_int_t\n+ngx_ssl_get_curve(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n+{\n+#ifdef SSL_get_negotiated_group\n+\n+    int  nid;\n+\n+    nid = SSL_get_negotiated_group(c->ssl->connection);\n+\n+    if (nid != NID_undef) {\n+\n+        if ((nid & TLSEXT_nid_unknown) == 0) {\n+            s->len = ngx_strlen(OBJ_nid2sn(nid));\n+            s->data = (u_char *) OBJ_nid2sn(nid);\n+            return NGX_OK;\n+        }\n+\n+        s->len = sizeof(\"0x0000\") - 1;\n+\n+        s->data = ngx_pnalloc(pool, s->len);\n+        if (s->data == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_sprintf(s->data, \"0x%04xd\", nid & 0xffff);\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    s->len = 0;\n+    return NGX_OK;\n+}\n+\n+\n ngx_int_t\n ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n {\nDiff:\n@@ -256,6 +256,8 @@ ngx_int_t ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n+ngx_int_t ngx_ssl_get_curve(ngx_connection_t *c, ngx_pool_t *pool,\n+    ngx_str_t *s);\n ngx_int_t ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool,\nDiff:\n@@ -342,6 +342,9 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {\n     { ngx_string(\"ssl_ciphers\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_ciphers, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_curve\"), NULL, ngx_http_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_curve, NGX_HTTP_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_curves\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_curves, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \nDiff:\n@@ -269,6 +269,9 @@ static ngx_stream_variable_t  ngx_stream_ssl_vars[] = {\n     { ngx_string(\"ssl_ciphers\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_ciphers, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_curve\"), NULL, ngx_stream_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_curve, NGX_STREAM_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_curves\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_curves, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n",
        "analysis": "The diff shows a newly added function `ngx_ssl_get_curve`. Let's analyze it line by line to check for any possibility of out-of-bounds write:\n\n```c\nngx_int_t\nngx_ssl_get_curve(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n{\n#ifdef SSL_get_negotiated_group\n\n    int  nid;\n\n    nid = SSL_get_negotiated_group(c->ssl->connection);\n\n    if (nid != NID_undef) {\n\n        if ((nid & TLSEXT_nid_unknown) == 0) {\n            s->len = ngx_strlen(OBJ_nid2sn(nid));\n            s->data = (u_char *) OBJ_nid2sn(nid);\n            return NGX_OK;\n        }\n\n        s->len = sizeof(\"0x0000\") - 1;\n\n        s->data = ngx_pnalloc(pool, s->len);\n        if (s->data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_sprintf(s->data, \"0x%04xd\", nid & 0xffff);\n\n        return NGX_OK;\n    }\n\n#endif\n\n    s->len = 0;\n    return NGX_OK;\n}\n```\n\n1. The function uses `SSL_get_negotiated_group` to obtain a negotiated group identifier (nid).\n2. It checks if the `nid` is not undefined (NID_undef).\n3. If the nid is known and not unknown, it assigns the length of the string name associated with the nid to `s->len` and copies the string representation of the nid to `s->data`.\n4. Otherwise, it sets `s->len` to the length of the string `\"0x0000\"`.\n5. It then allocates memory for `s->data` using `ngx_pnalloc`, which safely allocates memory with a fixed size, therefore reducing risks of out-of-bounds issues here.\n6. After allocation, it checks if the allocation was successful.\n7. Finally, it formats the nid into the allocated data buffer using `ngx_sprintf`.\n\nConsidering the function uses safe allocation with `ngx_pnalloc` and checks allocation success, it does not present any immediate indication of an out-of-bounds write. \n\nBased on the analysis above, there seems to be no function with an out-of-bounds write potential. \n\nFinal output: \n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 131",
        "commit_diff": "Diff:\n@@ -464,3 +464,4 @@ df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n 2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\n+39be8a682c58308d9399cddd57e37f9fdb7bdf3e release-1.21.4\nDiff:\n@@ -5,6 +5,137 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.4\" date=\"2021-11-02\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+поддержка NPN вместо ALPN для установления HTTP/2-соединений\n+упразднена.\n+</para>\n+<para lang=\"en\">\n+support for NPN instead of ALPN to establish HTTP/2 connections\n+has been removed.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx закрывает SSL соединение, если клиент использует ALPN,\n+но nginx не поддерживает ни один из присланных клиентом протоколов.\n+</para>\n+<para lang=\"en\">\n+now nginx rejects SSL connections if ALPN is used by the client,\n+but no supported protocols can be negotiated.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+в директиве sendfile_max_chunk значение по умолчанию\n+изменено на 2 мегабайта.\n+</para>\n+<para lang=\"en\">\n+the default value of the \"sendfile_max_chunk\" directive\n+was changed to 2 megabytes.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива proxy_half_close в модуле stream.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_half_close\" directive in the stream module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива ssl_alpn в модуле stream.\n+</para>\n+<para lang=\"en\">\n+the \"ssl_alpn\" directive in the stream module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $ssl_alpn_protocol.\n+</para>\n+<para lang=\"en\">\n+the $ssl_alpn_protocol variable.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+поддержка SSL_sendfile() при использовании OpenSSL 3.0.\n+</para>\n+<para lang=\"en\">\n+support for SSL_sendfile() when using OpenSSL 3.0.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива mp4_start_key_frame в модуле ngx_http_mp4_module.<br/>\n+Спасибо Tracey Jaquith.\n+</para>\n+<para lang=\"en\">\n+the \"mp4_start_key_frame\" directive in the ngx_http_mp4_module.<br/>\n+Thanks to Tracey Jaquith.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в переменной $content_length при использовании chunked transfer encoding.\n+</para>\n+<para lang=\"en\">\n+in the $content_length variable when using chunked transfer encoding.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при получении ответа некорректной длины от проксируемого бэкенда\n+nginx мог тем не менее закэшировать соединение.<br/>\n+Спасибо Awdhesh Mathpal.\n+</para>\n+<para lang=\"en\">\n+after receiving a response with incorrect length from a proxied backend\n+nginx might nevertheless cache the connection.<br/>\n+Thanks to Awdhesh Mathpal.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+некорректные заголовки от бэкендов\n+логгировались на уровне info вместо error;\n+ошибка появилась в 1.21.1.\n+</para>\n+<para lang=\"en\">\n+invalid headers from backends\n+were logged at the \"info\" level instead of \"error\";\n+the bug had appeared in 1.21.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2 и директивы aio_write\n+запросы могли зависать.\n+</para>\n+<para lang=\"en\">\n+requests might hang\n+when using HTTP/2 and the \"aio_write\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.3\" date=\"2021-09-07\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021004\n-#define NGINX_VERSION      \"1.21.4\"\n+#define nginx_version      1021005\n+#define NGINX_VERSION      \"1.21.5\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 130",
        "commit_diff": "Diff:\n@@ -203,16 +203,16 @@ ngx_chain_update_chains(ngx_pool_t *p, ngx_chain_t **free, ngx_chain_t **busy,\n     while (*busy) {\n         cl = *busy;\n \n-        if (ngx_buf_size(cl->buf) != 0) {\n-            break;\n-        }\n-\n         if (cl->buf->tag != tag) {\n             *busy = cl->next;\n             ngx_free_chain(p, cl);\n             continue;\n         }\n \n+        if (ngx_buf_size(cl->buf) != 0) {\n+            break;\n+        }\n+\n         cl->buf->pos = cl->buf->start;\n         cl->buf->last = cl->buf->start;\n \nDiff:\n@@ -804,6 +804,10 @@ ngx_chain_writer(void *data, ngx_chain_t *in)\n         return NGX_ERROR;\n     }\n \n+    if (chain && c->write->ready) {\n+        ngx_post_event(c->write, &ngx_posted_next_events);\n+    }\n+\n     for (cl = ctx->out; cl && cl != chain; /* void */) {\n         ln = cl;\n         cl = cl->next;\nDiff:\n@@ -3720,7 +3720,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->internal, prev->internal, 0);\n     ngx_conf_merge_value(conf->sendfile, prev->sendfile, 0);\n     ngx_conf_merge_size_value(conf->sendfile_max_chunk,\n-                              prev->sendfile_max_chunk, 0);\n+                              prev->sendfile_max_chunk, 2 * 1024 * 1024);\n     ngx_conf_merge_size_value(conf->subrequest_output_buffer_size,\n                               prev->subrequest_output_buffer_size,\n                               (size_t) ngx_pagesize);\nDiff:\n@@ -1511,8 +1511,9 @@ ngx_http_upstream_check_broken_connection(ngx_http_request_t *r,\n static void\n ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)\n {\n-    ngx_int_t          rc;\n-    ngx_connection_t  *c;\n+    ngx_int_t                  rc;\n+    ngx_connection_t          *c;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     r->connection->log->action = \"connecting to upstream\";\n \n@@ -1599,10 +1600,12 @@ ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)\n \n     /* init or reinit the ngx_output_chain() and ngx_chain_writer() contexts */\n \n+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+\n     u->writer.out = NULL;\n     u->writer.last = &u->writer.out;\n     u->writer.connection = c;\n-    u->writer.limit = 0;\n+    u->writer.limit = clcf->sendfile_max_chunk;\n \n     if (u->request_sent) {\n         if (ngx_http_upstream_reinit(r, u) != NGX_OK) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 129",
        "commit_diff": "Diff:\n@@ -11,38 +11,41 @@\n \n #define NGX_HTTP_MP4_TRAK_ATOM     0\n #define NGX_HTTP_MP4_TKHD_ATOM     1\n-#define NGX_HTTP_MP4_MDIA_ATOM     2\n-#define NGX_HTTP_MP4_MDHD_ATOM     3\n-#define NGX_HTTP_MP4_HDLR_ATOM     4\n-#define NGX_HTTP_MP4_MINF_ATOM     5\n-#define NGX_HTTP_MP4_VMHD_ATOM     6\n-#define NGX_HTTP_MP4_SMHD_ATOM     7\n-#define NGX_HTTP_MP4_DINF_ATOM     8\n-#define NGX_HTTP_MP4_STBL_ATOM     9\n-#define NGX_HTTP_MP4_STSD_ATOM    10\n-#define NGX_HTTP_MP4_STTS_ATOM    11\n-#define NGX_HTTP_MP4_STTS_DATA    12\n-#define NGX_HTTP_MP4_STSS_ATOM    13\n-#define NGX_HTTP_MP4_STSS_DATA    14\n-#define NGX_HTTP_MP4_CTTS_ATOM    15\n-#define NGX_HTTP_MP4_CTTS_DATA    16\n-#define NGX_HTTP_MP4_STSC_ATOM    17\n-#define NGX_HTTP_MP4_STSC_START   18\n-#define NGX_HTTP_MP4_STSC_DATA    19\n-#define NGX_HTTP_MP4_STSC_END     20\n-#define NGX_HTTP_MP4_STSZ_ATOM    21\n-#define NGX_HTTP_MP4_STSZ_DATA    22\n-#define NGX_HTTP_MP4_STCO_ATOM    23\n-#define NGX_HTTP_MP4_STCO_DATA    24\n-#define NGX_HTTP_MP4_CO64_ATOM    25\n-#define NGX_HTTP_MP4_CO64_DATA    26\n+#define NGX_HTTP_MP4_EDTS_ATOM     2\n+#define NGX_HTTP_MP4_ELST_ATOM     3\n+#define NGX_HTTP_MP4_MDIA_ATOM     4\n+#define NGX_HTTP_MP4_MDHD_ATOM     5\n+#define NGX_HTTP_MP4_HDLR_ATOM     6\n+#define NGX_HTTP_MP4_MINF_ATOM     7\n+#define NGX_HTTP_MP4_VMHD_ATOM     8\n+#define NGX_HTTP_MP4_SMHD_ATOM     9\n+#define NGX_HTTP_MP4_DINF_ATOM    10\n+#define NGX_HTTP_MP4_STBL_ATOM    11\n+#define NGX_HTTP_MP4_STSD_ATOM    12\n+#define NGX_HTTP_MP4_STTS_ATOM    13\n+#define NGX_HTTP_MP4_STTS_DATA    14\n+#define NGX_HTTP_MP4_STSS_ATOM    15\n+#define NGX_HTTP_MP4_STSS_DATA    16\n+#define NGX_HTTP_MP4_CTTS_ATOM    17\n+#define NGX_HTTP_MP4_CTTS_DATA    18\n+#define NGX_HTTP_MP4_STSC_ATOM    19\n+#define NGX_HTTP_MP4_STSC_START   20\n+#define NGX_HTTP_MP4_STSC_DATA    21\n+#define NGX_HTTP_MP4_STSC_END     22\n+#define NGX_HTTP_MP4_STSZ_ATOM    23\n+#define NGX_HTTP_MP4_STSZ_DATA    24\n+#define NGX_HTTP_MP4_STCO_ATOM    25\n+#define NGX_HTTP_MP4_STCO_DATA    26\n+#define NGX_HTTP_MP4_CO64_ATOM    27\n+#define NGX_HTTP_MP4_CO64_DATA    28\n \n #define NGX_HTTP_MP4_LAST_ATOM    NGX_HTTP_MP4_CO64_DATA\n \n \n typedef struct {\n     size_t                buffer_size;\n     size_t                max_buffer_size;\n+    ngx_flag_t            start_key_frame;\n } ngx_http_mp4_conf_t;\n \n \n@@ -53,6 +56,25 @@ typedef struct {\n } ngx_mp4_stsc_entry_t;\n \n \n+typedef struct {\n+    u_char                size[4];\n+    u_char                name[4];\n+} ngx_mp4_edts_atom_t;\n+\n+\n+typedef struct {\n+    u_char                size[4];\n+    u_char                name[4];\n+    u_char                version[1];\n+    u_char                flags[3];\n+    u_char                entries[4];\n+    u_char                duration[8];\n+    u_char                media_time[8];\n+    u_char                media_rate[2];\n+    u_char                reserved[2];\n+} ngx_mp4_elst_atom_t;\n+\n+\n typedef struct {\n     uint32_t              timescale;\n     uint32_t              time_to_sample_entries;\n@@ -71,6 +93,8 @@ typedef struct {\n     uint64_t              start_chunk_samples_size;\n     uint64_t              end_chunk_samples_size;\n     uint64_t              duration;\n+    uint64_t              prefix;\n+    uint64_t              movie_duration;\n     off_t                 start_offset;\n     off_t                 end_offset;\n \n@@ -86,6 +110,8 @@ typedef struct {\n \n     ngx_buf_t             trak_atom_buf;\n     ngx_buf_t             tkhd_atom_buf;\n+    ngx_buf_t             edts_atom_buf;\n+    ngx_buf_t             elst_atom_buf;\n     ngx_buf_t             mdia_atom_buf;\n     ngx_buf_t             mdhd_atom_buf;\n     ngx_buf_t             hdlr_atom_buf;\n@@ -112,6 +138,8 @@ typedef struct {\n     ngx_buf_t             co64_atom_buf;\n     ngx_buf_t             co64_data_buf;\n \n+    ngx_mp4_edts_atom_t   edts_atom;\n+    ngx_mp4_elst_atom_t   elst_atom;\n     ngx_mp4_stsc_entry_t  stsc_start_chunk_entry;\n     ngx_mp4_stsc_entry_t  stsc_end_chunk_entry;\n } ngx_http_mp4_trak_t;\n@@ -187,6 +215,14 @@ typedef struct {\n     ((u_char *) (p))[6] = n3;                                                 \\\n     ((u_char *) (p))[7] = n4\n \n+#define ngx_mp4_get_16value(p)                                                \\\n+    ( ((uint16_t) ((u_char *) (p))[0] << 8)                                   \\\n+    + (           ((u_char *) (p))[1]) )\n+\n+#define ngx_mp4_set_16value(p, n)                                             \\\n+    ((u_char *) (p))[0] = (u_char) ((n) >> 8);                                \\\n+    ((u_char *) (p))[1] = (u_char)  (n)\n+\n #define ngx_mp4_get_32value(p)                                                \\\n     ( ((uint32_t) ((u_char *) (p))[0] << 24)                                  \\\n     + (           ((u_char *) (p))[1] << 16)                                  \\\n@@ -270,6 +306,8 @@ static ngx_int_t ngx_http_mp4_read_smhd_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n static ngx_int_t ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n+static void ngx_http_mp4_update_edts_atom(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak);\n static void ngx_http_mp4_update_stbl_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_read_stsd_atom(ngx_http_mp4_file_t *mp4,\n@@ -280,6 +318,8 @@ static ngx_int_t ngx_http_mp4_update_stts_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak, ngx_uint_t start);\n+static uint32_t ngx_http_mp4_seek_key_frame(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak, uint32_t start_sample);\n static ngx_int_t ngx_http_mp4_read_stss_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n static ngx_int_t ngx_http_mp4_update_stss_atom(ngx_http_mp4_file_t *mp4,\n@@ -343,6 +383,13 @@ static ngx_command_t  ngx_http_mp4_commands[] = {\n       offsetof(ngx_http_mp4_conf_t, max_buffer_size),\n       NULL },\n \n+    { ngx_string(\"mp4_start_key_frame\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_mp4_conf_t, start_key_frame),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -829,6 +876,7 @@ ngx_http_mp4_process(ngx_http_mp4_file_t *mp4)\n         trak[i].size += trak[i].hdlr_size;\n         ngx_http_mp4_update_mdia_atom(mp4, &trak[i]);\n         trak[i].size += trak[i].tkhd_size;\n+        ngx_http_mp4_update_edts_atom(mp4, &trak[i]);\n         ngx_http_mp4_update_trak_atom(mp4, &trak[i]);\n \n         mp4->moov_size += trak[i].size;\n@@ -1590,6 +1638,7 @@ ngx_http_mp4_read_tkhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n \n     trak = ngx_mp4_last_trak(mp4);\n     trak->tkhd_size = atom_size;\n+    trak->movie_duration = duration;\n \n     ngx_mp4_set_32value(tkhd_atom->size, atom_size);\n \n@@ -1985,6 +2034,59 @@ ngx_http_mp4_read_stbl_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n }\n \n \n+static void\n+ngx_http_mp4_update_edts_atom(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak)\n+{\n+    ngx_buf_t            *atom;\n+    ngx_mp4_elst_atom_t  *elst_atom;\n+    ngx_mp4_edts_atom_t  *edts_atom;\n+\n+    if (trak->prefix == 0) {\n+        return;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n+                   \"mp4 edts atom update prefix:%uL\", trak->prefix);\n+\n+    edts_atom = &trak->edts_atom;\n+    ngx_mp4_set_32value(edts_atom->size, sizeof(ngx_mp4_edts_atom_t)\n+                                         + sizeof(ngx_mp4_elst_atom_t));\n+    ngx_mp4_set_atom_name(edts_atom, 'e', 'd', 't', 's');\n+\n+    atom = &trak->edts_atom_buf;\n+    atom->temporary = 1;\n+    atom->pos = (u_char *) edts_atom;\n+    atom->last = (u_char *) edts_atom + sizeof(ngx_mp4_edts_atom_t);\n+\n+    trak->out[NGX_HTTP_MP4_EDTS_ATOM].buf = atom;\n+\n+    elst_atom = &trak->elst_atom;\n+    ngx_mp4_set_32value(elst_atom->size, sizeof(ngx_mp4_elst_atom_t));\n+    ngx_mp4_set_atom_name(elst_atom, 'e', 'l', 's', 't');\n+\n+    elst_atom->version[0] = 1;\n+    elst_atom->flags[0] = 0;\n+    elst_atom->flags[1] = 0;\n+    elst_atom->flags[2] = 0;\n+\n+    ngx_mp4_set_32value(elst_atom->entries, 1);\n+    ngx_mp4_set_64value(elst_atom->duration, trak->movie_duration);\n+    ngx_mp4_set_64value(elst_atom->media_time, trak->prefix);\n+    ngx_mp4_set_16value(elst_atom->media_rate, 1);\n+    ngx_mp4_set_16value(elst_atom->reserved, 0);\n+\n+    atom = &trak->elst_atom_buf;\n+    atom->temporary = 1;\n+    atom->pos = (u_char *) elst_atom;\n+    atom->last = (u_char *) elst_atom + sizeof(ngx_mp4_elst_atom_t);\n+\n+    trak->out[NGX_HTTP_MP4_ELST_ATOM].buf = atom;\n+\n+    trak->size += sizeof(ngx_mp4_edts_atom_t) + sizeof(ngx_mp4_elst_atom_t);\n+}\n+\n+\n static void\n ngx_http_mp4_update_stbl_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak)\n@@ -2183,7 +2285,7 @@ static ngx_int_t\n ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak, ngx_uint_t start)\n {\n-    uint32_t               count, duration, rest;\n+    uint32_t               count, duration, rest, key_prefix;\n     uint64_t               start_time;\n     ngx_buf_t             *data;\n     ngx_uint_t             start_sample, entries, start_sec;\n@@ -2207,7 +2309,7 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n \n     data = trak->out[NGX_HTTP_MP4_STTS_DATA].buf;\n \n-    start_time = (uint64_t) start_sec * trak->timescale / 1000;\n+    start_time = (uint64_t) start_sec * trak->timescale / 1000 + trak->prefix;\n \n     entries = trak->time_to_sample_entries;\n     start_sample = 0;\n@@ -2253,6 +2355,26 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n found:\n \n     if (start) {\n+        key_prefix = ngx_http_mp4_seek_key_frame(mp4, trak, start_sample);\n+\n+        start_sample -= key_prefix;\n+\n+        while (rest < key_prefix) {\n+            trak->prefix += rest * duration;\n+            key_prefix -= rest;\n+\n+            entry--;\n+            entries++;\n+\n+            count = ngx_mp4_get_32value(entry->count);\n+            duration = ngx_mp4_get_32value(entry->duration);\n+            rest = count;\n+        }\n+\n+        trak->prefix += key_prefix * duration;\n+        trak->duration += trak->prefix;\n+        rest -= key_prefix;\n+\n         ngx_mp4_set_32value(entry->count, count - rest);\n         data->pos = (u_char *) entry;\n         trak->time_to_sample_entries = entries;\n@@ -2277,6 +2399,49 @@ ngx_http_mp4_crop_stts_data(ngx_http_mp4_file_t *mp4,\n }\n \n \n+static uint32_t\n+ngx_http_mp4_seek_key_frame(ngx_http_mp4_file_t *mp4, ngx_http_mp4_trak_t *trak,\n+    uint32_t start_sample)\n+{\n+    uint32_t              key_prefix, sample, *entry, *end;\n+    ngx_buf_t            *data;\n+    ngx_http_mp4_conf_t  *conf;\n+\n+    conf = ngx_http_get_module_loc_conf(mp4->request, ngx_http_mp4_module);\n+    if (!conf->start_key_frame) {\n+        return 0;\n+    }\n+\n+    data = trak->out[NGX_HTTP_MP4_STSS_DATA].buf;\n+    if (data == NULL) {\n+        return 0;\n+    }\n+\n+    entry = (uint32_t *) data->pos;\n+    end = (uint32_t *) data->last;\n+\n+    /* sync samples starts from 1 */\n+    start_sample++;\n+\n+    key_prefix = 0;\n+\n+    while (entry < end) {\n+        sample = ngx_mp4_get_32value(entry);\n+        if (sample > start_sample) {\n+            break;\n+        }\n+\n+        key_prefix = start_sample - sample;\n+        entry++;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n+                   \"mp4 key frame prefix:%uD\", key_prefix);\n+\n+    return key_prefix;\n+}\n+\n+\n typedef struct {\n     u_char    size[4];\n     u_char    name[4];\n@@ -3614,6 +3779,7 @@ ngx_http_mp4_create_conf(ngx_conf_t *cf)\n \n     conf->buffer_size = NGX_CONF_UNSET_SIZE;\n     conf->max_buffer_size = NGX_CONF_UNSET_SIZE;\n+    conf->start_key_frame = NGX_CONF_UNSET;\n \n     return conf;\n }\n@@ -3628,6 +3794,7 @@ ngx_http_mp4_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size, 512 * 1024);\n     ngx_conf_merge_size_value(conf->max_buffer_size, prev->max_buffer_size,\n                               10 * 1024 * 1024);\n+    ngx_conf_merge_value(conf->start_key_frame, prev->start_key_frame, 0);\n \n     return NGX_CONF_OK;\n }\nDiff:\n@@ -321,18 +321,13 @@ ngx_http_write_filter(ngx_http_request_t *r, ngx_chain_t *in)\n         delay = (ngx_msec_t) ((nsent - sent) * 1000 / r->limit_rate);\n \n         if (delay > 0) {\n-            limit = 0;\n             c->write->delayed = 1;\n             ngx_add_timer(c->write, delay);\n         }\n     }\n \n-    if (limit\n-        && c->write->ready\n-        && c->sent - sent >= limit - (off_t) (2 * ngx_pagesize))\n-    {\n-        c->write->delayed = 1;\n-        ngx_add_timer(c->write, 1);\n+    if (chain && c->write->ready && !c->write->delayed) {\n+        ngx_post_event(c->write, &ngx_posted_next_events);\n     }\n \n     for (cl = r->out; cl && cl != chain; /* void */) {\nDiff:\n@@ -38,6 +38,9 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\n  * On Linux up to 2.6.16 sendfile() does not allow to pass the count parameter\n  * more than 2G-1 bytes even on 64-bit platforms: it returns EINVAL,\n  * so we limit it to 2G-1 bytes.\n+ *\n+ * On Linux 2.6.16 and later, sendfile() silently limits the count parameter\n+ * to 2G minus the page size, even on 64-bit platforms.\n  */\n \n #define NGX_SENDFILE_MAXSIZE  2147483647L\n@@ -259,7 +262,6 @@ ngx_linux_sendfile_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n              */\n \n             send = prev_send + sent;\n-            continue;\n         }\n \n         if (send >= limit || in == NULL) {\n",
        "analysis": "Let's analyze the newly added entire functions from the provided diff.\n\n1. **Function: ngx_http_mp4_update_edts_atom**\n   - **Line 1:** The function is defined with two parameters. There's no immediate issue here.\n   - **Line 4:** Buffers and atoms are declared as local variables.\n   - **Line 6-8:** The function checks a condition to decide if it should proceed, which is safe as it's a guard condition.\n   - **Line 10:** Logs a debug message, nothing suspicious here.\n   - **Line 12-15:** Sets values for the `edts_atom` and initializes its buffer properties but does not directly manipulate any data using external input, appearing safe.\n   - **Line 17:** Associates the initialized buffer with a specific output slot, without any manipulation of size.\n   - **Line 19-23:** Sets values for the `elst_atom`. No dynamic data is being directly accessed or set that could cause an overflow here.\n   - **Line 25-28:** Sets up value for entries and uses a known size to set duration and media time. Seems safe as no unchecked buffer manipulation occurs.\n   - **Line 30-34:** Initializes the buffer and sets its boundaries correctly based on the `sizeof` the structure, without using input data which might lead to an overrun. \n   - **Line 36:** Associates the updated buffer to an output slot. No suspicious external data manipulation. \n   - **Line 38:** Finally updates a size value, again only using fixed-size increments. \n\n   **Observation:** \n   This function seems to handle buffer setups with known fixed sizes according to structure definitions. There are no apparent buffer overruns as all the buffer sizes used have been set using static structure sizes.\n\n2. **Function: ngx_http_mp4_seek_key_frame**\n   - **Line 1:** Function definition, still safe.\n   - **Line 4:** Local variables are initialized. No buffer directly manipulated at this point.\n   - **Line 6-8:** Correctly handles a configuration check, ensuring safety before proceeding with operations that depend on this.\n   - **Line 10-12:** Retrieves a buffer but does not manipulate size, so no immediate danger.\n   - **Line 14-15:** Converts position pointers within the buffer to specific types for iteration, avoiding direct buffer writes. \n   - **Line 17-19:** Safely advances a sample identifier while ensuring that the values are within readable bounds, not written. \n   - **Line 22-30:** Iterates with checks that maintain safe traversal of buffer entries without writing beyond bounds.\n   - **Line 32-37:** Logs debug info and finishes execution safely without any outward buffer operations. \n\n   **Observation:** \n   With proper boundary checks and return for when buffers are not found or critical configurations are false, this function also doesn’t show potential for out-of-bounds vulnerability.\n\n**Summary:** \nThere is sufficient caution in handling buffer sizes using fixed structure sizes and validating bounds during operations in these additions.\n\nFinal determination:\n- There is no indication of an out-of-bounds write vulnerability in the analyzed functions.\n\n\"FALSE\""
    },
    {
        "commit_index": "Commit 128",
        "commit_diff": "Diff:\n@@ -15,6 +15,7 @@ types {\n     text/vnd.wap.wml                                 wml;\n     text/x-component                                 htc;\n \n+    image/avif                                       avif;\n     image/png                                        png;\n     image/svg+xml                                    svg svgz;\n     image/tiff                                       tif tiff;\nDiff:\n@@ -274,6 +274,10 @@ ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts)\n     }\n \n     for (n = 0; n < nelts; n++) {\n+        if (names[n].key.data == NULL) {\n+            continue;\n+        }\n+\n         if (hinit->bucket_size < NGX_HASH_ELT_SIZE(&names[n]) + sizeof(void *))\n         {\n             ngx_log_error(NGX_LOG_EMERG, hinit->pool->log, 0,\nDiff:\n@@ -70,6 +70,7 @@ typedef struct {\n     ngx_uint_t            end_chunk_samples;\n     uint64_t              start_chunk_samples_size;\n     uint64_t              end_chunk_samples_size;\n+    uint64_t              duration;\n     off_t                 start_offset;\n     off_t                 end_offset;\n \n@@ -253,6 +254,8 @@ static void ngx_http_mp4_update_mdia_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n+static void ngx_http_mp4_update_mdhd_atom(ngx_http_mp4_file_t *mp4,\n+    ngx_http_mp4_trak_t *trak);\n static ngx_int_t ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4,\n     uint64_t atom_data_size);\n static ngx_int_t ngx_http_mp4_read_minf_atom(ngx_http_mp4_file_t *mp4,\n@@ -822,7 +825,7 @@ ngx_http_mp4_process(ngx_http_mp4_file_t *mp4)\n \n         ngx_http_mp4_update_stbl_atom(mp4, &trak[i]);\n         ngx_http_mp4_update_minf_atom(mp4, &trak[i]);\n-        trak[i].size += trak[i].mdhd_size;\n+        ngx_http_mp4_update_mdhd_atom(mp4, &trak[i]);\n         trak[i].size += trak[i].hdlr_size;\n         ngx_http_mp4_update_mdia_atom(mp4, &trak[i]);\n         trak[i].size += trak[i].tkhd_size;\n@@ -1749,16 +1752,10 @@ ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n     trak = ngx_mp4_last_trak(mp4);\n     trak->mdhd_size = atom_size;\n     trak->timescale = timescale;\n+    trak->duration = duration;\n \n     ngx_mp4_set_32value(mdhd_atom->size, atom_size);\n \n-    if (mdhd_atom->version[0] == 0) {\n-        ngx_mp4_set_32value(mdhd_atom->duration, duration);\n-\n-    } else {\n-        ngx_mp4_set_64value(mdhd64_atom->duration, duration);\n-    }\n-\n     atom = &trak->mdhd_atom_buf;\n     atom->temporary = 1;\n     atom->pos = atom_header;\n@@ -1772,6 +1769,33 @@ ngx_http_mp4_read_mdhd_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n }\n \n \n+static void\n+ngx_http_mp4_update_mdhd_atom(ngx_http_mp4_file_t *mp4,\n+            ngx_http_mp4_trak_t *trak)\n+{\n+    ngx_buf_t              *atom;\n+    ngx_mp4_mdhd_atom_t    *mdhd_atom;\n+    ngx_mp4_mdhd64_atom_t  *mdhd64_atom;\n+\n+    atom = trak->out[NGX_HTTP_MP4_MDHD_ATOM].buf;\n+    if (atom == NULL) {\n+        return;\n+    }\n+\n+    mdhd_atom = (ngx_mp4_mdhd_atom_t *) atom->pos;\n+    mdhd64_atom = (ngx_mp4_mdhd64_atom_t *) atom->pos;\n+\n+    if (mdhd_atom->version[0] == 0) {\n+        ngx_mp4_set_32value(mdhd_atom->duration, trak->duration);\n+\n+    } else {\n+        ngx_mp4_set_64value(mdhd64_atom->duration, trak->duration);\n+    }\n+\n+    trak->size += trak->mdhd_size;\n+}\n+\n+\n static ngx_int_t\n ngx_http_mp4_read_hdlr_atom(ngx_http_mp4_file_t *mp4, uint64_t atom_data_size)\n {\n",
        "analysis": "To determine if there are any newly added functions and analyze them for potential out-of-bounds write vulnerabilities, we examine the diff provided:\n\nThe diff includes the addition of a new function:\n\n```c\nstatic void\nngx_http_mp4_update_mdhd_atom(ngx_http_mp4_file_t *mp4,\n            ngx_http_mp4_trak_t *trak)\n{\n    ngx_buf_t *atom;\n    ngx_mp4_mdhd_atom_t *mdhd_atom;\n    ngx_mp4_mdhd64_atom_t *mdhd64_atom;\n\n    atom = trak->out[NGX_HTTP_MP4_MDHD_ATOM].buf;\n    if (atom == NULL) {\n        return;\n    }\n\n    mdhd_atom = (ngx_mp4_mdhd_atom_t *) atom->pos;\n    mdhd64_atom = (ngx_mp4_mdhd64_atom_t *) atom->pos;\n\n    if (mdhd_atom->version[0] == 0) {\n        ngx_mp4_set_32value(mdhd_atom->duration, trak->duration);\n\n    } else {\n        ngx_mp4_set_64value(mdhd64_atom->duration, trak->duration);\n    }\n\n    trak->size += trak->mdhd_size;\n}\n```\n\nNow we'll analyze this function line by line:\n\n1. **Function Declaration**: The function `ngx_http_mp4_update_mdhd_atom` is declared as static, indicating it is local to its translation unit. It takes two arguments: `ngx_http_mp4_file_t *mp4` and `ngx_http_mp4_trak_t *trak`.\n\n2. **Variable Declaration**: Three pointer variables are declared: `atom`, `mdhd_atom`, and `mdhd64_atom`.\n\n3. **Buffer Assignment**: \n   - `atom = trak->out[NGX_HTTP_MP4_MDHD_ATOM].buf;`\n   - This line assigns the buffer from the `trak->out` array to the `atom` pointer. There is a potential for out-of-bounds access if `NGX_HTTP_MP4_MDHD_ATOM` is not within the boundaries of the `trak->out` array, but this is dependent on how `trak->out` is defined and managed elsewhere in the code.\n\n4. **NULL Check**: \n   - `if (atom == NULL) { return; }`\n   - A null check is performed on `atom`, which prevents further code execution if `atom` is NULL, thus preventing a direct null pointer dereference.\n\n5. **Casting and Assignment**:\n   - `mdhd_atom = (ngx_mp4_mdhd_atom_t *) atom->pos;`\n   - `mdhd64_atom = (ngx_mp4_mdhd64_atom_t *) atom->pos;`\n   - These lines cast the `atom->pos` to two different structures. The same position is being cast to different structure types, which can be a source of vulnerability if the interpretation of the buffer is incorrect or if `atom->pos` does not point to a sufficiently large buffer for either `ngx_mp4_mdhd_atom_t` or `ngx_mp4_mdhd64_atom_t`.\n\n6. **Conditional Update**:\n   - `if (mdhd_atom->version[0] == 0) { ngx_mp4_set_32value(mdhd_atom->duration, trak->duration); } else { ngx_mp4_set_64value(mdhd64_atom->duration, trak->duration); }`\n   - This block conditionally updates the `duration` field. The method of update depends on the version, implying different layout structures. The safety of this update depends on proper initialization and layout of `mdhd_atom` and `mdhd64_atom`.\n\n7. **Size Update**:\n   - `trak->size += trak->mdhd_size;`\n   - This line updates a size field within the `trak` structure.\n\n**Conclusion**: While this code performs a NULL check on `atom`, there are potential concerns with casting `atom->pos` to two different structure types without verifying that the buffer is large enough or appropriate for either type. Given these factors, there is a potential for out-of-bounds write if the wrong structure type is assumed and written to.\n\nBased on this analysis, there is a possibility of an out-of-bounds write under malicious conditions, specifically regarding the type casting and writing to the buffered positions within the conditionals.\n\nFinal Line:\n\n```\nTRUE [ngx_http_mp4_update_mdhd_atom]\n```"
    },
    {
        "commit_index": "Commit 127",
        "commit_diff": "Diff:\n@@ -47,6 +47,8 @@ static void ngx_ssl_write_handler(ngx_event_t *wev);\n static ssize_t ngx_ssl_write_early(ngx_connection_t *c, u_char *data,\n     size_t size);\n #endif\n+static ssize_t ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file,\n+    size_t size);\n static void ngx_ssl_read_handler(ngx_event_t *rev);\n static void ngx_ssl_shutdown_handler(ngx_event_t *ev);\n static void ngx_ssl_connection_error(ngx_connection_t *c, int sslerr,\n@@ -1762,6 +1764,16 @@ ngx_ssl_handshake(ngx_connection_t *c)\n \n #endif\n #endif\n+#endif\n+\n+#ifdef BIO_get_ktls_send\n+\n+        if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"BIO_get_ktls_send(): 1\");\n+            c->ssl->sendfile = 1;\n+        }\n+\n #endif\n \n         rc = ngx_ssl_ocsp_validate(c);\n@@ -1899,6 +1911,16 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->read->ready = 1;\n         c->write->ready = 1;\n \n+#ifdef BIO_get_ktls_send\n+\n+        if (BIO_get_ktls_send(SSL_get_wbio(c->ssl->connection)) == 1) {\n+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"BIO_get_ktls_send(): 1\");\n+            c->ssl->sendfile = 1;\n+        }\n+\n+#endif\n+\n         rc = ngx_ssl_ocsp_validate(c);\n \n         if (rc == NGX_ERROR) {\n@@ -2502,10 +2524,11 @@ ngx_ssl_write_handler(ngx_event_t *wev)\n ngx_chain_t *\n ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n {\n-    int          n;\n-    ngx_uint_t   flush;\n-    ssize_t      send, size;\n-    ngx_buf_t   *buf;\n+    int           n;\n+    ngx_uint_t    flush;\n+    ssize_t       send, size, file_size;\n+    ngx_buf_t    *buf;\n+    ngx_chain_t  *cl;\n \n     if (!c->ssl->buffer) {\n \n@@ -2579,6 +2602,11 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                 continue;\n             }\n \n+            if (in->buf->in_file && c->ssl->sendfile) {\n+                flush = 1;\n+                break;\n+            }\n+\n             size = in->buf->last - in->buf->pos;\n \n             if (size > buf->end - buf->last) {\n@@ -2610,8 +2638,35 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n         size = buf->last - buf->pos;\n \n         if (size == 0) {\n+\n+            if (in && in->buf->in_file && send < limit) {\n+\n+                /* coalesce the neighbouring file bufs */\n+\n+                cl = in;\n+                file_size = (size_t) ngx_chain_coalesce_file(&cl, limit - send);\n+\n+                n = ngx_ssl_sendfile(c, in->buf, file_size);\n+\n+                if (n == NGX_ERROR) {\n+                    return NGX_CHAIN_ERROR;\n+                }\n+\n+                if (n == NGX_AGAIN) {\n+                    break;\n+                }\n+\n+                in = ngx_chain_update_sent(in, n);\n+\n+                send += n;\n+                flush = 0;\n+\n+                continue;\n+            }\n+\n             buf->flush = 0;\n             c->buffered &= ~NGX_SSL_BUFFERED;\n+\n             return in;\n         }\n \n@@ -2636,7 +2691,7 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n         buf->pos = buf->start;\n         buf->last = buf->start;\n \n-        if (in == NULL || send == limit) {\n+        if (in == NULL || send >= limit) {\n             break;\n         }\n     }\n@@ -2882,6 +2937,150 @@ ngx_ssl_write_early(ngx_connection_t *c, u_char *data, size_t size)\n #endif\n \n \n+static ssize_t\n+ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+#ifdef BIO_get_ktls_send\n+\n+    int        sslerr;\n+    ssize_t    n;\n+    ngx_err_t  err;\n+\n+    ngx_ssl_clear_error(c->log);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"SSL to sendfile: @%O %uz\",\n+                   file->file_pos, size);\n+\n+    ngx_set_errno(0);\n+\n+    n = SSL_sendfile(c->ssl->connection, file->file->fd, file->file_pos,\n+                     size, 0);\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_sendfile: %d\", n);\n+\n+    if (n > 0) {\n+\n+        if (c->ssl->saved_read_handler) {\n+\n+            c->read->handler = c->ssl->saved_read_handler;\n+            c->ssl->saved_read_handler = NULL;\n+            c->read->ready = 1;\n+\n+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_post_event(c->read, &ngx_posted_events);\n+        }\n+\n+        c->sent += n;\n+\n+        return n;\n+    }\n+\n+    if (n == 0) {\n+\n+        /*\n+         * if sendfile returns zero, then someone has truncated the file,\n+         * so the offset became beyond the end of the file\n+         */\n+\n+        ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                      \"SSL_sendfile() reported that \\\"%s\\\" was truncated at %O\",\n+                      file->file->name.data, file->file_pos);\n+\n+        return NGX_ERROR;\n+    }\n+\n+    sslerr = SSL_get_error(c->ssl->connection, n);\n+\n+    if (sslerr == SSL_ERROR_ZERO_RETURN) {\n+\n+        /*\n+         * OpenSSL fails to return SSL_ERROR_SYSCALL if an error\n+         * happens during writing after close_notify alert from the\n+         * peer, and returns SSL_ERROR_ZERO_RETURN instead\n+         */\n+\n+        sslerr = SSL_ERROR_SYSCALL;\n+    }\n+\n+    if (sslerr == SSL_ERROR_SSL\n+        && ERR_GET_REASON(ERR_peek_error()) == SSL_R_UNINITIALIZED\n+        && ngx_errno != 0)\n+    {\n+        /*\n+         * OpenSSL fails to return SSL_ERROR_SYSCALL if an error\n+         * happens in sendfile(), and returns SSL_ERROR_SSL with\n+         * SSL_R_UNINITIALIZED reason instead\n+         */\n+\n+        sslerr = SSL_ERROR_SYSCALL;\n+    }\n+\n+    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_get_error: %d\", sslerr);\n+\n+    if (sslerr == SSL_ERROR_WANT_WRITE) {\n+\n+        if (c->ssl->saved_read_handler) {\n+\n+            c->read->handler = c->ssl->saved_read_handler;\n+            c->ssl->saved_read_handler = NULL;\n+            c->read->ready = 1;\n+\n+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n+\n+            ngx_post_event(c->read, &ngx_posted_events);\n+        }\n+\n+        c->write->ready = 0;\n+        return NGX_AGAIN;\n+    }\n+\n+    if (sslerr == SSL_ERROR_WANT_READ) {\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"SSL_sendfile: want read\");\n+\n+        c->read->ready = 0;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        /*\n+         * we do not set the timer because there is already\n+         * the write event timer\n+         */\n+\n+        if (c->ssl->saved_read_handler == NULL) {\n+            c->ssl->saved_read_handler = c->read->handler;\n+            c->read->handler = ngx_ssl_read_handler;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    c->ssl->no_wait_shutdown = 1;\n+    c->ssl->no_send_shutdown = 1;\n+    c->write->error = 1;\n+\n+    ngx_ssl_connection_error(c, sslerr, err, \"SSL_sendfile() failed\");\n+\n+#else\n+    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                  \"SSL_sendfile() not available\");\n+#endif\n+\n+    return NGX_ERROR;\n+}\n+\n+\n static void\n ngx_ssl_read_handler(ngx_event_t *rev)\n {\nDiff:\n@@ -109,6 +109,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    handshake_rejected:1;\n     unsigned                    renegotiation:1;\n     unsigned                    buffer:1;\n+    unsigned                    sendfile:1;\n     unsigned                    no_wait_shutdown:1;\n     unsigned                    no_send_shutdown:1;\n     unsigned                    shutdown_without_free:1;\nDiff:\n@@ -626,7 +626,7 @@ ngx_http_alloc_request(ngx_connection_t *c)\n     }\n \n #if (NGX_HTTP_SSL)\n-    if (c->ssl) {\n+    if (c->ssl && !c->ssl->sendfile) {\n         r->main_filter_need_in_memory = 1;\n     }\n #endif\nDiff:\n@@ -1683,9 +1683,6 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,\n         return;\n     }\n \n-    c->sendfile = 0;\n-    u->output.sendfile = 0;\n-\n     if (u->conf->ssl_server_name || u->conf->ssl_verify) {\n         if (ngx_http_upstream_ssl_name(r, u, c) != NGX_OK) {\n             ngx_http_upstream_finalize_request(r, u,\n@@ -1791,6 +1788,11 @@ ngx_http_upstream_ssl_handshake(ngx_http_request_t *r, ngx_http_upstream_t *u,\n             }\n         }\n \n+        if (!c->ssl->sendfile) {\n+            c->sendfile = 0;\n+            u->output.sendfile = 0;\n+        }\n+\n         c->write->handler = ngx_http_upstream_handler;\n         c->read->handler = ngx_http_upstream_handler;\n \n",
        "analysis": "Upon reviewing the diff provided, I found one newly added function:\n\n1. `ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)`\n\nLet's analyze this function line by line to identify any potential for an out-of-bounds write.\n\n### Function: `ngx_ssl_sendfile`\n\n1. **Function Definition**: \n   - The function is defined with a specific prototype: `ngx_ssl_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)`.\n   - It's newly introduced, hence critical for review.\n\n2. **Preprocessor Directive - `#ifdef BIO_get_ktls_send`**:\n   - The function's contents are conditioned to compile based on this directive.\n\n3. **Variable Declarations**: \n   - Variables `sslerr`, `n`, and `err` are declared for managing SSL operations and error handling.\n\n4. **Error Handling**: \n   - `ngx_ssl_clear_error(c->log)` clears SSL error queue and prepares for a new operation.\n\n5. **Debug Logs**: \n   - Log operations indicate beginning of a sendfile operation with specified offset and size.\n\n6. **Set Error Number to 0**: \n   - This is a common practice to handle errors deliberately later in code.\n\n7. **SSLSendfile Operation**: \n   - The function `SSL_sendfile(...)` carries out the primary file transmission.\n\n8. **Positive `n` Handling**: \n   - When `n > 0`, it indicates successful send, leading to operations like restoration of read handler and logging sent bytes.\n\n9. **Zero `n` Handling**: \n   - When `n == 0`, a log error indicating potential file truncation is mentioned. \n\n10. **Error Handlings based on `sslerr` values**:\n    - Various error cases are inspected and handled.\n\n11. **Return Values Based on Conditions**: \n    - The function can return varying values like `n`, `NGX_ERROR`, or `NGX_AGAIN` based on outcomes of `SSL_sendfile`.\n\n### Analysis for Out-of-Bounds Write:\n\n- **Size Parameter**: The third parameter `size` directly influences the number of bytes the function intends to write. If larger than the source or destination allows, it may result in a vulnerability.\n\n- **Boundary Checks and Error Management**: Although multiple error handling mechanisms are present, close attention is needed on controlling file positions and sizes directly passed to `SSL_sendfile.`\n\n- **Possibility of Out-of-Bounds**: \n  - If `size` exceeds the actual file/data boundaries, then either intentionally or unintentionally, it might lead to out-of-bounds writes.\n  - The function assumes `file->file_pos` and `size` are correctly set, disregarding malicious manipulation potential.\n\nGiven the above insights into the newly added function, it is considered to have a potential for out-of-bounds write, primarily due to the `size` parameter control assumptions.\n\n**Final Conclusion**: \n\nTRUE [ngx_ssl_sendfile]"
    },
    {
        "commit_index": "Commit 126",
        "commit_diff": "Diff:\n@@ -200,10 +200,6 @@ ngx_monotonic_time(time_t sec, ngx_uint_t msec)\n \n #if defined(CLOCK_MONOTONIC_FAST)\n     clock_gettime(CLOCK_MONOTONIC_FAST, &ts);\n-\n-#elif defined(CLOCK_MONOTONIC_COARSE)\n-    clock_gettime(CLOCK_MONOTONIC_COARSE, &ts);\n-\n #else\n     clock_gettime(CLOCK_MONOTONIC, &ts);\n #endif\nDiff:\n@@ -2767,7 +2767,7 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)\n \n #ifdef SSL_READ_EARLY_DATA_SUCCESS\n \n-ssize_t\n+static ssize_t\n ngx_ssl_write_early(ngx_connection_t *c, u_char *data, size_t size)\n {\n     int        n, sslerr;\nDiff:\n@@ -23,7 +23,8 @@ static ngx_int_t ngx_stream_ssl_init_connection(ngx_ssl_t *ssl,\n     ngx_connection_t *c);\n static void ngx_stream_ssl_handshake_handler(ngx_connection_t *c);\n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n-int ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg);\n+static int ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad,\n+    void *arg);\n #endif\n #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n static int ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n@@ -451,7 +452,7 @@ ngx_stream_ssl_handshake_handler(ngx_connection_t *c)\n \n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n \n-int\n+static int\n ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n {\n     return SSL_TLSEXT_ERR_OK;\n@@ -502,7 +503,7 @@ ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n \n #ifdef SSL_R_CERT_CB_ERROR\n \n-int\n+static int\n ngx_stream_ssl_certificate(ngx_ssl_conn_t *ssl_conn, void *arg)\n {\n     ngx_str_t                    cert, key;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 125",
        "commit_diff": "Diff:\n@@ -324,6 +324,7 @@ typedef ngx_int_t (*ngx_mail_parse_command_pt)(ngx_mail_session_t *s);\n \n struct ngx_mail_protocol_s {\n     ngx_str_t                   name;\n+    ngx_str_t                   alpn;\n     in_port_t                   port[4];\n     ngx_uint_t                  type;\n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_str_t  ngx_mail_imap_auth_methods_names[] = {\n \n static ngx_mail_protocol_t  ngx_mail_imap_protocol = {\n     ngx_string(\"imap\"),\n+    ngx_string(\"\\x04imap\"),\n     { 143, 993, 0, 0 },\n     NGX_MAIL_IMAP_PROTOCOL,\n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_str_t  ngx_mail_pop3_auth_methods_names[] = {\n \n static ngx_mail_protocol_t  ngx_mail_pop3_protocol = {\n     ngx_string(\"pop3\"),\n+    ngx_string(\"\\x04pop3\"),\n     { 110, 995, 0, 0 },\n     NGX_MAIL_POP3_PROTOCOL,\n \nDiff:\n@@ -39,6 +39,7 @@ static ngx_str_t  ngx_mail_smtp_auth_methods_names[] = {\n \n static ngx_mail_protocol_t  ngx_mail_smtp_protocol = {\n     ngx_string(\"smtp\"),\n+    ngx_string(\"\\x04smtp\"),\n     { 25, 465, 587, 0 },\n     NGX_MAIL_SMTP_PROTOCOL,\n \nDiff:\n@@ -14,6 +14,12 @@\n #define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n \n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+static int ngx_mail_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n+    const unsigned char **out, unsigned char *outlen,\n+    const unsigned char *in, unsigned int inlen, void *arg);\n+#endif\n+\n static void *ngx_mail_ssl_create_conf(ngx_conf_t *cf);\n static char *ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child);\n \n@@ -244,6 +250,54 @@ ngx_module_t  ngx_mail_ssl_module = {\n static ngx_str_t ngx_mail_ssl_sess_id_ctx = ngx_string(\"MAIL\");\n \n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+static int\n+ngx_mail_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n+    unsigned char *outlen, const unsigned char *in, unsigned int inlen,\n+    void *arg)\n+{\n+    unsigned int               srvlen;\n+    unsigned char             *srv;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n+#if (NGX_DEBUG)\n+    unsigned int               i;\n+#endif\n+\n+    c = ngx_ssl_get_connection(ssl_conn);\n+    s = c->data;\n+\n+#if (NGX_DEBUG)\n+    for (i = 0; i < inlen; i += in[i] + 1) {\n+        ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                       \"SSL ALPN supported by client: %*s\",\n+                       (size_t) in[i], &in[i + 1]);\n+    }\n+#endif\n+\n+    cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+\n+    srv = cscf->protocol->alpn.data;\n+    srvlen = cscf->protocol->alpn.len;\n+\n+    if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,\n+                              in, inlen)\n+        != OPENSSL_NPN_NEGOTIATED)\n+    {\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"SSL ALPN selected: %*s\", (size_t) *outlen, *out);\n+\n+    return SSL_TLSEXT_ERR_OK;\n+}\n+\n+#endif\n+\n+\n static void *\n ngx_mail_ssl_create_conf(ngx_conf_t *cf)\n {\n@@ -394,6 +448,10 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = &conf->ssl;\n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+    SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_mail_ssl_alpn_select, NULL);\n+#endif\n+\n     if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n                         conf->prefer_server_ciphers)\n         != NGX_OK)\n",
        "analysis": "Let's analyze the newly added function `ngx_mail_ssl_alpn_select` line by line to determine if there is a possibility of an out-of-bounds write.\n\n1. **Function Definition**:\n   - The function `ngx_mail_ssl_alpn_select` is defined with parameters which include pointers and lengths for incoming and outgoing protocol negotiation data. No out-of-bounds write risk so far.\n\n2. **Variable Declarations**:\n   - Several variables are declared for use within this function, including buffers and lengths.\n\n3. **Connection and Session Retrieval**:\n   - The connection and session are retrieved from the `ssl_conn` parameter, which is standard practice.\n\n4. **Debug Loop** (`#if (NGX_DEBUG)`):\n   - This loop iterates over the `in` buffer, using `in[i]` as a length indicator for user-provided protocol names. This could be a potential out-of-bounds read if the attacker provides malicious input which leads to miscalculation of `i`. However, it does not write to `in`, hence no out-of-bounds write risk.\n\n5. **Server Protocol Retrieval**:\n   - `srv` and `srvlen` are assigned values from `cscf->protocol->alpn`, which should refer to server-defined data.\n\n6. **Protocol Selection**:\n   - The function `SSL_select_next_proto` is called with pointers to potentially update `*out` and `*outlen`. Proper implementations of `SSL_select_next_proto` should manage memory correctly. \n\n7. **Return Statement**:\n   - Depending on the success of the protocol selection, an appropriate response is returned.\n\nOverall, while there could be concerns about whether `SSL_select_next_proto` checks its boundaries, no clear out-of-bounds write vulnerability is exposed directly in the provided function based on the assumptions made during its standard usage. However, since the vulnerability can sometimes be context-specific (dependent on external factors or details outside the visible code logic), if more evidence or broader context were available, a different conclusion might emerge.\n\nSince there is no conclusive finding of a clear out-of-bounds write vulnerability in this function per general analysis, it returns:\n\nFALSE"
    },
    {
        "commit_index": "Commit 124",
        "commit_diff": "Diff:\n@@ -3133,6 +3133,9 @@ ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,\n #endif\n #ifdef SSL_R_CALLBACK_FAILED\n             || n == SSL_R_CALLBACK_FAILED                            /*  234 */\n+#endif\n+#ifdef SSL_R_NO_APPLICATION_PROTOCOL\n+            || n == SSL_R_NO_APPLICATION_PROTOCOL                    /*  235 */\n #endif\n             || n == SSL_R_UNEXPECTED_MESSAGE                         /*  244 */\n             || n == SSL_R_UNEXPECTED_RECORD                          /*  245 */\nDiff:\n@@ -17,7 +17,7 @@ typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,\n #define NGX_DEFAULT_CIPHERS     \"HIGH:!aNULL:!MD5\"\n #define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n \n-#define NGX_HTTP_ALPN_PROTO     \"\\x08http/1.1\"\n+#define NGX_HTTP_ALPN_PROTOS    \"\\x08http/1.1\\x08http/1.0\\x08http/0.9\"\n \n \n #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n@@ -442,21 +442,20 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n     hc = c->data;\n \n     if (hc->addr_conf->http2) {\n-        srv = (unsigned char *) NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO;\n-        srvlen = sizeof(NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO) - 1;\n-\n+        srv = (unsigned char *) NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTOS;\n+        srvlen = sizeof(NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTOS) - 1;\n     } else\n #endif\n     {\n-        srv = (unsigned char *) NGX_HTTP_ALPN_PROTO;\n-        srvlen = sizeof(NGX_HTTP_ALPN_PROTO) - 1;\n+        srv = (unsigned char *) NGX_HTTP_ALPN_PROTOS;\n+        srvlen = sizeof(NGX_HTTP_ALPN_PROTOS) - 1;\n     }\n \n     if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,\n                               in, inlen)\n         != OPENSSL_NPN_NEGOTIATED)\n     {\n-        return SSL_TLSEXT_ERR_NOACK;\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n     }\n \n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\nDiff:\n@@ -25,6 +25,11 @@ static void ngx_stream_ssl_handshake_handler(ngx_connection_t *c);\n #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n int ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg);\n #endif\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+static int ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n+    const unsigned char **out, unsigned char *outlen,\n+    const unsigned char *in, unsigned int inlen, void *arg);\n+#endif\n #ifdef SSL_R_CERT_CB_ERROR\n static int ngx_stream_ssl_certificate(ngx_ssl_conn_t *ssl_conn, void *arg);\n #endif\n@@ -45,6 +50,8 @@ static char *ngx_stream_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static char *ngx_stream_ssl_alpn(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n \n static char *ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n     void *data);\n@@ -211,6 +218,13 @@ static ngx_command_t  ngx_stream_ssl_commands[] = {\n       offsetof(ngx_stream_ssl_conf_t, conf_commands),\n       &ngx_stream_ssl_conf_command_post },\n \n+    { ngx_string(\"ssl_alpn\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_1MORE,\n+      ngx_stream_ssl_alpn,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -446,6 +460,46 @@ ngx_stream_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n #endif\n \n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+static int\n+ngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n+    unsigned char *outlen, const unsigned char *in, unsigned int inlen,\n+    void *arg)\n+{\n+    ngx_str_t         *alpn;\n+#if (NGX_DEBUG)\n+    unsigned int       i;\n+    ngx_connection_t  *c;\n+\n+    c = ngx_ssl_get_connection(ssl_conn);\n+\n+    for (i = 0; i < inlen; i += in[i] + 1) {\n+        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                       \"SSL ALPN supported by client: %*s\",\n+                       (size_t) in[i], &in[i + 1]);\n+    }\n+\n+#endif\n+\n+    alpn = arg;\n+\n+    if (SSL_select_next_proto((unsigned char **) out, outlen, alpn->data,\n+                              alpn->len, in, inlen)\n+        != OPENSSL_NPN_NEGOTIATED)\n+    {\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+    }\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                   \"SSL ALPN selected: %*s\", (size_t) *outlen, *out);\n+\n+    return SSL_TLSEXT_ERR_OK;\n+}\n+\n+#endif\n+\n+\n #ifdef SSL_R_CERT_CB_ERROR\n \n int\n@@ -605,6 +659,7 @@ ngx_stream_ssl_create_conf(ngx_conf_t *cf)\n      *     scf->client_certificate = { 0, NULL };\n      *     scf->trusted_certificate = { 0, NULL };\n      *     scf->crl = { 0, NULL };\n+     *     scf->alpn = { 0, NULL };\n      *     scf->ciphers = { 0, NULL };\n      *     scf->shm_zone = NULL;\n      */\n@@ -663,6 +718,7 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->trusted_certificate,\n                          prev->trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->crl, prev->crl, \"\");\n+    ngx_conf_merge_str_value(conf->alpn, prev->alpn, \"\");\n \n     ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,\n                          NGX_DEFAULT_ECDH_CURVE);\n@@ -723,6 +779,13 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                                            ngx_stream_ssl_servername);\n #endif\n \n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+    if (conf->alpn.len) {\n+        SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_stream_ssl_alpn_select,\n+                                   &conf->alpn);\n+    }\n+#endif\n+\n     if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n                         conf->prefer_server_ciphers)\n         != NGX_OK)\n@@ -1059,6 +1122,60 @@ ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_stream_ssl_alpn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+    ngx_stream_ssl_conf_t  *scf = conf;\n+\n+    u_char      *p;\n+    size_t       len;\n+    ngx_str_t   *value;\n+    ngx_uint_t   i;\n+\n+    if (scf->alpn.len) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    len = 0;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+\n+        if (value[i].len > 255) {\n+            return \"protocol too long\";\n+        }\n+\n+        len += value[i].len + 1;\n+    }\n+\n+    scf->alpn.data = ngx_pnalloc(cf->pool, len);\n+    if (scf->alpn.data == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    p = scf->alpn.data;\n+\n+    for (i = 1; i < cf->args->nelts; i++) {\n+        *p++ = value[i].len;\n+        p = ngx_cpymem(p, value[i].data, value[i].len);\n+    }\n+\n+    scf->alpn.len = len;\n+\n+    return NGX_CONF_OK;\n+\n+#else\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"the \\\"ssl_alpn\\\" directive requires OpenSSL \"\n+                       \"with ALPN support\");\n+    return NGX_CONF_ERROR;\n+#endif\n+}\n+\n+\n static char *\n ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\nDiff:\n@@ -42,6 +42,7 @@ typedef struct {\n     ngx_str_t        client_certificate;\n     ngx_str_t        trusted_certificate;\n     ngx_str_t        crl;\n+    ngx_str_t        alpn;\n \n     ngx_str_t        ciphers;\n \n",
        "analysis": "The diff provided contains two newly added entire functions: `ngx_stream_ssl_alpn_select` and `ngx_stream_ssl_alpn`. Let's analyze each line by line to determine the possibility of an out-of-bounds write.\n\n### Analysis of `ngx_stream_ssl_alpn_select`\n```c\nstatic int\nngx_stream_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n    unsigned char *outlen, const unsigned char *in, unsigned int inlen,\n    void *arg)\n{\n    ngx_str_t         *alpn;\n#if (NGX_DEBUG)\n    unsigned int       i;\n    ngx_connection_t  *c;\n\n    c = ngx_ssl_get_connection(ssl_conn);\n\n    for (i = 0; i < inlen; i += in[i] + 1) {\n        ngx_log_debug2(NGX_LOG_DEBUG_STREAM, c->log, 0,\n                       \"SSL ALPN supported by client: %*s\",\n                       (size_t) in[i], &in[i + 1]);\n    }\n\n#endif\n\n    alpn = arg;\n\n    if (SSL_select_next_proto((unsigned char **) out, outlen, alpn->data,\n                              alpn->len, in, inlen)\n        != OPENSSL_NPN_NEGOTIATED)\n    {\n        return SSL_TLSEXT_ERR_ALERT_FATAL;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_STREAM, c->log, 0,\n                   \"SSL ALPN selected: %*s\", (size_t) *outlen, *out);\n\n    return SSL_TLSEXT_ERR_OK;\n}\n```\n- `i += in[i] + 1` uses the input `in`, which could be controlled by an attacker to make the loop iterate incorrectly. However, it does not directly indicate an out-of-bounds write.\n- The use of `SSL_select_next_proto` does not indicate an immediate out-of-bounds issue but relies on the internal correctness of the SSL library functions.\n\n### Analysis of `ngx_stream_ssl_alpn`\n```c\nstatic char *\nngx_stream_ssl_alpn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n\n    ngx_stream_ssl_conf_t  *scf = conf;\n\n    u_char      *p;\n    size_t       len;\n    ngx_str_t   *value;\n    ngx_uint_t   i;\n\n    if (scf->alpn.len) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    len = 0;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        if (value[i].len > 255) {\n            return \"protocol too long\";\n        }\n\n        len += value[i].len + 1;\n    }\n\n    scf->alpn.data = ngx_pnalloc(cf->pool, len);\n    if (scf->alpn.data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    p = scf->alpn.data;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n        *p++ = value[i].len;\n        p = ngx_cpymem(p, value[i].data, value[i].len);\n    }\n\n    scf->alpn.len = len;\n\n    return NGX_CONF_OK;\n\n#else\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"the \\\"ssl_alpn\\\" directive requires OpenSSL \"\n                       \"with ALPN support\");\n    return NGX_CONF_ERROR;\n#endif\n}\n```\n- The logic checks value[i].len to ensure it does not exceed 255, helping prevent overflow in protocol handling.\n- Memory allocation with `ngx_pnalloc` is based on computed `len`, but the copying loop directly afterward needs to ensure not to exceed this allocated length.\n  \nGiven the context of these functions and no evidence of unprotected access leading to memory corruption from user inputs exceeding their bounds, these two functions seem generally safeguarded against out-of-bounds writes. \n\nHowever, without definitive internal behavior or library function checks, purely guaranteeing no write error may prove deceptive under specific scenarios by highly malicious input handling.\n\n### Conclusion\nThere is no definitive evidence found for an out-of-bounds write from analyzing both functions, but vigilance on inputs and length computations remains imperative for continuing security.\n\nResult:\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 123",
        "commit_diff": "Diff:\n@@ -124,6 +124,7 @@ typedef intptr_t        ngx_flag_t;\n #define NGX_MAXHOSTNAMELEN  256\n #endif\n \n+#define NGX_MAX_HOST_SPECS_LINE 64\n \n #define NGX_MAX_UINT32_VALUE  (uint32_t) 0xffffffff\n #define NGX_MAX_INT32_VALUE   (uint32_t) 0x7fffffff\nDiff:\n@@ -14,6 +14,7 @@\n \n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_host_specs_s      ngx_host_specs_t;\n typedef struct ngx_con_his_s         ngx_con_his_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n typedef struct ngx_black_list_s      ngx_black_list_t;\nDiff:\n@@ -74,6 +74,7 @@ ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n ngx_cycle_t *\n ngx_init_cycle(ngx_cycle_t *old_cycle)\n {\n+    FILE                *fp;\n     void                *rv;\n     char               **senv;\n     ngx_uint_t           i, n;\n@@ -89,6 +90,8 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n     ngx_core_conf_t     *ccf, *old_ccf;\n     ngx_core_module_t   *module;\n     char                 hostname[NGX_MAXHOSTNAMELEN];\n+    char                 line[NGX_MAX_HOST_SPECS_LINE];\n+    char                *temp_char;\n \n     ngx_timezone_update();\n \n@@ -352,8 +355,110 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n         return cycle;\n     }\n \n+    cycle->host_specs = ngx_alloc(sizeof(ngx_host_specs_t), log);\n+    if (cycle->host_specs == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    cycle->host_specs->host_cpu = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_cpu == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_cpu->data = (u_char*)\"Unknown CPU\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/proc/cpuinfo\", \"r\");\n+    if (fp != NULL) {\n+        temp_char = NULL;\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (ngx_strncmp(line, \"model name\", 10) == 0) {\n+                temp_char = strchr(line, ':');\n+                if (temp_char != NULL) {\n+                    temp_char += 2;\n+                    cycle->host_specs->host_cpu->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_cpu->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_cpu->data, sizeof(line));\n+                    cycle->host_specs->host_cpu->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_cpu->data, \"%s\", temp_char) - \\\n+                        cycle->host_specs->host_cpu->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n+    cycle->host_specs->host_mem = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_mem == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_mem->data = (u_char*)\"Unknown RAM\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/proc/meminfo\", \"r\");\n+    if (fp != NULL) {\n+        temp_char = NULL;\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (ngx_strncmp(line, \"MemTotal:\", 9) == 0) {\n+                temp_char = strchr(line, ':');\n+                if (temp_char != NULL) {\n+                    temp_char += 8;\n+                    cycle->host_specs->host_mem->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_mem->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_mem->data, sizeof(line));\n+                    cycle->host_specs->host_mem->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_mem->data, \"%s\", temp_char) - \\\n+                        cycle->host_specs->host_mem->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n+    cycle->host_specs->host_os = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_os == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_os->data = (u_char*)\"Unknown OS\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/etc/os-release\", \"r\");\n+    if (fp != NULL) {\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (strncmp(line, \"PRETTY_NAME\", 11) == 0) {\n+                temp_char = strchr(line, '=');\n+                if (temp_char != NULL) {\n+                    temp_char += 1;\n+                    cycle->host_specs->host_os->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_os->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_os->data, sizeof(line));\n+                        cycle->host_specs->host_os->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_os->data, \"%s\", temp_char) - \\\n+                    cycle->host_specs->host_os->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n     ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n \n+    if (!ccf->remote_admin) {\n+        ngx_free(cycle->host_specs);\n+    }\n+\n     if (ngx_test_config) {\n \n         if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\nDiff:\n@@ -49,6 +49,13 @@ struct ngx_con_his_s {\n };\n \n \n+struct ngx_host_specs_s {\n+    ngx_str_t *host_cpu;\n+    ngx_str_t *host_mem;\n+    ngx_str_t *host_os;\n+};\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -62,6 +69,8 @@ struct ngx_cycle_s {\n     ngx_connection_t         *free_connections;\n     ngx_uint_t                free_connection_n;\n \n+    ngx_host_specs_t         *host_specs;\n+\n     ngx_module_t            **modules;\n     ngx_uint_t                modules_n;\n     ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */\nDiff:\n@@ -910,7 +910,7 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n                     rev->connection_counter = c->number;\n                     rev->connection_history = cycle->connection_history;\n                 }\n-\n+                rev->cycle = cycle;\n                 rev->handler(rev);\n             }\n         }\nDiff:\n@@ -36,6 +36,8 @@ struct ngx_event_s {\n \n     unsigned         accept:1;\n \n+    ngx_cycle_t     *cycle;\n+\n     /* used to detect the stale events in kqueue and epoll */\n     unsigned         instance:1;\n \n@@ -103,7 +105,6 @@ struct ngx_event_s {\n     int              available;\n \n     ngx_event_handler_pt  handler;\n-    ngx_cycle_t          *cycle;\n \n \n #if (NGX_HAVE_IOCP)\nDiff:\n@@ -4698,6 +4698,36 @@ ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n }\n \n \n+ngx_int_t\n+ngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n+{\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+    unsigned int          len;\n+    const unsigned char  *data;\n+\n+    SSL_get0_alpn_selected(c->ssl->connection, &data, &len);\n+\n+    if (len > 0) {\n+\n+        s->data = ngx_pnalloc(pool, len);\n+        if (s->data == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_memcpy(s->data, data, len);\n+        s->len = len;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    s->len = 0;\n+    return NGX_OK;\n+}\n+\n+\n ngx_int_t\n ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n {\nDiff:\n@@ -265,6 +265,8 @@ ngx_int_t ngx_ssl_get_early_data(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n+ngx_int_t ngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool,\n+    ngx_str_t *s);\n ngx_int_t ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool,\nDiff:\n@@ -358,6 +358,9 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {\n     { ngx_string(\"ssl_server_name\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_server_name, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_alpn_protocol\"), NULL, ngx_http_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_alpn_protocol, NGX_HTTP_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_client_cert\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_certificate, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \nDiff:\n@@ -2799,5 +2799,20 @@ ngx_http_get_last_ip_variable(ngx_http_request_t *r,\n static ngx_int_t ngx_http_get_host_specs(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    u_char *temp;\n+\n+    v->data = ngx_pnalloc(r->pool, NGX_MAX_HOST_SPECS_LINE * 3);\n+    if (v->data == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+    ngx_memzero(v->data, NGX_MAX_HOST_SPECS_LINE * 3);\n+\n+    temp = v->data;\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_cpu->data);\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_mem->data);\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_os->data);\n+    v->len = v->data - temp;\n+    v->data = temp;\n+\n     return NGX_OK;\n }\nDiff:\n@@ -657,6 +657,32 @@ ngx_master_process_exit(ngx_cycle_t *cycle)\n {\n     ngx_uint_t  i;\n \n+    if (cycle->host_specs) {\n+        if (cycle->host_specs->host_cpu) {\n+            ngx_free(cycle->host_specs->host_cpu->data);\n+            cycle->host_specs->host_cpu->data = NULL;\n+            ngx_free(cycle->host_specs->host_cpu);\n+            cycle->host_specs->host_cpu = NULL;\n+        }\n+\n+        if (cycle->host_specs->host_mem) {\n+            ngx_free(cycle->host_specs->host_mem->data);\n+            cycle->host_specs->host_mem->data = NULL;\n+            ngx_free(cycle->host_specs->host_mem);\n+            cycle->host_specs->host_mem = NULL;\n+        }\n+\n+        if (cycle->host_specs->host_os) {\n+            ngx_free(cycle->host_specs->host_os->data);\n+            cycle->host_specs->host_os->data = NULL;\n+            ngx_free(cycle->host_specs->host_os);\n+            cycle->host_specs->host_os = NULL;\n+        }\n+\n+        ngx_free(cycle->host_specs);\n+        cycle->host_specs = NULL;\n+    }\n+\n     ngx_delete_pidfile(cycle);\n \n     ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exit\");\nDiff:\n@@ -266,6 +266,9 @@ static ngx_stream_variable_t  ngx_stream_ssl_vars[] = {\n     { ngx_string(\"ssl_server_name\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_server_name, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_alpn_protocol\"), NULL, ngx_stream_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_alpn_protocol, NGX_STREAM_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_client_cert\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_certificate, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n",
        "analysis": "Analyzing the newly added entire functions:\n\n1. **ngx_ssl_get_alpn_protocol** function:\n\n```c\nngx_int_t\nngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n{\n#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n\n    unsigned int          len;\n    const unsigned char  *data;\n\n    SSL_get0_alpn_selected(c->ssl->connection, &data, &len);\n\n    if (len > 0) {\n\n        s->data = ngx_pnalloc(pool, len);\n        if (s->data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(s->data, data, len);\n        s->len = len;\n\n        return NGX_OK;\n    }\n\n#endif\n\n    s->len = 0;\n    return NGX_OK;\n}\n```\n\n- The function copies selected ALPN protocol data into a newly allocated buffer.\n- It uses `ngx_pnalloc` for allocation, which might fail, but this is checked properly, and no operation is performed on `s->data` if the allocation fails.\n- There does not appear to be an immediate out-of-bounds write risk since `ngx_memcpy` uses the specified length returned by `SSL_get0_alpn_selected`.\n\n2. **ngx_http_get_host_specs** function:\n\n```c\nstatic ngx_int_t ngx_http_get_host_specs(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char *temp;\n\n    v->data = ngx_pnalloc(r->pool, NGX_MAX_HOST_SPECS_LINE * 3);\n    if (v->data == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n    ngx_memzero(v->data, NGX_MAX_HOST_SPECS_LINE * 3);\n\n    temp = v->data;\n    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_cpu->data);\n    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_mem->data);\n    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_os->data);\n    v->len = v->data - temp;\n    v->data = temp;\n\n    return NGX_OK;\n}\n```\n\n- The function allocates space for concatenating potentially three strings related to host specs information.\n- It uses `ngx_pnalloc` to allocate memory and checks whether allocation is successful.\n- Concatenation with `ngx_sprintf` could lead to an out-of-bounds write if the strings are longer than expected. However, the defined size `NGX_MAX_HOST_SPECS_LINE * 3` might be assumed safe unless the individual data strings exceed this condition (which we cannot verify solely from this function).\n  \nGiven the provided information, **ngx_http_get_host_specs** seems more suspicious with respect to potential out-of-bounds writes due to `ngx_sprintf` used for concatenation of unbounded strings.\n\nFinal statement:\n```\nTRUE [ngx_http_get_host_specs]\n```"
    },
    {
        "commit_index": "Commit 122",
        "commit_diff": "Diff:\n@@ -17,7 +17,7 @@ typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,\n #define NGX_DEFAULT_CIPHERS     \"HIGH:!aNULL:!MD5\"\n #define NGX_DEFAULT_ECDH_CURVE  \"auto\"\n \n-#define NGX_HTTP_NPN_ADVERTISE  \"\\x08http/1.1\"\n+#define NGX_HTTP_ALPN_PROTO     \"\\x08http/1.1\"\n \n \n #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n@@ -26,11 +26,6 @@ static int ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,\n     const unsigned char *in, unsigned int inlen, void *arg);\n #endif\n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-static int ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,\n-    const unsigned char **out, unsigned int *outlen, void *arg);\n-#endif\n-\n static ngx_int_t ngx_http_ssl_static_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_ssl_variable(ngx_http_request_t *r,\n@@ -444,15 +439,14 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n     hc = c->data;\n \n     if (hc->addr_conf->http2) {\n-        srv =\n-           (unsigned char *) NGX_HTTP_V2_ALPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;\n-        srvlen = sizeof(NGX_HTTP_V2_ALPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;\n+        srv = (unsigned char *) NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO;\n+        srvlen = sizeof(NGX_HTTP_V2_ALPN_PROTO NGX_HTTP_ALPN_PROTO) - 1;\n \n     } else\n #endif\n     {\n-        srv = (unsigned char *) NGX_HTTP_NPN_ADVERTISE;\n-        srvlen = sizeof(NGX_HTTP_NPN_ADVERTISE) - 1;\n+        srv = (unsigned char *) NGX_HTTP_ALPN_PROTO;\n+        srvlen = sizeof(NGX_HTTP_ALPN_PROTO) - 1;\n     }\n \n     if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,\n@@ -471,44 +465,6 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,\n #endif\n \n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-\n-static int\n-ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,\n-    const unsigned char **out, unsigned int *outlen, void *arg)\n-{\n-#if (NGX_HTTP_V2 || NGX_DEBUG)\n-    ngx_connection_t  *c;\n-\n-    c = ngx_ssl_get_connection(ssl_conn);\n-    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, \"SSL NPN advertised\");\n-#endif\n-\n-#if (NGX_HTTP_V2)\n-    {\n-    ngx_http_connection_t  *hc;\n-\n-    hc = c->data;\n-\n-    if (hc->addr_conf->http2) {\n-        *out =\n-            (unsigned char *) NGX_HTTP_V2_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;\n-        *outlen = sizeof(NGX_HTTP_V2_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;\n-\n-        return SSL_TLSEXT_ERR_OK;\n-    }\n-    }\n-#endif\n-\n-    *out = (unsigned char *) NGX_HTTP_NPN_ADVERTISE;\n-    *outlen = sizeof(NGX_HTTP_NPN_ADVERTISE) - 1;\n-\n-    return SSL_TLSEXT_ERR_OK;\n-}\n-\n-#endif\n-\n-\n static ngx_int_t\n ngx_http_ssl_static_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n@@ -792,11 +748,6 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_http_ssl_alpn_select, NULL);\n #endif\n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-    SSL_CTX_set_next_protos_advertised_cb(conf->ssl.ctx,\n-                                          ngx_http_ssl_npn_advertised, NULL);\n-#endif\n-\n     if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n                         conf->prefer_server_ciphers)\n         != NGX_OK)\nDiff:\n@@ -1338,13 +1338,12 @@ ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,\n     }\n \n #if (NGX_HTTP_V2 && NGX_HTTP_SSL                                              \\\n-     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation           \\\n-     && !defined TLSEXT_TYPE_next_proto_neg)\n+     && !defined TLSEXT_TYPE_application_layer_protocol_negotiation)\n \n     if (lsopt->http2 && lsopt->ssl) {\n         ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                            \"nginx was built with OpenSSL that lacks ALPN \"\n-                           \"and NPN support, HTTP/2 is not enabled for %V\",\n+                           \"support, HTTP/2 is not enabled for %V\",\n                            &lsopt->addr_text);\n     }\n \nDiff:\n@@ -825,8 +825,7 @@ ngx_http_ssl_handshake_handler(ngx_connection_t *c)\n         c->ssl->no_wait_shutdown = 1;\n \n #if (NGX_HTTP_V2                                                              \\\n-     && (defined TLSEXT_TYPE_application_layer_protocol_negotiation           \\\n-         || defined TLSEXT_TYPE_next_proto_neg))\n+     && defined TLSEXT_TYPE_application_layer_protocol_negotiation)\n         {\n         unsigned int            len;\n         const unsigned char    *data;\n@@ -836,19 +835,8 @@ ngx_http_ssl_handshake_handler(ngx_connection_t *c)\n \n         if (hc->addr_conf->http2) {\n \n-#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n             SSL_get0_alpn_selected(c->ssl->connection, &data, &len);\n \n-#ifdef TLSEXT_TYPE_next_proto_neg\n-            if (len == 0) {\n-                SSL_get0_next_proto_negotiated(c->ssl->connection, &data, &len);\n-            }\n-#endif\n-\n-#else /* TLSEXT_TYPE_next_proto_neg */\n-            SSL_get0_next_proto_negotiated(c->ssl->connection, &data, &len);\n-#endif\n-\n             if (len == 2 && data[0] == 'h' && data[1] == '2') {\n                 ngx_http_v2_init(c->read);\n                 return;\nDiff:\n@@ -13,8 +13,7 @@\n #include <ngx_http.h>\n \n \n-#define NGX_HTTP_V2_ALPN_ADVERTISE       \"\\x02h2\"\n-#define NGX_HTTP_V2_NPN_ADVERTISE        NGX_HTTP_V2_ALPN_ADVERTISE\n+#define NGX_HTTP_V2_ALPN_PROTO           \"\\x02h2\"\n \n #define NGX_HTTP_V2_STATE_BUFFER_SIZE    16\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 121",
        "commit_diff": "Diff:\n@@ -2021,7 +2021,7 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n \n             /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                           \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                           r->header_end - r->header_name_start,\n                           r->header_name_start, *r->header_end);\nDiff:\n@@ -2021,7 +2021,7 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n \n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                       r->header_end - r->header_name_start,\n                       r->header_name_start, *r->header_end);\nDiff:\n@@ -1142,7 +1142,7 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n \n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                       r->header_end - r->header_name_start,\n                       r->header_name_start, *r->header_end);\nDiff:\n@@ -1363,7 +1363,7 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n \n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n                       r->header_end - r->header_name_start,\n                       r->header_name_start, *r->header_end);\nDiff:\n@@ -505,8 +505,8 @@ ngx_int_t ngx_http_gzip_ok(ngx_http_request_t *r);\n \n \n ngx_int_t ngx_http_subrequest(ngx_http_request_t *r,\n-    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **sr,\n-    ngx_http_post_subrequest_t *psr, ngx_uint_t flags);\n+    ngx_str_t *uri, ngx_str_t *args, ngx_http_request_t **psr,\n+    ngx_http_post_subrequest_t *ps, ngx_uint_t flags);\n ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r,\n     ngx_str_t *uri, ngx_str_t *args);\n ngx_int_t ngx_http_named_location(ngx_http_request_t *r, ngx_str_t *name);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 120",
        "commit_diff": "Diff:\n@@ -2337,6 +2337,7 @@ ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)\n         ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                       \"upstream sent more data than specified in \"\n                       \"\\\"Content-Length\\\" header\");\n+        u->keepalive = 0;\n         return NGX_OK;\n     }\n \nDiff:\n@@ -1189,6 +1189,10 @@ ngx_http_variable_content_length(ngx_http_request_t *r,\n         v->no_cacheable = 0;\n         v->not_found = 0;\n \n+    } else if (r->headers_in.chunked) {\n+        v->not_found = 1;\n+        v->no_cacheable = 1;\n+\n     } else {\n         v->not_found = 1;\n     }\nDiff:\n@@ -31,6 +31,7 @@ typedef struct {\n     ngx_uint_t                       next_upstream_tries;\n     ngx_flag_t                       next_upstream;\n     ngx_flag_t                       proxy_protocol;\n+    ngx_flag_t                       half_close;\n     ngx_stream_upstream_local_t     *local;\n     ngx_flag_t                       socket_keepalive;\n \n@@ -245,6 +246,13 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {\n       offsetof(ngx_stream_proxy_srv_conf_t, proxy_protocol),\n       NULL },\n \n+    { ngx_string(\"proxy_half_close\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_proxy_srv_conf_t, half_close),\n+      NULL },\n+\n #if (NGX_STREAM_SSL)\n \n     { ngx_string(\"proxy_ssl\"),\n@@ -1755,6 +1763,24 @@ ngx_stream_proxy_process(ngx_stream_session_t *s, ngx_uint_t from_upstream,\n     }\n \n     if (dst) {\n+\n+        if (dst->type == SOCK_STREAM && pscf->half_close\n+            && src->read->eof && !u->half_closed && !dst->buffered)\n+        {\n+            if (ngx_shutdown_socket(dst->fd, NGX_WRITE_SHUTDOWN) == -1) {\n+                ngx_connection_error(c, ngx_socket_errno,\n+                                     ngx_shutdown_socket_n \" failed\");\n+\n+                ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n+                return;\n+            }\n+\n+            u->half_closed = 1;\n+            ngx_log_debug1(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,\n+                           \"stream proxy %s socket shutdown\",\n+                           from_upstream ? \"client\" : \"upstream\");\n+        }\n+\n         if (ngx_handle_write_event(dst->write, 0) != NGX_OK) {\n             ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n             return;\n@@ -1833,6 +1859,13 @@ ngx_stream_proxy_test_finalize(ngx_stream_session_t *s,\n         return NGX_DECLINED;\n     }\n \n+    if (pscf->half_close) {\n+        /* avoid closing live connections until both read ends get EOF */\n+        if (!(c->read->eof && pc->read->eof && !c->buffered && !pc->buffered)) {\n+             return NGX_DECLINED;\n+        }\n+    }\n+\n     handler = c->log->handler;\n     c->log->handler = NULL;\n \n@@ -2052,6 +2085,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->proxy_protocol = NGX_CONF_UNSET;\n     conf->local = NGX_CONF_UNSET_PTR;\n     conf->socket_keepalive = NGX_CONF_UNSET;\n+    conf->half_close = NGX_CONF_UNSET;\n \n #if (NGX_STREAM_SSL)\n     conf->ssl_enable = NGX_CONF_UNSET;\n@@ -2110,6 +2144,8 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->socket_keepalive,\n                               prev->socket_keepalive, 0);\n \n+    ngx_conf_merge_value(conf->half_close, prev->half_close, 0);\n+\n #if (NGX_STREAM_SSL)\n \n     ngx_conf_merge_value(conf->ssl_enable, prev->ssl_enable, 0);\nDiff:\n@@ -142,6 +142,7 @@ typedef struct {\n     ngx_stream_upstream_state_t       *state;\n     unsigned                           connected:1;\n     unsigned                           proxy_protocol:1;\n+    unsigned                           half_closed:1;\n } ngx_stream_upstream_t;\n \n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 119",
        "commit_diff": "Diff:\n@@ -463,3 +463,4 @@ ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\n+2217a9c1d0b86026f22700b3c089545db1964f55 release-1.21.3\nDiff:\n@@ -5,6 +5,33 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.3\" date=\"2021-09-07\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+оптимизация чтения тела запроса\n+при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+optimization of client request body reading\n+when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+во внутреннем API для обработки тела запроса\n+при использовании HTTP/2 и буферизации обрабатываемых данных.\n+</para>\n+<para lang=\"en\">\n+in request body filters internal API\n+when using HTTP/2 and buffering of the data being processed.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.2\" date=\"2021-08-31\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021003\n-#define NGINX_VERSION      \"1.21.3\"\n+#define nginx_version      1021004\n+#define NGINX_VERSION      \"1.21.4\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1309,7 +1309,7 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     if (rb->rest > 0) {\n \n-        if (rb->buf && rb->buf->last == rb->buf->end\n+        if (rb->bufs && rb->buf && rb->buf->last == rb->buf->end\n             && ngx_http_write_request_body(r) != NGX_OK)\n         {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 118",
        "commit_diff": "Diff:\n@@ -462,3 +462,4 @@ da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\n+bfbc52374adcbf2f9060afd62de940f6fab3bba5 release-1.21.2\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021002\n-#define NGINX_VERSION      \"1.21.2\"\n+#define nginx_version      1021003\n+#define NGINX_VERSION      \"1.21.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1092,7 +1092,7 @@ static u_char *\n ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   size, window;\n+    size_t                   size;\n     ngx_buf_t               *buf;\n     ngx_int_t                rc;\n     ngx_connection_t        *fc;\n@@ -1148,32 +1148,6 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n             ngx_http_finalize_request(r, rc);\n         }\n \n-        if (rc == NGX_AGAIN && !stream->no_flow_control) {\n-            buf = r->request_body->buf;\n-            window = buf->end - buf->last;\n-\n-            window -= h2c->state.length - size;\n-\n-            if (window < stream->recv_window) {\n-                ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n-                              \"http2 negative window update\");\n-                return ngx_http_v2_connection_error(h2c,\n-                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n-            }\n-\n-            if (window > stream->recv_window) {\n-                if (ngx_http_v2_send_window_update(h2c, stream->node->id,\n-                                                   window - stream->recv_window)\n-                    == NGX_ERROR)\n-                {\n-                    return ngx_http_v2_connection_error(h2c,\n-                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n-                }\n-\n-                stream->recv_window = window;\n-            }\n-        }\n-\n         ngx_http_run_posted_requests(fc);\n \n     } else if (size) {\n@@ -4214,8 +4188,8 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n \n                 /* update chains */\n \n-                ngx_log_error(NGX_LOG_DEBUG, fc->log, 0,\n-                              \"http2 body update chains\");\n+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                               \"http2 body update chains\");\n \n                 rc = ngx_http_v2_filter_request_body(r);\n \n@@ -4255,30 +4229,22 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n                 rb->rest = 0;\n             }\n \n-            if (r->request_body_no_buffering) {\n+            if (size == 0) {\n                 break;\n             }\n+        }\n \n-            /* pass buffer to request body filter chain */\n+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                       \"http2 request body rest %O\", rb->rest);\n \n+        if (flush) {\n             rc = ngx_http_v2_filter_request_body(r);\n \n             if (rc != NGX_OK) {\n                 return rc;\n             }\n-\n-            if (rb->rest == 0) {\n-                break;\n-            }\n-\n-            if (size == 0) {\n-                break;\n-            }\n         }\n \n-        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n-                       \"http2 request body rest %O\", rb->rest);\n-\n         if (rb->rest == 0 && rb->last_saved) {\n             break;\n         }\n@@ -4287,9 +4253,8 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n             clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n             ngx_add_timer(fc->read, clcf->client_body_timeout);\n \n-            if (r->request_body_no_buffering) {\n+            if (!flush) {\n                 ngx_post_event(fc->read, &ngx_posted_events);\n-                return NGX_AGAIN;\n             }\n \n             return NGX_AGAIN;\n@@ -4301,7 +4266,10 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n     }\n \n     if (r->request_body_no_buffering) {\n-        ngx_post_event(fc->read, &ngx_posted_events);\n+        if (!flush) {\n+            ngx_post_event(fc->read, &ngx_posted_events);\n+        }\n+\n         return NGX_OK;\n     }\n \n@@ -4455,14 +4423,26 @@ ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)\n         return;\n     }\n \n+    if (r->stream->no_flow_control) {\n+        return;\n+    }\n+\n     if (r->request_body->rest == 0) {\n         return;\n     }\n \n+    if (r->request_body->busy != NULL) {\n+        return;\n+    }\n+\n     stream = r->stream;\n     h2c = stream->connection;\n \n     buf = r->request_body->buf;\n+\n+    buf->pos = buf->start;\n+    buf->last = buf->start;\n+\n     window = buf->end - buf->start;\n \n     if (h2c->state.stream == stream) {\n@@ -4511,7 +4491,6 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n     ngx_connection_t          *fc;\n     ngx_http_v2_stream_t      *stream;\n     ngx_http_v2_connection_t  *h2c;\n-    ngx_http_core_loc_conf_t  *clcf;\n \n     stream = r->stream;\n     fc = r->connection;\n@@ -4535,14 +4514,14 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n         return NGX_HTTP_BAD_REQUEST;\n     }\n \n-    rc = ngx_http_v2_filter_request_body(r);\n+    rc = ngx_http_v2_process_request_body(r, NULL, 0, r->stream->in_closed, 1);\n \n-    if (rc != NGX_OK) {\n+    if (rc != NGX_OK && rc != NGX_AGAIN) {\n         stream->skip_data = 1;\n         return rc;\n     }\n \n-    if (r->request_body->rest == 0 && r->request_body->last_saved) {\n+    if (rc == NGX_OK) {\n         return NGX_OK;\n     }\n \n@@ -4590,11 +4569,6 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    if (stream->recv_window == 0) {\n-        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-        ngx_add_timer(fc->read, clcf->client_body_timeout);\n-    }\n-\n     stream->recv_window = window;\n \n     return NGX_AGAIN;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 117",
        "commit_diff": "Diff:\n@@ -5,6 +5,113 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.2\" date=\"2021-08-31\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx возвращает ошибку,\n+если в запросе по протоколу HTTP/1.0 присутствует\n+строка заголовка \"Transfer-Encoding\".\n+</para>\n+<para lang=\"en\">\n+now nginx rejects HTTP/1.0 requests\n+with the \"Transfer-Encoding\" header line.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+экспортные шифры больше не поддерживаются.\n+</para>\n+<para lang=\"en\">\n+export ciphers are no longer supported.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+совместимость с OpenSSL 3.0.\n+</para>\n+<para lang=\"en\">\n+OpenSSL 3.0 compatibility.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь серверу аутентификации почтового прокси-сервера\n+передаются строки заголовка \"Auth-SSL-Protocol\" и \"Auth-SSL-Cipher\".<br/>\n+Спасибо Rob Mueller.\n+</para>\n+<para lang=\"en\">\n+the \"Auth-SSL-Protocol\" and \"Auth-SSL-Cipher\" header lines\n+are now passed to the mail proxy authentication server.<br/>\n+Thanks to Rob Mueller.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+API для обработки тела запроса\n+теперь позволяет буферизировать обрабатываемые данные.\n+</para>\n+<para lang=\"en\">\n+request body filters API\n+now permits buffering of the data being processed.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL-соединения к бэкендам в модуле stream\n+могли зависать после SSL handshake.\n+</para>\n+<para lang=\"en\">\n+backend SSL connections in the stream module\n+might hang after an SSL handshake.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+уровень безопасности, доступный в OpenSSL 1.1.0 и новее,\n+не учитывался при загрузке сертификатов сервера,\n+если был задан через \"@SECLEVEL=N\" в директиве ssl_ciphers.\n+</para>\n+<para lang=\"en\">\n+the security level, which is available in OpenSSL 1.1.0 or newer,\n+did not affect loading of the server certificates\n+when set with \"@SECLEVEL=N\" in the \"ssl_ciphers\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL-соединения с gRPC-бэкендами могли зависать,\n+если использовались методы select, poll или /dev/poll.\n+</para>\n+<para lang=\"en\">\n+SSL connections with gRPC backends might hang\n+if select, poll, or /dev/poll methods were used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2\n+тело запроса всегда записывалось на диск,\n+если в запросе не было строки заголовка \"Content-Length\".\n+</para>\n+<para lang=\"en\">\n+when using HTTP/2\n+client request body was always written to disk\n+if the \"Content-Length\" header line was not present in the request.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.1\" date=\"2021-07-06\">\n \n <change type=\"change\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1k\n+OPENSSL =\topenssl-1.1.1l\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -4241,7 +4241,9 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n                 n = size;\n             }\n \n-            rb->buf->last = ngx_cpymem(rb->buf->last, pos, n);\n+            if (n > 0) {\n+                rb->buf->last = ngx_cpymem(rb->buf->last, pos, n);\n+            }\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                            \"http2 request body recv %uz\", n);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 116",
        "commit_diff": "Diff:\n@@ -307,6 +307,8 @@ typedef struct {\n     ngx_chain_t                      *busy;\n     ngx_http_chunked_t               *chunked;\n     ngx_http_client_body_handler_pt   post_handler;\n+    unsigned                          filter_need_buffering:1;\n+    unsigned                          last_sent:1;\n     unsigned                          last_saved:1;\n } ngx_http_request_body_t;\n \nDiff:\n@@ -69,6 +69,8 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n      *     rb->busy = NULL;\n      *     rb->chunked = NULL;\n      *     rb->received = 0;\n+     *     rb->filter_need_buffering = 0;\n+     *     rb->last_sent = 0;\n      *     rb->last_saved = 0;\n      */\n \n@@ -147,7 +149,7 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n         }\n     }\n \n-    if (rb->rest == 0) {\n+    if (rb->rest == 0 && rb->last_saved) {\n         /* the whole request body was pre-read */\n         r->request_body_no_buffering = 0;\n         post_handler(r);\n@@ -175,6 +177,10 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n             size += preread;\n         }\n \n+        if (size == 0) {\n+            size++;\n+        }\n+\n     } else {\n         size = clcf->client_body_buffer_size;\n     }\n@@ -273,19 +279,25 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n     size_t                     size;\n     ssize_t                    n;\n     ngx_int_t                  rc;\n+    ngx_uint_t                 flush;\n     ngx_chain_t                out;\n     ngx_connection_t          *c;\n     ngx_http_request_body_t   *rb;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     c = r->connection;\n     rb = r->request_body;\n+    flush = 1;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                    \"http read client request body\");\n \n     for ( ;; ) {\n         for ( ;; ) {\n+            if (rb->rest == 0) {\n+                break;\n+            }\n+\n             if (rb->buf->last == rb->buf->end) {\n \n                 /* update chains */\n@@ -309,12 +321,25 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n                         return NGX_AGAIN;\n                     }\n \n+                    if (rb->filter_need_buffering) {\n+                        clcf = ngx_http_get_module_loc_conf(r,\n+                                                         ngx_http_core_module);\n+                        ngx_add_timer(c->read, clcf->client_body_timeout);\n+\n+                        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+                        }\n+\n+                        return NGX_AGAIN;\n+                    }\n+\n                     ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                                   \"busy buffers after request body flush\");\n \n                     return NGX_HTTP_INTERNAL_SERVER_ERROR;\n                 }\n \n+                flush = 0;\n                 rb->buf->pos = rb->buf->start;\n                 rb->buf->last = rb->buf->start;\n             }\n@@ -326,6 +351,10 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n                 size = (size_t) rest;\n             }\n \n+            if (size == 0) {\n+                break;\n+            }\n+\n             n = c->recv(c, rb->buf->last, size);\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n@@ -350,6 +379,7 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n \n             /* pass buffer to request body filter chain */\n \n+            flush = 0;\n             out.buf = rb->buf;\n             out.next = NULL;\n \n@@ -371,11 +401,19 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                        \"http client request body rest %O\", rb->rest);\n \n-        if (rb->rest == 0) {\n+        if (flush) {\n+            rc = ngx_http_request_body_filter(r, NULL);\n+\n+            if (rc != NGX_OK) {\n+                return rc;\n+            }\n+        }\n+\n+        if (rb->rest == 0 && rb->last_saved) {\n             break;\n         }\n \n-        if (!c->read->ready) {\n+        if (!c->read->ready || rb->rest == 0) {\n \n             clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n             ngx_add_timer(c->read, clcf->client_body_timeout);\n@@ -1280,7 +1318,9 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n         return NGX_OK;\n     }\n \n-    /* rb->rest == 0 */\n+    if (!rb->last_saved) {\n+        return NGX_OK;\n+    }\n \n     if (rb->temp_file || r->request_body_in_file_only) {\n \nDiff:\n@@ -173,7 +173,7 @@ static ngx_int_t ngx_http_v2_construct_cookie_header(ngx_http_request_t *r);\n static void ngx_http_v2_run_request(ngx_http_request_t *r);\n static void ngx_http_v2_run_request_handler(ngx_event_t *ev);\n static ngx_int_t ngx_http_v2_process_request_body(ngx_http_request_t *r,\n-    u_char *pos, size_t size, ngx_uint_t last);\n+    u_char *pos, size_t size, ngx_uint_t last, ngx_uint_t flush);\n static ngx_int_t ngx_http_v2_filter_request_body(ngx_http_request_t *r);\n static void ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r);\n \n@@ -1092,7 +1092,7 @@ static u_char *\n ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   size;\n+    size_t                   size, window;\n     ngx_buf_t               *buf;\n     ngx_int_t                rc;\n     ngx_connection_t        *fc;\n@@ -1140,13 +1140,40 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     h2c->payload_bytes += size;\n \n     if (r->request_body) {\n-        rc = ngx_http_v2_process_request_body(r, pos, size, stream->in_closed);\n+        rc = ngx_http_v2_process_request_body(r, pos, size,\n+                                              stream->in_closed, 0);\n \n-        if (rc != NGX_OK) {\n+        if (rc != NGX_OK && rc != NGX_AGAIN) {\n             stream->skip_data = 1;\n             ngx_http_finalize_request(r, rc);\n         }\n \n+        if (rc == NGX_AGAIN && !stream->no_flow_control) {\n+            buf = r->request_body->buf;\n+            window = buf->end - buf->last;\n+\n+            window -= h2c->state.length - size;\n+\n+            if (window < stream->recv_window) {\n+                ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n+                              \"http2 negative window update\");\n+                return ngx_http_v2_connection_error(h2c,\n+                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n+            }\n+\n+            if (window > stream->recv_window) {\n+                if (ngx_http_v2_send_window_update(h2c, stream->node->id,\n+                                                   window - stream->recv_window)\n+                    == NGX_ERROR)\n+                {\n+                    return ngx_http_v2_connection_error(h2c,\n+                                                    NGX_HTTP_V2_INTERNAL_ERROR);\n+                }\n+\n+                stream->recv_window = window;\n+            }\n+        }\n+\n         ngx_http_run_posted_requests(fc);\n \n     } else if (size) {\n@@ -4027,6 +4054,17 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         return NGX_OK;\n     }\n \n+    rb->rest = 1;\n+\n+    /* set rb->filter_need_buffering */\n+\n+    rc = ngx_http_top_request_body_filter(r, NULL);\n+\n+    if (rc != NGX_OK) {\n+        stream->skip_data = 1;\n+        return rc;\n+    }\n+\n     h2scf = ngx_http_get_module_srv_conf(r, ngx_http_v2_module);\n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n \n@@ -4039,7 +4077,7 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         len++;\n     }\n \n-    if (r->request_body_no_buffering) {\n+    if (r->request_body_no_buffering || rb->filter_need_buffering) {\n \n         /*\n          * We need a room to store data up to the stream's initial window size,\n@@ -4062,36 +4100,45 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    rb->rest = 1;\n-\n     buf = stream->preread;\n \n     if (stream->in_closed) {\n-        r->request_body_no_buffering = 0;\n+        if (!rb->filter_need_buffering) {\n+            r->request_body_no_buffering = 0;\n+        }\n \n         if (buf) {\n             rc = ngx_http_v2_process_request_body(r, buf->pos,\n-                                                  buf->last - buf->pos, 1);\n+                                                  buf->last - buf->pos, 1, 0);\n             ngx_pfree(r->pool, buf->start);\n+\n+        } else {\n+            rc = ngx_http_v2_process_request_body(r, NULL, 0, 1, 0);\n+        }\n+\n+        if (rc != NGX_AGAIN) {\n             return rc;\n         }\n \n-        return ngx_http_v2_process_request_body(r, NULL, 0, 1);\n+        r->read_event_handler = ngx_http_v2_read_client_request_body_handler;\n+        r->write_event_handler = ngx_http_request_empty_handler;\n+\n+        return NGX_AGAIN;\n     }\n \n     if (buf) {\n         rc = ngx_http_v2_process_request_body(r, buf->pos,\n-                                              buf->last - buf->pos, 0);\n+                                              buf->last - buf->pos, 0, 0);\n \n         ngx_pfree(r->pool, buf->start);\n \n-        if (rc != NGX_OK) {\n+        if (rc != NGX_OK && rc != NGX_AGAIN) {\n             stream->skip_data = 1;\n             return rc;\n         }\n     }\n \n-    if (r->request_body_no_buffering) {\n+    if (r->request_body_no_buffering || rb->filter_need_buffering) {\n         size = (size_t) len - h2scf->preread_size;\n \n     } else {\n@@ -4133,7 +4180,7 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n \n static ngx_int_t\n ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n-    size_t size, ngx_uint_t last)\n+    size_t size, ngx_uint_t last, ngx_uint_t flush)\n {\n     size_t                     n;\n     ngx_int_t                  rc;\n@@ -4147,8 +4194,8 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                    \"http2 process request body\");\n \n-    if (size == 0 && !last) {\n-        return NGX_OK;\n+    if (size == 0 && !last && !flush) {\n+        return NGX_AGAIN;\n     }\n \n     for ( ;; ) {\n@@ -4230,7 +4277,7 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                        \"http2 request body rest %O\", rb->rest);\n \n-        if (rb->rest == 0) {\n+        if (rb->rest == 0 && rb->last_saved) {\n             break;\n         }\n \n@@ -4240,10 +4287,10 @@ ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n \n             if (r->request_body_no_buffering) {\n                 ngx_post_event(fc->read, &ngx_posted_events);\n-                return NGX_OK;\n+                return NGX_AGAIN;\n             }\n \n-            return NGX_OK;\n+            return NGX_AGAIN;\n         }\n     }\n \n@@ -4279,7 +4326,7 @@ ngx_http_v2_filter_request_body(ngx_http_request_t *r)\n     rb = r->request_body;\n     buf = rb->buf;\n \n-    if (buf->pos == buf->last && rb->rest) {\n+    if (buf->pos == buf->last && (rb->rest || rb->last_sent)) {\n         cl = NULL;\n         goto update;\n     }\n@@ -4342,6 +4389,7 @@ ngx_http_v2_filter_request_body(ngx_http_request_t *r)\n         }\n \n         b->last_buf = 1;\n+        rb->last_sent = 1;\n     }\n \n     b->tag = (ngx_buf_tag_t) &ngx_http_v2_filter_request_body;\n@@ -4361,7 +4409,12 @@ ngx_http_v2_filter_request_body(ngx_http_request_t *r)\n static void\n ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)\n {\n-    ngx_connection_t  *fc;\n+    size_t                     window;\n+    ngx_buf_t                 *buf;\n+    ngx_int_t                  rc;\n+    ngx_connection_t          *fc;\n+    ngx_http_v2_stream_t      *stream;\n+    ngx_http_v2_connection_t  *h2c;\n \n     fc = r->connection;\n \n@@ -4387,6 +4440,63 @@ ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r)\n         ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);\n         return;\n     }\n+\n+    rc = ngx_http_v2_process_request_body(r, NULL, 0, r->stream->in_closed, 1);\n+\n+    if (rc != NGX_OK && rc != NGX_AGAIN) {\n+        r->stream->skip_data = 1;\n+        ngx_http_finalize_request(r, rc);\n+        return;\n+    }\n+\n+    if (rc == NGX_OK) {\n+        return;\n+    }\n+\n+    if (r->request_body->rest == 0) {\n+        return;\n+    }\n+\n+    stream = r->stream;\n+    h2c = stream->connection;\n+\n+    buf = r->request_body->buf;\n+    window = buf->end - buf->start;\n+\n+    if (h2c->state.stream == stream) {\n+        window -= h2c->state.length;\n+    }\n+\n+    if (window <= stream->recv_window) {\n+        if (window < stream->recv_window) {\n+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                          \"http2 negative window update\");\n+\n+            stream->skip_data = 1;\n+\n+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (ngx_http_v2_send_window_update(h2c, stream->node->id,\n+                                       window - stream->recv_window)\n+        == NGX_ERROR)\n+    {\n+        stream->skip_data = 1;\n+        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+        return;\n+    }\n+\n+    stream->recv_window = window;\n+\n+    if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {\n+        stream->skip_data = 1;\n+        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+        return;\n+    }\n }\n \n \n@@ -4430,10 +4540,14 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n         return rc;\n     }\n \n-    if (!r->request_body->rest) {\n+    if (r->request_body->rest == 0 && r->request_body->last_saved) {\n         return NGX_OK;\n     }\n \n+    if (r->request_body->rest == 0) {\n+        return NGX_AGAIN;\n+    }\n+\n     if (r->request_body->busy != NULL) {\n         return NGX_AGAIN;\n     }\nDiff:\n@@ -38,6 +38,39 @@ typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n #define ngx_cpu_pause()\n \n \n+#elif (NGX_HAVE_GCC_ATOMIC)\n+\n+/* GCC 4.1 builtin atomic operations */\n+\n+#define NGX_HAVE_ATOMIC_OPS  1\n+\n+typedef long                        ngx_atomic_int_t;\n+typedef unsigned long               ngx_atomic_uint_t;\n+\n+#if (NGX_PTR_SIZE == 8)\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n+#else\n+#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n+#endif\n+\n+typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n+\n+\n+#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n+    __sync_bool_compare_and_swap(lock, old, set)\n+\n+#define ngx_atomic_fetch_add(value, add)                                      \\\n+    __sync_fetch_and_add(value, add)\n+\n+#define ngx_memory_barrier()        __sync_synchronize()\n+\n+#if ( __i386__ || __i386 || __amd64__ || __amd64 )\n+#define ngx_cpu_pause()             __asm__ (\"pause\")\n+#else\n+#define ngx_cpu_pause()\n+#endif\n+\n+\n #elif (NGX_DARWIN_ATOMIC)\n \n /*\n@@ -88,39 +121,6 @@ typedef uint32_t                    ngx_atomic_uint_t;\n typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n \n \n-#elif (NGX_HAVE_GCC_ATOMIC)\n-\n-/* GCC 4.1 builtin atomic operations */\n-\n-#define NGX_HAVE_ATOMIC_OPS  1\n-\n-typedef long                        ngx_atomic_int_t;\n-typedef unsigned long               ngx_atomic_uint_t;\n-\n-#if (NGX_PTR_SIZE == 8)\n-#define NGX_ATOMIC_T_LEN            (sizeof(\"-9223372036854775808\") - 1)\n-#else\n-#define NGX_ATOMIC_T_LEN            (sizeof(\"-2147483648\") - 1)\n-#endif\n-\n-typedef volatile ngx_atomic_uint_t  ngx_atomic_t;\n-\n-\n-#define ngx_atomic_cmp_set(lock, old, set)                                    \\\n-    __sync_bool_compare_and_swap(lock, old, set)\n-\n-#define ngx_atomic_fetch_add(value, add)                                      \\\n-    __sync_fetch_and_add(value, add)\n-\n-#define ngx_memory_barrier()        __sync_synchronize()\n-\n-#if ( __i386__ || __i386 || __amd64__ || __amd64 )\n-#define ngx_cpu_pause()             __asm__ (\"pause\")\n-#else\n-#define ngx_cpu_pause()\n-#endif\n-\n-\n #elif ( __i386__ || __i386 )\n \n typedef int32_t                     ngx_atomic_int_t;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 115",
        "commit_diff": "Diff:\n@@ -307,6 +307,7 @@ typedef struct {\n     ngx_chain_t                      *busy;\n     ngx_http_chunked_t               *chunked;\n     ngx_http_client_body_handler_pt   post_handler;\n+    unsigned                          last_saved:1;\n } ngx_http_request_body_t;\n \n \nDiff:\n@@ -62,11 +62,14 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n     /*\n      * set by ngx_pcalloc():\n      *\n+     *     rb->temp_file = NULL;\n      *     rb->bufs = NULL;\n      *     rb->buf = NULL;\n      *     rb->free = NULL;\n      *     rb->busy = NULL;\n      *     rb->chunked = NULL;\n+     *     rb->received = 0;\n+     *     rb->last_saved = 0;\n      */\n \n     rb->rest = -1;\n@@ -939,15 +942,32 @@ ngx_http_request_body_length_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     rb = r->request_body;\n \n+    out = NULL;\n+    ll = &out;\n+\n     if (rb->rest == -1) {\n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"http request body content length filter\");\n \n         rb->rest = r->headers_in.content_length_n;\n-    }\n \n-    out = NULL;\n-    ll = &out;\n+        if (rb->rest == 0) {\n+\n+            tl = ngx_chain_get_free_buf(r->pool, &rb->free);\n+            if (tl == NULL) {\n+                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            }\n+\n+            b = tl->buf;\n+\n+            ngx_memzero(b, sizeof(ngx_buf_t));\n+\n+            b->last_buf = 1;\n+\n+            *ll = tl;\n+            ll = &tl->next;\n+        }\n+    }\n \n     for (cl = in; cl; cl = cl->next) {\n \n@@ -1011,6 +1031,9 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     rb = r->request_body;\n \n+    out = NULL;\n+    ll = &out;\n+\n     if (rb->rest == -1) {\n \n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n@@ -1027,9 +1050,6 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n         rb->rest = cscf->large_client_header_buffers.size;\n     }\n \n-    out = NULL;\n-    ll = &out;\n-\n     for (cl = in; cl; cl = cl->next) {\n \n         b = NULL;\n@@ -1186,15 +1206,16 @@ ngx_int_t\n ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n {\n     ngx_buf_t                 *b;\n-    ngx_chain_t               *cl;\n+    ngx_chain_t               *cl, *tl, **ll;\n     ngx_http_request_body_t   *rb;\n \n     rb = r->request_body;\n \n-#if (NGX_DEBUG)\n+    ll = &rb->bufs;\n \n-#if 0\n     for (cl = rb->bufs; cl; cl = cl->next) {\n+\n+#if 0\n         ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                        \"http body old buf t:%d f:%d %p, pos %p, size: %z \"\n                        \"file: %O, size: %O\",\n@@ -1203,10 +1224,13 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n                        cl->buf->last - cl->buf->pos,\n                        cl->buf->file_pos,\n                        cl->buf->file_last - cl->buf->file_pos);\n-    }\n #endif\n \n+        ll = &cl->next;\n+    }\n+\n     for (cl = in; cl; cl = cl->next) {\n+\n         ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n                        \"http body new buf t:%d f:%d %p, pos %p, size: %z \"\n                        \"file: %O, size: %O\",\n@@ -1215,16 +1239,32 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n                        cl->buf->last - cl->buf->pos,\n                        cl->buf->file_pos,\n                        cl->buf->file_last - cl->buf->file_pos);\n-    }\n \n-#endif\n+        if (cl->buf->last_buf) {\n \n-    /* TODO: coalesce neighbouring buffers */\n+            if (rb->last_saved) {\n+                ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                              \"duplicate last buf in save filter\");\n+                *ll = NULL;\n+                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            }\n \n-    if (ngx_chain_add_copy(r->pool, &rb->bufs, in) != NGX_OK) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            rb->last_saved = 1;\n+        }\n+\n+        tl = ngx_alloc_chain_link(r->pool);\n+        if (tl == NULL) {\n+            *ll = NULL;\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n+        tl->buf = cl->buf;\n+        *ll = tl;\n+        ll = &tl->next;\n     }\n \n+    *ll = NULL;\n+\n     if (r->request_body_no_buffering) {\n         return NGX_OK;\n     }\n@@ -1244,6 +1284,12 @@ ngx_http_request_body_save_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     if (rb->temp_file || r->request_body_in_file_only) {\n \n+        if (rb->bufs && rb->bufs->buf->in_file) {\n+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                          \"body already in file\");\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n         if (ngx_http_write_request_body(r) != NGX_OK) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\nDiff:\n@@ -4039,7 +4039,7 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         len++;\n     }\n \n-    if (r->request_body_no_buffering && !stream->in_closed) {\n+    if (r->request_body_no_buffering) {\n \n         /*\n          * We need a room to store data up to the stream's initial window size,\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 114",
        "commit_diff": "Diff:\n@@ -2113,6 +2113,10 @@ ngx_http_upstream_send_request(ngx_http_request_t *r, ngx_http_upstream_t *u,\n             c->tcp_nopush = NGX_TCP_NOPUSH_UNSET;\n         }\n \n+        if (c->read->ready) {\n+            ngx_post_event(c->read, &ngx_posted_events);\n+        }\n+\n         return;\n     }\n \nDiff:\n@@ -4032,11 +4032,14 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n \n     len = r->headers_in.content_length_n;\n \n-    if (r->request_body_no_buffering && !stream->in_closed) {\n+    if (len < 0 || len > (off_t) clcf->client_body_buffer_size) {\n+        len = clcf->client_body_buffer_size;\n \n-        if (len < 0 || len > (off_t) clcf->client_body_buffer_size) {\n-            len = clcf->client_body_buffer_size;\n-        }\n+    } else {\n+        len++;\n+    }\n+\n+    if (r->request_body_no_buffering && !stream->in_closed) {\n \n         /*\n          * We need a room to store data up to the stream's initial window size,\n@@ -4050,22 +4053,10 @@ ngx_http_v2_read_request_body(ngx_http_request_t *r)\n         if (len > NGX_HTTP_V2_MAX_WINDOW) {\n             len = NGX_HTTP_V2_MAX_WINDOW;\n         }\n-\n-        rb->buf = ngx_create_temp_buf(r->pool, (size_t) len);\n-\n-    } else if (len >= 0 && len <= (off_t) clcf->client_body_buffer_size\n-               && !r->request_body_in_file_only)\n-    {\n-        rb->buf = ngx_create_temp_buf(r->pool, (size_t) len);\n-\n-    } else {\n-        rb->buf = ngx_calloc_buf(r->pool);\n-\n-        if (rb->buf != NULL) {\n-            rb->buf->sync = 1;\n-        }\n     }\n \n+    rb->buf = ngx_create_temp_buf(r->pool, (size_t) len);\n+\n     if (rb->buf == NULL) {\n         stream->skip_data = 1;\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n@@ -4144,85 +4135,134 @@ static ngx_int_t\n ngx_http_v2_process_request_body(ngx_http_request_t *r, u_char *pos,\n     size_t size, ngx_uint_t last)\n {\n-    ngx_buf_t                 *buf;\n+    size_t                     n;\n     ngx_int_t                  rc;\n     ngx_connection_t          *fc;\n     ngx_http_request_body_t   *rb;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     fc = r->connection;\n     rb = r->request_body;\n-    buf = rb->buf;\n \n-    if (size) {\n-        if (buf->sync) {\n-            buf->pos = buf->start = pos;\n-            buf->last = buf->end = pos + size;\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 process request body\");\n+\n+    if (size == 0 && !last) {\n+        return NGX_OK;\n+    }\n \n-            r->request_body_in_file_only = 1;\n+    for ( ;; ) {\n+        for ( ;; ) {\n+            if (rb->buf->last == rb->buf->end && size) {\n \n-        } else {\n-            if (size > (size_t) (buf->end - buf->last)) {\n-                ngx_log_error(NGX_LOG_INFO, fc->log, 0,\n-                              \"client intended to send body data \"\n-                              \"larger than declared\");\n+                if (r->request_body_no_buffering) {\n \n-                return NGX_HTTP_BAD_REQUEST;\n+                    /* should never happen due to flow control */\n+\n+                    ngx_log_error(NGX_LOG_ALERT, fc->log, 0,\n+                                  \"no space in http2 body buffer\");\n+\n+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+                }\n+\n+                /* update chains */\n+\n+                ngx_log_error(NGX_LOG_DEBUG, fc->log, 0,\n+                              \"http2 body update chains\");\n+\n+                rc = ngx_http_v2_filter_request_body(r);\n+\n+                if (rc != NGX_OK) {\n+                    return rc;\n+                }\n+\n+                if (rb->busy != NULL) {\n+                    ngx_log_error(NGX_LOG_ALERT, fc->log, 0,\n+                                  \"busy buffers after request body flush\");\n+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+                }\n+\n+                rb->buf->pos = rb->buf->start;\n+                rb->buf->last = rb->buf->start;\n             }\n \n-            buf->last = ngx_cpymem(buf->last, pos, size);\n-        }\n-    }\n+            /* copy body data to the buffer */\n \n-    if (last) {\n-        rb->rest = 0;\n+            n = rb->buf->end - rb->buf->last;\n \n-        if (fc->read->timer_set) {\n-            ngx_del_timer(fc->read);\n-        }\n+            if (n > size) {\n+                n = size;\n+            }\n \n-        if (r->request_body_no_buffering) {\n-            ngx_post_event(fc->read, &ngx_posted_events);\n-            return NGX_OK;\n-        }\n+            rb->buf->last = ngx_cpymem(rb->buf->last, pos, n);\n \n-        rc = ngx_http_v2_filter_request_body(r);\n+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                           \"http2 request body recv %uz\", n);\n \n-        if (rc != NGX_OK) {\n-            return rc;\n-        }\n+            pos += n;\n+            size -= n;\n+\n+            if (size == 0 && last) {\n+                rb->rest = 0;\n+            }\n \n-        if (buf->sync) {\n-            /* prevent reusing this buffer in the upstream module */\n-            rb->buf = NULL;\n+            if (r->request_body_no_buffering) {\n+                break;\n+            }\n+\n+            /* pass buffer to request body filter chain */\n+\n+            rc = ngx_http_v2_filter_request_body(r);\n+\n+            if (rc != NGX_OK) {\n+                return rc;\n+            }\n+\n+            if (rb->rest == 0) {\n+                break;\n+            }\n+\n+            if (size == 0) {\n+                break;\n+            }\n         }\n \n-        if (r->headers_in.chunked) {\n-            r->headers_in.content_length_n = rb->received;\n+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                       \"http2 request body rest %O\", rb->rest);\n+\n+        if (rb->rest == 0) {\n+            break;\n         }\n \n-        r->read_event_handler = ngx_http_block_reading;\n-        rb->post_handler(r);\n+        if (size == 0) {\n+            clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+            ngx_add_timer(fc->read, clcf->client_body_timeout);\n \n-        return NGX_OK;\n-    }\n+            if (r->request_body_no_buffering) {\n+                ngx_post_event(fc->read, &ngx_posted_events);\n+                return NGX_OK;\n+            }\n \n-    if (size == 0) {\n-        return NGX_OK;\n+            return NGX_OK;\n+        }\n     }\n \n-    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-    ngx_add_timer(fc->read, clcf->client_body_timeout);\n+    if (fc->read->timer_set) {\n+        ngx_del_timer(fc->read);\n+    }\n \n     if (r->request_body_no_buffering) {\n         ngx_post_event(fc->read, &ngx_posted_events);\n         return NGX_OK;\n     }\n \n-    if (buf->sync) {\n-        return ngx_http_v2_filter_request_body(r);\n+    if (r->headers_in.chunked) {\n+        r->headers_in.content_length_n = rb->received;\n     }\n \n+    r->read_event_handler = ngx_http_block_reading;\n+    rb->post_handler(r);\n+\n     return NGX_OK;\n }\n \n@@ -4364,6 +4404,9 @@ ngx_http_v2_read_unbuffered_request_body(ngx_http_request_t *r)\n     stream = r->stream;\n     fc = r->connection;\n \n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 read unbuffered request body\");\n+\n     if (fc->read->timedout) {\n         if (stream->recv_window) {\n             stream->skip_data = 1;\nDiff:\n@@ -1137,8 +1137,8 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n     ngx_str_t                  login, passwd;\n     ngx_connection_t          *c;\n #if (NGX_MAIL_SSL)\n-    ngx_str_t                  verify, subject, issuer, serial, fingerprint,\n-                               raw_cert, cert;\n+    ngx_str_t                  protocol, cipher, verify, subject, issuer,\n+                               serial, fingerprint, raw_cert, cert;\n     ngx_mail_ssl_conf_t       *sslcf;\n #endif\n     ngx_mail_core_srv_conf_t  *cscf;\n@@ -1155,6 +1155,25 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n \n #if (NGX_MAIL_SSL)\n \n+    if (c->ssl) {\n+\n+        if (ngx_ssl_get_protocol(c, pool, &protocol) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        protocol.len = ngx_strlen(protocol.data);\n+\n+        if (ngx_ssl_get_cipher_name(c, pool, &cipher) != NGX_OK) {\n+            return NULL;\n+        }\n+\n+        cipher.len = ngx_strlen(cipher.data);\n+\n+    } else {\n+        ngx_str_null(&protocol);\n+        ngx_str_null(&cipher);\n+    }\n+\n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n     if (c->ssl && sslcf->verify) {\n@@ -1252,6 +1271,10 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n \n     if (c->ssl) {\n         len += sizeof(\"Auth-SSL: on\" CRLF) - 1\n+               + sizeof(\"Auth-SSL-Protocol: \") - 1 + protocol.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Cipher: \") - 1 + cipher.len\n+                     + sizeof(CRLF) - 1\n                + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len\n                      + sizeof(CRLF) - 1\n                + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len\n@@ -1373,6 +1396,20 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n         b->last = ngx_cpymem(b->last, \"Auth-SSL: on\" CRLF,\n                              sizeof(\"Auth-SSL: on\" CRLF) - 1);\n \n+        if (protocol.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Protocol: \",\n+                                 sizeof(\"Auth-SSL-Protocol: \") - 1);\n+            b->last = ngx_copy(b->last, protocol.data, protocol.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n+        if (cipher.len) {\n+            b->last = ngx_cpymem(b->last, \"Auth-SSL-Cipher: \",\n+                                 sizeof(\"Auth-SSL-Cipher: \") - 1);\n+            b->last = ngx_copy(b->last, cipher.data, cipher.len);\n+            *b->last++ = CR; *b->last++ = LF;\n+        }\n+\n         if (verify.len) {\n             b->last = ngx_cpymem(b->last, \"Auth-SSL-Verify: \",\n                                  sizeof(\"Auth-SSL-Verify: \") - 1);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 113",
        "commit_diff": "Diff:\n@@ -4896,6 +4896,12 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = glcf->upstream.ssl;\n \n+    if (ngx_ssl_ciphers(cf, glcf->upstream.ssl, &glcf->ssl_ciphers, 0)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     if (glcf->upstream.ssl_certificate) {\n \n         if (glcf->upstream.ssl_certificate_key == NULL) {\n@@ -4927,12 +4933,6 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, glcf->upstream.ssl, &glcf->ssl_ciphers, 0)\n-        != NGX_OK)\n-    {\n-        return NGX_ERROR;\n-    }\n-\n     if (glcf->upstream.ssl_verify) {\n         if (glcf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -4944,6 +4944,12 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = plcf->upstream.ssl;\n \n+    if (ngx_ssl_ciphers(cf, plcf->upstream.ssl, &plcf->ssl_ciphers, 0)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     if (plcf->upstream.ssl_certificate) {\n \n         if (plcf->upstream.ssl_certificate_key == NULL) {\n@@ -4975,12 +4981,6 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, plcf->upstream.ssl, &plcf->ssl_ciphers, 0)\n-        != NGX_OK)\n-    {\n-        return NGX_ERROR;\n-    }\n-\n     if (plcf->upstream.ssl_verify) {\n         if (plcf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -797,6 +797,13 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                                           ngx_http_ssl_npn_advertised, NULL);\n #endif\n \n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     if (ngx_http_ssl_compile_certificates(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -829,13 +836,6 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n-                        conf->prefer_server_ciphers)\n-        != NGX_OK)\n-    {\n-        return NGX_CONF_ERROR;\n-    }\n-\n     conf->ssl.buffer_size = conf->buffer_size;\n \n     if (conf->verify) {\nDiff:\n@@ -2432,6 +2432,12 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = uwcf->upstream.ssl;\n \n+    if (ngx_ssl_ciphers(cf, uwcf->upstream.ssl, &uwcf->ssl_ciphers, 0)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     if (uwcf->upstream.ssl_certificate) {\n \n         if (uwcf->upstream.ssl_certificate_key == NULL) {\n@@ -2463,12 +2469,6 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, uwcf->upstream.ssl, &uwcf->ssl_ciphers, 0)\n-        != NGX_OK)\n-    {\n-        return NGX_ERROR;\n-    }\n-\n     if (uwcf->upstream.ssl_verify) {\n         if (uwcf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -394,6 +394,13 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = &conf->ssl;\n \n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,\n                              conf->certificate_keys, conf->passwords)\n         != NGX_OK)\n@@ -430,13 +437,6 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n-                        conf->prefer_server_ciphers)\n-        != NGX_OK)\n-    {\n-        return NGX_CONF_ERROR;\n-    }\n-\n     if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\nDiff:\n@@ -2185,6 +2185,10 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = pscf->ssl;\n \n+    if (ngx_ssl_ciphers(cf, pscf->ssl, &pscf->ssl_ciphers, 0) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n     if (pscf->ssl_certificate) {\n \n         if (pscf->ssl_certificate_key == NULL) {\n@@ -2216,10 +2220,6 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, pscf->ssl, &pscf->ssl_ciphers, 0) != NGX_OK) {\n-        return NGX_ERROR;\n-    }\n-\n     if (pscf->ssl_verify) {\n         if (pscf->ssl_trusted_certificate.len == 0) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\nDiff:\n@@ -720,6 +720,13 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                                            ngx_stream_ssl_servername);\n #endif\n \n+    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n+                        conf->prefer_server_ciphers)\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     if (ngx_stream_ssl_compile_certificates(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -752,13 +759,6 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (ngx_ssl_ciphers(cf, &conf->ssl, &conf->ciphers,\n-                        conf->prefer_server_ciphers)\n-        != NGX_OK)\n-    {\n-        return NGX_CONF_ERROR;\n-    }\n-\n     if (conf->verify) {\n \n         if (conf->client_certificate.len == 0 && conf->verify != 3) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 112",
        "commit_diff": "Diff:\n@@ -3,11 +3,9 @@\n <head>\n <title>Error</title>\n <style>\n-    body {\n-        width: 35em;\n-        margin: 0 auto;\n-        font-family: Tahoma, Verdana, Arial, sans-serif;\n-    }\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n </style>\n </head>\n <body>\nDiff:\n@@ -3,11 +3,9 @@\n <head>\n <title>Welcome to nginx!</title>\n <style>\n-    body {\n-        width: 35em;\n-        margin: 0 auto;\n-        font-family: Tahoma, Verdana, Arial, sans-serif;\n-    }\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n </style>\n </head>\n <body>\nDiff:\n@@ -514,6 +514,15 @@ ngx_http_header_filter(ngx_http_request_t *r)\n         *b->last++ = CR; *b->last++ = LF;\n     }\n \n+    if (r->headers_in.prefer) {\n+        b->last = ngx_cpymem(b->last, \"Prefer: \",\n+                             sizeof(\"Prefer: \") - 1);\n+        b->last = ngx_cpymem(b->last, r->headers_in.prefer->value.data,\n+                             r->headers_in.prefer->value.len);\n+\n+        *b->last++ = CR; *b->last++ = LF;\n+    }\n+\n     if (host.data) {\n \n         p = b->last + sizeof(\"Location: \") - 1;\n@@ -551,6 +560,10 @@ ngx_http_header_filter(ngx_http_request_t *r)\n                              sizeof(\"Transfer-Encoding: chunked\" CRLF) - 1);\n     }\n \n+    if (r->headers_in.prefer) {\n+        len += sizeof(\"Prefer: \" CRLF) + r->headers_in.prefer->value.len;\n+    }\n+\n     if (r->headers_out.status == NGX_HTTP_SWITCHING_PROTOCOLS) {\n         b->last = ngx_cpymem(b->last, \"Connection: upgrade\" CRLF,\n                              sizeof(\"Connection: upgrade\" CRLF) - 1);\nDiff:\n@@ -30,6 +30,8 @@ static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,\n@@ -126,6 +128,9 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  offsetof(ngx_http_headers_in_t, content_type),\n                  ngx_http_process_header_line },\n \n+    { ngx_string(\"Prefer\"), offsetof(ngx_http_headers_in_t, prefer),\n+                 ngx_http_process_prefer },\n+\n     { ngx_string(\"Range\"), offsetof(ngx_http_headers_in_t, range),\n                  ngx_http_process_header_line },\n \n@@ -4017,3 +4022,38 @@ ngx_http_process_black_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     return NGX_OK;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    ngx_table_elt_t *p;\n+\n+    if (r->headers_in.prefer) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate host header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.prefer->key,\n+                      &r->headers_in.prefer->value);\n+        ngx_free(r->headers_in.prefer);\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_alloc(sizeof(ngx_table_elt_t), r->connection->log);\n+\n+    if (!p) {\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    p->hash = h->hash;\n+    p->key.len = h->key.len;\n+    p->key.data = h->key.data;\n+    p->value.len = h->value.len;\n+    p->value.data = h->value.data;\n+\n+    r->headers_in.prefer = p;\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -190,6 +190,7 @@ typedef struct {\n     ngx_table_elt_t                  *if_match;\n     ngx_table_elt_t                  *if_none_match;\n     ngx_table_elt_t                  *user_agent;\n+    ngx_table_elt_t                  *prefer;\n     ngx_table_elt_t                  *referer;\n     ngx_table_elt_t                  *content_length;\n     ngx_table_elt_t                  *content_range;\n",
        "analysis": "Let's analyze the newly added entire function in the diff:\n\n```c\nstatic ngx_int_t\nngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n    ngx_uint_t offset)\n{\n    ngx_table_elt_t *p;\n\n    if (r->headers_in.prefer) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      \"client sent duplicate host header: \\\"%V: %V\\\", \"\n                      \"previous value: \\\"%V: %V\\\"\",\n                      &h->key, &h->value, &r->headers_in.prefer->key,\n                      &r->headers_in.prefer->value);\n        ngx_free(r->headers_in.prefer);\n        return NGX_OK;\n    }\n\n    p = ngx_alloc(sizeof(ngx_table_elt_t), r->connection->log);\n\n    if (!p) {\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    p->hash = h->hash;\n    p->key.len = h->key.len;\n    p->key.data = h->key.data;\n    p->value.len = h->value.len;\n    p->value.data = h->value.data;\n\n    r->headers_in.prefer = p;\n\n    return NGX_OK;\n}\n```\n\n### Line-by-Line Analysis:\n\n1. **Function Declaration and Argument Check**: The function `ngx_http_process_prefer` is declared. It takes a request, a header, and an offset.\n   \n2. **Duplicate Header Check**: \n    - The code checks if `r->headers_in.prefer` already exists. If it does, it logs a message about a duplicate header and frees the memory for `r->headers_in.prefer`.\n    - Potentially vulnerable if freeing without validating that `r->headers_in.prefer` points to a valid memory location.\n\n3. **Memory Allocation**:\n    - Allocates memory for a new `ngx_table_elt_t` structure. \n    - The allocation result is checked immediately. If it fails, it ends the HTTP request and returns an error status. This is a good practice.\n\n4. **Copying Header Values**:\n    - Copies header information into the newly allocated structure. This is a straightforward process where size checks are handled by the memory allocation—and does not directly show an out-of-bounds write.\n\n5. **Assignment**:\n    - The newly allocated structure `p` is assigned to `r->headers_in.prefer`. Given that the allocation and copying seem to have been handled correctly, there is no immediate out-of-bounds write concern here.\n\n### Conclusion:\nThe function does not directly show potential for an out-of-bounds write since it checks for duplicate headers and only allocates memory when necessary. However, the line responsible for freeing the duplicated header without further validation (`ngx_free(r->headers_in.prefer);`) might raise concern in a different security context but not directly related to an out-of-bounds write.\n\nBased on the analysis with the focus on out-of-bounds write vulnerabilities, it is unlikely this function introduces such an issue. Therefore, if considering only out-of-bounds write, I conclude there is no immediate out-of-bounds write risk identified solely from this function.\n\nFinal Conclusion:\nFALSE"
    },
    {
        "commit_index": "Commit 111",
        "commit_diff": "Diff:\n@@ -299,11 +299,6 @@ ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)\n     SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);\n #endif\n \n-#ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING\n-    /* this option allow a potential SSL 2.0 rollback (CAN-2005-2969) */\n-    SSL_CTX_set_options(ssl->ctx, SSL_OP_MSIE_SSLV2_RSA_PADDING);\n-#endif\n-\n #ifdef SSL_OP_SSLEAY_080_CLIENT_DH_BUG\n     SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLEAY_080_CLIENT_DH_BUG);\n #endif\n@@ -378,6 +373,10 @@ ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)\n     SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_CLIENT_RENEGOTIATION);\n #endif\n \n+#ifdef SSL_OP_IGNORE_UNEXPECTED_EOF\n+    SSL_CTX_set_options(ssl->ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);\n+#endif\n+\n #ifdef SSL_MODE_RELEASE_BUFFERS\n     SSL_CTX_set_mode(ssl->ctx, SSL_MODE_RELEASE_BUFFERS);\n #endif\n@@ -859,11 +858,6 @@ ngx_ssl_ciphers(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *ciphers,\n         SSL_CTX_set_options(ssl->ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);\n     }\n \n-#if (OPENSSL_VERSION_NUMBER < 0x10100001L && !defined LIBRESSL_VERSION_NUMBER)\n-    /* a temporary 512-bit RSA key is required for export versions of MSIE */\n-    SSL_CTX_set_tmp_rsa_callback(ssl->ctx, ngx_ssl_rsa512_key_callback);\n-#endif\n-\n     return NGX_OK;\n }\n \n@@ -1116,28 +1110,6 @@ ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)\n }\n \n \n-RSA *\n-ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n-    int key_length)\n-{\n-    static RSA  *key;\n-\n-    if (key_length != 512) {\n-        return NULL;\n-    }\n-\n-#if (OPENSSL_VERSION_NUMBER < 0x10100003L && !defined OPENSSL_NO_DEPRECATED)\n-\n-    if (key == NULL) {\n-        key = RSA_generate_key(512, RSA_F4, NULL, NULL);\n-    }\n-\n-#endif\n-\n-    return key;\n-}\n-\n-\n ngx_array_t *\n ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file)\n {\n@@ -1350,7 +1322,6 @@ ngx_ssl_passwords_cleanup(void *data)\n ngx_int_t\n ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n {\n-    DH   *dh;\n     BIO  *bio;\n \n     if (file->len == 0) {\n@@ -1368,6 +1339,10 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n         return NGX_ERROR;\n     }\n \n+#ifdef SSL_CTX_set_tmp_dh\n+    {\n+    DH  *dh;\n+\n     dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n     if (dh == NULL) {\n         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n@@ -1385,6 +1360,33 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n     }\n \n     DH_free(dh);\n+    }\n+#else\n+    {\n+    EVP_PKEY  *dh;\n+\n+    /*\n+     * PEM_read_bio_DHparams() and SSL_CTX_set_tmp_dh()\n+     * are deprecated in OpenSSL 3.0\n+     */\n+\n+    dh = PEM_read_bio_Parameters(bio, NULL);\n+    if (dh == NULL) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"PEM_read_bio_Parameters(\\\"%s\\\") failed\", file->data);\n+        BIO_free(bio);\n+        return NGX_ERROR;\n+    }\n+\n+    if (SSL_CTX_set0_tmp_dh_pkey(ssl->ctx, dh) != 1) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set0_tmp_dh_pkey(\\%s\\\") failed\", file->data);\n+        BIO_free(bio);\n+        return NGX_ERROR;\n+    }\n+    }\n+#endif\n+\n     BIO_free(bio);\n \n     return NGX_OK;\n@@ -3246,7 +3248,7 @@ ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, char *fmt, ...)\n \n         for ( ;; ) {\n \n-            n = ERR_peek_error_line_data(NULL, NULL, &data, &flags);\n+            n = ERR_peek_error_data(&data, &flags);\n \n             if (n == 0) {\n                 break;\nDiff:\n@@ -12,6 +12,8 @@\n #include <ngx_config.h>\n #include <ngx_core.h>\n \n+#define OPENSSL_SUPPRESS_DEPRECATED\n+\n #include <openssl/ssl.h>\n #include <openssl/err.h>\n #include <openssl/bn.h>\n@@ -27,7 +29,6 @@\n #include <openssl/ocsp.h>\n #endif\n #include <openssl/rand.h>\n-#include <openssl/rsa.h>\n #include <openssl/x509.h>\n #include <openssl/x509v3.h>\n \n@@ -64,6 +65,16 @@\n #endif\n \n \n+#if (OPENSSL_VERSION_NUMBER >= 0x30000000L && !defined SSL_get_peer_certificate)\n+#define SSL_get_peer_certificate(s)  SSL_get1_peer_certificate(s)\n+#endif\n+\n+\n+#if (OPENSSL_VERSION_NUMBER < 0x30000000L && !defined ERR_peek_error_data)\n+#define ERR_peek_error_data(d, f)    ERR_peek_error_line_data(NULL, NULL, d, f)\n+#endif\n+\n+\n typedef struct ngx_ssl_ocsp_s  ngx_ssl_ocsp_t;\n \n \n@@ -196,8 +207,6 @@ ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n-RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n-    int key_length);\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\n ngx_array_t *ngx_ssl_preserve_passwords(ngx_conf_t *cf,\n     ngx_array_t *passwords);\nDiff:\n@@ -2002,6 +2002,14 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n     }\n \n     if (r->headers_in.transfer_encoding) {\n+        if (r->http_version < NGX_HTTP_VERSION_11) {\n+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                          \"client sent HTTP/1.0 request with \"\n+                          \"\\\"Transfer-Encoding\\\" header\");\n+            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+            return NGX_ERROR;\n+        }\n+\n         if (r->headers_in.transfer_encoding->value.len == 7\n             && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                                (u_char *) \"chunked\", 7) == 0)\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 110",
        "commit_diff": "Diff:\n@@ -461,3 +461,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\n+a68ac0677f8553b1f84d357bc9da114731ab5f47 release-1.21.1\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021001\n-#define NGINX_VERSION      \"1.21.1\"\n+#define nginx_version      1021002\n+#define NGINX_VERSION      \"1.21.2\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1376,7 +1376,13 @@ ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)\n         return NGX_ERROR;\n     }\n \n-    SSL_CTX_set_tmp_dh(ssl->ctx, dh);\n+    if (SSL_CTX_set_tmp_dh(ssl->ctx, dh) != 1) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set_tmp_dh(\\\"%s\\\") failed\", file->data);\n+        DH_free(dh);\n+        BIO_free(bio);\n+        return NGX_ERROR;\n+    }\n \n     DH_free(dh);\n     BIO_free(bio);\n@@ -1740,6 +1746,9 @@ ngx_ssl_handshake(ngx_connection_t *c)\n         c->recv_chain = ngx_ssl_recv_chain;\n         c->send_chain = ngx_ssl_send_chain;\n \n+        c->read->ready = 1;\n+        c->write->ready = 1;\n+\n #ifndef SSL_OP_NO_RENEGOTIATION\n #if OPENSSL_VERSION_NUMBER < 0x10100000L\n #ifdef SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS\n@@ -1885,6 +1894,9 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->recv_chain = ngx_ssl_recv_chain;\n         c->send_chain = ngx_ssl_send_chain;\n \n+        c->read->ready = 1;\n+        c->write->ready = 1;\n+\n         rc = ngx_ssl_ocsp_validate(c);\n \n         if (rc == NGX_ERROR) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 109",
        "commit_diff": "Diff:\n@@ -5,6 +5,125 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.1\" date=\"2021-07-06\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx для метода CONNECT всегда возвращает ошибку.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error for the CONNECT method.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в запросе одновременно присутствуют строки заголовка \"Content-Length\"\n+и \"Transfer-Encoding\".\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if both \"Content-Length\" and \"Transfer-Encoding\" header lines\n+are present in the request.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в строке запроса используются пробелы или управляющие символы.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if spaces or control characters are used in the request line.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в имени заголовка используются пробелы или управляющие символы.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if spaces or control characters are used in a header name.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx всегда возвращает ошибку,\n+если в строке \"Host\" заголовка запроса\n+используются пробелы или управляющие символы.\n+</para>\n+<para lang=\"en\">\n+now nginx always returns an error\n+if spaces or control characters\n+are used in the \"Host\" request header line.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+оптимизация тестирования конфигурации\n+при использовании большого количества listen-сокетов.\n+</para>\n+<para lang=\"en\">\n+optimization of configuration testing\n+when using many listening sockets.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не экранировал\n+символы \"\"\", \"&lt;\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", и \"}\"\n+при проксировании с изменением URI запроса.\n+</para>\n+<para lang=\"en\">\n+nginx did not escape\n+\"\"\", \"&lt;\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", and \"}\" characters\n+when proxying with changed URI.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL-переменные могли быть пустыми при записи в лог;\n+ошибка появилась в 1.19.5.\n+</para>\n+<para lang=\"en\">\n+SSL variables might be empty when used in logs;\n+the bug had appeared in 1.19.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+keepalive-соединения с gRPC-бэкендами могли не закрываться\n+после получения GOAWAY-фрейма.\n+</para>\n+<para lang=\"en\">\n+keepalive connections with gRPC backends might not be closed\n+after receiving a GOAWAY frame.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+уменьшено потребление памяти для долгоживущих запросов\n+при проксировании с использованием более 64 буферов.\n+</para>\n+<para lang=\"en\">\n+reduced memory consumption for long-lived requests\n+when proxying with more than 64 buffers.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.21.0\" date=\"2021-05-25\">\n \n <change type=\"security\">\nDiff:\n@@ -10,7 +10,7 @@\n #include <ngx_event.h>\n \n \n-#define NGX_WSABUFS  8\n+#define NGX_WSABUFS  64\n \n \n ssize_t\n@@ -57,6 +57,10 @@ ngx_wsarecv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n             wsabuf->len += n;\n \n         } else {\n+            if (vec.nelts == vec.nalloc) {\n+                break;\n+            }\n+\n             wsabuf = ngx_array_push(&vec);\n             if (wsabuf == NULL) {\n                 return NGX_ERROR;\nDiff:\n@@ -10,7 +10,7 @@\n #include <ngx_event.h>\n \n \n-#define NGX_WSABUFS  8\n+#define NGX_WSABUFS  64\n \n \n ngx_chain_t *\n@@ -47,7 +47,7 @@ ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n     vec.elts = wsabufs;\n     vec.size = sizeof(WSABUF);\n-    vec.nalloc = NGX_WSABUFS;\n+    vec.nalloc = ngx_min(NGX_WSABUFS, ngx_max_wsabufs);\n     vec.pool = c->pool;\n \n     for ( ;; ) {\n@@ -59,10 +59,8 @@ ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         /* create the WSABUF and coalesce the neighbouring bufs */\n \n-        for (cl = in;\n-             cl && vec.nelts < ngx_max_wsabufs && send < limit;\n-             cl = cl->next)\n-        {\n+        for (cl = in; cl && send < limit; cl = cl->next) {\n+\n             if (ngx_buf_special(cl->buf)) {\n                 continue;\n             }\n@@ -77,6 +75,10 @@ ngx_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                 wsabuf->len += cl->buf->last - cl->buf->pos;\n \n             } else {\n+                if (vec.nelts == vec.nalloc) {\n+                    break;\n+                }\n+\n                 wsabuf = ngx_array_push(&vec);\n                 if (wsabuf == NULL) {\n                     return NGX_CHAIN_ERROR;\n@@ -169,7 +171,7 @@ ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n         vec.elts = wsabufs;\n         vec.nelts = 0;\n         vec.size = sizeof(WSABUF);\n-        vec.nalloc = NGX_WSABUFS;\n+        vec.nalloc = ngx_min(NGX_WSABUFS, ngx_max_wsabufs);\n         vec.pool = c->pool;\n \n         send = 0;\n@@ -178,10 +180,8 @@ ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n \n         /* create the WSABUF and coalesce the neighbouring bufs */\n \n-        for (cl = in;\n-             cl && vec.nelts < ngx_max_wsabufs && send < limit;\n-             cl = cl->next)\n-        {\n+        for (cl = in; cl && send < limit; cl = cl->next) {\n+\n             if (ngx_buf_special(cl->buf)) {\n                 continue;\n             }\n@@ -196,6 +196,10 @@ ngx_overlapped_wsasend_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)\n                 wsabuf->len += cl->buf->last - cl->buf->pos;\n \n             } else {\n+                if (vec.nelts == vec.nalloc) {\n+                    break;\n+                }\n+\n                 wsabuf = ngx_array_push(&vec);\n                 if (wsabuf == NULL) {\n                     return NGX_CHAIN_ERROR;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 108",
        "commit_diff": "Diff:\n@@ -2019,10 +2019,12 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n                 break;\n             }\n \n-            /* there was error while a header line parsing */\n+            /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                          \"upstream sent invalid header\");\n+            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                          \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                          r->header_end - r->header_name_start,\n+                          r->header_name_start, *r->header_end);\n \n             return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n         }\nDiff:\n@@ -2019,10 +2019,12 @@ ngx_http_proxy_process_header(ngx_http_request_t *r)\n             return NGX_AGAIN;\n         }\n \n-        /* there was error while a header line parsing */\n+        /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                      \"upstream sent invalid header\");\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\nDiff:\n@@ -1140,10 +1140,12 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n             return NGX_AGAIN;\n         }\n \n-        /* there was error while a header line parsing */\n+        /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                      \"upstream sent invalid header\");\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\nDiff:\n@@ -1361,10 +1361,12 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n             return NGX_AGAIN;\n         }\n \n-        /* there was error while a header line parsing */\n+        /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                      \"upstream sent invalid header\");\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"upstream sent invalid header: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n     }\nDiff:\n@@ -894,6 +894,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 }\n \n                 if (ch <= 0x20 || ch == 0x7f || ch == ':') {\n+                    r->header_end = p;\n                     return NGX_HTTP_PARSE_INVALID_HEADER;\n                 }\n \n@@ -962,6 +963,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n             }\n \n             if (ch <= 0x20 || ch == 0x7f) {\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             }\n \n@@ -984,6 +986,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 r->header_end = p;\n                 goto done;\n             case '\\0':\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             default:\n                 r->header_start = p;\n@@ -1007,6 +1010,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 r->header_end = p;\n                 goto done;\n             case '\\0':\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             }\n             break;\n@@ -1022,6 +1026,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n             case LF:\n                 goto done;\n             case '\\0':\n+                r->header_end = p;\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             default:\n                 state = sw_value;\nDiff:\n@@ -1541,7 +1541,9 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n         /* rc == NGX_HTTP_PARSE_INVALID_HEADER */\n \n         ngx_log_error(NGX_LOG_INFO, c->log, 0,\n-                      \"client sent invalid header line\");\n+                      \"client sent invalid header line: \\\"%*s\\\\x%02xd...\\\"\",\n+                      r->header_end - r->header_name_start,\n+                      r->header_name_start, *r->header_end);\n \n         ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n         break;\n@@ -2193,15 +2195,16 @@ ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool, ngx_uint_t alloc)\n             }\n             break;\n \n-        case '\\0':\n-            return NGX_DECLINED;\n-\n         default:\n \n             if (ngx_path_separator(ch)) {\n                 return NGX_DECLINED;\n             }\n \n+            if (ch <= 0x20 || ch == 0x7f) {\n+                return NGX_DECLINED;\n+            }\n+\n             if (ch >= 'A' && ch <= 'Z') {\n                 alloc = 1;\n             }\nDiff:\n@@ -96,7 +96,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n             iov->iov_len += n;\n \n         } else {\n-            if (vec.nelts >= IOV_MAX) {\n+            if (vec.nelts == vec.nalloc) {\n                 break;\n             }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 107",
        "commit_diff": "Diff:\n@@ -3384,7 +3384,7 @@ ngx_http_grpc_validate_header_name(ngx_http_request_t *r, ngx_str_t *s)\n             return NGX_ERROR;\n         }\n \n-        if (ch == '\\0' || ch == CR || ch == LF) {\n+        if (ch <= 0x20 || ch == 0x7f) {\n             return NGX_ERROR;\n         }\n     }\nDiff:\n@@ -11,7 +11,7 @@\n \n \n static uint32_t  usual[] = {\n-    0xffffdbfe, /* 1111 1111 1111 1111  1101 1011 1111 1110 */\n+    0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n \n                 /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n     0x7fff37d6, /* 0111 1111 1111 1111  0011 0111 1101 0110 */\n@@ -24,7 +24,7 @@ static uint32_t  usual[] = {\n #endif\n \n                 /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n+    0x7fffffff, /* 0111 1111 1111 1111  1111 1111 1111 1111 */\n \n     0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n@@ -528,9 +528,10 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             case '+':\n                 r->plus_in_uri = 1;\n                 break;\n-            case '\\0':\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n             default:\n+                if (ch < 0x20 || ch == 0x7f) {\n+                    return NGX_HTTP_PARSE_INVALID_REQUEST;\n+                }\n                 state = sw_check_uri;\n                 break;\n             }\n@@ -592,8 +593,11 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             case '+':\n                 r->plus_in_uri = 1;\n                 break;\n-            case '\\0':\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n+            default:\n+                if (ch < 0x20 || ch == 0x7f) {\n+                    return NGX_HTTP_PARSE_INVALID_REQUEST;\n+                }\n+                break;\n             }\n             break;\n \n@@ -621,8 +625,11 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             case '#':\n                 r->complex_uri = 1;\n                 break;\n-            case '\\0':\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n+            default:\n+                if (ch < 0x20 || ch == 0x7f) {\n+                    return NGX_HTTP_PARSE_INVALID_REQUEST;\n+                }\n+                break;\n             }\n             break;\n \n@@ -886,7 +893,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                     break;\n                 }\n \n-                if (ch == '\\0') {\n+                if (ch <= 0x20 || ch == 0x7f || ch == ':') {\n                     return NGX_HTTP_PARSE_INVALID_HEADER;\n                 }\n \n@@ -954,7 +961,7 @@ ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n                 break;\n             }\n \n-            if (ch == '\\0') {\n+            if (ch <= 0x20 || ch == 0x7f) {\n                 return NGX_HTTP_PARSE_INVALID_HEADER;\n             }\n \n@@ -1118,8 +1125,6 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             }\n \n             switch (ch) {\n-            case ' ':\n-                return NGX_ERROR;\n             case '.':\n                 r->complex_uri = 1;\n                 state = sw_uri;\n@@ -1150,6 +1155,9 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n                 r->plus_in_uri = 1;\n                 break;\n             default:\n+                if (ch <= 0x20 || ch == 0x7f) {\n+                    return NGX_ERROR;\n+                }\n                 state = sw_check_uri;\n                 break;\n             }\n@@ -1177,8 +1185,6 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             case '.':\n                 r->uri_ext = p + 1;\n                 break;\n-            case ' ':\n-                return NGX_ERROR;\n #if (NGX_WIN32)\n             case '\\\\':\n                 r->complex_uri = 1;\n@@ -1200,6 +1206,11 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             case '+':\n                 r->plus_in_uri = 1;\n                 break;\n+            default:\n+                if (ch <= 0x20 || ch == 0x7f) {\n+                    return NGX_ERROR;\n+                }\n+                break;\n             }\n             break;\n \n@@ -1211,11 +1222,14 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n             }\n \n             switch (ch) {\n-            case ' ':\n-                return NGX_ERROR;\n             case '#':\n                 r->complex_uri = 1;\n                 break;\n+            default:\n+                if (ch <= 0x20 || ch == 0x7f) {\n+                    return NGX_ERROR;\n+                }\n+                break;\n             }\n             break;\n         }\nDiff:\n@@ -3457,7 +3457,7 @@ ngx_http_v2_validate_header(ngx_http_request_t *r, ngx_http_v2_header_t *header)\n             continue;\n         }\n \n-        if (ch == '\\0' || ch == LF || ch == CR || ch == ':'\n+        if (ch <= 0x20 || ch == 0x7f || ch == ':'\n             || (ch >= 'A' && ch <= 'Z'))\n         {\n             ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 106",
        "commit_diff": "Diff:\n@@ -1186,7 +1186,7 @@ ngx_http_proxy_create_key(ngx_http_request_t *r)\n \n     loc_len = (r->valid_location && ctx->vars.uri.len) ? plcf->location.len : 0;\n \n-    if (r->quoted_uri || r->space_in_uri || r->internal) {\n+    if (r->quoted_uri || r->internal) {\n         escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len,\n                                     r->uri.len - loc_len, NGX_ESCAPE_URI);\n     } else {\n@@ -1299,7 +1299,7 @@ ngx_http_proxy_create_request(ngx_http_request_t *r)\n         loc_len = (r->valid_location && ctx->vars.uri.len) ?\n                       plcf->location.len : 0;\n \n-        if (r->quoted_uri || r->space_in_uri || r->internal) {\n+        if (r->quoted_uri || r->internal) {\n             escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len,\n                                         r->uri.len - loc_len, NGX_ESCAPE_URI);\n         }\nDiff:\n@@ -116,10 +116,8 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n         sw_host_end,\n         sw_host_ip_literal,\n         sw_port,\n-        sw_host_http_09,\n         sw_after_slash_in_uri,\n         sw_check_uri,\n-        sw_check_uri_http_09,\n         sw_uri,\n         sw_http_09,\n         sw_http_H,\n@@ -398,7 +396,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                  */\n                 r->uri_start = r->schema_end + 1;\n                 r->uri_end = r->schema_end + 2;\n-                state = sw_host_http_09;\n+                state = sw_http_09;\n                 break;\n             default:\n                 return NGX_HTTP_PARSE_INVALID_REQUEST;\n@@ -472,35 +470,13 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                  */\n                 r->uri_start = r->schema_end + 1;\n                 r->uri_end = r->schema_end + 2;\n-                state = sw_host_http_09;\n-                break;\n-            default:\n-                return NGX_HTTP_PARSE_INVALID_REQUEST;\n-            }\n-            break;\n-\n-        /* space+ after \"http://host[:port] \" */\n-        case sw_host_http_09:\n-            switch (ch) {\n-            case ' ':\n-                break;\n-            case CR:\n-                r->http_minor = 9;\n-                state = sw_almost_done;\n-                break;\n-            case LF:\n-                r->http_minor = 9;\n-                goto done;\n-            case 'H':\n-                r->http_protocol.data = p;\n-                state = sw_http_H;\n+                state = sw_http_09;\n                 break;\n             default:\n                 return NGX_HTTP_PARSE_INVALID_REQUEST;\n             }\n             break;\n \n-\n         /* check \"/.\", \"//\", \"%\", and \"\\\" (Win32) in URI */\n         case sw_after_slash_in_uri:\n \n@@ -512,7 +488,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             switch (ch) {\n             case ' ':\n                 r->uri_end = p;\n-                state = sw_check_uri_http_09;\n+                state = sw_http_09;\n                 break;\n             case CR:\n                 r->uri_end = p;\n@@ -584,7 +560,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 break;\n             case ' ':\n                 r->uri_end = p;\n-                state = sw_check_uri_http_09;\n+                state = sw_http_09;\n                 break;\n             case CR:\n                 r->uri_end = p;\n@@ -621,31 +597,6 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n             }\n             break;\n \n-        /* space+ after URI */\n-        case sw_check_uri_http_09:\n-            switch (ch) {\n-            case ' ':\n-                break;\n-            case CR:\n-                r->http_minor = 9;\n-                state = sw_almost_done;\n-                break;\n-            case LF:\n-                r->http_minor = 9;\n-                goto done;\n-            case 'H':\n-                r->http_protocol.data = p;\n-                state = sw_http_H;\n-                break;\n-            default:\n-                r->space_in_uri = 1;\n-                state = sw_check_uri;\n-                p--;\n-                break;\n-            }\n-            break;\n-\n-\n         /* URI */\n         case sw_uri:\n \n@@ -692,10 +643,7 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 state = sw_http_H;\n                 break;\n             default:\n-                r->space_in_uri = 1;\n-                state = sw_uri;\n-                p--;\n-                break;\n+                return NGX_HTTP_PARSE_INVALID_REQUEST;\n             }\n             break;\n \n@@ -1171,9 +1119,7 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n \n             switch (ch) {\n             case ' ':\n-                r->space_in_uri = 1;\n-                state = sw_check_uri;\n-                break;\n+                return NGX_ERROR;\n             case '.':\n                 r->complex_uri = 1;\n                 state = sw_uri;\n@@ -1232,8 +1178,7 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n                 r->uri_ext = p + 1;\n                 break;\n             case ' ':\n-                r->space_in_uri = 1;\n-                break;\n+                return NGX_ERROR;\n #if (NGX_WIN32)\n             case '\\\\':\n                 r->complex_uri = 1;\n@@ -1267,8 +1212,7 @@ ngx_http_parse_uri(ngx_http_request_t *r)\n \n             switch (ch) {\n             case ' ':\n-                r->space_in_uri = 1;\n-                break;\n+                return NGX_ERROR;\n             case '#':\n                 r->complex_uri = 1;\n                 break;\nDiff:\n@@ -1279,7 +1279,7 @@ ngx_http_process_request_uri(ngx_http_request_t *r)\n     r->unparsed_uri.len = r->uri_end - r->uri_start;\n     r->unparsed_uri.data = r->uri_start;\n \n-    r->valid_unparsed_uri = (r->space_in_uri || r->empty_path_in_uri) ? 0 : 1;\n+    r->valid_unparsed_uri = r->empty_path_in_uri ? 0 : 1;\n \n     if (r->uri_ext) {\n         if (r->args_start) {\nDiff:\n@@ -477,9 +477,6 @@ struct ngx_http_request_s {\n     /* URI with \"+\" */\n     unsigned                          plus_in_uri:1;\n \n-    /* URI with \" \" */\n-    unsigned                          space_in_uri:1;\n-\n     /* URI with empty path */\n     unsigned                          empty_path_in_uri:1;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 105",
        "commit_diff": "Diff:\n@@ -1493,39 +1493,52 @@ ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n     uint32_t       *escape;\n     static u_char   hex[] = \"0123456789ABCDEF\";\n \n-                    /* \" \", \"#\", \"%\", \"?\", %00-%1F, %7F-%FF */\n+    /*\n+     * Per RFC 3986 only the following chars are allowed in URIs unescaped:\n+     *\n+     * unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+     * gen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n+     * sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+     *               / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+     *\n+     * And \"%\" can appear as a part of escaping itself.  The following\n+     * characters are not allowed and need to be escaped: %00-%1F, %7F-%FF,\n+     * \" \", \"\"\", \"<\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", \"}\".\n+     */\n+\n+                    /* \" \", \"#\", \"%\", \"?\", not allowed */\n \n     static uint32_t   uri[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x80000029, /* 1000 0000 0000 0000  0000 0000 0010 1001 */\n+        0xd000002d, /* 1101 0000 0000 0000  0000 0000 0010 1101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"#\", \"%\", \"&\", \"+\", \"?\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"#\", \"%\", \"&\", \"+\", \";\", \"?\", not allowed */\n \n     static uint32_t   args[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x88000869, /* 1000 1000 0000 0000  0000 1000 0110 1001 */\n+        0xd800086d, /* 1101 1000 0000 0000  0000 1000 0110 1101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n@@ -1553,39 +1566,39 @@ ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"#\", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"#\", \"\"\", \"%\", \"'\", not allowed */\n \n     static uint32_t   html[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x000000ad, /* 0000 0000 0000 0000  0000 0000 1010 1101 */\n+        0x500000ad, /* 0101 0000 0000 0000  0000 0000 1010 1101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xb8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"\"\", \"'\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"\"\", \"'\", not allowed */\n \n     static uint32_t   refresh[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n \n                     /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n-        0x00000085, /* 0000 0000 0000 0000  0000 0000 1000 0101 */\n+        0x50000085, /* 0101 0000 0000 0000  0000 0000 1000 0101 */\n \n                     /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n-        0x00000000, /* 0000 0000 0000 0000  0000 0000 0000 0000 */\n+        0x50000000, /* 0101 0000 0000 0000  0000 0000 0000 0000 */\n \n                     /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n-        0x80000000, /* 1000 0000 0000 0000  0000 0000 0000 0000 */\n+        0xd8000001, /* 1011 1000 0000 0000  0000 0000 0000 0001 */\n \n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\nDiff:\n@@ -246,6 +246,11 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                         r->method = NGX_HTTP_OPTIONS;\n                     }\n \n+                    if (ngx_str7_cmp(m, 'C', 'O', 'N', 'N', 'E', 'C', 'T', ' '))\n+                    {\n+                        r->method = NGX_HTTP_CONNECT;\n+                    }\n+\n                     break;\n \n                 case 8:\nDiff:\n@@ -2004,8 +2004,15 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n             && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                                (u_char *) \"chunked\", 7) == 0)\n         {\n-            r->headers_in.content_length = NULL;\n-            r->headers_in.content_length_n = -1;\n+            if (r->headers_in.content_length) {\n+                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                              \"client sent \\\"Content-Length\\\" and \"\n+                              \"\\\"Transfer-Encoding\\\" headers \"\n+                              \"at the same time\");\n+                ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+                return NGX_ERROR;\n+            }\n+\n             r->headers_in.chunked = 1;\n \n         } else {\n@@ -2025,6 +2032,13 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n         }\n     }\n \n+    if (r->method == NGX_HTTP_CONNECT) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent CONNECT method\");\n+        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+        return NGX_ERROR;\n+    }\n+\n     if (r->method == NGX_HTTP_TRACE) {\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                       \"client sent TRACE method\");\nDiff:\n@@ -25,22 +25,23 @@\n #define NGX_HTTP_VERSION_11                1001\n #define NGX_HTTP_VERSION_20                2000\n \n-#define NGX_HTTP_UNKNOWN                   0x0001\n-#define NGX_HTTP_GET                       0x0002\n-#define NGX_HTTP_HEAD                      0x0004\n-#define NGX_HTTP_POST                      0x0008\n-#define NGX_HTTP_PUT                       0x0010\n-#define NGX_HTTP_DELETE                    0x0020\n-#define NGX_HTTP_MKCOL                     0x0040\n-#define NGX_HTTP_COPY                      0x0080\n-#define NGX_HTTP_MOVE                      0x0100\n-#define NGX_HTTP_OPTIONS                   0x0200\n-#define NGX_HTTP_PROPFIND                  0x0400\n-#define NGX_HTTP_PROPPATCH                 0x0800\n-#define NGX_HTTP_LOCK                      0x1000\n-#define NGX_HTTP_UNLOCK                    0x2000\n-#define NGX_HTTP_PATCH                     0x4000\n-#define NGX_HTTP_TRACE                     0x8000\n+#define NGX_HTTP_UNKNOWN                   0x00000001\n+#define NGX_HTTP_GET                       0x00000002\n+#define NGX_HTTP_HEAD                      0x00000004\n+#define NGX_HTTP_POST                      0x00000008\n+#define NGX_HTTP_PUT                       0x00000010\n+#define NGX_HTTP_DELETE                    0x00000020\n+#define NGX_HTTP_MKCOL                     0x00000040\n+#define NGX_HTTP_COPY                      0x00000080\n+#define NGX_HTTP_MOVE                      0x00000100\n+#define NGX_HTTP_OPTIONS                   0x00000200\n+#define NGX_HTTP_PROPFIND                  0x00000400\n+#define NGX_HTTP_PROPPATCH                 0x00000800\n+#define NGX_HTTP_LOCK                      0x00001000\n+#define NGX_HTTP_UNLOCK                    0x00002000\n+#define NGX_HTTP_PATCH                     0x00004000\n+#define NGX_HTTP_TRACE                     0x00008000\n+#define NGX_HTTP_CONNECT                   0x00010000\n \n #define NGX_HTTP_CONNECTION_CLOSE          1\n #define NGX_HTTP_CONNECTION_KEEP_ALIVE     2\nDiff:\n@@ -3606,7 +3606,8 @@ ngx_http_v2_parse_method(ngx_http_request_t *r, ngx_str_t *value)\n         { 4, \"LOCK\",      NGX_HTTP_LOCK },\n         { 6, \"UNLOCK\",    NGX_HTTP_UNLOCK },\n         { 5, \"PATCH\",     NGX_HTTP_PATCH },\n-        { 5, \"TRACE\",     NGX_HTTP_TRACE }\n+        { 5, \"TRACE\",     NGX_HTTP_TRACE },\n+        { 7, \"CONNECT\",   NGX_HTTP_CONNECT }\n     }, *test;\n \n     if (r->method_name.len) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 104",
        "commit_diff": "Diff:\n@@ -47,6 +47,9 @@ struct ngx_rbtree_s {\n     (tree)->sentinel = s;                                                     \\\n     (tree)->insert = i\n \n+#define ngx_rbtree_data(node, type, link)                                     \\\n+    (type *) ((u_char *) (node) - offsetof(type, link))\n+\n \n void ngx_rbtree_insert(ngx_rbtree_t *tree, ngx_rbtree_node_t *node);\n void ngx_rbtree_delete(ngx_rbtree_t *tree, ngx_rbtree_node_t *node);\nDiff:\n@@ -51,9 +51,7 @@ typedef struct {\n } ngx_resolver_an_t;\n \n \n-#define ngx_resolver_node(n)                                                 \\\n-    (ngx_resolver_node_t *)                                                  \\\n-        ((u_char *) (n) - offsetof(ngx_resolver_node_t, node))\n+#define ngx_resolver_node(n)  ngx_rbtree_data(n, ngx_resolver_node_t, node)\n \n \n static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec);\nDiff:\n@@ -73,7 +73,7 @@ ngx_event_expire_timers(void)\n             return;\n         }\n \n-        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));\n+        ev = ngx_rbtree_data(node, ngx_event_t, timer);\n \n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev->log, 0,\n                        \"event timer del: %d: %M\",\n@@ -113,7 +113,7 @@ ngx_event_no_timers_left(void)\n          node;\n          node = ngx_rbtree_next(&ngx_event_timer_rbtree, node))\n     {\n-        ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer));\n+        ev = ngx_rbtree_data(node, ngx_event_t, timer);\n \n         if (!ev->cancelable) {\n             return NGX_AGAIN;\nDiff:\n@@ -1999,13 +1999,6 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n         }\n     }\n \n-    if (r->method == NGX_HTTP_TRACE) {\n-        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n-                      \"client sent TRACE method\");\n-        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n-        return NGX_ERROR;\n-    }\n-\n     if (r->headers_in.transfer_encoding) {\n         if (r->headers_in.transfer_encoding->value.len == 7\n             && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n@@ -2032,6 +2025,13 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n         }\n     }\n \n+    if (r->method == NGX_HTTP_TRACE) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent TRACE method\");\n+        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 103",
        "commit_diff": "Diff:\n@@ -3008,6 +3008,12 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n done:\n \n+    if (c->ssl->shutdown_without_free) {\n+        c->ssl->shutdown_without_free = 0;\n+        c->recv = ngx_recv;\n+        return rc;\n+    }\n+\n     SSL_free(c->ssl->connection);\n     c->ssl = NULL;\n     c->recv = ngx_recv;\nDiff:\n@@ -100,6 +100,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    buffer:1;\n     unsigned                    no_wait_shutdown:1;\n     unsigned                    no_send_shutdown:1;\n+    unsigned                    shutdown_without_free:1;\n     unsigned                    handshake_buffer_set:1;\n     unsigned                    try_early_data:1;\n     unsigned                    in_early:1;\nDiff:\n@@ -121,6 +121,7 @@ typedef struct {\n     unsigned                   done:1;\n     unsigned                   status:1;\n     unsigned                   rst:1;\n+    unsigned                   goaway:1;\n \n     ngx_http_request_t        *request;\n \n@@ -1210,6 +1211,7 @@ ngx_http_grpc_reinit_request(ngx_http_request_t *r)\n     ctx->done = 0;\n     ctx->status = 0;\n     ctx->rst = 0;\n+    ctx->goaway = 0;\n     ctx->connection = NULL;\n \n     return NGX_OK;\n@@ -1565,6 +1567,7 @@ ngx_http_grpc_body_output_filter(void *data, ngx_chain_t *in)\n             && ctx->out == NULL\n             && ctx->output_closed\n             && !ctx->output_blocked\n+            && !ctx->goaway\n             && ctx->state == ngx_http_grpc_st_start)\n         {\n             u->keepalive = 1;\n@@ -1714,6 +1717,8 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n                 return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n             }\n \n+            ctx->goaway = 1;\n+\n             continue;\n         }\n \n@@ -1907,6 +1912,7 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n                         && ctx->out == NULL\n                         && ctx->output_closed\n                         && !ctx->output_blocked\n+                        && !ctx->goaway\n                         && b->last == b->pos)\n                     {\n                         u->keepalive = 1;\n@@ -2035,6 +2041,7 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                     if (ctx->in == NULL\n                         && ctx->output_closed\n                         && !ctx->output_blocked\n+                        && !ctx->goaway\n                         && ctx->state == ngx_http_grpc_st_start)\n                     {\n                         u->keepalive = 1;\n@@ -2170,6 +2177,8 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n             }\n \n             ctx->rst = 1;\n+\n+            continue;\n         }\n \n         if (ctx->type == NGX_HTTP_V2_GOAWAY_FRAME) {\n@@ -2204,6 +2213,8 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                 return NGX_ERROR;\n             }\n \n+            ctx->goaway = 1;\n+\n             continue;\n         }\n \n@@ -3475,6 +3486,8 @@ ngx_http_grpc_parse_rst_stream(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n         return NGX_AGAIN;\n     }\n \n+    ctx->state = ngx_http_grpc_st_start;\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -3419,6 +3419,8 @@ ngx_http_set_lingering_close(ngx_connection_t *c)\n     if (c->ssl) {\n         ngx_int_t  rc;\n \n+        c->ssl->shutdown_without_free = 1;\n+\n         rc = ngx_ssl_shutdown(c);\n \n         if (rc == NGX_ERROR) {\nDiff:\n@@ -295,7 +295,7 @@ ngx_os_status(ngx_log_t *log)\n         osviex_stub = (ngx_osviex_stub_t *) &osvi.wServicePackMinor;\n \n         ngx_log_error(NGX_LOG_INFO, log, 0,\n-                      \"OS: %ud build:%ud, \\\"%s\\\", suite:%Xd, type:%ud\",\n+                      \"OS: %ui build:%ud, \\\"%s\\\", suite:%Xd, type:%ud\",\n                       ngx_win32_version, osvi.dwBuildNumber, osvi.szCSDVersion,\n                       osviex_stub->wSuiteMask, osviex_stub->wProductType);\n \n@@ -305,7 +305,7 @@ ngx_os_status(ngx_log_t *log)\n             /* Win9x build */\n \n             ngx_log_error(NGX_LOG_INFO, log, 0,\n-                          \"OS: %u build:%ud.%ud.%ud, \\\"%s\\\"\",\n+                          \"OS: %ui build:%ud.%ud.%ud, \\\"%s\\\"\",\n                           ngx_win32_version,\n                           osvi.dwBuildNumber >> 24,\n                           (osvi.dwBuildNumber >> 16) & 0xff,\n@@ -321,7 +321,7 @@ ngx_os_status(ngx_log_t *log)\n              * and we do not support VER_PLATFORM_WIN32s at all\n              */\n \n-            ngx_log_error(NGX_LOG_INFO, log, 0, \"OS: %ud build:%ud, \\\"%s\\\"\",\n+            ngx_log_error(NGX_LOG_INFO, log, 0, \"OS: %ui build:%ud, \\\"%s\\\"\",\n                           ngx_win32_version, osvi.dwBuildNumber,\n                           osvi.szCSDVersion);\n         }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 102",
        "commit_diff": "Diff:\n@@ -152,6 +152,7 @@ syn keyword ngxDirective contained auth_jwt_header_set\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n+syn keyword ngxDirective contained auth_jwt_type\n syn keyword ngxDirective contained auth_request\n syn keyword ngxDirective contained auth_request_set\n syn keyword ngxDirective contained autoindex\n@@ -332,16 +333,20 @@ syn keyword ngxDirective contained index\n syn keyword ngxDirective contained iocp_threads\n syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n+syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n syn keyword ngxDirective contained js_filter\n+syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n syn keyword ngxDirective contained js_set\n+syn keyword ngxDirective contained js_var\n syn keyword ngxDirective contained keepalive\n syn keyword ngxDirective contained keepalive_disable\n syn keyword ngxDirective contained keepalive_requests\n+syn keyword ngxDirective contained keepalive_time\n syn keyword ngxDirective contained keepalive_timeout\n syn keyword ngxDirective contained keyval\n syn keyword ngxDirective contained keyval_zone\n@@ -373,6 +378,7 @@ syn keyword ngxDirective contained log_subrequest\n syn keyword ngxDirective contained map_hash_bucket_size\n syn keyword ngxDirective contained map_hash_max_size\n syn keyword ngxDirective contained master_process\n+syn keyword ngxDirective contained max_errors\n syn keyword ngxDirective contained max_ranges\n syn keyword ngxDirective contained memcached_bind\n syn keyword ngxDirective contained memcached_buffer_size\n@@ -1080,6 +1086,8 @@ syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_mess\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n+syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info\n+syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info_string\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_last_message_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_location\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_message_id_custom_etag_header\n@@ -2368,9 +2376,9 @@ syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n \" IP2Location Nginx\n \" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+syn keyword ngxDirectiveThirdParty contained ip2location_addresstype\n syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n+syn keyword ngxDirectiveThirdParty contained ip2location_category\n syn keyword ngxDirectiveThirdParty contained ip2location_city\n syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n@@ -2384,6 +2392,8 @@ syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2location_region\n syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n@@ -2403,6 +2413,7 @@ syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_provider\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\nDiff:\n@@ -2896,9 +2896,12 @@ ngx_int_t\n ngx_ssl_shutdown(ngx_connection_t *c)\n {\n     int         n, sslerr, mode;\n+    ngx_int_t   rc;\n     ngx_err_t   err;\n     ngx_uint_t  tries;\n \n+    rc = NGX_OK;\n+\n     ngx_ssl_ocsp_cleanup(c);\n \n     if (SSL_in_init(c->ssl->connection)) {\n@@ -2908,11 +2911,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n          * Avoid calling SSL_shutdown() if handshake wasn't completed.\n          */\n \n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n-        c->recv = ngx_recv;\n-\n-        return NGX_OK;\n+        goto done;\n     }\n \n     if (c->timedout || c->error || c->buffered) {\n@@ -2954,11 +2953,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n \n         if (n == 1) {\n-            SSL_free(c->ssl->connection);\n-            c->ssl = NULL;\n-            c->recv = ngx_recv;\n-\n-            return NGX_OK;\n+            goto done;\n         }\n \n         if (n == 0 && tries-- > 1) {\n@@ -2984,11 +2979,11 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n             }\n \n             if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             ngx_add_timer(c->read, 3000);\n@@ -2997,23 +2992,27 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         }\n \n         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n-            SSL_free(c->ssl->connection);\n-            c->ssl = NULL;\n-            c->recv = ngx_recv;\n-\n-            return NGX_OK;\n+            goto done;\n         }\n \n         err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n         ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n \n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n-        c->recv = ngx_recv;\n-\n-        return NGX_ERROR;\n+        break;\n     }\n+\n+failed:\n+\n+    rc = NGX_ERROR;\n+\n+done:\n+\n+    SSL_free(c->ssl->connection);\n+    c->ssl = NULL;\n+    c->recv = ngx_recv;\n+\n+    return rc;\n }\n \n \nDiff:\n@@ -28,6 +28,7 @@ static ngx_int_t ngx_mail_smtp_starttls(ngx_mail_session_t *s,\n     ngx_connection_t *c);\n static ngx_int_t ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c);\n \n static ngx_int_t ngx_mail_smtp_discard_command(ngx_mail_session_t *s,\n     ngx_connection_t *c, char *err);\n@@ -36,6 +37,7 @@ static void ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s,\n \n \n static u_char  smtp_ok[] = \"250 2.0.0 OK\" CRLF;\n+static u_char  smtp_noop[] = \"255 2.0.0 OK\" CRLF;\n static u_char  smtp_bye[] = \"221 2.0.0 Bye\" CRLF;\n static u_char  smtp_starttls[] = \"220 2.0.0 Start TLS\" CRLF;\n static u_char  smtp_next[] = \"334 \" CRLF;\n@@ -511,6 +513,7 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n                 break;\n \n             case NGX_SMTP_NOOP:\n+                rc = ngx_mail_smtp_noop(s, c);\n                 break;\n \n             case NGX_SMTP_STARTTLS:\n@@ -825,6 +828,20 @@ ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)\n }\n \n \n+static ngx_int_t\n+ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    if (s->args.nelts > 10) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        ngx_mail_close_connection(c);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_str_set(&s->out, smtp_noop);\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n",
        "analysis": "First, we look for newly added entire functions in the diff:\n\n1. **Function `ngx_mail_smtp_noop`:**\n\n```c\nstatic ngx_int_t\nngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c)\n{\n    if (s->args.nelts > 10) {\n        ngx_str_set(&s->out, smtp_invalid_argument);\n        ngx_mail_close_connection(c);\n        return NGX_ERROR;\n    }\n\n    ngx_str_set(&s->out, smtp_noop);\n    return NGX_OK;\n}\n```\n\nNow, let's analyze this function line by line to check for potential out-of-bounds write vulnerabilities:\n\n- `if (s->args.nelts > 10)`: This checks if the number of elements exceeds 10. This appears to be a condition to prevent excessive arguments, but without knowing the context of how `s->args` and `s->out` are used, it's difficult to ascertain if any bounds are strictly respected.\n- `ngx_str_set(&s->out, smtp_invalid_argument);` and `ngx_str_set(&s->out, smtp_noop);`: These lines assign fixed strings to the `s->out` variable. Assuming `ngx_str_set` is a safe function that handles its arguments correctly (for instance, it might ensure that it does not write past the bounds of `s->out`), there might not be a vulnerability here. However, this is based on the assumption that `ngx_str_set` operates safely.\n- No other operations suggest an obvious out-of-bounds write risk unless there are underlying assumptions about the structure sizes (`s->out` etc.) that are violated elsewhere.\n\nAfter the analysis, based on what we can see:\n\nThe `ngx_mail_smtp_noop` function directly doesn't exhibit any immediate coding pattern synonymous with out-of-bounds writes, assuming the helper functions (like `ngx_str_set`) are safe.\n\nConclusion:\nBased on currently available analysis, there is no apparent indication of an out-of-bounds write vulnerability in the newly added function under typical analysis constraints, so the result is:\n\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 101",
        "commit_diff": "Diff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1021000\n-#define NGINX_VERSION      \"1.21.0\"\n+#define nginx_version      1021001\n+#define NGINX_VERSION      \"1.21.1\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -495,21 +495,24 @@ ngx_open_listening_sockets(ngx_cycle_t *cycle)\n                 return NGX_ERROR;\n             }\n \n-            if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n-                           (const void *) &reuseaddr, sizeof(int))\n-                == -1)\n-            {\n-                ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n-                              \"setsockopt(SO_REUSEADDR) %V failed\",\n-                              &ls[i].addr_text);\n+            if (ls[i].type != SOCK_DGRAM || !ngx_test_config) {\n \n-                if (ngx_close_socket(s) == -1) {\n+                if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n+                               (const void *) &reuseaddr, sizeof(int))\n+                    == -1)\n+                {\n                     ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n-                                  ngx_close_socket_n \" %V failed\",\n+                                  \"setsockopt(SO_REUSEADDR) %V failed\",\n                                   &ls[i].addr_text);\n-                }\n \n-                return NGX_ERROR;\n+                    if (ngx_close_socket(s) == -1) {\n+                        ngx_log_error(NGX_LOG_EMERG, log, ngx_socket_errno,\n+                                      ngx_close_socket_n \" %V failed\",\n+                                      &ls[i].addr_text);\n+                    }\n+\n+                    return NGX_ERROR;\n+                }\n             }\n \n #if (NGX_HAVE_REUSEPORT)\nDiff:\n@@ -441,20 +441,23 @@ ngx_event_init_conf(ngx_cycle_t *cycle, void *conf)\n \n #if (NGX_HAVE_REUSEPORT)\n \n-    ls = cycle->listening.elts;\n-    for (i = 0; i < cycle->listening.nelts; i++) {\n+    if (!ngx_test_config) {\n \n-        if (!ls[i].reuseport || ls[i].worker != 0) {\n-            continue;\n-        }\n+        ls = cycle->listening.elts;\n+        for (i = 0; i < cycle->listening.nelts; i++) {\n \n-        if (ngx_clone_listening(cycle, &ls[i]) != NGX_OK) {\n-            return NGX_CONF_ERROR;\n-        }\n+            if (!ls[i].reuseport || ls[i].worker != 0) {\n+                continue;\n+            }\n \n-        /* cloning may change cycle->listening.elts */\n+            if (ngx_clone_listening(cycle, &ls[i]) != NGX_OK) {\n+                return NGX_CONF_ERROR;\n+            }\n \n-        ls = cycle->listening.elts;\n+            /* cloning may change cycle->listening.elts */\n+\n+            ls = cycle->listening.elts;\n+        }\n     }\n \n #endif\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 100",
        "commit_diff": "Diff:\n@@ -460,3 +460,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\n+df34dcc9ac072ffd0945e5a1f3eb7987e8275375 release-1.21.0\nDiff:\n@@ -5,6 +5,100 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.21.0\" date=\"2021-05-25\">\n+\n+<change type=\"security\">\n+<para lang=\"ru\">\n+при использовании директивы resolver\n+во время обработки ответа DNS-сервера\n+могла происходить перезапись одного байта памяти,\n+что позволяло атакующему,\n+имеющему возможность подделывать UDP-пакеты от DNS-сервера,\n+вызвать падение рабочего процесса\n+или, потенциально, выполнение произвольного кода (CVE-2021-23017).\n+</para>\n+<para lang=\"en\">\n+1-byte memory overwrite might occur\n+during DNS server response processing\n+if the \"resolver\" directive was used,\n+allowing an attacker\n+who is able to forge UDP packets from the DNS server\n+to cause worker process crash\n+or, potentially, arbitrary code execution (CVE-2021-23017).\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директивы proxy_ssl_certificate, proxy_ssl_certificate_key,\n+grpc_ssl_certificate, grpc_ssl_certificate_key,\n+uwsgi_ssl_certificate и uwsgi_ssl_certificate_key\n+поддерживают переменные.\n+</para>\n+<para lang=\"en\">\n+variables support\n+in the \"proxy_ssl_certificate\", \"proxy_ssl_certificate_key\"\n+\"grpc_ssl_certificate\", \"grpc_ssl_certificate_key\",\n+\"uwsgi_ssl_certificate\", and \"uwsgi_ssl_certificate_key\" directives.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива max_errors в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+the \"max_errors\" directive in the mail proxy module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+почтовый прокси-сервер поддерживает POP3 и IMAP pipelining.\n+</para>\n+<para lang=\"en\">\n+the mail proxy module supports POP3 and IMAP pipelining.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+параметр fastopen директивы listen в модуле stream.<br/>\n+Спасибо Anbang Wen.\n+</para>\n+<para lang=\"en\">\n+the \"fastopen\" parameter of the \"listen\" directive in the stream module.<br/>\n+Thanks to Anbang Wen.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+специальные символы не экранировались\n+при автоматическом перенаправлении с добавлением завершающего слэша.\n+</para>\n+<para lang=\"en\">\n+special characters were not escaped\n+during automatic redirect with appended trailing slash.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании SMTP pipelining\n+соединения с клиентами в почтовом прокси-сервере\n+могли неожиданно закрываться.\n+</para>\n+<para lang=\"en\">\n+connections with clients in the mail proxy module\n+might be closed unexpectedly\n+when using SMTP pipelining.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.10\" date=\"2021-04-13\">\n \n <change type=\"change\">\nDiff:\n@@ -1798,6 +1798,12 @@ ngx_resolver_process_response(ngx_resolver_t *r, u_char *buf, size_t n,\n     i = sizeof(ngx_resolver_hdr_t);\n \n     while (i < (ngx_uint_t) n) {\n+\n+        if (buf[i] & 0xc0) {\n+            err = \"unexpected compression pointer in DNS response\";\n+            goto done;\n+        }\n+\n         if (buf[i] == '\\0') {\n             goto found;\n         }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 99",
        "commit_diff": "Diff:\n@@ -3939,11 +3939,11 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n {\n     char        *err;\n     u_char      *p, *dst;\n-    ssize_t      len;\n+    size_t       len;\n     ngx_uint_t   i, n;\n \n     p = src;\n-    len = -1;\n+    len = 0;\n \n     /*\n      * compression pointers allow to create endless loop, so we set limit;\n@@ -3958,6 +3958,16 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         }\n \n         if (n & 0xc0) {\n+            if ((n & 0xc0) != 0xc0) {\n+                err = \"invalid label type in DNS response\";\n+                goto invalid;\n+            }\n+\n+            if (p >= last) {\n+                err = \"name is out of DNS response\";\n+                goto invalid;\n+            }\n+\n             n = ((n & 0x3f) << 8) + *p;\n             p = &buf[n];\n \n@@ -3986,7 +3996,7 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         return NGX_OK;\n     }\n \n-    if (len == -1) {\n+    if (len == 0) {\n         ngx_str_null(name);\n         return NGX_OK;\n     }\n@@ -3998,30 +4008,23 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n \n     name->data = dst;\n \n-    n = *src++;\n-\n     for ( ;; ) {\n+        n = *src++;\n+\n+        if (n == 0) {\n+            name->len = dst - name->data - 1;\n+            return NGX_OK;\n+        }\n+\n         if (n & 0xc0) {\n             n = ((n & 0x3f) << 8) + *src;\n             src = &buf[n];\n \n-            n = *src++;\n-\n         } else {\n             ngx_strlow(dst, src, n);\n             dst += n;\n             src += n;\n-\n-            n = *src++;\n-\n-            if (n != 0) {\n-                *dst++ = '.';\n-            }\n-        }\n-\n-        if (n == 0) {\n-            name->len = dst - name->data;\n-            return NGX_OK;\n+            *dst++ = '.';\n         }\n     }\n }\nDiff:\n@@ -1072,14 +1072,37 @@ ngx_http_dav_error(ngx_log_t *log, ngx_err_t err, ngx_int_t not_found,\n static ngx_int_t\n ngx_http_dav_location(ngx_http_request_t *r)\n {\n+    u_char     *p;\n+    size_t      len;\n+    uintptr_t   escape;\n+\n     r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n     if (r->headers_out.location == NULL) {\n         return NGX_ERROR;\n     }\n \n     r->headers_out.location->hash = 1;\n     ngx_str_set(&r->headers_out.location->key, \"Location\");\n-    r->headers_out.location->value = r->uri;\n+\n+    escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n+\n+    if (escape) {\n+        len = r->uri.len + escape;\n+\n+        p = ngx_pnalloc(r->pool, len);\n+        if (p == NULL) {\n+            ngx_http_clear_location(r);\n+            return NGX_ERROR;\n+        }\n+\n+        r->headers_out.location->value.len = len;\n+        r->headers_out.location->value.data = p;\n+\n+        ngx_escape_uri(p, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n+\n+    } else {\n+        r->headers_out.location->value = r->uri;\n+    }\n \n     return NGX_OK;\n }\nDiff:\n@@ -50,6 +50,7 @@ ngx_http_static_handler(ngx_http_request_t *r)\n {\n     u_char                    *last, *location;\n     size_t                     root, len;\n+    uintptr_t                  escape;\n     ngx_str_t                  path;\n     ngx_int_t                  rc;\n     ngx_uint_t                 level;\n@@ -155,14 +156,18 @@ ngx_http_static_handler(ngx_http_request_t *r)\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n-        len = r->uri.len + 1;\n+        escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len,\n+                                    NGX_ESCAPE_URI);\n \n-        if (!clcf->alias && r->args.len == 0) {\n+        if (!clcf->alias && r->args.len == 0 && escape == 0) {\n+            len = r->uri.len + 1;\n             location = path.data + root;\n \n             *last = '/';\n \n         } else {\n+            len = r->uri.len + escape + 1;\n+\n             if (r->args.len) {\n                 len += r->args.len + 1;\n             }\n@@ -173,7 +178,13 @@ ngx_http_static_handler(ngx_http_request_t *r)\n                 return NGX_HTTP_INTERNAL_SERVER_ERROR;\n             }\n \n-            last = ngx_copy(location, r->uri.data, r->uri.len);\n+            if (escape) {\n+                last = (u_char *) ngx_escape_uri(location, r->uri.data,\n+                                                 r->uri.len, NGX_ESCAPE_URI);\n+\n+            } else {\n+                last = ngx_copy(location, r->uri.data, r->uri.len);\n+            }\n \n             *last = '/';\n \nDiff:\n@@ -37,6 +37,8 @@ static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf,\n     ngx_http_core_srv_conf_t *cscf, ngx_http_core_loc_conf_t *pclcf);\n static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf,\n     ngx_http_core_loc_conf_t *pclcf);\n+static ngx_int_t ngx_http_escape_location_name(ngx_conf_t *cf,\n+    ngx_http_core_loc_conf_t *clcf);\n static ngx_int_t ngx_http_cmp_locations(const ngx_queue_t *one,\n     const ngx_queue_t *two);\n static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf,\n@@ -882,6 +884,41 @@ ngx_http_add_location(ngx_conf_t *cf, ngx_queue_t **locations,\n \n     ngx_queue_insert_tail(*locations, &lq->queue);\n \n+    if (ngx_http_escape_location_name(cf, clcf) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_escape_location_name(ngx_conf_t *cf, ngx_http_core_loc_conf_t *clcf)\n+{\n+    u_char     *p;\n+    size_t      len;\n+    uintptr_t   escape;\n+\n+    escape = 2 * ngx_escape_uri(NULL, clcf->name.data, clcf->name.len,\n+                                NGX_ESCAPE_URI);\n+\n+    if (escape) {\n+        len = clcf->name.len + escape;\n+\n+        p = ngx_pnalloc(cf->pool, len);\n+        if (p == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        clcf->escaped_name.len = len;\n+        clcf->escaped_name.data = p;\n+\n+        ngx_escape_uri(p, clcf->name.data, clcf->name.len, NGX_ESCAPE_URI);\n+\n+    } else {\n+        clcf->escaped_name = clcf->name;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -1010,10 +1010,10 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,\n         ngx_str_set(&r->headers_out.location->key, \"Location\");\n \n         if (r->args.len == 0) {\n-            r->headers_out.location->value = clcf->name;\n+            r->headers_out.location->value = clcf->escaped_name;\n \n         } else {\n-            len = clcf->name.len + 1 + r->args.len;\n+            len = clcf->escaped_name.len + 1 + r->args.len;\n             p = ngx_pnalloc(r->pool, len);\n \n             if (p == NULL) {\n@@ -1025,7 +1025,7 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,\n             r->headers_out.location->value.len = len;\n             r->headers_out.location->value.data = p;\n \n-            p = ngx_cpymem(p, clcf->name.data, clcf->name.len);\n+            p = ngx_cpymem(p, clcf->escaped_name.data, clcf->escaped_name.len);\n             *p++ = '?';\n             ngx_memcpy(p, r->args.data, r->args.len);\n         }\n@@ -3467,6 +3467,7 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     /*\n      * set by ngx_pcalloc():\n      *\n+     *     clcf->escaped_name = { 0, NULL };\n      *     clcf->root = { 0, NULL };\n      *     clcf->limit_except = 0;\n      *     clcf->post_action = { 0, NULL };\nDiff:\n@@ -302,6 +302,7 @@ typedef struct {\n \n struct ngx_http_core_loc_conf_s {\n     ngx_str_t     name;          /* location name */\n+    ngx_str_t     escaped_name;\n \n #if (NGX_PCRE)\n     ngx_http_regex_t  *regex;\n",
        "analysis": "``` \nTRUE [ngx_http_dav_location] [ngx_http_escape_location_name]\n```\n\n1. **Function ngx_http_dav_location:**\n\n    - **Lines of concern:**\n        - Lines where `len` and `escape` are calculated and `p` is allocated and then used without explicit boundary checking.\n\n    - **Potential vulnerability:**\n        - The function calculates an escaped string size (`len`) and attempts to allocate memory (`p = ngx_pnalloc(r->pool, len)`). If `nginx_escape_uri()` expands the string more than expected, there could be an out-of-bounds write.\n\n2. **Function ngx_http_escape_location_name:**\n\n    - **Lines of concern:**\n        - Similar to `ngx_http_dav_location`, `len` is updated with escape calculations and memory is allocated with possible misuse.\n\n    - **Potential vulnerability:**\n        - The allocated memory `p` utilizes `ngx_pnalloc` which can end up in buffer overflow due to miscalculation in the expanded string length in `escape = 2 * ngx_escape_uri(...)`."
    },
    {
        "commit_index": "Commit 98",
        "commit_diff": "Diff:\n@@ -1057,12 +1057,14 @@ ngx_http_ssl_certificate(ngx_ssl_conn_t *ssl_conn, void *arg)\n     }\n \n     ngx_http_free_request(r, 0);\n+    c->log->action = \"SSL handshaking\";\n     c->destroyed = 0;\n     return 1;\n \n failed:\n \n     ngx_http_free_request(r, 0);\n+    c->log->action = \"SSL handshaking\";\n     c->destroyed = 0;\n     return 0;\n }\nDiff:\n@@ -510,6 +510,10 @@ ngx_stream_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports)\n             ls->ipv6only = addr[i].opt.ipv6only;\n #endif\n \n+#if (NGX_HAVE_TCP_FASTOPEN)\n+            ls->fastopen = addr[i].opt.fastopen;\n+#endif\n+\n #if (NGX_HAVE_REUSEPORT)\n             ls->reuseport = addr[i].opt.reuseport;\n #endif\nDiff:\n@@ -65,6 +65,9 @@ typedef struct {\n     int                            backlog;\n     int                            rcvbuf;\n     int                            sndbuf;\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+    int                            fastopen;\n+#endif\n     int                            type;\n } ngx_stream_listen_t;\n \nDiff:\n@@ -615,6 +615,10 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ls->type = SOCK_STREAM;\n     ls->ctx = cf->ctx;\n \n+#if (NGX_HAVE_TCP_FASTOPEN)\n+    ls->fastopen = -1;\n+#endif\n+\n #if (NGX_HAVE_INET6)\n     ls->ipv6only = 1;\n #endif\n@@ -635,6 +639,21 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n             continue;\n         }\n \n+#if (NGX_HAVE_TCP_FASTOPEN)\n+        if (ngx_strncmp(value[i].data, \"fastopen=\", 9) == 0) {\n+            ls->fastopen = ngx_atoi(value[i].data + 9, value[i].len - 9);\n+            ls->bind = 1;\n+\n+            if (ls->fastopen == NGX_ERROR) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid fastopen \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            continue;\n+        }\n+#endif\n+\n         if (ngx_strncmp(value[i].data, \"backlog=\", 8) == 0) {\n             ls->backlog = ngx_atoi(value[i].data + 8, value[i].len - 8);\n             ls->bind = 1;\n@@ -859,6 +878,12 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         if (ls->proxy_protocol) {\n             return \"\\\"proxy_protocol\\\" parameter is incompatible with \\\"udp\\\"\";\n         }\n+\n+#if (NGX_HAVE_TCP_FASTOPEN)\n+        if (ls->fastopen != -1) {\n+            return \"\\\"fastopen\\\" parameter is incompatible with \\\"udp\\\"\";\n+        }\n+#endif\n     }\n \n     als = cmcf->listen.elts;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 97",
        "commit_diff": "Diff:\n@@ -1573,7 +1573,7 @@ ngx_escape_uri(u_char *dst, u_char *src, size_t size, ngx_uint_t type)\n         0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n     };\n \n-                    /* \" \", \"\"\", \"%\", \"'\", %00-%1F, %7F-%FF */\n+                    /* \" \", \"\"\", \"'\", %00-%1F, %7F-%FF */\n \n     static uint32_t   refresh[] = {\n         0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\nDiff:\n@@ -115,6 +115,8 @@ typedef struct {\n     ngx_msec_t              timeout;\n     ngx_msec_t              resolver_timeout;\n \n+    ngx_uint_t              max_errors;\n+\n     ngx_str_t               server_name;\n \n     u_char                 *file_name;\n@@ -231,6 +233,7 @@ typedef struct {\n     ngx_uint_t              command;\n     ngx_array_t             args;\n \n+    ngx_uint_t              errors;\n     ngx_uint_t              login_attempt;\n \n     /* used to parse POP3/IMAP/SMTP command */\nDiff:\n@@ -85,6 +85,13 @@ static ngx_command_t  ngx_mail_core_commands[] = {\n       offsetof(ngx_mail_core_srv_conf_t, resolver_timeout),\n       NULL },\n \n+    { ngx_string(\"max_errors\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_num_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_core_srv_conf_t, max_errors),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -163,6 +170,8 @@ ngx_mail_core_create_srv_conf(ngx_conf_t *cf)\n     cscf->timeout = NGX_CONF_UNSET_MSEC;\n     cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;\n \n+    cscf->max_errors = NGX_CONF_UNSET_UINT;\n+\n     cscf->resolver = NGX_CONF_UNSET_PTR;\n \n     cscf->file_name = cf->conf_file->file.name.data;\n@@ -182,6 +191,7 @@ ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n                               30000);\n \n+    ngx_conf_merge_uint_value(conf->max_errors, prev->max_errors, 5);\n \n     ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n \nDiff:\n@@ -874,7 +874,20 @@ ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n         return NGX_MAIL_PARSE_INVALID_COMMAND;\n     }\n \n-    if (rc == NGX_IMAP_NEXT || rc == NGX_MAIL_PARSE_INVALID_COMMAND) {\n+    if (rc == NGX_MAIL_PARSE_INVALID_COMMAND) {\n+\n+        s->errors++;\n+\n+        if (s->errors >= cscf->max_errors) {\n+            ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                          \"client sent too many invalid commands\");\n+            s->quit = 1;\n+        }\n+\n+        return rc;\n+    }\n+\n+    if (rc == NGX_IMAP_NEXT) {\n         return rc;\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 96",
        "commit_diff": "Diff:\n@@ -236,6 +236,7 @@ typedef struct {\n     /* used to parse POP3/IMAP/SMTP command */\n \n     ngx_uint_t              state;\n+    u_char                 *tag_start;\n     u_char                 *cmd_start;\n     u_char                 *arg_start;\n     ngx_uint_t              literal_len;\nDiff:\n@@ -226,6 +226,10 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n         ngx_str_set(&s->out, imap_next);\n     }\n \n+    if (s->buffer->pos < s->buffer->last) {\n+        s->blocked = 1;\n+    }\n+\n     switch (rc) {\n \n     case NGX_DONE:\n@@ -275,13 +279,14 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n \n         if (s->state) {\n             /* preserve tag */\n-            s->arg_start = s->buffer->start + s->tag.len;\n-            s->buffer->pos = s->arg_start;\n-            s->buffer->last = s->arg_start;\n+            s->arg_start = s->buffer->pos;\n \n         } else {\n-            s->buffer->pos = s->buffer->start;\n-            s->buffer->last = s->buffer->start;\n+            if (s->buffer->pos == s->buffer->last) {\n+                s->buffer->pos = s->buffer->start;\n+                s->buffer->last = s->buffer->start;\n+            }\n+\n             s->tag.len = 0;\n         }\n     }\n@@ -459,6 +464,8 @@ ngx_mail_imap_starttls(ngx_mail_session_t *s, ngx_connection_t *c)\n     if (c->ssl == NULL) {\n         sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n         if (sslcf->starttls) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n             c->read->handler = ngx_mail_starttls_handler;\n             return NGX_OK;\n         }\nDiff:\n@@ -231,6 +231,8 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n     ngx_str_t  *arg;\n     enum {\n         sw_start = 0,\n+        sw_tag,\n+        sw_invalid,\n         sw_spaces_before_command,\n         sw_command,\n         sw_spaces_before_argument,\n@@ -253,42 +255,45 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n \n         /* IMAP tag */\n         case sw_start:\n+            s->tag_start = p;\n+            state = sw_tag;\n+\n+            /* fall through */\n+\n+        case sw_tag:\n             switch (ch) {\n             case ' ':\n-                s->tag.len = p - s->buffer->start + 1;\n-                s->tag.data = s->buffer->start;\n+                s->tag.len = p - s->tag_start + 1;\n+                s->tag.data = s->tag_start;\n                 state = sw_spaces_before_command;\n                 break;\n             case CR:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n             case LF:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+                goto invalid;\n             default:\n                 if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')\n                     && (ch < '0' || ch > '9') && ch != '-' && ch != '.'\n                     && ch != '_')\n                 {\n                     goto invalid;\n                 }\n-                if (p - s->buffer->start > 31) {\n+                if (p - s->tag_start > 31) {\n                     goto invalid;\n                 }\n                 break;\n             }\n             break;\n \n+        case sw_invalid:\n+            goto invalid;\n+\n         case sw_spaces_before_command:\n             switch (ch) {\n             case ' ':\n                 break;\n             case CR:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n             case LF:\n-                s->state = sw_start;\n-                return NGX_MAIL_PARSE_INVALID_COMMAND;\n+                goto invalid;\n             default:\n                 s->cmd_start = p;\n                 state = sw_command;\n@@ -408,6 +413,9 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n                     goto invalid;\n                 }\n \n+                s->cmd.data = s->cmd_start;\n+                s->cmd.len = p - s->cmd_start;\n+\n                 switch (ch) {\n                 case ' ':\n                     state = sw_spaces_before_argument;\n@@ -631,13 +639,40 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n \n invalid:\n \n-    s->state = sw_start;\n+    s->state = sw_invalid;\n     s->quoted = 0;\n     s->backslash = 0;\n     s->no_sync_literal = 0;\n     s->literal_len = 0;\n \n-    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    /* skip invalid command till LF */\n+\n+    for ( /* void */ ; p < s->buffer->last; p++) {\n+        if (*p == LF) {\n+            s->state = sw_start;\n+            s->buffer->pos = p + 1;\n+\n+            /* detect non-synchronizing literals */\n+\n+            if ((size_t) (p - s->buffer->start) > sizeof(\"{1+}\") - 1) {\n+                p--;\n+\n+                if (*p == CR) {\n+                    p--;\n+                }\n+\n+                if (*p == '}' && *(p - 1) == '+') {\n+                    s->quit = 1;\n+                }\n+            }\n+\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+\n+    return NGX_AGAIN;\n }\n \n \nDiff:\n@@ -486,6 +486,10 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n+        if (s->buffer->pos < s->buffer->last) {\n+            ngx_post_event(c->write, &ngx_posted_events);\n+        }\n+\n         ngx_mail_proxy_handler(s->connection->write);\n \n         return;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 95",
        "commit_diff": "Diff:\n@@ -238,7 +238,6 @@ typedef struct {\n     ngx_uint_t              state;\n     u_char                 *cmd_start;\n     u_char                 *arg_start;\n-    u_char                 *arg_end;\n     ngx_uint_t              literal_len;\n } ngx_mail_session_t;\n \nDiff:\n@@ -101,10 +101,9 @@ ngx_mail_imap_init_protocol(ngx_event_t *rev)\n void\n ngx_mail_imap_auth_state(ngx_event_t *rev)\n {\n-    u_char              *p, *dst, *src, *end;\n-    ngx_str_t           *arg;\n+    u_char              *p;\n     ngx_int_t            rc;\n-    ngx_uint_t           tag, i;\n+    ngx_uint_t           tag;\n     ngx_connection_t    *c;\n     ngx_mail_session_t  *s;\n \n@@ -158,27 +157,6 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n         ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap auth command: %i\",\n                        s->command);\n \n-        if (s->backslash) {\n-\n-            arg = s->args.elts;\n-\n-            for (i = 0; i < s->args.nelts; i++) {\n-                dst = arg[i].data;\n-                end = dst + arg[i].len;\n-\n-                for (src = dst; src < end; dst++) {\n-                    *dst = *src;\n-                    if (*src++ == '\\\\') {\n-                        *dst = *src++;\n-                    }\n-                }\n-\n-                arg[i].len = dst - arg[i].data;\n-            }\n-\n-            s->backslash = 0;\n-        }\n-\n         switch (s->mail_state) {\n \n         case ngx_imap_start:\nDiff:\n@@ -124,10 +124,8 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                 break;\n             case CR:\n                 state = sw_almost_done;\n-                s->arg_end = p;\n                 break;\n             case LF:\n-                s->arg_end = p;\n                 goto done;\n             default:\n                 if (s->args.nelts <= 2) {\n@@ -202,25 +200,13 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n done:\n \n     s->buffer->pos = p + 1;\n-\n-    if (s->arg_start) {\n-        arg = ngx_array_push(&s->args);\n-        if (arg == NULL) {\n-            return NGX_ERROR;\n-        }\n-        arg->len = s->arg_end - s->arg_start;\n-        arg->data = s->arg_start;\n-        s->arg_start = NULL;\n-    }\n-\n     s->state = (s->command != NGX_POP3_AUTH) ? sw_start : sw_argument;\n \n     return NGX_OK;\n \n invalid:\n \n     s->state = sw_invalid;\n-    s->arg_start = NULL;\n \n     /* skip invalid command till LF */\n \n@@ -241,7 +227,7 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n ngx_int_t\n ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n {\n-    u_char      ch, *p, *c;\n+    u_char      ch, *p, *c, *dst, *src, *end;\n     ngx_str_t  *arg;\n     enum {\n         sw_start = 0,\n@@ -279,6 +265,17 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n             case LF:\n                 s->state = sw_start;\n                 return NGX_MAIL_PARSE_INVALID_COMMAND;\n+            default:\n+                if ((ch < 'A' || ch > 'Z') && (ch < 'a' || ch > 'z')\n+                    && (ch < '0' || ch > '9') && ch != '-' && ch != '.'\n+                    && ch != '_')\n+                {\n+                    goto invalid;\n+                }\n+                if (p - s->buffer->start > 31) {\n+                    goto invalid;\n+                }\n+                break;\n             }\n             break;\n \n@@ -436,10 +433,8 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n                 break;\n             case CR:\n                 state = sw_almost_done;\n-                s->arg_end = p;\n                 break;\n             case LF:\n-                s->arg_end = p;\n                 goto done;\n             case '\"':\n                 if (s->args.nelts <= 2) {\n@@ -486,6 +481,22 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n                 }\n                 arg->len = p - s->arg_start;\n                 arg->data = s->arg_start;\n+\n+                if (s->backslash) {\n+                    dst = s->arg_start;\n+                    end = p;\n+\n+                    for (src = dst; src < end; dst++) {\n+                        *dst = *src;\n+                        if (*src++ == '\\\\') {\n+                            *dst = *src++;\n+                        }\n+                    }\n+\n+                    arg->len = dst - s->arg_start;\n+                    s->backslash = 0;\n+                }\n+\n                 s->arg_start = NULL;\n \n                 switch (ch) {\n@@ -614,30 +625,13 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n done:\n \n     s->buffer->pos = p + 1;\n-\n-    if (s->arg_start) {\n-        arg = ngx_array_push(&s->args);\n-        if (arg == NULL) {\n-            return NGX_ERROR;\n-        }\n-        arg->len = s->arg_end - s->arg_start;\n-        arg->data = s->arg_start;\n-\n-        s->arg_start = NULL;\n-        s->cmd_start = NULL;\n-        s->quoted = 0;\n-        s->no_sync_literal = 0;\n-        s->literal_len = 0;\n-    }\n-\n     s->state = (s->command != NGX_IMAP_AUTHENTICATE) ? sw_start : sw_argument;\n \n     return NGX_OK;\n \n invalid:\n \n     s->state = sw_start;\n-    s->arg_start = NULL;\n     s->quoted = 0;\n     s->backslash = 0;\n     s->no_sync_literal = 0;\n@@ -786,10 +780,8 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n                 break;\n             case CR:\n                 state = sw_almost_done;\n-                s->arg_end = p;\n                 break;\n             case LF:\n-                s->arg_end = p;\n                 goto done;\n             default:\n                 if (s->args.nelts <= 10) {\n@@ -849,25 +841,13 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n done:\n \n     s->buffer->pos = p + 1;\n-\n-    if (s->arg_start) {\n-        arg = ngx_array_push(&s->args);\n-        if (arg == NULL) {\n-            return NGX_ERROR;\n-        }\n-        arg->len = s->arg_end - s->arg_start;\n-        arg->data = s->arg_start;\n-        s->arg_start = NULL;\n-    }\n-\n     s->state = (s->command != NGX_SMTP_AUTH) ? sw_start : sw_argument;\n \n     return NGX_OK;\n \n invalid:\n \n     s->state = sw_invalid;\n-    s->arg_start = NULL;\n \n     /* skip invalid command till LF */\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 94",
        "commit_diff": "Diff:\n@@ -21,6 +21,8 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n     ngx_str_t  *arg;\n     enum {\n         sw_start = 0,\n+        sw_command,\n+        sw_invalid,\n         sw_spaces_before_argument,\n         sw_argument,\n         sw_almost_done\n@@ -35,8 +37,14 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n \n         /* POP3 command */\n         case sw_start:\n+            s->cmd_start = p;\n+            state = sw_command;\n+\n+            /* fall through */\n+\n+        case sw_command:\n             if (ch == ' ' || ch == CR || ch == LF) {\n-                c = s->buffer->start;\n+                c = s->cmd_start;\n \n                 if (p - c == 4) {\n \n@@ -85,6 +93,9 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                     goto invalid;\n                 }\n \n+                s->cmd.data = s->cmd_start;\n+                s->cmd.len = p - s->cmd_start;\n+\n                 switch (ch) {\n                 case ' ':\n                     state = sw_spaces_before_argument;\n@@ -104,6 +115,9 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n \n             break;\n \n+        case sw_invalid:\n+            goto invalid;\n+\n         case sw_spaces_before_argument:\n             switch (ch) {\n             case ' ':\n@@ -205,10 +219,22 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n \n invalid:\n \n-    s->state = sw_start;\n+    s->state = sw_invalid;\n     s->arg_start = NULL;\n \n-    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    /* skip invalid command till LF */\n+\n+    for ( /* void */ ; p < s->buffer->last; p++) {\n+        if (*p == LF) {\n+            s->state = sw_start;\n+            s->buffer->pos = p + 1;\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n+        }\n+    }\n+\n+    s->buffer->pos = p;\n+\n+    return NGX_AGAIN;\n }\n \n \n@@ -611,7 +637,9 @@ ngx_mail_imap_parse_command(ngx_mail_session_t *s)\n invalid:\n \n     s->state = sw_start;\n+    s->arg_start = NULL;\n     s->quoted = 0;\n+    s->backslash = 0;\n     s->no_sync_literal = 0;\n     s->literal_len = 0;\n \nDiff:\n@@ -262,6 +262,10 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n         }\n     }\n \n+    if (s->buffer->pos < s->buffer->last) {\n+        s->blocked = 1;\n+    }\n+\n     switch (rc) {\n \n     case NGX_DONE:\n@@ -283,11 +287,14 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n     case NGX_OK:\n \n         s->args.nelts = 0;\n-        s->buffer->pos = s->buffer->start;\n-        s->buffer->last = s->buffer->start;\n+\n+        if (s->buffer->pos == s->buffer->last) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n+        }\n \n         if (s->state) {\n-            s->arg_start = s->buffer->start;\n+            s->arg_start = s->buffer->pos;\n         }\n \n         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n@@ -400,6 +407,8 @@ ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c)\n     if (c->ssl == NULL) {\n         sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n         if (sslcf->starttls) {\n+            s->buffer->pos = s->buffer->start;\n+            s->buffer->last = s->buffer->start;\n             c->read->handler = ngx_mail_starttls_handler;\n             return NGX_OK;\n         }\nDiff:\n@@ -327,6 +327,10 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n+        if (s->buffer->pos < s->buffer->last) {\n+            ngx_post_event(c->write, &ngx_posted_events);\n+        }\n+\n         ngx_mail_proxy_handler(s->connection->write);\n \n         return;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 93",
        "commit_diff": "Diff:\n@@ -51,6 +51,7 @@ types {\n     application/vnd.openxmlformats-officedocument.wordprocessingml.document\n                                                      docx;\n     application/vnd.wap.wmlc                         wmlc;\n+    application/wasm                                 wasm;\n     application/x-7z-compressed                      7z;\n     application/x-cocoa                              cco;\n     application/x-java-archive-diff                  jardiff;\nDiff:\n@@ -843,17 +843,17 @@ ngx_mail_smtp_parse_command(ngx_mail_session_t *s)\n \n     /* skip invalid command till LF */\n \n-    for (p = s->buffer->pos; p < s->buffer->last; p++) {\n+    for ( /* void */ ; p < s->buffer->last; p++) {\n         if (*p == LF) {\n             s->state = sw_start;\n-            p++;\n-            break;\n+            s->buffer->pos = p + 1;\n+            return NGX_MAIL_PARSE_INVALID_COMMAND;\n         }\n     }\n \n     s->buffer->pos = p;\n \n-    return NGX_MAIL_PARSE_INVALID_COMMAND;\n+    return NGX_AGAIN;\n }\n \n \nDiff:\n@@ -813,13 +813,12 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         c->log->action = NULL;\n         ngx_log_error(NGX_LOG_INFO, c->log, 0, \"client logged in\");\n \n-        if (s->buffer->pos == s->buffer->last) {\n-            ngx_mail_proxy_handler(s->connection->write);\n-\n-        } else {\n-            ngx_mail_proxy_handler(c->write);\n+        if (s->buffer->pos < s->buffer->last) {\n+            ngx_post_event(c->write, &ngx_posted_events);\n         }\n \n+        ngx_mail_proxy_handler(s->connection->write);\n+\n         return;\n \n     default:\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 92",
        "commit_diff": "Diff:\n@@ -37,9 +37,6 @@ typedef struct {\n     ngx_uint_t                 ssl_verify_depth;\n     ngx_str_t                  ssl_trusted_certificate;\n     ngx_str_t                  ssl_crl;\n-    ngx_str_t                  ssl_certificate;\n-    ngx_str_t                  ssl_certificate_key;\n-    ngx_array_t               *ssl_passwords;\n     ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_grpc_loc_conf_t;\n@@ -425,16 +422,16 @@ static ngx_command_t  ngx_http_grpc_commands[] = {\n \n     { ngx_string(\"grpc_ssl_certificate\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_grpc_loc_conf_t, ssl_certificate),\n+      offsetof(ngx_http_grpc_loc_conf_t, upstream.ssl_certificate),\n       NULL },\n \n     { ngx_string(\"grpc_ssl_certificate_key\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_grpc_loc_conf_t, ssl_certificate_key),\n+      offsetof(ngx_http_grpc_loc_conf_t, upstream.ssl_certificate_key),\n       NULL },\n \n     { ngx_string(\"grpc_ssl_password_file\"),\n@@ -4342,8 +4339,6 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n      *     conf->ssl_ciphers = { 0, NULL };\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n-     *     conf->ssl_certificate = { 0, NULL };\n-     *     conf->ssl_certificate_key = { 0, NULL };\n      */\n \n     conf->upstream.local = NGX_CONF_UNSET_PTR;\n@@ -4367,7 +4362,9 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n-    conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate_key = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n@@ -4471,11 +4468,12 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n-    ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate,\n+                              prev->upstream.ssl_certificate, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate_key,\n+                              prev->upstream.ssl_certificate_key, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_passwords,\n+                              prev->upstream.ssl_passwords, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n                               prev->ssl_conf_commands, NULL);\n@@ -4831,15 +4829,15 @@ ngx_http_grpc_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t  *value;\n \n-    if (glcf->ssl_passwords != NGX_CONF_UNSET_PTR) {\n+    if (glcf->upstream.ssl_passwords != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n-    glcf->ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+    glcf->upstream.ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n \n-    if (glcf->ssl_passwords == NULL) {\n+    if (glcf->upstream.ssl_passwords == NULL) {\n         return NGX_CONF_ERROR;\n     }\n \n@@ -4885,20 +4883,34 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = glcf->upstream.ssl;\n \n-    if (glcf->ssl_certificate.len) {\n+    if (glcf->upstream.ssl_certificate) {\n \n-        if (glcf->ssl_certificate_key.len == 0) {\n+        if (glcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"grpc_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &glcf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &glcf->upstream.ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, glcf->upstream.ssl, &glcf->ssl_certificate,\n-                                &glcf->ssl_certificate_key, glcf->ssl_passwords)\n-            != NGX_OK)\n+        if (glcf->upstream.ssl_certificate->lengths\n+            || glcf->upstream.ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            glcf->upstream.ssl_passwords =\n+                  ngx_ssl_preserve_passwords(cf, glcf->upstream.ssl_passwords);\n+            if (glcf->upstream.ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, glcf->upstream.ssl,\n+                                    &glcf->upstream.ssl_certificate->value,\n+                                    &glcf->upstream.ssl_certificate_key->value,\n+                                    glcf->upstream.ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -124,9 +124,6 @@ typedef struct {\n     ngx_uint_t                     ssl_verify_depth;\n     ngx_str_t                      ssl_trusted_certificate;\n     ngx_str_t                      ssl_crl;\n-    ngx_str_t                      ssl_certificate;\n-    ngx_str_t                      ssl_certificate_key;\n-    ngx_array_t                   *ssl_passwords;\n     ngx_array_t                   *ssl_conf_commands;\n #endif\n } ngx_http_proxy_loc_conf_t;\n@@ -753,16 +750,16 @@ static ngx_command_t  ngx_http_proxy_commands[] = {\n \n     { ngx_string(\"proxy_ssl_certificate\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_proxy_loc_conf_t, ssl_certificate),\n+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ssl_certificate),\n       NULL },\n \n     { ngx_string(\"proxy_ssl_certificate_key\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_proxy_loc_conf_t, ssl_certificate_key),\n+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ssl_certificate_key),\n       NULL },\n \n     { ngx_string(\"proxy_ssl_password_file\"),\n@@ -3345,8 +3342,6 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n      *     conf->ssl_ciphers = { 0, NULL };\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n-     *     conf->ssl_certificate = { 0, NULL };\n-     *     conf->ssl_certificate_key = { 0, NULL };\n      */\n \n     conf->upstream.store = NGX_CONF_UNSET;\n@@ -3401,8 +3396,10 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n+    conf->upstream.ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate_key = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n-    conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n@@ -3742,11 +3739,12 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n-    ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate,\n+                              prev->upstream.ssl_certificate, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate_key,\n+                              prev->upstream.ssl_certificate_key, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_passwords,\n+                              prev->upstream.ssl_passwords, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n                               prev->ssl_conf_commands, NULL);\n@@ -4857,15 +4855,15 @@ ngx_http_proxy_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t  *value;\n \n-    if (plcf->ssl_passwords != NGX_CONF_UNSET_PTR) {\n+    if (plcf->upstream.ssl_passwords != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n-    plcf->ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+    plcf->upstream.ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n \n-    if (plcf->ssl_passwords == NULL) {\n+    if (plcf->upstream.ssl_passwords == NULL) {\n         return NGX_CONF_ERROR;\n     }\n \n@@ -4944,20 +4942,34 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = plcf->upstream.ssl;\n \n-    if (plcf->ssl_certificate.len) {\n+    if (plcf->upstream.ssl_certificate) {\n \n-        if (plcf->ssl_certificate_key.len == 0) {\n+        if (plcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &plcf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &plcf->upstream.ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, plcf->upstream.ssl, &plcf->ssl_certificate,\n-                                &plcf->ssl_certificate_key, plcf->ssl_passwords)\n-            != NGX_OK)\n+        if (plcf->upstream.ssl_certificate->lengths\n+            || plcf->upstream.ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            plcf->upstream.ssl_passwords =\n+                  ngx_ssl_preserve_passwords(cf, plcf->upstream.ssl_passwords);\n+            if (plcf->upstream.ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, plcf->upstream.ssl,\n+                                    &plcf->upstream.ssl_certificate->value,\n+                                    &plcf->upstream.ssl_certificate_key->value,\n+                                    plcf->upstream.ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -54,9 +54,6 @@ typedef struct {\n     ngx_uint_t                 ssl_verify_depth;\n     ngx_str_t                  ssl_trusted_certificate;\n     ngx_str_t                  ssl_crl;\n-    ngx_str_t                  ssl_certificate;\n-    ngx_str_t                  ssl_certificate_key;\n-    ngx_array_t               *ssl_passwords;\n     ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_uwsgi_loc_conf_t;\n@@ -548,16 +545,16 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {\n \n     { ngx_string(\"uwsgi_ssl_certificate\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_uwsgi_loc_conf_t, ssl_certificate),\n+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.ssl_certificate),\n       NULL },\n \n     { ngx_string(\"uwsgi_ssl_certificate_key\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_http_set_complex_value_zero_slot,\n       NGX_HTTP_LOC_CONF_OFFSET,\n-      offsetof(ngx_http_uwsgi_loc_conf_t, ssl_certificate_key),\n+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.ssl_certificate_key),\n       NULL },\n \n     { ngx_string(\"uwsgi_ssl_password_file\"),\n@@ -1513,7 +1510,9 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n-    conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_certificate_key = NGX_CONF_UNSET_PTR;\n+    conf->upstream.ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n@@ -1837,11 +1836,12 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_trusted_certificate, \"\");\n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n-    ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate,\n+                              prev->upstream.ssl_certificate, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_certificate_key,\n+                              prev->upstream.ssl_certificate_key, NULL);\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_passwords,\n+                              prev->upstream.ssl_passwords, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n                               prev->ssl_conf_commands, NULL);\n@@ -2376,15 +2376,15 @@ ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     ngx_str_t  *value;\n \n-    if (uwcf->ssl_passwords != NGX_CONF_UNSET_PTR) {\n+    if (uwcf->upstream.ssl_passwords != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n-    uwcf->ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n+    uwcf->upstream.ssl_passwords = ngx_ssl_read_password_file(cf, &value[1]);\n \n-    if (uwcf->ssl_passwords == NULL) {\n+    if (uwcf->upstream.ssl_passwords == NULL) {\n         return NGX_CONF_ERROR;\n     }\n \n@@ -2430,20 +2430,34 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = uwcf->upstream.ssl;\n \n-    if (uwcf->ssl_certificate.len) {\n+    if (uwcf->upstream.ssl_certificate) {\n \n-        if (uwcf->ssl_certificate_key.len == 0) {\n+        if (uwcf->upstream.ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"uwsgi_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &uwcf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &uwcf->upstream.ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, uwcf->upstream.ssl, &uwcf->ssl_certificate,\n-                                &uwcf->ssl_certificate_key, uwcf->ssl_passwords)\n-            != NGX_OK)\n+        if (uwcf->upstream.ssl_certificate->lengths\n+            || uwcf->upstream.ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            uwcf->upstream.ssl_passwords =\n+                  ngx_ssl_preserve_passwords(cf, uwcf->upstream.ssl_passwords);\n+            if (uwcf->upstream.ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, uwcf->upstream.ssl,\n+                                    &uwcf->upstream.ssl_certificate->value,\n+                                    &uwcf->upstream.ssl_certificate_key->value,\n+                                    uwcf->upstream.ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -275,6 +275,44 @@ ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+char *\n+ngx_http_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t                          *value;\n+    ngx_http_complex_value_t          **cv;\n+    ngx_http_compile_complex_value_t    ccv;\n+\n+    cv = (ngx_http_complex_value_t **) (p + cmd->offset);\n+\n+    if (*cv != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    *cv = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));\n+    if (*cv == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n+\n+    ccv.cf = cf;\n+    ccv.value = &value[1];\n+    ccv.complex_value = *cv;\n+    ccv.zero = 1;\n+\n+    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n char *\n ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf)\nDiff:\n@@ -216,6 +216,8 @@ size_t ngx_http_complex_value_size(ngx_http_request_t *r,\n ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv);\n char *ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+char *ngx_http_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n char *ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \nDiff:\n@@ -187,6 +187,8 @@ static void ngx_http_upstream_ssl_handshake(ngx_http_request_t *,\n static void ngx_http_upstream_ssl_save_session(ngx_connection_t *c);\n static ngx_int_t ngx_http_upstream_ssl_name(ngx_http_request_t *r,\n     ngx_http_upstream_t *u, ngx_connection_t *c);\n+static ngx_int_t ngx_http_upstream_ssl_certificate(ngx_http_request_t *r,\n+    ngx_http_upstream_t *u, ngx_connection_t *c);\n #endif\n \n \n@@ -1692,6 +1694,16 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,\n         }\n     }\n \n+    if (u->conf->ssl_certificate && (u->conf->ssl_certificate->lengths\n+                                     || u->conf->ssl_certificate_key->lengths))\n+    {\n+        if (ngx_http_upstream_ssl_certificate(r, u, c) != NGX_OK) {\n+            ngx_http_upstream_finalize_request(r, u,\n+                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+    }\n+\n     if (u->conf->ssl_session_reuse) {\n         c->ssl->save_session = ngx_http_upstream_ssl_save_session;\n \n@@ -1912,6 +1924,45 @@ ngx_http_upstream_ssl_name(ngx_http_request_t *r, ngx_http_upstream_t *u,\n     return NGX_OK;\n }\n \n+\n+static ngx_int_t\n+ngx_http_upstream_ssl_certificate(ngx_http_request_t *r,\n+    ngx_http_upstream_t *u, ngx_connection_t *c)\n+{\n+    ngx_str_t  cert, key;\n+\n+    if (ngx_http_complex_value(r, u->conf->ssl_certificate, &cert)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                   \"http upstream ssl cert: \\\"%s\\\"\", cert.data);\n+\n+    if (*cert.data == '\\0') {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_http_complex_value(r, u->conf->ssl_certificate_key, &key)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                   \"http upstream ssl key: \\\"%s\\\"\", key.data);\n+\n+    if (ngx_ssl_connection_certificate(c, r->pool, &cert, &key,\n+                                       u->conf->ssl_passwords)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n #endif\n \n \nDiff:\n@@ -234,6 +234,10 @@ typedef struct {\n     ngx_http_complex_value_t        *ssl_name;\n     ngx_flag_t                       ssl_server_name;\n     ngx_flag_t                       ssl_verify;\n+\n+    ngx_http_complex_value_t        *ssl_certificate;\n+    ngx_http_complex_value_t        *ssl_certificate_key;\n+    ngx_array_t                     *ssl_passwords;\n #endif\n \n     ngx_str_t                        module;\nDiff:\n@@ -46,8 +46,8 @@ typedef struct {\n     ngx_uint_t                       ssl_verify_depth;\n     ngx_str_t                        ssl_trusted_certificate;\n     ngx_str_t                        ssl_crl;\n-    ngx_str_t                        ssl_certificate;\n-    ngx_str_t                        ssl_certificate_key;\n+    ngx_stream_complex_value_t      *ssl_certificate;\n+    ngx_stream_complex_value_t      *ssl_certificate_key;\n     ngx_array_t                     *ssl_passwords;\n     ngx_array_t                     *ssl_conf_commands;\n \n@@ -101,6 +101,7 @@ static void ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s);\n static void ngx_stream_proxy_ssl_handshake(ngx_connection_t *pc);\n static void ngx_stream_proxy_ssl_save_session(ngx_connection_t *c);\n static ngx_int_t ngx_stream_proxy_ssl_name(ngx_stream_session_t *s);\n+static ngx_int_t ngx_stream_proxy_ssl_certificate(ngx_stream_session_t *s);\n static ngx_int_t ngx_stream_proxy_set_ssl(ngx_conf_t *cf,\n     ngx_stream_proxy_srv_conf_t *pscf);\n \n@@ -318,14 +319,14 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {\n \n     { ngx_string(\"proxy_ssl_certificate\"),\n       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_stream_set_complex_value_zero_slot,\n       NGX_STREAM_SRV_CONF_OFFSET,\n       offsetof(ngx_stream_proxy_srv_conf_t, ssl_certificate),\n       NULL },\n \n     { ngx_string(\"proxy_ssl_certificate_key\"),\n       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_str_slot,\n+      ngx_stream_set_complex_value_zero_slot,\n       NGX_STREAM_SRV_CONF_OFFSET,\n       offsetof(ngx_stream_proxy_srv_conf_t, ssl_certificate_key),\n       NULL },\n@@ -1060,6 +1061,15 @@ ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s)\n         }\n     }\n \n+    if (pscf->ssl_certificate && (pscf->ssl_certificate->lengths\n+                                  || pscf->ssl_certificate_key->lengths))\n+    {\n+        if (ngx_stream_proxy_ssl_certificate(s) != NGX_OK) {\n+            ngx_stream_proxy_finalize(s, NGX_STREAM_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+    }\n+\n     if (pscf->ssl_session_reuse) {\n         pc->ssl->save_session = ngx_stream_proxy_ssl_save_session;\n \n@@ -1247,6 +1257,50 @@ ngx_stream_proxy_ssl_name(ngx_stream_session_t *s)\n     return NGX_OK;\n }\n \n+\n+static ngx_int_t\n+ngx_stream_proxy_ssl_certificate(ngx_stream_session_t *s)\n+{\n+    ngx_str_t                     cert, key;\n+    ngx_connection_t             *c;\n+    ngx_stream_proxy_srv_conf_t  *pscf;\n+\n+    c = s->upstream->peer.connection;\n+\n+    pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);\n+\n+    if (ngx_stream_complex_value(s, pscf->ssl_certificate, &cert)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                   \"stream upstream ssl cert: \\\"%s\\\"\", cert.data);\n+\n+    if (*cert.data == '\\0') {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_stream_complex_value(s, pscf->ssl_certificate_key, &key)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,\n+                   \"stream upstream ssl key: \\\"%s\\\"\", key.data);\n+\n+    if (ngx_ssl_connection_certificate(c, c->pool, &cert, &key,\n+                                       pscf->ssl_passwords)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n #endif\n \n \n@@ -1979,8 +2033,6 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n      *     conf->ssl_ciphers = { 0, NULL };\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n-     *     conf->ssl_certificate = { 0, NULL };\n-     *     conf->ssl_certificate_key = { 0, NULL };\n      *\n      *     conf->ssl = NULL;\n      *     conf->upstream = NULL;\n@@ -2008,6 +2060,8 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->ssl_server_name = NGX_CONF_UNSET;\n     conf->ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n+    conf->ssl_certificate = NGX_CONF_UNSET_PTR;\n+    conf->ssl_certificate_key = NGX_CONF_UNSET_PTR;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n     conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n@@ -2083,11 +2137,11 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ssl_crl, prev->ssl_crl, \"\");\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate,\n-                              prev->ssl_certificate, \"\");\n+    ngx_conf_merge_ptr_value(conf->ssl_certificate,\n+                              prev->ssl_certificate, NULL);\n \n-    ngx_conf_merge_str_value(conf->ssl_certificate_key,\n-                              prev->ssl_certificate_key, \"\");\n+    ngx_conf_merge_ptr_value(conf->ssl_certificate_key,\n+                              prev->ssl_certificate_key, NULL);\n \n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n@@ -2131,20 +2185,34 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n     cln->handler = ngx_ssl_cleanup_ctx;\n     cln->data = pscf->ssl;\n \n-    if (pscf->ssl_certificate.len) {\n+    if (pscf->ssl_certificate) {\n \n-        if (pscf->ssl_certificate_key.len == 0) {\n+        if (pscf->ssl_certificate_key == NULL) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                           \"no \\\"proxy_ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\"\", &pscf->ssl_certificate);\n+                          \"for certificate \\\"%V\\\"\",\n+                          &pscf->ssl_certificate->value);\n             return NGX_ERROR;\n         }\n \n-        if (ngx_ssl_certificate(cf, pscf->ssl, &pscf->ssl_certificate,\n-                                &pscf->ssl_certificate_key, pscf->ssl_passwords)\n-            != NGX_OK)\n+        if (pscf->ssl_certificate->lengths\n+            || pscf->ssl_certificate_key->lengths)\n         {\n-            return NGX_ERROR;\n+            pscf->ssl_passwords =\n+                           ngx_ssl_preserve_passwords(cf, pscf->ssl_passwords);\n+            if (pscf->ssl_passwords == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+        } else {\n+            if (ngx_ssl_certificate(cf, pscf->ssl,\n+                                    &pscf->ssl_certificate->value,\n+                                    &pscf->ssl_certificate_key->value,\n+                                    pscf->ssl_passwords)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -277,6 +277,44 @@ ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n }\n \n \n+char *\n+ngx_stream_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf)\n+{\n+    char  *p = conf;\n+\n+    ngx_str_t                            *value;\n+    ngx_stream_complex_value_t          **cv;\n+    ngx_stream_compile_complex_value_t    ccv;\n+\n+    cv = (ngx_stream_complex_value_t **) (p + cmd->offset);\n+\n+    if (*cv != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    *cv = ngx_palloc(cf->pool, sizeof(ngx_stream_complex_value_t));\n+    if (*cv == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    value = cf->args->elts;\n+\n+    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));\n+\n+    ccv.cf = cf;\n+    ccv.value = &value[1];\n+    ccv.complex_value = *cv;\n+    ccv.zero = 1;\n+\n+    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n char *\n ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf)\nDiff:\n@@ -112,6 +112,8 @@ ngx_int_t ngx_stream_compile_complex_value(\n     ngx_stream_compile_complex_value_t *ccv);\n char *ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+char *ngx_stream_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n char *ngx_stream_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \n",
        "analysis": "The diff contains newly added entire functions, which are:\n\n1. `ngx_http_set_complex_value_zero_slot`\n2. `ngx_http_upstream_ssl_certificate`\n3. `ngx_stream_proxy_ssl_certificate`\n4. `ngx_stream_set_complex_value_zero_slot`\n\nLet's analyze these functions individually for possible out-of-bounds write vulnerabilities:\n\n1. **Function `ngx_http_set_complex_value_zero_slot`:**\n    - The function assigns a pointer `cv` to a location in memory.\n    - Memory allocation is attempted using `ngx_palloc` to allocate size for `ngx_http_complex_value_t`.\n    - There's a check for null allocation, with appropriate error handling.\n    - No explicit boundary checks on buffer sizes, but no apparent risky operations either.\n\n2. **Function `ngx_http_upstream_ssl_certificate`:**\n    - Uses `ngx_http_complex_value` to process `ssl_certificate` and `ssl_certificate_key`.\n    - Both the certificate data and key are logged.\n    - Calls `ngx_ssl_connection_certificate` with certificates and keys but there is no apparent unsafe buffer usage.\n    - Although there is no definitive proof of boundary checks on the data passed to `ngx_ssl_connection_certificate`, this function itself does not manipulate buffer sizes directly.\n\n3. **Function `ngx_stream_proxy_ssl_certificate`:**\n    - Similar to `ngx_http_upstream_ssl_certificate`, processes certificate and key values using `ngx_stream_complex_value`.\n    - Logs data implicitly assuming them to be strings.\n    - Passes these values to `ngx_ssl_connection_certificate`.\n    - As with the HTTP variant, it directly does not show a dangerous operation concerning buffers.\n\n4. **Function `ngx_stream_set_complex_value_zero_slot`:**\n    - Function allocates memory using `ngx_palloc` for `ngx_stream_complex_value_t`.\n    - There’s a check on whether allocation was successful.\n    - No apparent risky operations that directly address buffer indices or lengths.\n\nEach added function was analyzed, but based on current understanding, there are no definite indications of out-of-bounds write vulnerabilities in these specific functions. However, if a user manipulates input data to be abnormally large or the underlying certificates or keys are handled improperly, issues could arise, possibly outside these functions' direct control. Given coding patterns are similar among different functions without conclusive notes of vulnerability, the safe step is:\n\nFALSE"
    },
    {
        "commit_index": "Commit 91",
        "commit_diff": "Diff:\n@@ -16,7 +16,7 @@\n \n typedef struct {\n     ngx_http_complex_value_t  *realm;\n-    ngx_http_complex_value_t   user_file;\n+    ngx_http_complex_value_t  *user_file;\n } ngx_http_auth_basic_loc_conf_t;\n \n \n@@ -107,7 +107,7 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n \n     alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_basic_module);\n \n-    if (alcf->realm == NULL || alcf->user_file.value.data == NULL) {\n+    if (alcf->realm == NULL || alcf->user_file == NULL) {\n         return NGX_DECLINED;\n     }\n \n@@ -133,7 +133,7 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n-    if (ngx_http_complex_value(r, &alcf->user_file, &user_file) != NGX_OK) {\n+    if (ngx_http_complex_value(r, alcf->user_file, &user_file) != NGX_OK) {\n         return NGX_ERROR;\n     }\n \n@@ -357,6 +357,9 @@ ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf)\n         return NULL;\n     }\n \n+    conf->realm = NGX_CONF_UNSET_PTR;\n+    conf->user_file = NGX_CONF_UNSET_PTR;\n+\n     return conf;\n }\n \n@@ -367,13 +370,8 @@ ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_http_auth_basic_loc_conf_t  *prev = parent;\n     ngx_http_auth_basic_loc_conf_t  *conf = child;\n \n-    if (conf->realm == NULL) {\n-        conf->realm = prev->realm;\n-    }\n-\n-    if (conf->user_file.value.data == NULL) {\n-        conf->user_file = prev->user_file;\n-    }\n+    ngx_conf_merge_ptr_value(conf->realm, prev->realm, NULL);\n+    ngx_conf_merge_ptr_value(conf->user_file, prev->user_file, NULL);\n \n     return NGX_CONF_OK;\n }\n@@ -406,17 +404,22 @@ ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_str_t                         *value;\n     ngx_http_compile_complex_value_t   ccv;\n \n-    if (alcf->user_file.value.data) {\n+    if (alcf->user_file != NGX_CONF_UNSET_PTR) {\n         return \"is duplicate\";\n     }\n \n+    alcf->user_file = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));\n+    if (alcf->user_file == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     value = cf->args->elts;\n \n     ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n \n     ccv.cf = cf;\n     ccv.value = &value[1];\n-    ccv.complex_value = &alcf->user_file;\n+    ccv.complex_value = alcf->user_file;\n     ccv.zero = 1;\n     ccv.conf_prefix = 1;\n \nDiff:\n@@ -4331,7 +4331,6 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n      *     conf->upstream.ignore_headers = 0;\n      *     conf->upstream.next_upstream = 0;\n      *     conf->upstream.hide_headers_hash = { NULL, 0 };\n-     *     conf->upstream.ssl_name = NULL;\n      *\n      *     conf->headers.lengths = NULL;\n      *     conf->headers.values = NULL;\n@@ -4364,6 +4363,7 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n \n #if (NGX_HTTP_SSL)\n     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -4459,10 +4459,8 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\n \n-    if (conf->upstream.ssl_name == NULL) {\n-        conf->upstream.ssl_name = prev->upstream.ssl_name;\n-    }\n-\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_name,\n+                              prev->upstream.ssl_name, NULL);\n     ngx_conf_merge_value(conf->upstream.ssl_server_name,\n                               prev->upstream.ssl_server_name, 0);\n     ngx_conf_merge_value(conf->upstream.ssl_verify,\nDiff:\n@@ -3327,9 +3327,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n      *     conf->upstream.hide_headers_hash = { NULL, 0 };\n      *     conf->upstream.store_lengths = NULL;\n      *     conf->upstream.store_values = NULL;\n-     *     conf->upstream.ssl_name = NULL;\n      *\n-     *     conf->method = NULL;\n      *     conf->location = NULL;\n      *     conf->url = { 0, NULL };\n      *     conf->headers.lengths = NULL;\n@@ -3400,6 +3398,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n \n #if (NGX_HTTP_SSL)\n     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -3410,10 +3409,13 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     /* \"proxy_cyclic_temp_file\" is disabled */\n     conf->upstream.cyclic_temp_file = 0;\n \n+    conf->upstream.change_buffering = 1;\n+\n     conf->headers_source = NGX_CONF_UNSET_PTR;\n \n+    conf->method = NGX_CONF_UNSET_PTR;\n+\n     conf->redirect = NGX_CONF_UNSET;\n-    conf->upstream.change_buffering = 1;\n \n     conf->cookie_domains = NGX_CONF_UNSET_PTR;\n     conf->cookie_paths = NGX_CONF_UNSET_PTR;\n@@ -3708,10 +3710,6 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #endif\n \n-    if (conf->method == NULL) {\n-        conf->method = prev->method;\n-    }\n-\n     ngx_conf_merge_value(conf->upstream.pass_request_headers,\n                               prev->upstream.pass_request_headers, 1);\n     ngx_conf_merge_value(conf->upstream.pass_request_body,\n@@ -3732,10 +3730,8 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\n \n-    if (conf->upstream.ssl_name == NULL) {\n-        conf->upstream.ssl_name = prev->upstream.ssl_name;\n-    }\n-\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_name,\n+                              prev->upstream.ssl_name, NULL);\n     ngx_conf_merge_value(conf->upstream.ssl_server_name,\n                               prev->upstream.ssl_server_name, 0);\n     ngx_conf_merge_value(conf->upstream.ssl_verify,\n@@ -3761,6 +3757,8 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n #endif\n \n+    ngx_conf_merge_ptr_value(conf->method, prev->method, NULL);\n+\n     ngx_conf_merge_value(conf->redirect, prev->redirect, 1);\n \n     if (conf->redirect) {\nDiff:\n@@ -302,11 +302,12 @@ ngx_http_secure_link_create_conf(ngx_conf_t *cf)\n     /*\n      * set by ngx_pcalloc():\n      *\n-     *     conf->variable = NULL;\n-     *     conf->md5 = NULL;\n      *     conf->secret = { 0, NULL };\n      */\n \n+    conf->variable = NGX_CONF_UNSET_PTR;\n+    conf->md5 = NGX_CONF_UNSET_PTR;\n+\n     return conf;\n }\n \n@@ -318,6 +319,9 @@ ngx_http_secure_link_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_http_secure_link_conf_t *conf = child;\n \n     if (conf->secret.data) {\n+        ngx_conf_init_ptr_value(conf->variable, NULL);\n+        ngx_conf_init_ptr_value(conf->md5, NULL);\n+\n         if (conf->variable || conf->md5) {\n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"\\\"secure_link_secret\\\" cannot be mixed with \"\n@@ -328,13 +332,8 @@ ngx_http_secure_link_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_OK;\n     }\n \n-    if (conf->variable == NULL) {\n-        conf->variable = prev->variable;\n-    }\n-\n-    if (conf->md5 == NULL) {\n-        conf->md5 = prev->md5;\n-    }\n+    ngx_conf_merge_ptr_value(conf->variable, prev->variable, NULL);\n+    ngx_conf_merge_ptr_value(conf->md5, prev->md5, NULL);\n \n     if (conf->variable == NULL && conf->md5 == NULL) {\n         conf->secret = prev->secret;\nDiff:\n@@ -1509,6 +1509,7 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)\n \n #if (NGX_HTTP_SSL)\n     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;\n     conf->upstream.ssl_server_name = NGX_CONF_UNSET;\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -1824,10 +1825,8 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers,\n                              \"DEFAULT\");\n \n-    if (conf->upstream.ssl_name == NULL) {\n-        conf->upstream.ssl_name = prev->upstream.ssl_name;\n-    }\n-\n+    ngx_conf_merge_ptr_value(conf->upstream.ssl_name,\n+                              prev->upstream.ssl_name, NULL);\n     ngx_conf_merge_value(conf->upstream.ssl_server_name,\n                               prev->upstream.ssl_server_name, 0);\n     ngx_conf_merge_value(conf->upstream.ssl_verify,\nDiff:\n@@ -3479,8 +3479,6 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n      *     clcf->exact_match = 0;\n      *     clcf->auto_redirect = 0;\n      *     clcf->alias = 0;\n-     *     clcf->limit_rate = NULL;\n-     *     clcf->limit_rate_after = NULL;\n      *     clcf->gzip_proxied = 0;\n      *     clcf->keepalive_disable = 0;\n      */\n@@ -3512,6 +3510,8 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     clcf->send_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->send_lowat = NGX_CONF_UNSET_SIZE;\n     clcf->postpone_output = NGX_CONF_UNSET_SIZE;\n+    clcf->limit_rate = NGX_CONF_UNSET_PTR;\n+    clcf->limit_rate_after = NGX_CONF_UNSET_PTR;\n     clcf->keepalive_time = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_header = NGX_CONF_UNSET;\n@@ -3743,13 +3743,9 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_size_value(conf->postpone_output, prev->postpone_output,\n                               1460);\n \n-    if (conf->limit_rate == NULL) {\n-        conf->limit_rate = prev->limit_rate;\n-    }\n-\n-    if (conf->limit_rate_after == NULL) {\n-        conf->limit_rate_after = prev->limit_rate_after;\n-    }\n+    ngx_conf_merge_ptr_value(conf->limit_rate, prev->limit_rate, NULL);\n+    ngx_conf_merge_ptr_value(conf->limit_rate_after,\n+                              prev->limit_rate_after, NULL);\n \n     ngx_conf_merge_msec_value(conf->keepalive_time,\n                               prev->keepalive_time, 3600000);\nDiff:\n@@ -250,7 +250,7 @@ ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cv = (ngx_http_complex_value_t **) (p + cmd->offset);\n \n-    if (*cv != NULL) {\n+    if (*cv != NGX_CONF_UNSET_PTR && *cv != NULL) {\n         return \"is duplicate\";\n     }\n \nDiff:\n@@ -1977,14 +1977,11 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n      *\n      *     conf->ssl_protocols = 0;\n      *     conf->ssl_ciphers = { 0, NULL };\n-     *     conf->ssl_name = NULL;\n      *     conf->ssl_trusted_certificate = { 0, NULL };\n      *     conf->ssl_crl = { 0, NULL };\n      *     conf->ssl_certificate = { 0, NULL };\n      *     conf->ssl_certificate_key = { 0, NULL };\n      *\n-     *     conf->upload_rate = NULL;\n-     *     conf->download_rate = NULL;\n      *     conf->ssl = NULL;\n      *     conf->upstream = NULL;\n      *     conf->upstream_value = NULL;\n@@ -1994,6 +1991,8 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->timeout = NGX_CONF_UNSET_MSEC;\n     conf->next_upstream_timeout = NGX_CONF_UNSET_MSEC;\n     conf->buffer_size = NGX_CONF_UNSET_SIZE;\n+    conf->upload_rate = NGX_CONF_UNSET_PTR;\n+    conf->download_rate = NGX_CONF_UNSET_PTR;\n     conf->requests = NGX_CONF_UNSET_UINT;\n     conf->responses = NGX_CONF_UNSET_UINT;\n     conf->next_upstream_tries = NGX_CONF_UNSET_UINT;\n@@ -2005,6 +2004,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n #if (NGX_STREAM_SSL)\n     conf->ssl_enable = NGX_CONF_UNSET;\n     conf->ssl_session_reuse = NGX_CONF_UNSET;\n+    conf->ssl_name = NGX_CONF_UNSET_PTR;\n     conf->ssl_server_name = NGX_CONF_UNSET;\n     conf->ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n@@ -2034,13 +2034,9 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_size_value(conf->buffer_size,\n                               prev->buffer_size, 16384);\n \n-    if (conf->upload_rate == NULL) {\n-        conf->upload_rate = prev->upload_rate;\n-    }\n+    ngx_conf_merge_ptr_value(conf->upload_rate, prev->upload_rate, NULL);\n \n-    if (conf->download_rate == NULL) {\n-        conf->download_rate = prev->download_rate;\n-    }\n+    ngx_conf_merge_ptr_value(conf->download_rate, prev->download_rate, NULL);\n \n     ngx_conf_merge_uint_value(conf->requests,\n                               prev->requests, 0);\n@@ -2073,9 +2069,7 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ssl_ciphers, prev->ssl_ciphers, \"DEFAULT\");\n \n-    if (conf->ssl_name == NULL) {\n-        conf->ssl_name = prev->ssl_name;\n-    }\n+    ngx_conf_merge_ptr_value(conf->ssl_name, prev->ssl_name, NULL);\n \n     ngx_conf_merge_value(conf->ssl_server_name, prev->ssl_server_name, 0);\n \nDiff:\n@@ -252,7 +252,7 @@ ngx_stream_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n \n     cv = (ngx_stream_complex_value_t **) (p + cmd->offset);\n \n-    if (*cv != NULL) {\n+    if (*cv != NGX_CONF_UNSET_PTR && *cv != NULL) {\n         return \"is duplicate\";\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 90",
        "commit_diff": "Diff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019010\n-#define NGINX_VERSION      \"1.19.10\"\n+#define nginx_version      1021000\n+#define NGINX_VERSION      \"1.21.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -833,20 +833,23 @@ ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n     ngx_str_t                  l;\n     ngx_mail_core_srv_conf_t  *cscf;\n \n-    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);\n+    if (s->buffer->last < s->buffer->end) {\n \n-    if (n == NGX_ERROR || n == 0) {\n-        ngx_mail_close_connection(c);\n-        return NGX_ERROR;\n-    }\n+        n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);\n \n-    if (n > 0) {\n-        s->buffer->last += n;\n-    }\n+        if (n == NGX_ERROR || n == 0) {\n+            ngx_mail_close_connection(c);\n+            return NGX_ERROR;\n+        }\n \n-    if (n == NGX_AGAIN) {\n-        if (s->buffer->pos == s->buffer->last) {\n-            return NGX_AGAIN;\n+        if (n > 0) {\n+            s->buffer->last += n;\n+        }\n+\n+        if (n == NGX_AGAIN) {\n+            if (s->buffer->pos == s->buffer->last) {\n+                return NGX_AGAIN;\n+            }\n         }\n     }\n \nDiff:\n@@ -398,6 +398,8 @@ ngx_pass_open_channel(ngx_cycle_t *cycle)\n     ngx_int_t      i;\n     ngx_channel_t  ch;\n \n+    ngx_memzero(&ch, sizeof(ngx_channel_t));\n+\n     ch.command = NGX_CMD_OPEN_CHANNEL;\n     ch.pid = ngx_processes[ngx_process_slot].pid;\n     ch.slot = ngx_process_slot;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 89",
        "commit_diff": "Diff:\n@@ -459,3 +459,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n+ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\nDiff:\n@@ -5,6 +5,49 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.10\" date=\"2021-04-13\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+в директиве keepalive_requests значение по умолчанию изменено на 1000.\n+</para>\n+<para lang=\"en\">\n+the default value of the \"keepalive_requests\" directive was changed to 1000.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива keepalive_time.\n+</para>\n+<para lang=\"en\">\n+the \"keepalive_time\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $connection_time.\n+</para>\n+<para lang=\"en\">\n+the $connection_time variable.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании zlib-ng\n+в логах появлялись сообщения \"gzip filter failed to use preallocated memory\".\n+</para>\n+<para lang=\"en\">\n+\"gzip filter failed to use preallocated memory\" alerts appeared in logs\n+when using zlib-ng.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.9\" date=\"2021-03-30\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -102,7 +102,7 @@ ngx_mail_pop3_init_protocol(ngx_event_t *rev)\n             return;\n         }\n \n-        s->buffer = ngx_create_temp_buf(c->pool, 128);\n+        s->buffer = ngx_create_temp_buf(c->pool, 1000);\n         if (s->buffer == NULL) {\n             ngx_mail_session_internal_server_error(s);\n             return;\n@@ -316,7 +316,7 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n \n     arg = s->args.elts;\n     s->login.len = arg[0].len;\n-    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n+    s->login.data = ngx_pnalloc(c->pool, 100);\n     if (s->login.data == NULL) {\n         return NGX_ERROR;\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 88",
        "commit_diff": "Diff:\n@@ -159,7 +159,7 @@ ngx_http_upstream_init_keepalive(ngx_conf_t *cf,\n \n     ngx_conf_init_msec_value(kcf->time, 3600000);\n     ngx_conf_init_msec_value(kcf->timeout, 60000);\n-    ngx_conf_init_uint_value(kcf->requests, 100);\n+    ngx_conf_init_uint_value(kcf->requests, 1000);\n \n     if (kcf->original_init_upstream(cf, us) != NGX_OK) {\n         return NGX_ERROR;\nDiff:\n@@ -3758,7 +3758,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_sec_value(conf->keepalive_header,\n                               prev->keepalive_header, 0);\n     ngx_conf_merge_uint_value(conf->keepalive_requests,\n-                              prev->keepalive_requests, 100);\n+                              prev->keepalive_requests, 1000);\n     ngx_conf_merge_uint_value(conf->lingering_close,\n                               prev->lingering_close, NGX_HTTP_LINGERING_ON);\n     ngx_conf_merge_msec_value(conf->lingering_time,\nDiff:\n@@ -133,6 +133,8 @@ static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_http_variable_connection_time(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n \n static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data);\n@@ -346,6 +348,9 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n     { ngx_string(\"connection_requests\"), NULL,\n       ngx_http_variable_connection_requests, 0, 0, 0 },\n \n+    { ngx_string(\"connection_time\"), NULL, ngx_http_variable_connection_time,\n+      0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n+\n     { ngx_string(\"nginx_version\"), NULL, ngx_http_variable_nginx_version,\n       0, 0, 0 },\n \n@@ -2262,6 +2267,31 @@ ngx_http_variable_connection_requests(ngx_http_request_t *r,\n }\n \n \n+static ngx_int_t\n+ngx_http_variable_connection_time(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    u_char          *p;\n+    ngx_msec_int_t   ms;\n+\n+    p = ngx_pnalloc(r->pool, NGX_TIME_T_LEN + 4);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ms = ngx_current_msec - r->connection->start_time;\n+    ms = ngx_max(ms, 0);\n+\n+    v->len = ngx_sprintf(p, \"%T.%03M\", (time_t) ms / 1000, ms % 1000) - p;\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->data = p;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_variable_nginx_version(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n",
        "analysis": "TRUE [ngx_http_variable_connection_time]"
    },
    {
        "commit_index": "Commit 87",
        "commit_diff": "Diff:\n@@ -164,6 +164,7 @@ struct ngx_connection_s {\n \n     ngx_atomic_uint_t   number;\n \n+    ngx_msec_t          start_time;\n     ngx_uint_t          requests;\n \n     unsigned            buffered:8;\nDiff:\n@@ -4459,6 +4459,8 @@ ngx_udp_connect(ngx_resolver_connection_t *rec)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     ngx_log_debug3(NGX_LOG_DEBUG_EVENT, &rec->log, 0,\n                    \"connect to %V, fd:%d #%uA\", &rec->server, s, c->number);\n \n@@ -4545,6 +4547,8 @@ ngx_tcp_connect(ngx_resolver_connection_t *rec)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     if (ngx_add_conn) {\n         if (ngx_add_conn(c) == NGX_ERROR) {\n             goto failed;\nDiff:\n@@ -256,6 +256,8 @@ ngx_event_accept(ngx_event_t *ev)\n \n         c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+        c->start_time = ngx_current_msec;\n+\n #if (NGX_STAT_STUB)\n         (void) ngx_atomic_fetch_add(ngx_stat_handled, 1);\n #endif\nDiff:\n@@ -80,6 +80,8 @@ ngx_event_acceptex(ngx_event_t *rev)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     ls->handler(c);\n \n     return;\nDiff:\n@@ -193,6 +193,8 @@ ngx_event_connect_peer(ngx_peer_connection_t *pc)\n \n     c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+    c->start_time = ngx_current_msec;\n+\n     if (ngx_add_conn) {\n         if (ngx_add_conn(c) == NGX_ERROR) {\n             goto failed;\nDiff:\n@@ -363,6 +363,8 @@ ngx_event_recvmsg(ngx_event_t *ev)\n \n         c->number = ngx_atomic_fetch_add(ngx_connection_counter, 1);\n \n+        c->start_time = ngx_current_msec;\n+\n #if (NGX_STAT_STUB)\n         (void) ngx_atomic_fetch_add(ngx_stat_handled, 1);\n #endif\nDiff:\n@@ -13,6 +13,7 @@\n typedef struct {\n     ngx_uint_t                         max_cached;\n     ngx_uint_t                         requests;\n+    ngx_msec_t                         time;\n     ngx_msec_t                         timeout;\n \n     ngx_queue_t                        cache;\n@@ -86,6 +87,13 @@ static ngx_command_t  ngx_http_upstream_keepalive_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"keepalive_time\"),\n+      NGX_HTTP_UPS_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_upstream_keepalive_srv_conf_t, time),\n+      NULL },\n+\n     { ngx_string(\"keepalive_timeout\"),\n       NGX_HTTP_UPS_CONF|NGX_CONF_TAKE1,\n       ngx_conf_set_msec_slot,\n@@ -149,6 +157,7 @@ ngx_http_upstream_init_keepalive(ngx_conf_t *cf,\n     kcf = ngx_http_conf_upstream_srv_conf(us,\n                                           ngx_http_upstream_keepalive_module);\n \n+    ngx_conf_init_msec_value(kcf->time, 3600000);\n     ngx_conf_init_msec_value(kcf->timeout, 60000);\n     ngx_conf_init_uint_value(kcf->requests, 100);\n \n@@ -326,6 +335,10 @@ ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc, void *data,\n         goto invalid;\n     }\n \n+    if (ngx_current_msec - c->start_time > kp->conf->time) {\n+        goto invalid;\n+    }\n+\n     if (!u->keepalive) {\n         goto invalid;\n     }\n@@ -513,6 +526,7 @@ ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf)\n      *     conf->max_cached = 0;\n      */\n \n+    conf->time = NGX_CONF_UNSET_MSEC;\n     conf->timeout = NGX_CONF_UNSET_MSEC;\n     conf->requests = NGX_CONF_UNSET_UINT;\n \nDiff:\n@@ -495,6 +495,13 @@ static ngx_command_t  ngx_http_core_commands[] = {\n       offsetof(ngx_http_core_loc_conf_t, limit_rate_after),\n       NULL },\n \n+    { ngx_string(\"keepalive_time\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_core_loc_conf_t, keepalive_time),\n+      NULL },\n+\n     { ngx_string(\"keepalive_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE12,\n       ngx_http_core_keepalive,\n@@ -1335,6 +1342,11 @@ ngx_http_update_location_config(ngx_http_request_t *r)\n         } else if (r->connection->requests >= clcf->keepalive_requests) {\n             r->keepalive = 0;\n \n+        } else if (ngx_current_msec - r->connection->start_time\n+                   > clcf->keepalive_time)\n+        {\n+            r->keepalive = 0;\n+\n         } else if (r->headers_in.msie6\n                    && r->method == NGX_HTTP_POST\n                    && (clcf->keepalive_disable\n@@ -3500,6 +3512,7 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     clcf->send_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->send_lowat = NGX_CONF_UNSET_SIZE;\n     clcf->postpone_output = NGX_CONF_UNSET_SIZE;\n+    clcf->keepalive_time = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->keepalive_header = NGX_CONF_UNSET;\n     clcf->keepalive_requests = NGX_CONF_UNSET_UINT;\n@@ -3738,6 +3751,8 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         conf->limit_rate_after = prev->limit_rate_after;\n     }\n \n+    ngx_conf_merge_msec_value(conf->keepalive_time,\n+                              prev->keepalive_time, 3600000);\n     ngx_conf_merge_msec_value(conf->keepalive_timeout,\n                               prev->keepalive_timeout, 75000);\n     ngx_conf_merge_sec_value(conf->keepalive_header,\nDiff:\n@@ -362,6 +362,7 @@ struct ngx_http_core_loc_conf_s {\n \n     ngx_msec_t    client_body_timeout;     /* client_body_timeout */\n     ngx_msec_t    send_timeout;            /* send_timeout */\n+    ngx_msec_t    keepalive_time;          /* keepalive_time */\n     ngx_msec_t    keepalive_timeout;       /* keepalive_timeout */\n     ngx_msec_t    lingering_time;          /* lingering_time */\n     ngx_msec_t    lingering_timeout;       /* lingering_timeout */\nDiff:\n@@ -1369,7 +1369,9 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n                                         ngx_http_core_module);\n \n     if (clcf->keepalive_timeout == 0\n-        || h2c->connection->requests >= clcf->keepalive_requests)\n+        || h2c->connection->requests >= clcf->keepalive_requests\n+        || ngx_current_msec - h2c->connection->start_time\n+           > clcf->keepalive_time)\n     {\n         h2c->goaway = 1;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 86",
        "commit_diff": "Diff:\n@@ -86,6 +86,31 @@ if [ $ngx_found = yes ]; then\n                       ee.data.ptr = NULL;\n                       epoll_ctl(efd, EPOLL_CTL_ADD, fd, &ee)\"\n     . auto/feature\n+\n+\n+    # eventfd()\n+\n+    ngx_feature=\"eventfd()\"\n+    ngx_feature_name=\"NGX_HAVE_EVENTFD\"\n+    ngx_feature_run=no\n+    ngx_feature_incs=\"#include <sys/eventfd.h>\"\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test=\"(void) eventfd(0, 0)\"\n+    . auto/feature\n+\n+    if [ $ngx_found = yes ]; then\n+        have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n+    fi\n+\n+\n+    if [ $ngx_found = no ]; then\n+\n+        ngx_feature=\"eventfd() (SYS_eventfd)\"\n+        ngx_feature_incs=\"#include <sys/syscall.h>\"\n+        ngx_feature_test=\"(void) SYS_eventfd\"\n+        . auto/feature\n+    fi\n fi\n \n \nDiff:\n@@ -582,29 +582,6 @@ Currently file AIO is supported on FreeBSD 4.3+ and Linux 2.6.22+ only\n END\n         exit 1\n     fi\n-\n-else\n-\n-    ngx_feature=\"eventfd()\"\n-    ngx_feature_name=\"NGX_HAVE_EVENTFD\"\n-    ngx_feature_run=no\n-    ngx_feature_incs=\"#include <sys/eventfd.h>\"\n-    ngx_feature_path=\n-    ngx_feature_libs=\n-    ngx_feature_test=\"(void) eventfd(0, 0)\"\n-    . auto/feature\n-\n-    if [ $ngx_found = yes ]; then\n-        have=NGX_HAVE_SYS_EVENTFD_H . auto/have\n-    fi\n-\n-    if [ $ngx_found = no ]; then\n-\n-        ngx_feature=\"eventfd() (SYS_eventfd)\"\n-        ngx_feature_incs=\"#include <sys/syscall.h>\"\n-        ngx_feature_test=\"(void) SYS_eventfd\"\n-        . auto/feature\n-    fi\n fi\n \n \nDiff:\n@@ -277,7 +277,7 @@ ngx_http_v2_init(ngx_event_t *rev)\n     h2scf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_v2_module);\n \n     h2c->concurrent_pushes = h2scf->concurrent_pushes;\n-    h2c->priority_limit = h2scf->concurrent_streams;\n+    h2c->priority_limit = ngx_max(h2scf->concurrent_streams, 100);\n \n     h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);\n     if (h2c->pool == NULL) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 85",
        "commit_diff": "Diff:\n@@ -458,3 +458,4 @@ dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n+da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019009\n-#define NGINX_VERSION      \"1.19.9\"\n+#define nginx_version      1019010\n+#define NGINX_VERSION      \"1.19.10\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -56,7 +56,7 @@ typedef struct {\n     unsigned             done:1;\n     unsigned             nomem:1;\n     unsigned             buffering:1;\n-    unsigned             intel:1;\n+    unsigned             zlib_ng:1;\n \n     size_t               zin;\n     size_t               zout;\n@@ -213,7 +213,7 @@ static ngx_str_t  ngx_http_gzip_ratio = ngx_string(\"gzip_ratio\");\n static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;\n static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;\n \n-static ngx_uint_t  ngx_http_gzip_assume_intel;\n+static ngx_uint_t  ngx_http_gzip_assume_zlib_ng;\n \n \n static ngx_int_t\n@@ -501,28 +501,30 @@ ngx_http_gzip_filter_memory(ngx_http_request_t *r, ngx_http_gzip_ctx_t *ctx)\n      * 8K is for zlib deflate_state, it takes\n      *  *) 5816 bytes on i386 and sparc64 (32-bit mode)\n      *  *) 5920 bytes on amd64 and sparc64\n+     *\n+     * A zlib variant from Intel (https://github.com/jtkukunas/zlib)\n+     * uses additional 16-byte padding in one of window-sized buffers.\n      */\n \n-    if (!ngx_http_gzip_assume_intel) {\n-        ctx->allocated = 8192 + (1 << (wbits + 2)) + (1 << (memlevel + 9));\n+    if (!ngx_http_gzip_assume_zlib_ng) {\n+        ctx->allocated = 8192 + 16 + (1 << (wbits + 2))\n+                         + (1 << (memlevel + 9));\n \n     } else {\n         /*\n-         * A zlib variant from Intel, https://github.com/jtkukunas/zlib.\n-         * It can force window bits to 13 for fast compression level,\n-         * on processors with SSE 4.2 it uses 64K hash instead of scaling\n-         * it from the specified memory level, and also introduces\n-         * 16-byte padding in one out of the two window-sized buffers.\n+         * Another zlib variant, https://github.com/zlib-ng/zlib-ng.\n+         * It forces window bits to 13 for fast compression level,\n+         * uses 16-byte padding in one of window-sized buffers, and\n+         * uses 128K hash.\n          */\n \n         if (conf->level == 1) {\n             wbits = ngx_max(wbits, 13);\n         }\n \n         ctx->allocated = 8192 + 16 + (1 << (wbits + 2))\n-                         + (1 << (ngx_max(memlevel, 8) + 8))\n-                         + (1 << (memlevel + 8));\n-        ctx->intel = 1;\n+                         + 131072 + (1 << (memlevel + 8));\n+        ctx->zlib_ng = 1;\n     }\n }\n \n@@ -945,13 +947,13 @@ ngx_http_gzip_filter_alloc(void *opaque, u_int items, u_int size)\n         return p;\n     }\n \n-    if (ctx->intel) {\n+    if (ctx->zlib_ng) {\n         ngx_log_error(NGX_LOG_ALERT, ctx->request->connection->log, 0,\n                       \"gzip filter failed to use preallocated memory: \"\n                       \"%ud of %ui\", items * size, ctx->allocated);\n \n     } else {\n-        ngx_http_gzip_assume_intel = 1;\n+        ngx_http_gzip_assume_zlib_ng = 1;\n     }\n \n     p = ngx_palloc(ctx->request->pool, items * size);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 84",
        "commit_diff": "Diff:\n@@ -5,6 +5,68 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.9\" date=\"2021-03-30\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не собирался с почтовым прокси-сервером,\n+но без модуля ngx_mail_ssl_module;\n+ошибка появилась в 1.19.8.\n+</para>\n+<para lang=\"en\">\n+nginx could not be built with the mail proxy module,\n+but without the ngx_mail_ssl_module;\n+the bug had appeared in 1.19.8.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при работе с gRPC-бэкендами могли возникать ошибки\n+\"upstream sent response body larger than indicated content length\";\n+ошибка появилась в 1.19.1.\n+</para>\n+<para lang=\"en\">\n+\"upstream sent response body larger than indicated content length\"\n+errors might occur when working with gRPC backends;\n+the bug had appeared in 1.19.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если клиент закрывал соединение в момент отбрасывания тела запроса,\n+nginx мог не закрыть соединение до истечения keepalive-таймаута.\n+</para>\n+<para lang=\"en\">\n+nginx might not close a connection till keepalive timeout expiration\n+if the connection was closed by the client while discarding the request body.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при ожидании задержки limit_req или auth_delay, а также при работе с бэкендами\n+nginx мог не обнаружить, что соединение уже закрыто клиентом.\n+</para>\n+<para lang=\"en\">\n+nginx might not detect that a connection was already closed by the client\n+when waiting for auth_delay or limit_req delay, or when working with backends.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в методе обработки соединений eventport.\n+</para>\n+<para lang=\"en\">\n+in the eventport method.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.8\" date=\"2021-03-09\">\n \n <change type=\"feature\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1j\n+OPENSSL =\topenssl-1.1.1k\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -310,8 +310,13 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n \n     r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_DELAYED;\n \n-    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    if (r->connection->read->ready) {\n+        ngx_post_event(r->connection->read, &ngx_posted_events);\n+\n+    } else {\n+        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n     }\n \n     r->read_event_handler = ngx_http_test_reading;\nDiff:\n@@ -1190,8 +1190,13 @@ ngx_http_core_auth_delay(ngx_http_request_t *r)\n     ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                   \"delaying unauthorized request\");\n \n-    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    if (r->connection->read->ready) {\n+        ngx_post_event(r->connection->read, &ngx_posted_events);\n+\n+    } else {\n+        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n     }\n \n     r->read_event_handler = ngx_http_test_reading;\nDiff:\n@@ -608,9 +608,14 @@ ngx_http_upstream_init_request(ngx_http_request_t *r)\n \n     if (!u->store && !r->post_action && !u->conf->ignore_client_abort) {\n \n-        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n-            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-            return;\n+        if (r->connection->read->ready) {\n+            ngx_post_event(r->connection->read, &ngx_posted_events);\n+\n+        } else {\n+            if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+                return;\n+            }\n         }\n \n         r->read_event_handler = ngx_http_upstream_rd_check_broken_connection;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 83",
        "commit_diff": "Diff:\n@@ -1563,13 +1563,28 @@ ngx_resolver_udp_read(ngx_event_t *rev)\n     do {\n         n = ngx_udp_recv(c, buf, NGX_RESOLVER_UDP_SIZE);\n \n-        if (n < 0) {\n-            return;\n+        if (n == NGX_AGAIN) {\n+            break;\n+        }\n+\n+        if (n == NGX_ERROR) {\n+            goto failed;\n         }\n \n         ngx_resolver_process_response(rec->resolver, buf, n, 0);\n \n     } while (rev->ready);\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    return;\n+\n+failed:\n+\n+    ngx_close_connection(rec->udp);\n+    rec->udp = NULL;\n }\n \n \nDiff:\n@@ -399,7 +399,7 @@ ngx_eventport_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)\n             return NGX_ERROR;\n         }\n \n-    } else {\n+    } else if (ev->active) {\n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ev->log, 0,\n                        \"eventport del event: fd:%d\", c->fd);\n \nDiff:\n@@ -607,6 +607,12 @@ ngx_http_upstream_init_request(ngx_http_request_t *r)\n     u->store = u->conf->store;\n \n     if (!u->store && !r->post_action && !u->conf->ignore_client_abort) {\n+\n+        if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+            return;\n+        }\n+\n         r->read_event_handler = ngx_http_upstream_rd_check_broken_connection;\n         r->write_event_handler = ngx_http_upstream_wr_check_broken_connection;\n     }\n@@ -3011,9 +3017,7 @@ ngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)\n                 return;\n             }\n \n-            if (u->peer.connection->read->ready || u->length == 0) {\n-                ngx_http_upstream_process_non_buffered_upstream(r, u);\n-            }\n+            ngx_http_upstream_process_non_buffered_upstream(r, u);\n         }\n \n         return;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 82",
        "commit_diff": "Diff:\n@@ -257,9 +257,7 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n         ngx_shmtx_unlock(&ngx_accept_mutex);\n     }\n \n-    if (delta) {\n-        ngx_event_expire_timers();\n-    }\n+    ngx_event_expire_timers();\n \n     ngx_event_process_posted(cycle, &ngx_posted_events);\n }\nDiff:\n@@ -2662,11 +2662,6 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n         ngx_del_timer(c->write);\n     }\n \n-    if (c->read->eof) {\n-        ngx_http_close_request(r, 0);\n-        return;\n-    }\n-\n     ngx_http_finalize_connection(r);\n }\n \n@@ -2765,6 +2760,11 @@ ngx_http_finalize_connection(ngx_http_request_t *r)\n \n     r = r->main;\n \n+    if (r->connection->read->eof) {\n+        ngx_http_close_request(r, 0);\n+        return;\n+    }\n+\n     if (r->reading_body) {\n         r->keepalive = 0;\n         r->lingering_close = 1;\nDiff:\n@@ -1368,7 +1368,9 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n     clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n                                         ngx_http_core_module);\n \n-    if (h2c->connection->requests >= clcf->keepalive_requests) {\n+    if (clcf->keepalive_timeout == 0\n+        || h2c->connection->requests >= clcf->keepalive_requests)\n+    {\n         h2c->goaway = 1;\n \n         if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 81",
        "commit_diff": "Diff:\n@@ -457,3 +457,4 @@ dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n 8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\n f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n+8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\nDiff:\n@@ -985,6 +985,12 @@ if [ $MAIL != NO ]; then\n     ngx_module_srcs=src/mail/ngx_mail_proxy_module.c\n \n     . auto/module\n+\n+    ngx_module_name=ngx_mail_realip_module\n+    ngx_module_deps=\n+    ngx_module_srcs=src/mail/ngx_mail_realip_module.c\n+\n+    . auto/module\n fi\n \n \nDiff:\n@@ -5,6 +5,68 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.8\" date=\"2021-03-09\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+в директиве proxy_cookie_flags теперь\n+флаги можно задавать с помощью переменных.\n+</para>\n+<para lang=\"en\">\n+flags in the \"proxy_cookie_flags\" directive\n+can now contain variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+параметр proxy_protocol в директиве listen,\n+директивы proxy_protocol и set_real_ip_from\n+в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_protocol\" parameter of the \"listen\" directive,\n+the \"proxy_protocol\" and \"set_real_ip_from\" directives\n+in mail proxy.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+HTTP/2-соединения сразу закрывались\n+при использовании \"keepalive_timeout 0\";\n+ошибка появилась в 1.19.7.\n+</para>\n+<para lang=\"en\">\n+HTTP/2 connections were immediately closed\n+when using \"keepalive_timeout 0\";\n+the bug had appeared in 1.19.7.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+некоторые ошибки логгировались как неизвестные,\n+если nginx был собран с glibc 2.32.\n+</para>\n+<para lang=\"en\">\n+some errors were logged as unknown\n+if nginx was built with glibc 2.32.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в методе обработки соединений eventport.\n+</para>\n+<para lang=\"en\">\n+in the eventport method.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.7\" date=\"2021-02-16\">\n \n <change type=\"change\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1i\n+OPENSSL =\topenssl-1.1.1j\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019008\n-#define NGINX_VERSION      \"1.19.8\"\n+#define nginx_version      1019009\n+#define NGINX_VERSION      \"1.19.9\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -2074,17 +2074,6 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                     return NGX_ERROR;\n                 }\n \n-                if (ctx->length != -1) {\n-                    if ((off_t) ctx->rest > ctx->length) {\n-                        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                                      \"upstream sent response body larger \"\n-                                      \"than indicated content length\");\n-                        return NGX_ERROR;\n-                    }\n-\n-                    ctx->length -= ctx->rest;\n-                }\n-\n                 if (ctx->rest > ctx->recv_window) {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                                   \"upstream violated stream flow control, \"\n@@ -2450,13 +2439,37 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n             b->pos = b->last;\n             buf->last = b->pos;\n \n+            if (ctx->length != -1) {\n+\n+                if (buf->last - buf->pos > ctx->length) {\n+                    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                  \"upstream sent response body larger \"\n+                                  \"than indicated content length\");\n+                    return NGX_ERROR;\n+                }\n+\n+                ctx->length -= buf->last - buf->pos;\n+            }\n+\n             return NGX_AGAIN;\n         }\n \n         b->pos += ctx->rest - ctx->padding;\n         buf->last = b->pos;\n         ctx->rest = ctx->padding;\n \n+        if (ctx->length != -1) {\n+\n+            if (buf->last - buf->pos > ctx->length) {\n+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                              \"upstream sent response body larger \"\n+                              \"than indicated content length\");\n+                return NGX_ERROR;\n+            }\n+\n+            ctx->length -= buf->last - buf->pos;\n+        }\n+\n     done:\n \n         if (ctx->padding) {\nDiff:\n@@ -405,6 +405,7 @@ ngx_mail_add_addrs(ngx_conf_t *cf, ngx_mail_port_t *mport,\n #if (NGX_MAIL_SSL)\n         addrs[i].conf.ssl = addr[i].opt.ssl;\n #endif\n+        addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;\n         addrs[i].conf.addr_text = addr[i].opt.addr_text;\n     }\n \n@@ -439,6 +440,7 @@ ngx_mail_add_addrs6(ngx_conf_t *cf, ngx_mail_port_t *mport,\n #if (NGX_MAIL_SSL)\n         addrs6[i].conf.ssl = addr[i].opt.ssl;\n #endif\n+        addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;\n         addrs6[i].conf.addr_text = addr[i].opt.addr_text;\n     }\n \nDiff:\n@@ -41,6 +41,7 @@ typedef struct {\n     unsigned                ipv6only:1;\n #endif\n     unsigned                so_keepalive:2;\n+    unsigned                proxy_protocol:1;\n #if (NGX_HAVE_KEEPALIVE_TUNABLE)\n     int                     tcp_keepidle;\n     int                     tcp_keepintvl;\n@@ -55,7 +56,8 @@ typedef struct {\n typedef struct {\n     ngx_mail_conf_ctx_t    *ctx;\n     ngx_str_t               addr_text;\n-    ngx_uint_t              ssl;    /* unsigned   ssl:1; */\n+    unsigned                ssl:1;\n+    unsigned                proxy_protocol:1;\n } ngx_mail_addr_conf_t;\n \n typedef struct {\n@@ -176,6 +178,7 @@ typedef enum {\n typedef struct {\n     ngx_peer_connection_t   upstream;\n     ngx_buf_t              *buffer;\n+    ngx_uint_t              proxy_protocol;  /* unsigned  proxy_protocol:1; */\n } ngx_mail_proxy_ctx_t;\n \n \n@@ -406,6 +409,7 @@ char *ngx_mail_capabilities(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n /* STUB */\n void ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer);\n void ngx_mail_auth_http_init(ngx_mail_session_t *s);\n+ngx_int_t ngx_mail_realip_handler(ngx_mail_session_t *s);\n /**/\n \n \nDiff:\n@@ -1135,10 +1135,10 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n     size_t                     len;\n     ngx_buf_t                 *b;\n     ngx_str_t                  login, passwd;\n+    ngx_connection_t          *c;\n #if (NGX_MAIL_SSL)\n     ngx_str_t                  verify, subject, issuer, serial, fingerprint,\n                                raw_cert, cert;\n-    ngx_connection_t          *c;\n     ngx_mail_ssl_conf_t       *sslcf;\n #endif\n     ngx_mail_core_srv_conf_t  *cscf;\n@@ -1151,9 +1151,10 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n         return NULL;\n     }\n \n+    c = s->connection;\n+\n #if (NGX_MAIL_SSL)\n \n-    c = s->connection;\n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n     if (c->ssl && sslcf->verify) {\n@@ -1227,6 +1228,17 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n           + ahcf->header.len\n           + sizeof(CRLF) - 1;\n \n+    if (c->proxy_protocol) {\n+        len += sizeof(\"Proxy-Protocol-Addr: \") - 1\n+                     + c->proxy_protocol->src_addr.len + sizeof(CRLF) - 1\n+               + sizeof(\"Proxy-Protocol-Port: \") - 1\n+                     + sizeof(\"65535\") - 1 + sizeof(CRLF) - 1\n+               + sizeof(\"Proxy-Protocol-Server-Addr: \") - 1\n+                     + c->proxy_protocol->dst_addr.len + sizeof(CRLF) - 1\n+               + sizeof(\"Proxy-Protocol-Server-Port: \") - 1\n+                     + sizeof(\"65535\") - 1 + sizeof(CRLF) - 1;\n+    }\n+\n     if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n         len += sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len\n                      + sizeof(CRLF) - 1\n@@ -1314,6 +1326,26 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n         *b->last++ = CR; *b->last++ = LF;\n     }\n \n+    if (c->proxy_protocol) {\n+        b->last = ngx_cpymem(b->last, \"Proxy-Protocol-Addr: \",\n+                             sizeof(\"Proxy-Protocol-Addr: \") - 1);\n+        b->last = ngx_copy(b->last, c->proxy_protocol->src_addr.data,\n+                           c->proxy_protocol->src_addr.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+        b->last = ngx_sprintf(b->last, \"Proxy-Protocol-Port: %d\" CRLF,\n+                              c->proxy_protocol->src_port);\n+\n+        b->last = ngx_cpymem(b->last, \"Proxy-Protocol-Server-Addr: \",\n+                             sizeof(\"Proxy-Protocol-Server-Addr: \") - 1);\n+        b->last = ngx_copy(b->last, c->proxy_protocol->dst_addr.data,\n+                           c->proxy_protocol->dst_addr.len);\n+        *b->last++ = CR; *b->last++ = LF;\n+\n+        b->last = ngx_sprintf(b->last, \"Proxy-Protocol-Server-Port: %d\" CRLF,\n+                              c->proxy_protocol->dst_port);\n+    }\n+\n     if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n \n         /* HELO, MAIL FROM, and RCPT TO can't contain CRLF, no need to escape */\nDiff:\n@@ -548,6 +548,11 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n         }\n \n+        if (ngx_strcmp(value[i].data, \"proxy_protocol\") == 0) {\n+            ls->proxy_protocol = 1;\n+            continue;\n+        }\n+\n         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                            \"the invalid \\\"%V\\\" parameter\", &value[i]);\n         return NGX_CONF_ERROR;\nDiff:\n@@ -11,6 +11,7 @@\n #include <ngx_mail.h>\n \n \n+static void ngx_mail_proxy_protocol_handler(ngx_event_t *rev);\n static void ngx_mail_init_session_handler(ngx_event_t *rev);\n static void ngx_mail_init_session(ngx_connection_t *c);\n \n@@ -168,6 +169,22 @@ ngx_mail_init_connection(ngx_connection_t *c)\n     rev = c->read;\n     rev->handler = ngx_mail_init_session_handler;\n \n+    if (addr_conf->proxy_protocol) {\n+        c->log->action = \"reading PROXY protocol\";\n+\n+        rev->handler = ngx_mail_proxy_protocol_handler;\n+\n+        if (!rev->ready) {\n+            ngx_add_timer(rev, cscf->timeout);\n+\n+            if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+                ngx_mail_close_connection(c);\n+            }\n+\n+            return;\n+        }\n+    }\n+\n     if (ngx_use_accept_mutex) {\n         ngx_post_event(rev, &ngx_posted_events);\n         return;\n@@ -178,18 +195,94 @@ ngx_mail_init_connection(ngx_connection_t *c)\n \n \n static void\n-ngx_mail_init_session_handler(ngx_event_t *rev)\n+ngx_mail_proxy_protocol_handler(ngx_event_t *rev)\n {\n-    ngx_connection_t    *c;\n-    ngx_mail_session_t  *s;\n+    u_char                    *p, buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+    size_t                     size;\n+    ssize_t                    n;\n+    ngx_err_t                  err;\n+    ngx_connection_t          *c;\n+    ngx_mail_session_t        *s;\n+    ngx_mail_core_srv_conf_t  *cscf;\n \n     c = rev->data;\n     s = c->data;\n \n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0,\n+                   \"mail PROXY protocol handler\");\n+\n+    if (rev->timedout) {\n+        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n+        c->timedout = 1;\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    n = recv(c->fd, (char *) buf, sizeof(buf), MSG_PEEK);\n+\n+    err = ngx_socket_errno;\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_MAIL, c->log, 0, \"recv(): %z\", n);\n+\n+    if (n == -1) {\n+        if (err == NGX_EAGAIN) {\n+            rev->ready = 0;\n+\n+            if (!rev->timer_set) {\n+                cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+                ngx_add_timer(rev, cscf->timeout);\n+            }\n+\n+            if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+                ngx_mail_close_connection(c);\n+            }\n+\n+            return;\n+        }\n+\n+        ngx_connection_error(c, err, \"recv() failed\");\n+\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    p = ngx_proxy_protocol_read(c, buf, buf + n);\n+\n+    if (p == NULL) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    size = p - buf;\n+\n+    if (c->recv(c, buf, size) != (ssize_t) size) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    if (ngx_mail_realip_handler(s) != NGX_OK) {\n+        ngx_mail_close_connection(c);\n+        return;\n+    }\n+\n+    ngx_mail_init_session_handler(rev);\n+}\n+\n+\n+static void\n+ngx_mail_init_session_handler(ngx_event_t *rev)\n+{\n+    ngx_connection_t  *c;\n+\n+    c = rev->data;\n+\n #if (NGX_MAIL_SSL)\n     {\n+    ngx_mail_session_t   *s;\n     ngx_mail_ssl_conf_t  *sslcf;\n \n+    s = c->data;\n+\n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n     if (sslcf->enable || s->ssl) {\n@@ -242,9 +335,10 @@ ngx_mail_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)\n \n         s = c->data;\n \n-        cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n-\n-        ngx_add_timer(c->read, cscf->timeout);\n+        if (!c->read->timer_set) {\n+            cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n+            ngx_add_timer(c->read, cscf->timeout);\n+        }\n \n         c->ssl->handler = ngx_mail_ssl_handshake_handler;\n \nDiff:\n@@ -17,6 +17,7 @@ typedef struct {\n     ngx_flag_t  pass_error_message;\n     ngx_flag_t  xclient;\n     ngx_flag_t  smtp_auth;\n+    ngx_flag_t  proxy_protocol;\n     size_t      buffer_size;\n     ngx_msec_t  timeout;\n } ngx_mail_proxy_conf_t;\n@@ -26,7 +27,8 @@ static void ngx_mail_proxy_block_read(ngx_event_t *rev);\n static void ngx_mail_proxy_pop3_handler(ngx_event_t *rev);\n static void ngx_mail_proxy_imap_handler(ngx_event_t *rev);\n static void ngx_mail_proxy_smtp_handler(ngx_event_t *rev);\n-static void ngx_mail_proxy_dummy_handler(ngx_event_t *ev);\n+static void ngx_mail_proxy_write_handler(ngx_event_t *wev);\n+static ngx_int_t ngx_mail_proxy_send_proxy_protocol(ngx_mail_session_t *s);\n static ngx_int_t ngx_mail_proxy_read_response(ngx_mail_session_t *s,\n     ngx_uint_t state);\n static void ngx_mail_proxy_handler(ngx_event_t *ev);\n@@ -82,6 +84,13 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {\n       offsetof(ngx_mail_proxy_conf_t, smtp_auth),\n       NULL },\n \n+    { ngx_string(\"proxy_protocol\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, proxy_protocol),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -156,7 +165,7 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n     p->upstream.connection->pool = s->connection->pool;\n \n     s->connection->read->handler = ngx_mail_proxy_block_read;\n-    p->upstream.connection->write->handler = ngx_mail_proxy_dummy_handler;\n+    p->upstream.connection->write->handler = ngx_mail_proxy_write_handler;\n \n     pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n \n@@ -167,6 +176,8 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n         return;\n     }\n \n+    s->proxy->proxy_protocol = pcf->proxy_protocol;\n+\n     s->out.len = 0;\n \n     switch (s->protocol) {\n@@ -186,6 +197,12 @@ ngx_mail_proxy_init(ngx_mail_session_t *s, ngx_addr_t *peer)\n         s->mail_state = ngx_smtp_start;\n         break;\n     }\n+\n+    if (rc == NGX_AGAIN) {\n+        return;\n+    }\n+\n+    ngx_mail_proxy_write_handler(p->upstream.connection->write);\n }\n \n \n@@ -230,6 +247,17 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (s->proxy->proxy_protocol) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"mail proxy pop3 busy\");\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n     rc = ngx_mail_proxy_read_response(s, 0);\n \n     if (rc == NGX_AGAIN) {\n@@ -353,6 +381,17 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (s->proxy->proxy_protocol) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"mail proxy imap busy\");\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n@@ -499,6 +538,17 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (s->proxy->proxy_protocol) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"mail proxy smtp busy\");\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n@@ -799,19 +849,92 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n \n \n static void\n-ngx_mail_proxy_dummy_handler(ngx_event_t *wev)\n+ngx_mail_proxy_write_handler(ngx_event_t *wev)\n {\n     ngx_connection_t    *c;\n     ngx_mail_session_t  *s;\n \n-    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0, \"mail proxy dummy handler\");\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, wev->log, 0, \"mail proxy write handler\");\n+\n+    c = wev->data;\n+    s = c->data;\n+\n+    if (s->proxy->proxy_protocol) {\n+        if (ngx_mail_proxy_send_proxy_protocol(s) != NGX_OK) {\n+            return;\n+        }\n+\n+        s->proxy->proxy_protocol = 0;\n+    }\n \n     if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n-        c = wev->data;\n-        s = c->data;\n+        ngx_mail_proxy_internal_server_error(s);\n+    }\n \n-        ngx_mail_proxy_close_session(s);\n+    if (c->read->ready) {\n+        ngx_post_event(c->read, &ngx_posted_events);\n+    }\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_proxy_send_proxy_protocol(ngx_mail_session_t *s)\n+{\n+    u_char            *p;\n+    ssize_t            n, size;\n+    ngx_connection_t  *c;\n+    u_char             buf[NGX_PROXY_PROTOCOL_MAX_HEADER];\n+\n+    s->connection->log->action = \"sending PROXY protocol header to upstream\";\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_MAIL, s->connection->log, 0,\n+                   \"mail proxy send PROXY protocol header\");\n+\n+    p = ngx_proxy_protocol_write(s->connection, buf,\n+                                 buf + NGX_PROXY_PROTOCOL_MAX_HEADER);\n+    if (p == NULL) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    c = s->proxy->upstream.connection;\n+\n+    size = p - buf;\n+\n+    n = c->send(c, buf, size);\n+\n+    if (n == NGX_AGAIN) {\n+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return NGX_ERROR;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    if (n == NGX_ERROR) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    if (n != size) {\n+\n+        /*\n+         * PROXY protocol specification:\n+         * The sender must always ensure that the header\n+         * is sent at once, so that the transport layer\n+         * maintains atomicity along the path to the receiver.\n+         */\n+\n+        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                      \"could not send PROXY protocol header at once\");\n+\n+        ngx_mail_proxy_internal_server_error(s);\n+\n+        return NGX_ERROR;\n     }\n+\n+    return NGX_OK;\n }\n \n \n@@ -1212,6 +1335,7 @@ ngx_mail_proxy_create_conf(ngx_conf_t *cf)\n     pcf->pass_error_message = NGX_CONF_UNSET;\n     pcf->xclient = NGX_CONF_UNSET;\n     pcf->smtp_auth = NGX_CONF_UNSET;\n+    pcf->proxy_protocol = NGX_CONF_UNSET;\n     pcf->buffer_size = NGX_CONF_UNSET_SIZE;\n     pcf->timeout = NGX_CONF_UNSET_MSEC;\n \n@@ -1229,6 +1353,7 @@ ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);\n     ngx_conf_merge_value(conf->xclient, prev->xclient, 1);\n     ngx_conf_merge_value(conf->smtp_auth, prev->smtp_auth, 0);\n+    ngx_conf_merge_value(conf->proxy_protocol, prev->proxy_protocol, 0);\n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n                               (size_t) ngx_pagesize);\n     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);\nDiff:\n@@ -0,0 +1,269 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_mail.h>\n+\n+\n+typedef struct {\n+    ngx_array_t       *from;     /* array of ngx_cidr_t */\n+} ngx_mail_realip_srv_conf_t;\n+\n+\n+static ngx_int_t ngx_mail_realip_set_addr(ngx_mail_session_t *s,\n+    ngx_addr_t *addr);\n+static char *ngx_mail_realip_from(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+static void *ngx_mail_realip_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_mail_realip_merge_srv_conf(ngx_conf_t *cf, void *parent,\n+    void *child);\n+\n+\n+static ngx_command_t  ngx_mail_realip_commands[] = {\n+\n+    { ngx_string(\"set_real_ip_from\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_mail_realip_from,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_mail_module_t  ngx_mail_realip_module_ctx = {\n+    NULL,                                  /* protocol */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_mail_realip_create_srv_conf,       /* create server configuration */\n+    ngx_mail_realip_merge_srv_conf         /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_mail_realip_module = {\n+    NGX_MODULE_V1,\n+    &ngx_mail_realip_module_ctx,           /* module context */\n+    ngx_mail_realip_commands,              /* module directives */\n+    NGX_MAIL_MODULE,                       /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+ngx_int_t\n+ngx_mail_realip_handler(ngx_mail_session_t *s)\n+{\n+    ngx_addr_t                   addr;\n+    ngx_connection_t            *c;\n+    ngx_mail_realip_srv_conf_t  *rscf;\n+\n+    rscf = ngx_mail_get_module_srv_conf(s, ngx_mail_realip_module);\n+\n+    if (rscf->from == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    c = s->connection;\n+\n+    if (c->proxy_protocol == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) {\n+        return NGX_OK;\n+    }\n+\n+    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data,\n+                       c->proxy_protocol->src_addr.len)\n+        != NGX_OK)\n+    {\n+        return NGX_OK;\n+    }\n+\n+    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n+\n+    return ngx_mail_realip_set_addr(s, &addr);\n+}\n+\n+\n+static ngx_int_t\n+ngx_mail_realip_set_addr(ngx_mail_session_t *s, ngx_addr_t *addr)\n+{\n+    size_t             len;\n+    u_char            *p;\n+    u_char             text[NGX_SOCKADDR_STRLEN];\n+    ngx_connection_t  *c;\n+\n+    c = s->connection;\n+\n+    len = ngx_sock_ntop(addr->sockaddr, addr->socklen, text,\n+                        NGX_SOCKADDR_STRLEN, 0);\n+    if (len == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_pnalloc(c->pool, len);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(p, text, len);\n+\n+    c->sockaddr = addr->sockaddr;\n+    c->socklen = addr->socklen;\n+    c->addr_text.len = len;\n+    c->addr_text.data = p;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static char *\n+ngx_mail_realip_from(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_mail_realip_srv_conf_t *rscf = conf;\n+\n+    ngx_int_t             rc;\n+    ngx_str_t            *value;\n+    ngx_url_t             u;\n+    ngx_cidr_t            c, *cidr;\n+    ngx_uint_t            i;\n+    struct sockaddr_in   *sin;\n+#if (NGX_HAVE_INET6)\n+    struct sockaddr_in6  *sin6;\n+#endif\n+\n+    value = cf->args->elts;\n+\n+    if (rscf->from == NULL) {\n+        rscf->from = ngx_array_create(cf->pool, 2,\n+                                      sizeof(ngx_cidr_t));\n+        if (rscf->from == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+#if (NGX_HAVE_UNIX_DOMAIN)\n+\n+    if (ngx_strcmp(value[1].data, \"unix:\") == 0) {\n+        cidr = ngx_array_push(rscf->from);\n+        if (cidr == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        cidr->family = AF_UNIX;\n+        return NGX_CONF_OK;\n+    }\n+\n+#endif\n+\n+    rc = ngx_ptocidr(&value[1], &c);\n+\n+    if (rc != NGX_ERROR) {\n+        if (rc == NGX_DONE) {\n+            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                               \"low address bits of %V are meaningless\",\n+                               &value[1]);\n+        }\n+\n+        cidr = ngx_array_push(rscf->from);\n+        if (cidr == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        *cidr = c;\n+\n+        return NGX_CONF_OK;\n+    }\n+\n+    ngx_memzero(&u, sizeof(ngx_url_t));\n+    u.host = value[1];\n+\n+    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {\n+        if (u.err) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"%s in set_real_ip_from \\\"%V\\\"\",\n+                               u.err, &u.host);\n+        }\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    cidr = ngx_array_push_n(rscf->from, u.naddrs);\n+    if (cidr == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    ngx_memzero(cidr, u.naddrs * sizeof(ngx_cidr_t));\n+\n+    for (i = 0; i < u.naddrs; i++) {\n+        cidr[i].family = u.addrs[i].sockaddr->sa_family;\n+\n+        switch (cidr[i].family) {\n+\n+#if (NGX_HAVE_INET6)\n+        case AF_INET6:\n+            sin6 = (struct sockaddr_in6 *) u.addrs[i].sockaddr;\n+            cidr[i].u.in6.addr = sin6->sin6_addr;\n+            ngx_memset(cidr[i].u.in6.mask.s6_addr, 0xff, 16);\n+            break;\n+#endif\n+\n+        default: /* AF_INET */\n+            sin = (struct sockaddr_in *) u.addrs[i].sockaddr;\n+            cidr[i].u.in.addr = sin->sin_addr.s_addr;\n+            cidr[i].u.in.mask = 0xffffffff;\n+            break;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n+static void *\n+ngx_mail_realip_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_mail_realip_srv_conf_t  *conf;\n+\n+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_realip_srv_conf_t));\n+    if (conf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc():\n+     *\n+     *     conf->from = NULL;\n+     */\n+\n+    return conf;\n+}\n+\n+\n+static char *\n+ngx_mail_realip_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n+{\n+    ngx_mail_realip_srv_conf_t *prev = parent;\n+    ngx_mail_realip_srv_conf_t *conf = child;\n+\n+    if (conf->from == NULL) {\n+        conf->from = prev->from;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -15,7 +15,7 @@ static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,\n     ngx_int_t type);\n static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,\n     ngx_uint_t respawn);\n-static void ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch);\n+static void ngx_pass_open_channel(ngx_cycle_t *cycle);\n static void ngx_signal_worker_processes(ngx_cycle_t *cycle, int signo);\n static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle);\n static void ngx_master_process_exit(ngx_cycle_t *cycle);\n@@ -335,35 +335,25 @@ ngx_single_process_cycle(ngx_cycle_t *cycle)\n static void\n ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)\n {\n-    ngx_int_t      i;\n-    ngx_channel_t  ch;\n+    ngx_int_t  i;\n \n     ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"start worker processes\");\n \n-    ngx_memzero(&ch, sizeof(ngx_channel_t));\n-\n-    ch.command = NGX_CMD_OPEN_CHANNEL;\n-\n     for (i = 0; i < n; i++) {\n \n         ngx_spawn_process(cycle, ngx_worker_process_cycle,\n                           (void *) (intptr_t) i, \"worker process\", type);\n \n-        ch.pid = ngx_processes[ngx_process_slot].pid;\n-        ch.slot = ngx_process_slot;\n-        ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-        ngx_pass_open_channel(cycle, &ch);\n+        ngx_pass_open_channel(cycle);\n     }\n }\n \n \n static void\n ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n {\n-    ngx_uint_t       i, manager, loader;\n-    ngx_path_t     **path;\n-    ngx_channel_t    ch;\n+    ngx_uint_t    i, manager, loader;\n+    ngx_path_t  **path;\n \n     manager = 0;\n     loader = 0;\n@@ -388,14 +378,7 @@ ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n                       &ngx_cache_manager_ctx, \"cache manager process\",\n                       respawn ? NGX_PROCESS_JUST_RESPAWN : NGX_PROCESS_RESPAWN);\n \n-    ngx_memzero(&ch, sizeof(ngx_channel_t));\n-\n-    ch.command = NGX_CMD_OPEN_CHANNEL;\n-    ch.pid = ngx_processes[ngx_process_slot].pid;\n-    ch.slot = ngx_process_slot;\n-    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-    ngx_pass_open_channel(cycle, &ch);\n+    ngx_pass_open_channel(cycle);\n \n     if (loader == 0) {\n         return;\n@@ -405,19 +388,20 @@ ngx_start_cache_manager_processes(ngx_cycle_t *cycle, ngx_uint_t respawn)\n                       &ngx_cache_loader_ctx, \"cache loader process\",\n                       respawn ? NGX_PROCESS_JUST_SPAWN : NGX_PROCESS_NORESPAWN);\n \n-    ch.command = NGX_CMD_OPEN_CHANNEL;\n-    ch.pid = ngx_processes[ngx_process_slot].pid;\n-    ch.slot = ngx_process_slot;\n-    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-    ngx_pass_open_channel(cycle, &ch);\n+    ngx_pass_open_channel(cycle);\n }\n \n \n static void\n-ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)\n+ngx_pass_open_channel(ngx_cycle_t *cycle)\n {\n-    ngx_int_t  i;\n+    ngx_int_t      i;\n+    ngx_channel_t  ch;\n+\n+    ch.command = NGX_CMD_OPEN_CHANNEL;\n+    ch.pid = ngx_processes[ngx_process_slot].pid;\n+    ch.slot = ngx_process_slot;\n+    ch.fd = ngx_processes[ngx_process_slot].channel[0];\n \n     for (i = 0; i < ngx_last_process; i++) {\n \n@@ -430,14 +414,14 @@ ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)\n \n         ngx_log_debug6(NGX_LOG_DEBUG_CORE, cycle->log, 0,\n                       \"pass channel s:%i pid:%P fd:%d to s:%i pid:%P fd:%d\",\n-                      ch->slot, ch->pid, ch->fd,\n+                      ch.slot, ch.pid, ch.fd,\n                       i, ngx_processes[i].pid,\n                       ngx_processes[i].channel[0]);\n \n         /* TODO: NGX_AGAIN */\n \n         ngx_write_channel(ngx_processes[i].channel[0],\n-                          ch, sizeof(ngx_channel_t), cycle->log);\n+                          &ch, sizeof(ngx_channel_t), cycle->log);\n     }\n }\n \n@@ -621,12 +605,7 @@ ngx_reap_children(ngx_cycle_t *cycle)\n                 }\n \n \n-                ch.command = NGX_CMD_OPEN_CHANNEL;\n-                ch.pid = ngx_processes[ngx_process_slot].pid;\n-                ch.slot = ngx_process_slot;\n-                ch.fd = ngx_processes[ngx_process_slot].channel[0];\n-\n-                ngx_pass_open_channel(cycle, &ch);\n+                ngx_pass_open_channel(cycle);\n \n                 live = 1;\n \n",
        "analysis": "The only newly added entire function in the provided diff is `ngx_mail_realip_handler`. Let's analyze it for possible out-of-bounds write vulnerabilities:\n\n```c\nngx_int_t\nngx_mail_realip_handler(ngx_mail_session_t *s)\n{\n    ngx_addr_t                   addr;\n    ngx_connection_t            *c;\n    ngx_mail_realip_srv_conf_t  *rscf;\n\n    rscf = ngx_mail_get_module_srv_conf(s, ngx_mail_realip_module);\n\n    if (rscf->from == NULL) {\n        return NGX_OK;\n    }\n\n    c = s->connection;\n\n    if (c->proxy_protocol == NULL) {\n        return NGX_OK;\n    }\n\n    if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) {\n        return NGX_OK;\n    }\n\n    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data,\n                       c->proxy_protocol->src_addr.len)\n        != NGX_OK)\n    {\n        return NGX_OK;\n    }\n\n    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n\n    return ngx_mail_realip_set_addr(s, &addr);\n}\n```\n\nStep-by-step analysis:\n1. `rscf = ngx_mail_get_module_srv_conf(s, ngx_mail_realip_module);` - Retrieves configuration; no direct buffer writes.\n2. `if (rscf->from == NULL) { return NGX_OK; }` - Exits early if no configuration; no writes occur.\n3. `c = s->connection;` - Assigns a pointer; no buffer involved.\n4. `if (c->proxy_protocol == NULL) { return NGX_OK; }` - Checks for a valid pointer; no writing.\n5. `if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) { return NGX_OK; }` - Calls a function; no writing.\n6. `if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data, c->proxy_protocol->src_addr.len) != NGX_OK) { return NGX_OK; }` - Parses an address; potential for problems if size is incorrectly calculated based on `src_addr.len`, but seems safe since no explicit buffer is allocated here.\n7. `ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);` - Sets a port; relies on previously parsed address, but no direct evidence of out-of-bounds write here.\n\nOverall, the function uses existing structures and checks their configurations. It relies on external functions (`ngx_cidr_match`, `ngx_parse_addr`). The main focus point for potential out-of-bounds might be handling incorrect lengths with `src_addr.len`, but given that parsing functions should handle this correctly, there's no immediate evidence solely from this function of an out-of-bounds write vulnerability.\n\nConclusion: There does not seem to be a direct out-of-bounds write vulnerability in this function.\n\nFALSE"
    },
    {
        "commit_index": "Commit 80",
        "commit_diff": "Diff:\n@@ -197,6 +197,7 @@ typedef struct {\n \n     ngx_uint_t              mail_state;\n \n+    unsigned                ssl:1;\n     unsigned                protocol:3;\n     unsigned                blocked:1;\n     unsigned                quit:1;\nDiff:\n@@ -1224,22 +1224,38 @@ ngx_mail_auth_http_create_request(ngx_mail_session_t *s, ngx_pool_t *pool,\n           + sizeof(\"Client-IP: \") - 1 + s->connection->addr_text.len\n                 + sizeof(CRLF) - 1\n           + sizeof(\"Client-Host: \") - 1 + s->host.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SMTP-From: \") - 1 + s->smtp_from.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SMTP-To: \") - 1 + s->smtp_to.len + sizeof(CRLF) - 1\n-#if (NGX_MAIL_SSL)\n-          + sizeof(\"Auth-SSL: on\" CRLF) - 1\n-          + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Issuer: \") - 1 + issuer.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Serial: \") - 1 + serial.len + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Fingerprint: \") - 1 + fingerprint.len\n-              + sizeof(CRLF) - 1\n-          + sizeof(\"Auth-SSL-Cert: \") - 1 + cert.len + sizeof(CRLF) - 1\n-#endif\n           + ahcf->header.len\n           + sizeof(CRLF) - 1;\n \n+    if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+        len += sizeof(\"Auth-SMTP-Helo: \") - 1 + s->smtp_helo.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SMTP-From: \") - 1 + s->smtp_from.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SMTP-To: \") - 1 + s->smtp_to.len\n+                     + sizeof(CRLF) - 1;\n+    }\n+\n+#if (NGX_MAIL_SSL)\n+\n+    if (c->ssl) {\n+        len += sizeof(\"Auth-SSL: on\" CRLF) - 1\n+               + sizeof(\"Auth-SSL-Verify: \") - 1 + verify.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Subject: \") - 1 + subject.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Issuer: \") - 1 + issuer.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Serial: \") - 1 + serial.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Fingerprint: \") - 1 + fingerprint.len\n+                     + sizeof(CRLF) - 1\n+               + sizeof(\"Auth-SSL-Cert: \") - 1 + cert.len\n+                     + sizeof(CRLF) - 1;\n+    }\n+\n+#endif\n+\n     b = ngx_create_temp_buf(pool, len);\n     if (b == NULL) {\n         return NULL;\nDiff:\n@@ -11,6 +11,7 @@\n #include <ngx_mail.h>\n \n \n+static void ngx_mail_init_session_handler(ngx_event_t *rev);\n static void ngx_mail_init_session(ngx_connection_t *c);\n \n #if (NGX_MAIL_SSL)\n@@ -26,6 +27,7 @@ ngx_mail_init_connection(ngx_connection_t *c)\n {\n     size_t                     len;\n     ngx_uint_t                 i;\n+    ngx_event_t               *rev;\n     ngx_mail_port_t           *port;\n     struct sockaddr           *sa;\n     struct sockaddr_in        *sin;\n@@ -129,6 +131,10 @@ ngx_mail_init_connection(ngx_connection_t *c)\n     s->main_conf = addr_conf->ctx->main_conf;\n     s->srv_conf = addr_conf->ctx->srv_conf;\n \n+#if (NGX_MAIL_SSL)\n+    s->ssl = addr_conf->ssl;\n+#endif\n+\n     s->addr_text = &addr_conf->addr_text;\n \n     c->data = s;\n@@ -159,13 +165,34 @@ ngx_mail_init_connection(ngx_connection_t *c)\n \n     c->log_error = NGX_ERROR_INFO;\n \n+    rev = c->read;\n+    rev->handler = ngx_mail_init_session_handler;\n+\n+    if (ngx_use_accept_mutex) {\n+        ngx_post_event(rev, &ngx_posted_events);\n+        return;\n+    }\n+\n+    rev->handler(rev);\n+}\n+\n+\n+static void\n+ngx_mail_init_session_handler(ngx_event_t *rev)\n+{\n+    ngx_connection_t    *c;\n+    ngx_mail_session_t  *s;\n+\n+    c = rev->data;\n+    s = c->data;\n+\n #if (NGX_MAIL_SSL)\n     {\n     ngx_mail_ssl_conf_t  *sslcf;\n \n     sslcf = ngx_mail_get_module_srv_conf(s, ngx_mail_ssl_module);\n \n-    if (sslcf->enable || addr_conf->ssl) {\n+    if (sslcf->enable || s->ssl) {\n         c->log->action = \"SSL handshaking\";\n \n         ngx_mail_ssl_init_connection(&sslcf->ssl, c);\n@@ -338,6 +365,8 @@ ngx_mail_init_session(ngx_connection_t *c)\n \n     s = c->data;\n \n+    c->log->action = \"sending client greeting line\";\n+\n     cscf = ngx_mail_get_module_srv_conf(s, ngx_mail_core_module);\n \n     s->protocol = cscf->protocol->type;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 79",
        "commit_diff": "Diff:\n@@ -722,11 +722,6 @@ ngx_mail_read_command(ngx_mail_session_t *s, ngx_connection_t *c)\n     }\n \n     if (n == NGX_AGAIN) {\n-        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-            ngx_mail_session_internal_server_error(s);\n-            return NGX_ERROR;\n-        }\n-\n         if (s->buffer->pos == s->buffer->last) {\n             return NGX_AGAIN;\n         }\nDiff:\n@@ -136,7 +136,16 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n \n     rc = ngx_mail_read_command(s, c);\n \n-    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+    if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n         return;\n     }\n \n@@ -299,6 +308,11 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n         }\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_session_internal_server_error(s);\n+        return;\n+    }\n+\n     ngx_mail_send(c->write);\n }\n \nDiff:\n@@ -151,7 +151,16 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n \n     rc = ngx_mail_read_command(s, c);\n \n-    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+    if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n         return;\n     }\n \n@@ -281,6 +290,11 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n             s->arg_start = s->buffer->start;\n         }\n \n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n         ngx_mail_send(c->write);\n     }\n }\nDiff:\n@@ -233,6 +233,11 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n     rc = ngx_mail_proxy_read_response(s, 0);\n \n     if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n         return;\n     }\n \n@@ -314,6 +319,11 @@ ngx_mail_proxy_pop3_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n     s->proxy->buffer->pos = s->proxy->buffer->start;\n     s->proxy->buffer->last = s->proxy->buffer->start;\n }\n@@ -346,6 +356,11 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n         return;\n     }\n \n@@ -448,6 +463,11 @@ ngx_mail_proxy_imap_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n     s->proxy->buffer->pos = s->proxy->buffer->start;\n     s->proxy->buffer->last = s->proxy->buffer->start;\n }\n@@ -482,6 +502,11 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n     rc = ngx_mail_proxy_read_response(s, s->mail_state);\n \n     if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n         return;\n     }\n \n@@ -763,6 +788,11 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+        ngx_mail_proxy_internal_server_error(s);\n+        return;\n+    }\n+\n     s->proxy->buffer->pos = s->proxy->buffer->start;\n     s->proxy->buffer->last = s->proxy->buffer->start;\n }\nDiff:\n@@ -462,7 +462,16 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n \n     rc = ngx_mail_read_command(s, c);\n \n-    if (rc == NGX_AGAIN || rc == NGX_ERROR) {\n+    if (rc == NGX_AGAIN) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n+        return;\n+    }\n+\n+    if (rc == NGX_ERROR) {\n         return;\n     }\n \n@@ -574,6 +583,11 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n             s->arg_start = s->buffer->pos;\n         }\n \n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_session_internal_server_error(s);\n+            return;\n+        }\n+\n         ngx_mail_send(c->write);\n     }\n }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 78",
        "commit_diff": "Diff:\n@@ -123,6 +123,12 @@ ngx_mail_imap_auth_state(ngx_event_t *rev)\n     if (s->out.len) {\n         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"imap send handler busy\");\n         s->blocked = 1;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n         return;\n     }\n \nDiff:\n@@ -138,6 +138,12 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n     if (s->out.len) {\n         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"pop3 send handler busy\");\n         s->blocked = 1;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n         return;\n     }\n \nDiff:\n@@ -449,6 +449,12 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n     if (s->out.len) {\n         ngx_log_debug0(NGX_LOG_DEBUG_MAIL, c->log, 0, \"smtp send handler busy\");\n         s->blocked = 1;\n+\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            ngx_mail_close_connection(c);\n+            return;\n+        }\n+\n         return;\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 77",
        "commit_diff": "Diff:\n@@ -318,7 +318,7 @@ ngx_handle_read_event(ngx_event_t *rev, ngx_uint_t flags)\n             return NGX_OK;\n         }\n \n-        if (rev->oneshot && !rev->ready) {\n+        if (rev->oneshot && rev->ready) {\n             if (ngx_del_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {\n                 return NGX_ERROR;\n             }\nDiff:\n@@ -4841,9 +4841,9 @@ ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -4913,9 +4913,9 @@ ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -1274,9 +1274,9 @@ ngx_http_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -2398,9 +2398,9 @@ ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -682,7 +682,7 @@ ngx_mail_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\nDiff:\n@@ -1026,9 +1026,9 @@ ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \nDiff:\n@@ -1061,9 +1061,9 @@ ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n {\n #ifndef SSL_CONF_FLAG_FILE\n     return \"is not supported on this platform\";\n-#endif\n-\n+#else\n     return NGX_CONF_OK;\n+#endif\n }\n \n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 76",
        "commit_diff": "Diff:\n@@ -727,17 +727,33 @@ ngx_feature_test=\"char buf[1]; struct iovec vec[1]; ssize_t n;\n . auto/feature\n \n \n-ngx_feature=\"sys_nerr\"\n-ngx_feature_name=\"NGX_SYS_NERR\"\n-ngx_feature_run=value\n-ngx_feature_incs='#include <errno.h>\n-                  #include <stdio.h>'\n+# strerrordesc_np(), introduced in glibc 2.32\n+\n+ngx_feature=\"strerrordesc_np()\"\n+ngx_feature_name=\"NGX_HAVE_STRERRORDESC_NP\"\n+ngx_feature_run=no\n+ngx_feature_incs='#include <string.h>'\n ngx_feature_path=\n ngx_feature_libs=\n-ngx_feature_test='printf(\"%d\", sys_nerr);'\n+ngx_feature_test=\"char *p; p = strerrordesc_np(0);\n+                  if (p == NULL) return 1\"\n . auto/feature\n \n \n+if [ $ngx_found = no ]; then\n+\n+    ngx_feature=\"sys_nerr\"\n+    ngx_feature_name=\"NGX_SYS_NERR\"\n+    ngx_feature_run=value\n+    ngx_feature_incs='#include <errno.h>\n+                      #include <stdio.h>'\n+    ngx_feature_path=\n+    ngx_feature_libs=\n+    ngx_feature_test='printf(\"%d\", sys_nerr);'\n+    . auto/feature\n+fi\n+\n+\n if [ $ngx_found = no ]; then\n \n     # Cygiwn defines _sys_nerr\nDiff:\n@@ -56,7 +56,7 @@ typedef struct {\n #endif\n     } cookie;\n \n-    ngx_uint_t                     flags;\n+    ngx_array_t                    flags_values;\n     ngx_uint_t                     regex;\n } ngx_http_proxy_cookie_flags_t;\n \n@@ -2916,12 +2916,14 @@ static ngx_int_t\n ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n     ngx_array_t *flags)\n {\n-    ngx_str_t                       pattern;\n+    ngx_str_t                       pattern, value;\n #if (NGX_PCRE)\n     ngx_int_t                       rc;\n #endif\n-    ngx_uint_t                      i;\n+    ngx_uint_t                      i, m, f, nelts;\n     ngx_keyval_t                   *attr;\n+    ngx_conf_bitmask_t             *mask;\n+    ngx_http_complex_value_t       *flags_values;\n     ngx_http_proxy_cookie_flags_t  *pcf;\n \n     attr = attrs->elts;\n@@ -2965,7 +2967,47 @@ ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n         return NGX_DECLINED;\n     }\n \n-    return ngx_http_proxy_edit_cookie_flags(r, attrs, pcf[i].flags);\n+    nelts = pcf[i].flags_values.nelts;\n+    flags_values = pcf[i].flags_values.elts;\n+\n+    mask = ngx_http_proxy_cookie_flags_masks;\n+    f = 0;\n+\n+    for (i = 0; i < nelts; i++) {\n+\n+        if (ngx_http_complex_value(r, &flags_values[i], &value) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (value.len == 0) {\n+            continue;\n+        }\n+\n+        for (m = 0; mask[m].name.len != 0; m++) {\n+\n+            if (mask[m].name.len != value.len\n+                || ngx_strncasecmp(mask[m].name.data, value.data, value.len)\n+                   != 0)\n+            {\n+                continue;\n+            }\n+\n+            f |= mask[m].mask;\n+\n+            break;\n+        }\n+\n+        if (mask[m].name.len == 0) {\n+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                           \"invalid proxy_cookie_flags flag \\\"%V\\\"\", &value);\n+        }\n+    }\n+\n+    if (f == 0) {\n+        return NGX_DECLINED;\n+    }\n+\n+    return ngx_http_proxy_edit_cookie_flags(r, attrs, f);\n }\n \n \n@@ -4514,8 +4556,8 @@ ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_proxy_loc_conf_t *plcf = conf;\n \n     ngx_str_t                         *value;\n-    ngx_uint_t                         i, m;\n-    ngx_conf_bitmask_t                *mask;\n+    ngx_uint_t                         i;\n+    ngx_http_complex_value_t          *cv;\n     ngx_http_proxy_cookie_flags_t     *pcf;\n     ngx_http_compile_complex_value_t   ccv;\n #if (NGX_PCRE)\n@@ -4599,32 +4641,27 @@ ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         }\n     }\n \n-    mask = ngx_http_proxy_cookie_flags_masks;\n-    pcf->flags = 0;\n+    if (ngx_array_init(&pcf->flags_values, cf->pool, cf->args->nelts - 2,\n+                       sizeof(ngx_http_complex_value_t))\n+        != NGX_OK)\n+    {\n+        return NGX_CONF_ERROR;\n+    }\n \n     for (i = 2; i < cf->args->nelts; i++) {\n-        for (m = 0; mask[m].name.len != 0; m++) {\n-\n-            if (mask[m].name.len != value[i].len\n-                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)\n-            {\n-                continue;\n-            }\n \n-            if (pcf->flags & mask[m].mask) {\n-                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n-                                   \"duplicate parameter \\\"%V\\\"\", &value[i]);\n-                return NGX_CONF_ERROR;\n-            }\n+        cv = ngx_array_push(&pcf->flags_values);\n+        if (cv == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n \n-            pcf->flags |= mask[m].mask;\n+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n \n-            break;\n-        }\n+        ccv.cf = cf;\n+        ccv.value = &value[i];\n+        ccv.complex_value = cv;\n \n-        if (mask[m].name.len == 0) {\n-            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n-                               \"invalid parameter \\\"%V\\\"\", &value[i]);\n+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n             return NGX_CONF_ERROR;\n         }\n     }\nDiff:\n@@ -9,6 +9,49 @@\n #include <ngx_core.h>\n \n \n+static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n+\n+\n+#if (NGX_HAVE_STRERRORDESC_NP)\n+\n+/*\n+ * The strerrordesc_np() function, introduced in glibc 2.32, is\n+ * async-signal-safe.  This makes it possible to use it directly,\n+ * without copying error messages.\n+ */\n+\n+\n+u_char *\n+ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n+{\n+    size_t       len;\n+    const char  *msg;\n+\n+    msg = strerrordesc_np(err);\n+\n+    if (msg == NULL) {\n+        msg = (char *) ngx_unknown_error.data;\n+        len = ngx_unknown_error.len;\n+\n+    } else {\n+        len = ngx_strlen(msg);\n+    }\n+\n+    size = ngx_min(size, len);\n+\n+    return ngx_cpymem(errstr, msg, size);\n+}\n+\n+\n+ngx_int_t\n+ngx_strerror_init(void)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+#else\n+\n /*\n  * The strerror() messages are copied because:\n  *\n@@ -26,7 +69,6 @@\n \n \n static ngx_str_t  *ngx_sys_errlist;\n-static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n static ngx_err_t   ngx_first_error;\n static ngx_err_t   ngx_last_error;\n \n@@ -164,3 +206,5 @@ ngx_strerror_init(void)\n \n     return NGX_ERROR;\n }\n+\n+#endif\n",
        "analysis": "Let's analyze the newly added entire functions in the provided diff:\n\n1. **`ngx_strerror` function:**\n\n```c\nu_char *\nngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n{\n    size_t       len;\n    const char  *msg;\n\n    msg = strerrordesc_np(err);\n\n    if (msg == NULL) {\n        msg = (char *) ngx_unknown_error.data;\n        len = ngx_unknown_error.len;\n\n    } else {\n        len = ngx_strlen(msg);\n    }\n\n    size = ngx_min(size, len);\n\n    return ngx_cpymem(errstr, msg, size);\n}\n```\n\n- **Lines 7-8:** The function attempts to retrieve an error message description using the `strerrordesc_np` function.\n- **Line 10:** Checks if the message is `NULL` and assigns `ngx_unknown_error` if it is.\n- **Line 17:** Calculates the length of the message.\n- **Line 20:** Adjusts the size to be the minimum of the provided `size` and the message length.\n- **Line 22:** Copies the message to the provided buffer using `ngx_cpymem`.\n\nGiven this code, there's potential for concern in terms of out-of-bounds write if the size of `errstr` is not managed outside this function to a size that accommodates the \"safe\" value calculated (`size = ngx_min(size, len);`). However, based on the displayed logic, the size should allow it to safely copy the message without exceeding buffer limits.\n\n2. **`ngx_strerror_init` function:**\n\n```c\nngx_int_t\nngx_strerror_init(void)\n{\n    return NGX_OK;\n}\n```\n\n- This function initializes some settings and returns `NGX_OK`. It does not perform any operations involving memory buffers, so there’s no risk of out-of-bounds write here.\n\nThe primary function of interest is `ngx_strerror`. The safety of transferring messages is largely upheld by using size constraints with `ngx_min`. However, without knowing the context or constraints on `errstr` and its allocated size, it's not definitive that there is an out-of-bounds write, but monitoring or additional context regarding buffer sizes could be appropriate.\n\nConclusion of the analysis indicates potential concerns are minimal, but the function `ngx_strerror` requires careful size management:\n\n```plaintext\nTRUE [ngx_strerror]\n```"
    },
    {
        "commit_index": "Commit 75",
        "commit_diff": "Diff:\n@@ -753,34 +753,6 @@ if [ $ngx_found = no ]; then\n fi\n \n \n-if [ $ngx_found = no ]; then\n-\n-    # Solaris has no sys_nerr\n-    ngx_feature='maximum errno'\n-    ngx_feature_name=NGX_SYS_NERR\n-    ngx_feature_run=value\n-    ngx_feature_incs='#include <errno.h>\n-                      #include <string.h>\n-                      #include <stdio.h>'\n-    ngx_feature_path=\n-    ngx_feature_libs=\n-    ngx_feature_test='int  n;\n-                      char *p;\n-                      for (n = 1; n < 1000; n++) {\n-                          errno = 0;\n-                          p = strerror(n);\n-                          if (errno == EINVAL\n-                              || p == NULL\n-                              || strncmp(p, \"Unknown error\", 13) == 0)\n-                          {\n-                              break;\n-                          }\n-                      }\n-                      printf(\"%d\", n);'\n-    . auto/feature\n-fi\n-\n-\n ngx_feature=\"localtime_r()\"\n ngx_feature_name=\"NGX_HAVE_LOCALTIME_R\"\n ngx_feature_run=no\nDiff:\n@@ -25,6 +25,7 @@ struct ngx_buf_s {\n \n     u_char          *start;         /* start of buffer */\n     u_char          *end;           /* end of buffer */\n+    ngx_int_t        rev;\n     ngx_buf_tag_t    tag;\n     ngx_file_t      *file;\n     ngx_buf_t       *shadow;\nDiff:\n@@ -647,6 +647,7 @@ ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx)\n             return NGX_ERROR;\n         }\n \n+        dst->rev = src->rev;\n         dst->last += n;\n \n         if (sendfile) {\nDiff:\n@@ -48,6 +48,7 @@\n typedef struct {\n     off_t        start;\n     off_t        end;\n+    ngx_int_t    rev;\n     ngx_str_t    content_range;\n } ngx_http_range_t;\n \n@@ -274,6 +275,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n                                   cutlim;\n     ngx_uint_t                    suffix;\n     ngx_http_range_t             *range;\n+    ngx_uint_t                    rev;\n     ngx_http_range_filter_ctx_t  *mctx;\n \n     if (r != r->main) {\n@@ -293,6 +295,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n \n     p = r->headers_in.range->value.data + 6;\n     size = 0;\n+    rev = 0;\n     content_length = r->headers_out.content_length_n;\n \n     cutoff = NGX_MAX_OFF_T_VALUE / 10;\n@@ -332,8 +335,22 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n             }\n \n         } else {\n-            suffix = 1;\n             p++;\n+            if (*p == 'r') {\n+                p++;\n+                while (*p == ' ') { p++; }\n+\n+                if (*p++ != ',') {\n+                    return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n+                }\n+\n+                while (*p == ' ') { p++; }\n+\n+                rev = 1;\n+                continue;\n+            } else {\n+                suffix = 1;\n+            }\n         }\n \n         if (*p < '0' || *p > '9') {\n@@ -376,6 +393,8 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n \n             range->start = start;\n             range->end = end;\n+            range->rev = rev;\n+            rev = 0;\n \n             if (size > NGX_MAX_OFF_T_VALUE - (end - start)) {\n                 return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n@@ -721,6 +740,8 @@ ngx_http_range_singlepart_body(ngx_http_request_t *r,\n         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"http range body buf: %O-%O\", start, last);\n \n+        buf->rev = range->rev;\n+\n         if (ngx_buf_special(buf)) {\n \n             if (range->end <= start) {\n@@ -889,6 +910,7 @@ ngx_http_range_multipart_body(ngx_http_request_t *r,\n         b->memory = buf->memory;\n         b->mmap = buf->mmap;\n         b->file = buf->file;\n+        b->rev = range[i].rev;\n \n         if (buf->in_file) {\n             b->file_pos = buf->file_pos + range[i].start;\nDiff:\n@@ -27,15 +27,22 @@\n \n static ngx_str_t  *ngx_sys_errlist;\n static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n+static ngx_err_t   ngx_first_error;\n+static ngx_err_t   ngx_last_error;\n \n \n u_char *\n ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n {\n     ngx_str_t  *msg;\n \n-    msg = ((ngx_uint_t) err < NGX_SYS_NERR) ? &ngx_sys_errlist[err]:\n-                                              &ngx_unknown_error;\n+    if (err >= ngx_first_error && err < ngx_last_error) {\n+        msg = &ngx_sys_errlist[err - ngx_first_error];\n+\n+    } else {\n+        msg = &ngx_unknown_error;\n+    }\n+\n     size = ngx_min(size, msg->len);\n \n     return ngx_cpymem(errstr, msg->data, size);\n@@ -50,20 +57,92 @@ ngx_strerror_init(void)\n     size_t      len;\n     ngx_err_t   err;\n \n+#if (NGX_SYS_NERR)\n+    ngx_first_error = 0;\n+    ngx_last_error = NGX_SYS_NERR;\n+\n+#elif (EPERM > 1000 && EPERM < 0x7fffffff - 1000)\n+\n+    /*\n+     * If number of errors is not known, and EPERM error code has large\n+     * but reasonable value, guess possible error codes based on the error\n+     * messages returned by strerror(), starting from EPERM.  Notably,\n+     * this covers GNU/Hurd, where errors start at 0x40000001.\n+     */\n+\n+    for (err = EPERM; err > EPERM - 1000; err--) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_first_error = err;\n+    }\n+\n+    for (err = EPERM; err < EPERM + 1000; err++) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_last_error = err + 1;\n+    }\n+\n+#else\n+\n+    /*\n+     * If number of errors is not known, guess it based on the error\n+     * messages returned by strerror().\n+     */\n+\n+    ngx_first_error = 0;\n+\n+    for (err = 0; err < 1000; err++) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_last_error = err + 1;\n+    }\n+\n+#endif\n+\n     /*\n      * ngx_strerror() is not ready to work at this stage, therefore,\n      * malloc() is used and possible errors are logged using strerror().\n      */\n \n-    len = NGX_SYS_NERR * sizeof(ngx_str_t);\n+    len = (ngx_last_error - ngx_first_error) * sizeof(ngx_str_t);\n \n     ngx_sys_errlist = malloc(len);\n     if (ngx_sys_errlist == NULL) {\n         goto failed;\n     }\n \n-    for (err = 0; err < NGX_SYS_NERR; err++) {\n+    for (err = ngx_first_error; err < ngx_last_error; err++) {\n         msg = strerror(err);\n+\n+        if (msg == NULL) {\n+            ngx_sys_errlist[err - ngx_first_error] = ngx_unknown_error;\n+            continue;\n+        }\n+\n         len = ngx_strlen(msg);\n \n         p = malloc(len);\n@@ -72,8 +151,8 @@ ngx_strerror_init(void)\n         }\n \n         ngx_memcpy(p, msg, len);\n-        ngx_sys_errlist[err].len = len;\n-        ngx_sys_errlist[err].data = p;\n+        ngx_sys_errlist[err - ngx_first_error].len = len;\n+        ngx_sys_errlist[err - ngx_first_error].data = p;\n     }\n \n     return NGX_OK;\nDiff:\n@@ -41,6 +41,49 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\n  */\n \n #define NGX_SENDFILE_MAXSIZE  2147483647L\n+#define NGX_SENDFILE_R_MAXSIZE  100L\n+\n+ssize_t\n+ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+    struct stat sb;\n+    u_char *buf;\n+    u_char *rev;\n+    ssize_t n;\n+\n+    if (fstat(file->file->fd, &sb) != 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    buf = ngx_palloc(c->pool, ngx_file_size(&sb));\n+\n+    if (buf == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (read( file->file->fd, buf, ngx_file_size(&sb)) == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    lseek(file->file->fd, 0, SEEK_SET);\n+\n+    rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);\n+\n+    if ( rev == NULL ) {\n+        return NGX_ERROR;\n+    }\n+\n+    for ( int i = file->file_pos + size - 1, j = 0; i >= file->file_pos; i--, j++) {\n+        rev[j] = buf[i];\n+    }\n+\n+    n = c->send(c, rev, size);\n+\n+    ngx_pfree(c->pool, buf);\n+    ngx_free(rev);\n+\n+    return n;\n+}\n \n \n ngx_chain_t *\n@@ -256,7 +299,11 @@ ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"sendfile: @%O %uz\", file->file_pos, size);\n \n-    n = sendfile(c->fd, file->file->fd, &offset, size);\n+    if (file->rev) {\n+        n = ngx_sendfile_r(c, file, size);\n+    } else {\n+        n = sendfile(c->fd, file->file->fd, &offset, size);\n+    }\n \n     if (n == -1) {\n         err = ngx_errno;\nDiff:\n@@ -149,6 +149,14 @@ ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,\n \n         size = in->buf->last - in->buf->pos;\n \n+        if (in->buf->rev) {\n+            for (int i = 0, j = size - 1; i < j; i++, j--) {\n+                u_char c = in->buf->start[i];\n+                in->buf->start[i] = in->buf->start[j];\n+                in->buf->start[j] = c;\n+            }\n+        }\n+\n         if (size > limit - total) {\n             size = limit - total;\n         }\n",
        "analysis": "Analyzing the diffs for newly added entire functions:\n\n1. **Function: `ngx_sendfile_r`**\n   ```c\n   ssize_t ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size) {\n       struct stat sb;\n       u_char *buf;\n       u_char *rev;\n       ssize_t n;\n\n       if (fstat(file->file->fd, &sb) != 0) {\n           return NGX_ERROR;\n       }\n\n       buf = ngx_palloc(c->pool, ngx_file_size(&sb));\n\n       if (buf == NULL) {\n           return NGX_ERROR;\n       }\n\n       if (read( file->file->fd, buf, ngx_file_size(&sb)) == NGX_ERROR) {\n           return NGX_ERROR;\n       }\n\n       lseek(file->file->fd, 0, SEEK_SET);\n\n       rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);\n\n       if ( rev == NULL ) {\n           return NGX_ERROR;\n       }\n\n       for ( int i = file->file_pos + size - 1, j = 0; i >= file->file_pos; i--, j++) {\n           rev[j] = buf[i];\n       }\n\n       n = c->send(c, rev, size);\n\n       ngx_pfree(c->pool, buf);\n       ngx_free(rev);\n\n       return n;\n   }\n   ```\n\n   - **Analysis:**\n     - On line where `rev[j] = buf[i];` is executed, there is a potential risk of out-of-bounds write since the function calculates indices `i` and `j` based on user-provided parameters (`file_pos` and `size`). \n     - `rev` is allocated with a fixed size of `NGX_SENDFILE_R_MAXSIZE`. If `size` exceeds this constant value, there is a potential for buffer overflow in `rev`. \n\nGiven the careful examination of the newly added entire function, there is a possibility of out-of-bounds write in `ngx_sendfile_r`.\n\n**Summary:**\n\nTRUE [ngx_sendfile_r]"
    },
    {
        "commit_index": "Commit 74",
        "commit_diff": "Diff:\n@@ -2414,26 +2414,26 @@ syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n \n \" highlight\n \n-hi link ngxComment Comment\n-hi link ngxParamComment Comment\n-hi link ngxListenComment Comment\n-hi link ngxVariable Identifier\n-hi link ngxVariableString PreProc\n-hi link ngxString String\n-hi link ngxListenString String\n-\n-hi link ngxBoolean Boolean\n-hi link ngxDirectiveBlock Statement\n-hi link ngxDirectiveImportant Type\n-hi link ngxDirectiveListen Type\n-hi link ngxDirectiveControl Keyword\n-hi link ngxDirectiveError Constant\n-hi link ngxDirectiveDeprecated Error\n-hi link ngxDirective Identifier\n-hi link ngxDirectiveThirdParty Special\n-hi link ngxDirectiveThirdPartyDeprecated Error\n-\n-hi link ngxListenOptions Keyword\n-hi link ngxListenOptionsDeprecated Error\n+hi def link ngxComment Comment\n+hi def link ngxParamComment Comment\n+hi def link ngxListenComment Comment\n+hi def link ngxVariable Identifier\n+hi def link ngxVariableString PreProc\n+hi def link ngxString String\n+hi def link ngxListenString String\n+\n+hi def link ngxBoolean Boolean\n+hi def link ngxDirectiveBlock Statement\n+hi def link ngxDirectiveImportant Type\n+hi def link ngxDirectiveListen Type\n+hi def link ngxDirectiveControl Keyword\n+hi def link ngxDirectiveError Constant\n+hi def link ngxDirectiveDeprecated Error\n+hi def link ngxDirective Identifier\n+hi def link ngxDirectiveThirdParty Special\n+hi def link ngxDirectiveThirdPartyDeprecated Error\n+\n+hi def link ngxListenOptions Keyword\n+hi def link ngxListenOptionsDeprecated Error\n \n let b:current_syntax = \"nginx\"\nDiff:\n@@ -1014,6 +1014,10 @@ ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store)\n \n     c = ngx_ssl_get_connection(ssl_conn);\n \n+    if (!(c->log->log_level & NGX_LOG_DEBUG_EVENT)) {\n+        return 1;\n+    }\n+\n     cert = X509_STORE_CTX_get_current_cert(x509_store);\n     err = X509_STORE_CTX_get_error(x509_store);\n     depth = X509_STORE_CTX_get_error_depth(x509_store);\n@@ -1970,6 +1974,10 @@ ngx_ssl_handshake_log(ngx_connection_t *c)\n #endif\n     SSL_CIPHER  *cipher;\n \n+    if (!(c->log->log_level & NGX_LOG_DEBUG_EVENT)) {\n+        return;\n+    }\n+\n     cipher = SSL_get_current_cipher(c->ssl->connection);\n \n     if (cipher) {\nDiff:\n@@ -238,6 +238,7 @@ ngx_http_v2_init(ngx_event_t *rev)\n     ngx_http_v2_srv_conf_t    *h2scf;\n     ngx_http_v2_main_conf_t   *h2mcf;\n     ngx_http_v2_connection_t  *h2c;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     c = rev->data;\n     hc = c->data;\n@@ -325,8 +326,10 @@ ngx_http_v2_init(ngx_event_t *rev)\n     rev->handler = ngx_http_v2_read_handler;\n     c->write->handler = ngx_http_v2_write_handler;\n \n-    if (c->read->timer_set) {\n-        ngx_del_timer(c->read);\n+    if (!rev->timer_set) {\n+        cscf = ngx_http_get_module_srv_conf(hc->conf_ctx,\n+                                            ngx_http_core_module);\n+        ngx_add_timer(rev, cscf->client_header_timeout);\n     }\n \n     c->idle = 1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 73",
        "commit_diff": "Diff:\n@@ -48,4 +48,6 @@ default:\tbuild\n \n clean:\n \trm -rf Makefile $NGX_OBJS\n+\n+.PHONY:\tdefault clean\n END\nDiff:\n@@ -215,4 +215,6 @@ upgrade:\n \ttest -f $NGX_PID_PATH.oldbin\n \n \tkill -QUIT \\`cat $NGX_PID_PATH.oldbin\\`\n+\n+.PHONY:\tbuild install modules upgrade\n END\nDiff:\n@@ -83,7 +83,7 @@ static time_t ngx_ssl_parse_time(\n #if OPENSSL_VERSION_NUMBER > 0x10100000L\n     const\n #endif\n-    ASN1_TIME *asn1time);\n+    ASN1_TIME *asn1time, ngx_log_t *log);\n \n static void *ngx_openssl_create_conf(ngx_cycle_t *cycle);\n static char *ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n@@ -1019,21 +1019,43 @@ ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store)\n     depth = X509_STORE_CTX_get_error_depth(x509_store);\n \n     sname = X509_get_subject_name(cert);\n-    subject = sname ? X509_NAME_oneline(sname, NULL, 0) : \"(none)\";\n+\n+    if (sname) {\n+        subject = X509_NAME_oneline(sname, NULL, 0);\n+        if (subject == NULL) {\n+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"X509_NAME_oneline() failed\");\n+        }\n+\n+    } else {\n+        subject = NULL;\n+    }\n \n     iname = X509_get_issuer_name(cert);\n-    issuer = iname ? X509_NAME_oneline(iname, NULL, 0) : \"(none)\";\n+\n+    if (iname) {\n+        issuer = X509_NAME_oneline(iname, NULL, 0);\n+        if (issuer == NULL) {\n+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,\n+                          \"X509_NAME_oneline() failed\");\n+        }\n+\n+    } else {\n+        issuer = NULL;\n+    }\n \n     ngx_log_debug5(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"verify:%d, error:%d, depth:%d, \"\n                    \"subject:\\\"%s\\\", issuer:\\\"%s\\\"\",\n-                   ok, err, depth, subject, issuer);\n+                   ok, err, depth,\n+                   subject ? subject : \"(none)\",\n+                   issuer ? issuer : \"(none)\");\n \n-    if (sname) {\n+    if (subject) {\n         OPENSSL_free(subject);\n     }\n \n-    if (iname) {\n+    if (issuer) {\n         OPENSSL_free(issuer);\n     }\n #endif\n@@ -4795,11 +4817,13 @@ ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n \n     if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_print_ex() failed\");\n         goto failed;\n     }\n \n@@ -4847,11 +4871,13 @@ ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n \n     if (X509_NAME_print_ex(bio, name, 0, XN_FLAG_RFC2253) < 0) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_print_ex() failed\");\n         goto failed;\n     }\n \n@@ -4900,6 +4926,11 @@ ngx_ssl_get_subject_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,\n     }\n \n     p = X509_NAME_oneline(name, NULL, 0);\n+    if (p == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_oneline() failed\");\n+        X509_free(cert);\n+        return NGX_ERROR;\n+    }\n \n     for (len = 0; p[len]; len++) { /* void */ }\n \n@@ -4943,6 +4974,11 @@ ngx_ssl_get_issuer_dn_legacy(ngx_connection_t *c, ngx_pool_t *pool,\n     }\n \n     p = X509_NAME_oneline(name, NULL, 0);\n+    if (p == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_NAME_oneline() failed\");\n+        X509_free(cert);\n+        return NGX_ERROR;\n+    }\n \n     for (len = 0; p[len]; len++) { /* void */ }\n \n@@ -4979,6 +5015,7 @@ ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5017,6 +5054,7 @@ ngx_ssl_get_fingerprint(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n     }\n \n     if (!X509_digest(cert, EVP_sha1(), buf, &len)) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"X509_digest() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5090,6 +5128,7 @@ ngx_ssl_get_client_v_start(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5134,6 +5173,7 @@ ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, \"BIO_new() failed\");\n         X509_free(cert);\n         return NGX_ERROR;\n     }\n@@ -5176,9 +5216,9 @@ ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n     }\n \n #if OPENSSL_VERSION_NUMBER > 0x10100000L\n-    end = ngx_ssl_parse_time(X509_get0_notAfter(cert));\n+    end = ngx_ssl_parse_time(X509_get0_notAfter(cert), c->log);\n #else\n-    end = ngx_ssl_parse_time(X509_get_notAfter(cert));\n+    end = ngx_ssl_parse_time(X509_get_notAfter(cert), c->log);\n #endif\n \n     if (end == (time_t) NGX_ERROR) {\n@@ -5213,7 +5253,7 @@ ngx_ssl_parse_time(\n #if OPENSSL_VERSION_NUMBER > 0x10100000L\n     const\n #endif\n-    ASN1_TIME *asn1time)\n+    ASN1_TIME *asn1time, ngx_log_t *log)\n {\n     BIO     *bio;\n     char    *value;\n@@ -5229,6 +5269,7 @@ ngx_ssl_parse_time(\n \n     bio = BIO_new(BIO_s_mem());\n     if (bio == NULL) {\n+        ngx_ssl_error(NGX_LOG_ALERT, log, 0, \"BIO_new() failed\");\n         return NGX_ERROR;\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 72",
        "commit_diff": "Diff:\n@@ -456,3 +456,4 @@ a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n 8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\n f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n+3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\nDiff:\n@@ -5,6 +5,92 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.7\" date=\"2021-02-16\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+обработка соединений в HTTP/2 была изменена\n+и теперь более соответствует HTTP/1.x;\n+директивы http2_recv_timeout, http2_idle_timeout\n+и http2_max_requests упразднены,\n+вместо них следует использовать директивы\n+keepalive_timeout и keepalive_requests.\n+</para>\n+<para lang=\"en\">\n+connections handling in HTTP/2 has been changed\n+to better match HTTP/1.x;\n+the \"http2_recv_timeout\", \"http2_idle_timeout\",\n+and \"http2_max_requests\" directives have been removed,\n+the \"keepalive_timeout\" and \"keepalive_requests\" directives\n+should be used instead.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+директивы http2_max_field_size и http2_max_header_size упразднены,\n+вместо них следует использовать директиву large_client_header_buffers.\n+</para>\n+<para lang=\"en\">\n+the \"http2_max_field_size\" and \"http2_max_header_size\" directives\n+have been removed,\n+the \"large_client_header_buffers\" directive should be used instead.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь при исчерпании свободных соединений\n+nginx закрывает не только keepalive-соединения,\n+но и соединения в lingering close.\n+</para>\n+<para lang=\"en\">\n+now, if free worker connections are exhausted,\n+nginx starts closing not only keepalive connections,\n+but also connections in lingering close.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения \"zero size buf in output\",\n+если бэкенд возвращал некорректный ответ\n+при небуферизированном проксировании;\n+ошибка появилась в 1.19.1.\n+</para>\n+<para lang=\"en\">\n+\"zero size buf in output\" alerts might appear in logs\n+if an upstream server returned an incorrect response\n+during unbuffered proxying;\n+the bug had appeared in 1.19.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании директивы return\n+вместе с image_filter или xslt_stylesheet\n+HEAD-запросы обрабатывались некорректно.\n+</para>\n+<para lang=\"en\">\n+HEAD requests were handled incorrectly\n+if the \"return\" directive was used\n+with the \"image_filter\" or \"xslt_stylesheet\" directives.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве add_trailer.\n+</para>\n+<para lang=\"en\">\n+in the \"add_trailer\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.6\" date=\"2020-12-15\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019007\n-#define NGINX_VERSION      \"1.19.7\"\n+#define nginx_version      1019008\n+#define NGINX_VERSION      \"1.19.8\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 71",
        "commit_diff": "Diff:\n@@ -1198,6 +1198,7 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n     ngx_http_v2_node_t        *node;\n     ngx_http_v2_stream_t      *stream;\n     ngx_http_v2_srv_conf_t    *h2scf;\n+    ngx_http_core_srv_conf_t  *cscf;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG;\n@@ -1299,11 +1300,15 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n     }\n \n+    cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    h2c->state.header_limit = cscf->large_client_header_buffers.size\n+                              * cscf->large_client_header_buffers.num;\n+\n     h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n                                          ngx_http_v2_module);\n \n-    h2c->state.header_limit = h2scf->max_header_size;\n-\n     if (h2c->processing >= h2scf->concurrent_streams) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                       \"concurrent streams exceeded %ui\", h2c->processing);\n@@ -1485,10 +1490,10 @@ static u_char *\n ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   alloc;\n-    ngx_int_t                len;\n-    ngx_uint_t               huff;\n-    ngx_http_v2_srv_conf_t  *h2scf;\n+    size_t                     alloc;\n+    ngx_int_t                  len;\n+    ngx_uint_t                 huff;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)\n         && h2c->state.length < NGX_HTTP_V2_INT_OCTETS)\n@@ -1535,12 +1540,12 @@ ngx_http_v2_state_field_len(ngx_http_v2_connection_t *h2c, u_char *pos,\n                    \"http2 %s string, len:%i\",\n                    huff ? \"encoded\" : \"raw\", len);\n \n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n+    cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n \n-    if ((size_t) len > h2scf->max_field_size) {\n+    if ((size_t) len > cscf->large_client_header_buffers.size) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n-                      \"client exceeded http2_max_field_size limit\");\n+                      \"client sent too large header field\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n     }\n@@ -1755,7 +1760,7 @@ ngx_http_v2_state_process_header(ngx_http_v2_connection_t *h2c, u_char *pos,\n \n     if (len > h2c->state.header_limit) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n-                      \"client exceeded http2_max_header_size limit\");\n+                      \"client sent too large header\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n     }\nDiff:\n@@ -52,6 +52,14 @@ static ngx_conf_deprecated_t  ngx_http_v2_max_requests_deprecated = {\n     ngx_conf_deprecated, \"http2_max_requests\", \"keepalive_requests\"\n };\n \n+static ngx_conf_deprecated_t  ngx_http_v2_max_field_size_deprecated = {\n+    ngx_conf_deprecated, \"http2_max_field_size\", \"large_client_header_buffers\"\n+};\n+\n+static ngx_conf_deprecated_t  ngx_http_v2_max_header_size_deprecated = {\n+    ngx_conf_deprecated, \"http2_max_header_size\", \"large_client_header_buffers\"\n+};\n+\n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n     { ngx_http_v2_recv_buffer_size };\n@@ -104,17 +112,17 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_max_field_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_size_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, max_field_size),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_max_field_size_deprecated },\n \n     { ngx_string(\"http2_max_header_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_size_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, max_header_size),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_max_header_size_deprecated },\n \n     { ngx_string(\"http2_body_preread_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n@@ -311,9 +319,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n     h2scf->concurrent_streams = NGX_CONF_UNSET_UINT;\n     h2scf->concurrent_pushes = NGX_CONF_UNSET_UINT;\n \n-    h2scf->max_field_size = NGX_CONF_UNSET_SIZE;\n-    h2scf->max_header_size = NGX_CONF_UNSET_SIZE;\n-\n     h2scf->preread_size = NGX_CONF_UNSET_SIZE;\n \n     h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;\n@@ -335,11 +340,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->concurrent_pushes,\n                               prev->concurrent_pushes, 10);\n \n-    ngx_conf_merge_size_value(conf->max_field_size, prev->max_field_size,\n-                              4096);\n-    ngx_conf_merge_size_value(conf->max_header_size, prev->max_header_size,\n-                              16384);\n-\n     ngx_conf_merge_size_value(conf->preread_size, prev->preread_size, 65536);\n \n     ngx_conf_merge_uint_value(conf->streams_index_mask,\nDiff:\n@@ -24,8 +24,6 @@ typedef struct {\n     size_t                          pool_size;\n     ngx_uint_t                      concurrent_streams;\n     ngx_uint_t                      concurrent_pushes;\n-    size_t                          max_field_size;\n-    size_t                          max_header_size;\n     size_t                          preread_size;\n     ngx_uint_t                      streams_index_mask;\n } ngx_http_v2_srv_conf_t;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 70",
        "commit_diff": "Diff:\n@@ -325,6 +325,10 @@ ngx_http_v2_init(ngx_event_t *rev)\n     rev->handler = ngx_http_v2_read_handler;\n     c->write->handler = ngx_http_v2_write_handler;\n \n+    if (c->read->timer_set) {\n+        ngx_del_timer(c->read);\n+    }\n+\n     c->idle = 1;\n     ngx_reusable_connection(c, 0);\n \n@@ -455,14 +459,6 @@ ngx_http_v2_read_handler(ngx_event_t *rev)\n \n     h2c->blocked = 0;\n \n-    if (h2c->processing || h2c->pushing) {\n-        if (rev->timer_set) {\n-            ngx_del_timer(rev);\n-        }\n-\n-        return;\n-    }\n-\n     ngx_http_v2_handle_connection(h2c);\n }\n \n@@ -637,8 +633,7 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n {\n     ngx_int_t                  rc;\n     ngx_connection_t          *c;\n-    ngx_http_v2_srv_conf_t    *h2scf;\n-    ngx_http_core_srv_conf_t  *cscf;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     if (h2c->last_out || h2c->processing || h2c->pushing) {\n         return;\n@@ -675,15 +670,16 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    if (!c->read->timer_set) {\n+        ngx_add_timer(c->read, clcf->keepalive_timeout);\n+    }\n+\n     ngx_reusable_connection(c, 1);\n \n     if (h2c->state.incomplete) {\n-        if (!c->read->timer_set) {\n-            cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                                ngx_http_core_module);\n-            ngx_add_timer(c->read, cscf->client_header_timeout);\n-        }\n-\n         return;\n     }\n \n@@ -708,11 +704,6 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n     if (c->write->timer_set) {\n         ngx_del_timer(c->write);\n     }\n-\n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n-\n-    ngx_add_timer(c->read, h2scf->idle_timeout);\n }\n \n \n@@ -1200,12 +1191,14 @@ static u_char *\n ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n-    size_t                   size;\n-    ngx_uint_t               padded, priority, depend, dependency, excl, weight;\n-    ngx_uint_t               status;\n-    ngx_http_v2_node_t      *node;\n-    ngx_http_v2_stream_t    *stream;\n-    ngx_http_v2_srv_conf_t  *h2scf;\n+    size_t                     size;\n+    ngx_uint_t                 padded, priority, depend, dependency, excl,\n+                               weight;\n+    ngx_uint_t                 status;\n+    ngx_http_v2_node_t        *node;\n+    ngx_http_v2_stream_t      *stream;\n+    ngx_http_v2_srv_conf_t    *h2scf;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG;\n     priority = h2c->state.flags & NGX_HTTP_V2_PRIORITY_FLAG;\n@@ -1364,7 +1357,10 @@ ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos,\n         ngx_http_v2_set_dependency(h2c, node, depend, excl);\n     }\n \n-    if (h2c->connection->requests >= h2scf->max_requests) {\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    if (h2c->connection->requests >= clcf->keepalive_requests) {\n         h2c->goaway = 1;\n \n         if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n@@ -3293,6 +3289,10 @@ ngx_http_v2_create_stream(ngx_http_v2_connection_t *h2c, ngx_uint_t push)\n \n     h2c->priority_limit += h2scf->concurrent_streams;\n \n+    if (h2c->connection->read->timer_set) {\n+        ngx_del_timer(h2c->connection->read);\n+    }\n+\n     return stream;\n }\n \n@@ -4659,6 +4659,7 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n     ngx_connection_t          *c;\n     ngx_http_v2_srv_conf_t    *h2scf;\n     ngx_http_v2_connection_t  *h2c;\n+    ngx_http_core_loc_conf_t  *clcf;\n \n     c = rev->data;\n     h2c = c->data;\n@@ -4690,10 +4691,10 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n \n #endif\n \n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n \n-    if (h2c->idle++ > 10 * h2scf->max_requests) {\n+    if (h2c->idle++ > 10 * clcf->keepalive_requests) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                       \"http2 flood detected\");\n         ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n@@ -4703,9 +4704,8 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n     c->destroyed = 0;\n     ngx_reusable_connection(c, 0);\n \n-    if (c->read->timer_set) {\n-        ngx_del_timer(c->read);\n-    }\n+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                         ngx_http_v2_module);\n \n     h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);\n     if (h2c->pool == NULL) {\nDiff:\n@@ -44,6 +44,14 @@ static ngx_conf_deprecated_t  ngx_http_v2_recv_timeout_deprecated = {\n     ngx_conf_deprecated, \"http2_recv_timeout\", \"client_header_timeout\"\n };\n \n+static ngx_conf_deprecated_t  ngx_http_v2_idle_timeout_deprecated = {\n+    ngx_conf_deprecated, \"http2_idle_timeout\", \"keepalive_timeout\"\n+};\n+\n+static ngx_conf_deprecated_t  ngx_http_v2_max_requests_deprecated = {\n+    ngx_conf_deprecated, \"http2_max_requests\", \"keepalive_requests\"\n+};\n+\n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n     { ngx_http_v2_recv_buffer_size };\n@@ -89,10 +97,10 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_max_requests\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_num_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, max_requests),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_max_requests_deprecated },\n \n     { ngx_string(\"http2_max_field_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n@@ -131,10 +139,10 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_idle_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_msec_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, idle_timeout),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_idle_timeout_deprecated },\n \n     { ngx_string(\"http2_chunk_size\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n@@ -302,7 +310,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n \n     h2scf->concurrent_streams = NGX_CONF_UNSET_UINT;\n     h2scf->concurrent_pushes = NGX_CONF_UNSET_UINT;\n-    h2scf->max_requests = NGX_CONF_UNSET_UINT;\n \n     h2scf->max_field_size = NGX_CONF_UNSET_SIZE;\n     h2scf->max_header_size = NGX_CONF_UNSET_SIZE;\n@@ -311,8 +318,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n \n     h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;\n \n-    h2scf->idle_timeout = NGX_CONF_UNSET_MSEC;\n-\n     return h2scf;\n }\n \n@@ -329,7 +334,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->concurrent_streams, 128);\n     ngx_conf_merge_uint_value(conf->concurrent_pushes,\n                               prev->concurrent_pushes, 10);\n-    ngx_conf_merge_uint_value(conf->max_requests, prev->max_requests, 1000);\n \n     ngx_conf_merge_size_value(conf->max_field_size, prev->max_field_size,\n                               4096);\n@@ -341,9 +345,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->streams_index_mask,\n                               prev->streams_index_mask, 32 - 1);\n \n-    ngx_conf_merge_msec_value(conf->idle_timeout,\n-                              prev->idle_timeout, 180000);\n-\n     return NGX_CONF_OK;\n }\n \nDiff:\n@@ -24,12 +24,10 @@ typedef struct {\n     size_t                          pool_size;\n     ngx_uint_t                      concurrent_streams;\n     ngx_uint_t                      concurrent_pushes;\n-    ngx_uint_t                      max_requests;\n     size_t                          max_field_size;\n     size_t                          max_header_size;\n     size_t                          preread_size;\n     ngx_uint_t                      streams_index_mask;\n-    ngx_msec_t                      idle_timeout;\n } ngx_http_v2_srv_conf_t;\n \n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 69",
        "commit_diff": "Diff:\n@@ -635,9 +635,10 @@ ngx_http_v2_send_output_queue(ngx_http_v2_connection_t *h2c)\n static void\n ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n {\n-    ngx_int_t                rc;\n-    ngx_connection_t        *c;\n-    ngx_http_v2_srv_conf_t  *h2scf;\n+    ngx_int_t                  rc;\n+    ngx_connection_t          *c;\n+    ngx_http_v2_srv_conf_t    *h2scf;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     if (h2c->last_out || h2c->processing || h2c->pushing) {\n         return;\n@@ -676,10 +677,13 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n \n     ngx_reusable_connection(c, 1);\n \n-    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n-                                         ngx_http_v2_module);\n     if (h2c->state.incomplete) {\n-        ngx_add_timer(c->read, h2scf->recv_timeout);\n+        if (!c->read->timer_set) {\n+            cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                                ngx_http_core_module);\n+            ngx_add_timer(c->read, cscf->client_header_timeout);\n+        }\n+\n         return;\n     }\n \n@@ -705,6 +709,9 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n         ngx_del_timer(c->write);\n     }\n \n+    h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n+                                         ngx_http_v2_module);\n+\n     ngx_add_timer(c->read, h2scf->idle_timeout);\n }\n \n@@ -4696,6 +4703,10 @@ ngx_http_v2_idle_handler(ngx_event_t *rev)\n     c->destroyed = 0;\n     ngx_reusable_connection(c, 0);\n \n+    if (c->read->timer_set) {\n+        ngx_del_timer(c->read);\n+    }\n+\n     h2c->pool = ngx_create_pool(h2scf->pool_size, h2c->connection->log);\n     if (h2c->pool == NULL) {\n         ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\nDiff:\n@@ -36,6 +36,13 @@ static char *ngx_http_v2_preread_size(ngx_conf_t *cf, void *post, void *data);\n static char *ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post,\n     void *data);\n static char *ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data);\n+static char *ngx_http_v2_obsolete(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n+\n+\n+static ngx_conf_deprecated_t  ngx_http_v2_recv_timeout_deprecated = {\n+    ngx_conf_deprecated, \"http2_recv_timeout\", \"client_header_timeout\"\n+};\n \n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n@@ -117,10 +124,10 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n \n     { ngx_string(\"http2_recv_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_conf_set_msec_slot,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      offsetof(ngx_http_v2_srv_conf_t, recv_timeout),\n-      NULL },\n+      ngx_http_v2_obsolete,\n+      0,\n+      0,\n+      &ngx_http_v2_recv_timeout_deprecated },\n \n     { ngx_string(\"http2_idle_timeout\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n@@ -304,7 +311,6 @@ ngx_http_v2_create_srv_conf(ngx_conf_t *cf)\n \n     h2scf->streams_index_mask = NGX_CONF_UNSET_UINT;\n \n-    h2scf->recv_timeout = NGX_CONF_UNSET_MSEC;\n     h2scf->idle_timeout = NGX_CONF_UNSET_MSEC;\n \n     return h2scf;\n@@ -335,8 +341,6 @@ ngx_http_v2_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->streams_index_mask,\n                               prev->streams_index_mask, 32 - 1);\n \n-    ngx_conf_merge_msec_value(conf->recv_timeout,\n-                              prev->recv_timeout, 30000);\n     ngx_conf_merge_msec_value(conf->idle_timeout,\n                               prev->idle_timeout, 180000);\n \n@@ -539,3 +543,17 @@ ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data)\n \n     return NGX_CONF_OK;\n }\n+\n+\n+static char *\n+ngx_http_v2_obsolete(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_conf_deprecated_t  *d = cmd->post;\n+\n+    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                       \"the \\\"%s\\\" directive is obsolete, \"\n+                       \"use the \\\"%s\\\" directive instead\",\n+                       d->old_name, d->new_name);\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -29,7 +29,6 @@ typedef struct {\n     size_t                          max_header_size;\n     size_t                          preread_size;\n     ngx_uint_t                      streams_index_mask;\n-    ngx_msec_t                      recv_timeout;\n     ngx_msec_t                      idle_timeout;\n } ngx_http_v2_srv_conf_t;\n \n",
        "analysis": "TRUE [ngx_http_v2_obsolete]"
    },
    {
        "commit_index": "Commit 68",
        "commit_diff": "Diff:\n@@ -4078,14 +4078,6 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n #endif\n         }\n \n-        if (ngx_strcmp(value[n].data, \"spdy\") == 0) {\n-            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n-                               \"invalid parameter \\\"spdy\\\": \"\n-                               \"ngx_http_spdy_module was superseded \"\n-                               \"by ngx_http_v2_module\");\n-            continue;\n-        }\n-\n         if (ngx_strncmp(value[n].data, \"so_keepalive=\", 13) == 0) {\n \n             if (ngx_strcmp(&value[n].data[13], \"on\") == 0) {\nDiff:\n@@ -326,6 +326,7 @@ ngx_http_v2_init(ngx_event_t *rev)\n     c->write->handler = ngx_http_v2_write_handler;\n \n     c->idle = 1;\n+    ngx_reusable_connection(c, 0);\n \n     ngx_http_v2_read_handler(rev);\n }\nDiff:\n@@ -36,8 +36,6 @@ static char *ngx_http_v2_preread_size(ngx_conf_t *cf, void *post, void *data);\n static char *ngx_http_v2_streams_index_mask(ngx_conf_t *cf, void *post,\n     void *data);\n static char *ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data);\n-static char *ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd,\n-    void *conf);\n \n \n static ngx_conf_post_t  ngx_http_v2_recv_buffer_size_post =\n@@ -152,62 +150,6 @@ static ngx_command_t  ngx_http_v2_commands[] = {\n       0,\n       NULL },\n \n-    { ngx_string(\"spdy_recv_buffer_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_MAIN_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_pool_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_max_concurrent_streams\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_streams_index_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_recv_timeout\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_keepalive_timeout\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_headers_comp\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_SRV_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n-    { ngx_string(\"spdy_chunk_size\"),\n-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n-      ngx_http_v2_spdy_deprecated,\n-      NGX_HTTP_LOC_CONF_OFFSET,\n-      0,\n-      NULL },\n-\n       ngx_null_command\n };\n \n@@ -597,14 +539,3 @@ ngx_http_v2_chunk_size(ngx_conf_t *cf, void *post, void *data)\n \n     return NGX_CONF_OK;\n }\n-\n-\n-static char *\n-ngx_http_v2_spdy_deprecated(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n-{\n-    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n-                       \"invalid directive \\\"%V\\\": ngx_http_spdy_module \"\n-                       \"was superseded by ngx_http_v2_module\", &cmd->name);\n-\n-    return NGX_CONF_OK;\n-}\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 67",
        "commit_diff": "Diff:\n@@ -1313,6 +1313,7 @@ ngx_drain_connections(ngx_cycle_t *cycle)\n                       cycle->connection_n);\n     }\n \n+    c = NULL;\n     n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);\n \n     for (i = 0; i < n; i++) {\n@@ -1329,6 +1330,21 @@ ngx_drain_connections(ngx_cycle_t *cycle)\n         c->close = 1;\n         c->read->handler(c->read);\n     }\n+\n+    if (cycle->free_connection_n == 0 && c && c->reusable) {\n+\n+        /*\n+         * if no connections were freed, try to reuse the last\n+         * connection again: this should free it as long as\n+         * previous reuse moved it to lingering close\n+         */\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                       \"reusing connection again\");\n+\n+        c->close = 1;\n+        c->read->handler(c->read);\n+    }\n }\n \n \nDiff:\n@@ -3456,6 +3456,9 @@ ngx_http_set_lingering_close(ngx_connection_t *c)\n         return;\n     }\n \n+    c->close = 0;\n+    ngx_reusable_connection(c, 1);\n+\n     ngx_add_timer(rev, clcf->lingering_timeout);\n \n     if (rev->ready) {\n@@ -3480,7 +3483,7 @@ ngx_http_lingering_close_handler(ngx_event_t *rev)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                    \"http lingering close handler\");\n \n-    if (rev->timedout) {\n+    if (rev->timedout || c->close) {\n         ngx_http_close_request(r, 0);\n         return;\n     }\nDiff:\n@@ -362,6 +362,11 @@ ngx_http_v2_read_handler(ngx_event_t *rev)\n             return;\n         }\n \n+        if (!h2c->processing && !h2c->pushing) {\n+            ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n+            return;\n+        }\n+\n         if (!h2c->goaway) {\n             h2c->goaway = 1;\n \n@@ -668,6 +673,8 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    ngx_reusable_connection(c, 1);\n+\n     h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx,\n                                          ngx_http_v2_module);\n     if (h2c->state.incomplete) {\n@@ -689,7 +696,6 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n #endif\n \n     c->destroyed = 1;\n-    ngx_reusable_connection(c, 1);\n \n     c->write->handler = ngx_http_empty_handler;\n     c->read->handler = ngx_http_v2_idle_handler;\n@@ -767,6 +773,9 @@ ngx_http_v2_lingering_close(ngx_connection_t *c)\n         return;\n     }\n \n+    c->close = 0;\n+    ngx_reusable_connection(c, 1);\n+\n     ngx_add_timer(rev, clcf->lingering_timeout);\n \n     if (rev->ready) {\n@@ -791,7 +800,7 @@ ngx_http_v2_lingering_close_handler(ngx_event_t *rev)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                    \"http2 lingering close handler\");\n \n-    if (rev->timedout) {\n+    if (rev->timedout || c->close) {\n         ngx_http_close_connection(c);\n         return;\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 66",
        "commit_diff": "Diff:\n@@ -1,6 +1,6 @@\n /* \n- * Copyright (C) 2002-2019 Igor Sysoev\n- * Copyright (C) 2011-2019 Nginx, Inc.\n+ * Copyright (C) 2002-2021 Igor Sysoev\n+ * Copyright (C) 2011-2021 Nginx, Inc.\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\nDiff:\n@@ -575,6 +575,10 @@ ngx_http_clean_header(ngx_http_request_t *r)\n     r->headers_out.headers.part.next = NULL;\n     r->headers_out.headers.last = &r->headers_out.headers.part;\n \n+    r->headers_out.trailers.part.nelts = 0;\n+    r->headers_out.trailers.part.next = NULL;\n+    r->headers_out.trailers.last = &r->headers_out.trailers.part;\n+\n     r->headers_out.content_length_n = -1;\n     r->headers_out.last_modified_time = -1;\n }\nDiff:\n@@ -807,6 +807,10 @@ ngx_http_v2_lingering_close_handler(ngx_event_t *rev)\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, \"lingering read: %z\", n);\n \n+        if (n == NGX_AGAIN) {\n+            break;\n+        }\n+\n         if (n == NGX_ERROR || n == 0) {\n             ngx_http_close_connection(c);\n             return;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 65",
        "commit_diff": "Diff:\n@@ -45,8 +45,6 @@ struct ngx_listening_s {\n     size_t              pool_size;\n     /* should be here because of the AcceptEx() preread */\n     size_t              post_accept_buffer_size;\n-    /* should be here because of the deferred accept */\n-    ngx_msec_t          post_accept_timeout;\n \n     ngx_listening_t    *previous;\n     ngx_connection_t   *connection;\nDiff:\n@@ -1714,7 +1714,6 @@ ngx_http_add_listening(ngx_conf_t *cf, ngx_http_conf_addr_t *addr)\n \n     cscf = addr->default_server;\n     ls->pool_size = cscf->connection_pool_size;\n-    ls->post_accept_timeout = cscf->client_header_timeout;\n \n     clcf = cscf->ctx->loc_conf[ngx_http_core_module.ctx_index];\n \nDiff:\n@@ -216,16 +216,17 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n void\n ngx_http_init_connection(ngx_connection_t *c)\n {\n-    ngx_uint_t              i;\n-    ngx_event_t            *rev;\n-    struct sockaddr_in     *sin;\n-    ngx_http_port_t        *port;\n-    ngx_http_in_addr_t     *addr;\n-    ngx_http_log_ctx_t     *ctx;\n-    ngx_http_connection_t  *hc;\n+    ngx_uint_t                 i;\n+    ngx_event_t               *rev;\n+    struct sockaddr_in        *sin;\n+    ngx_http_port_t           *port;\n+    ngx_http_in_addr_t        *addr;\n+    ngx_http_log_ctx_t        *ctx;\n+    ngx_http_connection_t     *hc;\n+    ngx_http_core_srv_conf_t  *cscf;\n #if (NGX_HAVE_INET6)\n-    struct sockaddr_in6    *sin6;\n-    ngx_http_in6_addr_t    *addr6;\n+    struct sockaddr_in6       *sin6;\n+    ngx_http_in6_addr_t       *addr6;\n #endif\n \n     hc = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t));\n@@ -371,7 +372,9 @@ ngx_http_init_connection(ngx_connection_t *c)\n         return;\n     }\n \n-    ngx_add_timer(rev, c->listening->post_accept_timeout);\n+    cscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_core_module);\n+\n+    ngx_add_timer(rev, cscf->client_header_timeout);\n     ngx_reusable_connection(c, 1);\n \n     if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n@@ -445,7 +448,7 @@ ngx_http_wait_request_handler(ngx_event_t *rev)\n     if (n == NGX_AGAIN) {\n \n         if (!rev->timer_set) {\n-            ngx_add_timer(rev, c->listening->post_accept_timeout);\n+            ngx_add_timer(rev, cscf->client_header_timeout);\n             ngx_reusable_connection(c, 1);\n         }\n \n@@ -663,6 +666,7 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n     ngx_http_connection_t     *hc;\n     ngx_http_ssl_srv_conf_t   *sscf;\n     ngx_http_core_loc_conf_t  *clcf;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     c = rev->data;\n     hc = c->data;\n@@ -694,7 +698,9 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n             rev->ready = 0;\n \n             if (!rev->timer_set) {\n-                ngx_add_timer(rev, c->listening->post_accept_timeout);\n+                cscf = ngx_http_get_module_srv_conf(hc->conf_ctx,\n+                                                    ngx_http_core_module);\n+                ngx_add_timer(rev, cscf->client_header_timeout);\n                 ngx_reusable_connection(c, 1);\n             }\n \n@@ -769,7 +775,9 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n             if (rc == NGX_AGAIN) {\n \n                 if (!rev->timer_set) {\n-                    ngx_add_timer(rev, c->listening->post_accept_timeout);\n+                    cscf = ngx_http_get_module_srv_conf(hc->conf_ctx,\n+                                                        ngx_http_core_module);\n+                    ngx_add_timer(rev, cscf->client_header_timeout);\n                 }\n \n                 c->ssl->handler = ngx_http_ssl_handshake_handler;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 64",
        "commit_diff": "Diff:\n@@ -2334,6 +2334,13 @@ ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)\n \n     u = r->upstream;\n \n+    if (u->length == 0) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+        return NGX_OK;\n+    }\n+\n     for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {\n         ll = &cl->next;\n     }\nDiff:\n@@ -103,16 +103,6 @@ ngx_http_stub_status_handler(ngx_http_request_t *r)\n     ngx_str_set(&r->headers_out.content_type, \"text/plain\");\n     r->headers_out.content_type_lowcase = NULL;\n \n-    if (r->method == NGX_HTTP_HEAD) {\n-        r->headers_out.status = NGX_HTTP_OK;\n-\n-        rc = ngx_http_send_header(r);\n-\n-        if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n-            return rc;\n-        }\n-    }\n-\n     size = sizeof(\"Active connections:  \\n\") + NGX_ATOMIC_T_LEN\n            + sizeof(\"server accepts handled requests\\n\") - 1\n            + 6 + 3 * NGX_ATOMIC_T_LEN\nDiff:\n@@ -1782,7 +1782,7 @@ ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\n         }\n     }\n \n-    if (r->method == NGX_HTTP_HEAD || (r != r->main && val.len == 0)) {\n+    if (r != r->main && val.len == 0) {\n         return ngx_http_send_header(r);\n     }\n \nDiff:\n@@ -3721,6 +3721,13 @@ ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)\n \n     u = r->upstream;\n \n+    if (u->length == 0) {\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+        return NGX_OK;\n+    }\n+\n     for (cl = u->out_bufs, ll = &u->out_bufs; cl; cl = cl->next) {\n         ll = &cl->next;\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 63",
        "commit_diff": "Diff:\n@@ -455,3 +455,4 @@ a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n 3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\n dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n 8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\n+f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\nDiff:\n@@ -268,6 +268,7 @@ syn keyword ngxDirective contained grpc_socket_keepalive\n syn keyword ngxDirective contained grpc_ssl_certificate\n syn keyword ngxDirective contained grpc_ssl_certificate_key\n syn keyword ngxDirective contained grpc_ssl_ciphers\n+syn keyword ngxDirective contained grpc_ssl_conf_command\n syn keyword ngxDirective contained grpc_ssl_crl\n syn keyword ngxDirective contained grpc_ssl_name\n syn keyword ngxDirective contained grpc_ssl_password_file\n@@ -447,6 +448,7 @@ syn keyword ngxDirective contained proxy_cache_use_stale\n syn keyword ngxDirective contained proxy_cache_valid\n syn keyword ngxDirective contained proxy_connect_timeout\n syn keyword ngxDirective contained proxy_cookie_domain\n+syn keyword ngxDirective contained proxy_cookie_flags\n syn keyword ngxDirective contained proxy_cookie_path\n syn keyword ngxDirective contained proxy_download_rate\n syn keyword ngxDirective contained proxy_force_ranges\n@@ -480,11 +482,13 @@ syn keyword ngxDirective contained proxy_send_timeout\n syn keyword ngxDirective contained proxy_session_drop\n syn keyword ngxDirective contained proxy_set_body\n syn keyword ngxDirective contained proxy_set_header\n+syn keyword ngxDirective contained proxy_smtp_auth\n syn keyword ngxDirective contained proxy_socket_keepalive\n syn keyword ngxDirective contained proxy_ssl\n syn keyword ngxDirective contained proxy_ssl_certificate\n syn keyword ngxDirective contained proxy_ssl_certificate_key\n syn keyword ngxDirective contained proxy_ssl_ciphers\n+syn keyword ngxDirective contained proxy_ssl_conf_command\n syn keyword ngxDirective contained proxy_ssl_crl\n syn keyword ngxDirective contained proxy_ssl_name\n syn keyword ngxDirective contained proxy_ssl_password_file\n@@ -592,6 +596,7 @@ syn keyword ngxDirective contained ssl_certificate\n syn keyword ngxDirective contained ssl_certificate_key\n syn keyword ngxDirective contained ssl_ciphers\n syn keyword ngxDirective contained ssl_client_certificate\n+syn keyword ngxDirective contained ssl_conf_command\n syn keyword ngxDirective contained ssl_crl\n syn keyword ngxDirective contained ssl_dhparam\n syn keyword ngxDirective contained ssl_early_data\n@@ -605,6 +610,7 @@ syn keyword ngxDirective contained ssl_password_file\n syn keyword ngxDirective contained ssl_prefer_server_ciphers\n syn keyword ngxDirective contained ssl_preread\n syn keyword ngxDirective contained ssl_protocols\n+syn keyword ngxDirective contained ssl_reject_handshake\n syn keyword ngxDirective contained ssl_session_cache\n syn keyword ngxDirective contained ssl_session_ticket_key\n syn keyword ngxDirective contained ssl_session_tickets\n@@ -643,6 +649,7 @@ syn keyword ngxDirective contained user\n syn keyword ngxDirective contained userid\n syn keyword ngxDirective contained userid_domain\n syn keyword ngxDirective contained userid_expires\n+syn keyword ngxDirective contained userid_flags\n syn keyword ngxDirective contained userid_mark\n syn keyword ngxDirective contained userid_name\n syn keyword ngxDirective contained userid_p3p\n@@ -693,6 +700,7 @@ syn keyword ngxDirective contained uwsgi_socket_keepalive\n syn keyword ngxDirective contained uwsgi_ssl_certificate\n syn keyword ngxDirective contained uwsgi_ssl_certificate_key\n syn keyword ngxDirective contained uwsgi_ssl_ciphers\n+syn keyword ngxDirective contained uwsgi_ssl_conf_command\n syn keyword ngxDirective contained uwsgi_ssl_crl\n syn keyword ngxDirective contained uwsgi_ssl_name\n syn keyword ngxDirective contained uwsgi_ssl_password_file\n@@ -738,6 +746,7 @@ syn keyword ngxDirective contained zone_sync_ssl\n syn keyword ngxDirective contained zone_sync_ssl_certificate\n syn keyword ngxDirective contained zone_sync_ssl_certificate_key\n syn keyword ngxDirective contained zone_sync_ssl_ciphers\n+syn keyword ngxDirective contained zone_sync_ssl_conf_command\n syn keyword ngxDirective contained zone_sync_ssl_crl\n syn keyword ngxDirective contained zone_sync_ssl_name\n syn keyword ngxDirective contained zone_sync_ssl_password_file\n@@ -1329,6 +1338,8 @@ syn keyword ngxDirectiveThirdParty contained body_filter_by_lua_file\n syn keyword ngxDirectiveThirdParty contained content_by_lua\n syn keyword ngxDirectiveThirdParty contained content_by_lua_block\n syn keyword ngxDirectiveThirdParty contained content_by_lua_file\n+syn keyword ngxDirectiveThirdParty contained exit_worker_by_lua_block\n+syn keyword ngxDirectiveThirdParty contained exit_worker_by_lua_file\n syn keyword ngxDirectiveThirdParty contained header_filter_by_lua\n syn keyword ngxDirectiveThirdParty contained header_filter_by_lua_block\n syn keyword ngxDirectiveThirdParty contained header_filter_by_lua_file\n@@ -1370,6 +1381,7 @@ syn keyword ngxDirectiveThirdParty contained lua_ssl_crl\n syn keyword ngxDirectiveThirdParty contained lua_ssl_protocols\n syn keyword ngxDirectiveThirdParty contained lua_ssl_trusted_certificate\n syn keyword ngxDirectiveThirdParty contained lua_ssl_verify_depth\n+syn keyword ngxDirectiveThirdParty contained lua_thread_cache_max_entries\n syn keyword ngxDirectiveThirdParty contained lua_transform_underscores_in_response_headers\n syn keyword ngxDirectiveThirdParty contained lua_use_default_type\n syn keyword ngxDirectiveThirdParty contained rewrite_by_lua\n@@ -2285,6 +2297,7 @@ syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_i\n syn keyword ngxDirectiveThirdParty contained testcookie_refresh_encrypt_cookie_key\n syn keyword ngxDirectiveThirdParty contained testcookie_refresh_status\n syn keyword ngxDirectiveThirdParty contained testcookie_refresh_template\n+syn keyword ngxDirectiveThirdParty contained testcookie_samesite\n syn keyword ngxDirectiveThirdParty contained testcookie_secret\n syn keyword ngxDirectiveThirdParty contained testcookie_secure_flag\n syn keyword ngxDirectiveThirdParty contained testcookie_session\n@@ -2355,28 +2368,46 @@ syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n \" IP2Location Nginx\n \" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location\n-syn keyword ngxDirectiveThirdParty contained ip2location_access_type\n syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n+syn keyword ngxDirectiveThirdParty contained ip2location_city\n+syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n+syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n+syn keyword ngxDirectiveThirdParty contained ip2location_domain\n+syn keyword ngxDirectiveThirdParty contained ip2location_elevation\n+syn keyword ngxDirectiveThirdParty contained ip2location_iddcode\n+syn keyword ngxDirectiveThirdParty contained ip2location_isp\n+syn keyword ngxDirectiveThirdParty contained ip2location_latitude\n+syn keyword ngxDirectiveThirdParty contained ip2location_longitude\n+syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n+syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n+syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n+syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n+syn keyword ngxDirectiveThirdParty contained ip2location_region\n+syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n+syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n+syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationcode\n+syn keyword ngxDirectiveThirdParty contained ip2location_weatherstationname\n+syn keyword ngxDirectiveThirdParty contained ip2location_zipcode\n \n \" IP2Proxy module for Nginx\n \" https://github.com/ip2location/ip2proxy-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2proxy\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_access_type\n syn keyword ngxDirectiveThirdParty contained ip2proxy_as\n syn keyword ngxDirectiveThirdParty contained ip2proxy_asn\n syn keyword ngxDirectiveThirdParty contained ip2proxy_city\n syn keyword ngxDirectiveThirdParty contained ip2proxy_country_long\n syn keyword ngxDirectiveThirdParty contained ip2proxy_country_short\n syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\n syn keyword ngxDirectiveThirdParty contained ip2proxy_region\n-syn keyword ngxDirectiveThirdParty contained ip2proxy_reverse_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_threat\n syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n \n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019006\n-#define NGINX_VERSION      \"1.19.6\"\n+#define nginx_version      1019007\n+#define NGINX_VERSION      \"1.19.7\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 62",
        "commit_diff": "Diff:\n@@ -5,6 +5,55 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.6\" date=\"2020-12-15\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+ошибки \"no live upstreams\",\n+если server в блоке upstream был помечен как down.\n+</para>\n+<para lang=\"en\">\n+\"no live upstreams\" errors\n+if a \"server\" inside \"upstream\" block was marked as \"down\".\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTPS в рабочем процессе мог произойти segmentation fault;\n+ошибка появилась в 1.19.5.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process if HTTPS was used;\n+the bug had appeared in 1.19.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx возвращал ошибку 400 на запросы вида\n+<nobr>\"GET http://example.com?args HTTP/1.0\"</nobr>.\n+</para>\n+<para lang=\"en\">\n+nginx returned the 400 response on requests like\n+<nobr>\"GET http://example.com?args HTTP/1.0\"</nobr>.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модулях ngx_http_flv_module и ngx_http_mp4_module.<br/>\n+Спасибо Chris Newton.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_flv_module and ngx_http_mp4_module.<br/>\n+Thanks to Chris Newton.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.5\" date=\"2020-11-24\">\n \n <change type=\"feature\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1h\n+OPENSSL =\topenssl-1.1.1i\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -156,12 +156,6 @@ ngx_http_flv_handler(ngx_http_request_t *r)\n     }\n \n     if (!of.is_file) {\n-\n-        if (ngx_close_file(of.fd) == NGX_FILE_ERROR) {\n-            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n-                          ngx_close_file_n \" \\\"%s\\\" failed\", path.data);\n-        }\n-\n         return NGX_DECLINED;\n     }\n \nDiff:\n@@ -521,12 +521,6 @@ ngx_http_mp4_handler(ngx_http_request_t *r)\n     }\n \n     if (!of.is_file) {\n-\n-        if (ngx_close_file(of.fd) == NGX_FILE_ERROR) {\n-            ngx_log_error(NGX_LOG_ALERT, log, ngx_errno,\n-                          ngx_close_file_n \" \\\"%s\\\" failed\", path.data);\n-        }\n-\n         return NGX_DECLINED;\n     }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 61",
        "commit_diff": "Diff:\n@@ -380,6 +380,12 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 r->uri_start = p;\n                 state = sw_after_slash_in_uri;\n                 break;\n+            case '?':\n+                r->uri_start = p;\n+                r->args_start = p + 1;\n+                r->empty_path_in_uri = 1;\n+                state = sw_uri;\n+                break;\n             case ' ':\n                 /*\n                  * use single \"/\" from request line to preserve pointers,\n@@ -446,6 +452,13 @@ ngx_http_parse_request_line(ngx_http_request_t *r, ngx_buf_t *b)\n                 r->uri_start = p;\n                 state = sw_after_slash_in_uri;\n                 break;\n+            case '?':\n+                r->port_end = p;\n+                r->uri_start = p;\n+                r->args_start = p + 1;\n+                r->empty_path_in_uri = 1;\n+                state = sw_uri;\n+                break;\n             case ' ':\n                 r->port_end = p;\n                 /*\n@@ -1287,6 +1300,10 @@ ngx_http_parse_complex_uri(ngx_http_request_t *r, ngx_uint_t merge_slashes)\n     r->uri_ext = NULL;\n     r->args_start = NULL;\n \n+    if (r->empty_path_in_uri) {\n+        *u++ = '/';\n+    }\n+\n     ch = *p++;\n \n     while (p <= r->uri_end) {\nDiff:\n@@ -1239,9 +1239,13 @@ ngx_http_process_request_uri(ngx_http_request_t *r)\n         r->uri.len = r->uri_end - r->uri_start;\n     }\n \n-    if (r->complex_uri || r->quoted_uri) {\n+    if (r->complex_uri || r->quoted_uri || r->empty_path_in_uri) {\n \n-        r->uri.data = ngx_pnalloc(r->pool, r->uri.len + 1);\n+        if (r->empty_path_in_uri) {\n+            r->uri.len++;\n+        }\n+\n+        r->uri.data = ngx_pnalloc(r->pool, r->uri.len);\n         if (r->uri.data == NULL) {\n             ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n             return NGX_ERROR;\n@@ -1265,7 +1269,7 @@ ngx_http_process_request_uri(ngx_http_request_t *r)\n     r->unparsed_uri.len = r->uri_end - r->uri_start;\n     r->unparsed_uri.data = r->uri_start;\n \n-    r->valid_unparsed_uri = r->space_in_uri ? 0 : 1;\n+    r->valid_unparsed_uri = (r->space_in_uri || r->empty_path_in_uri) ? 0 : 1;\n \n     if (r->uri_ext) {\n         if (r->args_start) {\nDiff:\n@@ -479,6 +479,9 @@ struct ngx_http_request_s {\n     /* URI with \" \" */\n     unsigned                          space_in_uri:1;\n \n+    /* URI with empty path */\n+    unsigned                          empty_path_in_uri:1;\n+\n     unsigned                          invalid_header:1;\n \n     unsigned                          add_uri_to_alias:1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 60",
        "commit_diff": "Diff:\n@@ -2880,6 +2880,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n         SSL_free(c->ssl->connection);\n         c->ssl = NULL;\n+        c->recv = ngx_recv;\n \n         return NGX_OK;\n     }\n@@ -2925,6 +2926,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         if (n == 1) {\n             SSL_free(c->ssl->connection);\n             c->ssl = NULL;\n+            c->recv = ngx_recv;\n \n             return NGX_OK;\n         }\n@@ -2967,6 +2969,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n             SSL_free(c->ssl->connection);\n             c->ssl = NULL;\n+            c->recv = ngx_recv;\n \n             return NGX_OK;\n         }\n@@ -2977,6 +2980,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n         SSL_free(c->ssl->connection);\n         c->ssl = NULL;\n+        c->recv = ngx_recv;\n \n         return NGX_ERROR;\n     }\nDiff:\n@@ -3416,8 +3416,6 @@ ngx_http_set_lingering_close(ngx_connection_t *c)\n             c->ssl->handler = ngx_http_set_lingering_close;\n             return;\n         }\n-\n-        c->recv = ngx_recv;\n     }\n #endif\n \nDiff:\n@@ -10,8 +10,8 @@\n #include <ngx_http.h>\n \n \n-#define ngx_http_upstream_tries(p) ((p)->number                               \\\n-                                    + ((p)->next ? (p)->next->number : 0))\n+#define ngx_http_upstream_tries(p) ((p)->tries                                \\\n+                                    + ((p)->next ? (p)->next->tries : 0))\n \n \n static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(\n@@ -32,7 +32,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n     ngx_http_upstream_srv_conf_t *us)\n {\n     ngx_url_t                      u;\n-    ngx_uint_t                     i, j, n, w;\n+    ngx_uint_t                     i, j, n, w, t;\n     ngx_http_upstream_server_t    *server;\n     ngx_http_upstream_rr_peer_t   *peer, **peerp;\n     ngx_http_upstream_rr_peers_t  *peers, *backup;\n@@ -44,6 +44,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (server[i].backup) {\n@@ -52,6 +53,10 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -75,6 +80,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n         peers->number = n;\n         peers->weighted = (w != n);\n         peers->total_weight = w;\n+        peers->tries = t;\n         peers->name = &us->host;\n \n         n = 0;\n@@ -110,6 +116,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (!server[i].backup) {\n@@ -118,6 +125,10 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -139,6 +150,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n         backup->number = n;\n         backup->weighted = (w != n);\n         backup->total_weight = w;\n+        backup->tries = t;\n         backup->name = &us->host;\n \n         n = 0;\n@@ -214,6 +226,7 @@ ngx_http_upstream_init_round_robin(ngx_conf_t *cf,\n     peers->number = n;\n     peers->weighted = 0;\n     peers->total_weight = n;\n+    peers->tries = n;\n     peers->name = &us->host;\n \n     peerp = &peers->peer;\n@@ -332,6 +345,7 @@ ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r,\n \n     peers->single = (ur->naddrs == 1);\n     peers->number = ur->naddrs;\n+    peers->tries = ur->naddrs;\n     peers->name = &ur->host;\n \n     if (ur->sockaddr) {\nDiff:\n@@ -68,6 +68,7 @@ struct ngx_http_upstream_rr_peers_s {\n #endif\n \n     ngx_uint_t                      total_weight;\n+    ngx_uint_t                      tries;\n \n     unsigned                        single:1;\n     unsigned                        weighted:1;\nDiff:\n@@ -739,8 +739,6 @@ ngx_http_v2_lingering_close(ngx_connection_t *c)\n             c->ssl->handler = ngx_http_v2_lingering_close;\n             return;\n         }\n-\n-        c->recv = ngx_recv;\n     }\n #endif\n \nDiff:\n@@ -10,8 +10,8 @@\n #include <ngx_stream.h>\n \n \n-#define ngx_stream_upstream_tries(p) ((p)->number                             \\\n-                                      + ((p)->next ? (p)->next->number : 0))\n+#define ngx_stream_upstream_tries(p) ((p)->tries                              \\\n+                                      + ((p)->next ? (p)->next->tries : 0))\n \n \n static ngx_stream_upstream_rr_peer_t *ngx_stream_upstream_get_peer(\n@@ -38,7 +38,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n     ngx_stream_upstream_srv_conf_t *us)\n {\n     ngx_url_t                        u;\n-    ngx_uint_t                       i, j, n, w;\n+    ngx_uint_t                       i, j, n, w, t;\n     ngx_stream_upstream_server_t    *server;\n     ngx_stream_upstream_rr_peer_t   *peer, **peerp;\n     ngx_stream_upstream_rr_peers_t  *peers, *backup;\n@@ -50,6 +50,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (server[i].backup) {\n@@ -58,6 +59,10 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -81,6 +86,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n         peers->number = n;\n         peers->weighted = (w != n);\n         peers->total_weight = w;\n+        peers->tries = t;\n         peers->name = &us->host;\n \n         n = 0;\n@@ -116,6 +122,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n         n = 0;\n         w = 0;\n+        t = 0;\n \n         for (i = 0; i < us->servers->nelts; i++) {\n             if (!server[i].backup) {\n@@ -124,6 +131,10 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n \n             n += server[i].naddrs;\n             w += server[i].naddrs * server[i].weight;\n+\n+            if (!server[i].down) {\n+                t += server[i].naddrs;\n+            }\n         }\n \n         if (n == 0) {\n@@ -145,6 +156,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n         backup->number = n;\n         backup->weighted = (w != n);\n         backup->total_weight = w;\n+        backup->tries = t;\n         backup->name = &us->host;\n \n         n = 0;\n@@ -220,6 +232,7 @@ ngx_stream_upstream_init_round_robin(ngx_conf_t *cf,\n     peers->number = n;\n     peers->weighted = 0;\n     peers->total_weight = n;\n+    peers->tries = n;\n     peers->name = &us->host;\n \n     peerp = &peers->peer;\n@@ -342,6 +355,7 @@ ngx_stream_upstream_create_round_robin_peer(ngx_stream_session_t *s,\n \n     peers->single = (ur->naddrs == 1);\n     peers->number = ur->naddrs;\n+    peers->tries = ur->naddrs;\n     peers->name = &ur->host;\n \n     if (ur->sockaddr) {\nDiff:\n@@ -66,6 +66,7 @@ struct ngx_stream_upstream_rr_peers_s {\n #endif\n \n     ngx_uint_t                       total_weight;\n+    ngx_uint_t                       tries;\n \n     unsigned                         single:1;\n     unsigned                         weighted:1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 59",
        "commit_diff": "Diff:\n@@ -454,3 +454,4 @@ cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n 3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\n dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\n+8e5b068f761cd512d10c9671fbde0b568c1fd08b release-1.19.5\nDiff:\n@@ -5,6 +5,62 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.5\" date=\"2020-11-24\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+ключ -e.\n+</para>\n+<para lang=\"en\">\n+the -e switch.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+при сборке дополнительных модулей\n+теперь можно указывать одни и те же исходные файлы в разных модулях.\n+</para>\n+<para lang=\"en\">\n+the same source files can now be specified in different modules\n+while building addon modules.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL shutdown не работал\n+при закрытии соединений с ожиданием дополнительных данных (lingering close).\n+</para>\n+<para lang=\"en\">\n+SSL shutdown did not work\n+when lingering close was used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при работе с gRPC-бэкендами\n+могли возникать ошибки \"upstream sent frame for closed stream\".\n+</para>\n+<para lang=\"en\">\n+\"upstream sent frame for closed stream\" errors might occur\n+when working with gRPC backends.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+во внутреннем API для обработки тела запроса.\n+</para>\n+<para lang=\"en\">\n+in request body filters internal API.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.4\" date=\"2020-10-27\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019005\n-#define NGINX_VERSION      \"1.19.5\"\n+#define nginx_version      1019006\n+#define NGINX_VERSION      \"1.19.6\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 58",
        "commit_diff": "Diff:\n@@ -87,6 +87,10 @@ have=NGX_PID_PATH value=\"\\\"$NGX_PID_PATH\\\"\" . auto/define\n have=NGX_LOCK_PATH value=\"\\\"$NGX_LOCK_PATH\\\"\" . auto/define\n have=NGX_ERROR_LOG_PATH value=\"\\\"$NGX_ERROR_LOG_PATH\\\"\" . auto/define\n \n+if [ \".$NGX_ERROR_LOG_PATH\" = \".\" ]; then\n+    have=NGX_ERROR_LOG_STDERR . auto/have\n+fi\n+\n have=NGX_HTTP_LOG_PATH value=\"\\\"$NGX_HTTP_LOG_PATH\\\"\" . auto/define\n have=NGX_HTTP_CLIENT_TEMP_PATH value=\"\\\"$NGX_HTTP_CLIENT_TEMP_PATH\\\"\"\n . auto/define\nDiff:\n@@ -25,7 +25,7 @@\n .\\\" SUCH DAMAGE.\n .\\\"\n .\\\"\n-.Dd December 5, 2019\n+.Dd November 5, 2020\n .Dt NGINX 8\n .Os\n .Sh NAME\n@@ -35,6 +35,7 @@\n .Nm\n .Op Fl ?hqTtVv\n .Op Fl c Ar file\n+.Op Fl e Ar file\n .Op Fl g Ar directives\n .Op Fl p Ar prefix\n .Op Fl s Ar signal\n@@ -54,6 +55,12 @@ Print help.\n .It Fl c Ar file\n Use an alternative configuration\n .Ar file .\n+.It Fl e Ar file\n+Use an alternative error log\n+.Ar file .\n+Special value\n+.Cm stderr\n+indicates that the standard error output should be used.\n .It Fl g Ar directives\n Set global configuration directives.\n See\n@@ -198,10 +205,10 @@ Development of\n started in 2002, with the first public release on October 4, 2004.\n .Sh AUTHORS\n .An -nosplit\n-.An Igor Sysoev Aq igor@sysoev.ru .\n+.An Igor Sysoev Aq Mt igor@sysoev.ru .\n .Pp\n This manual page was originally written by\n-.An Sergey A. Osokin Aq osa@FreeBSD.org.ru\n+.An Sergey A. Osokin Aq Mt osa@FreeBSD.org.ru\n as a result of compiling many\n .Nm\n documents from all over the world.\nDiff:\n@@ -197,6 +197,7 @@ static ngx_uint_t   ngx_show_help;\n static ngx_uint_t   ngx_show_version;\n static ngx_uint_t   ngx_show_configure;\n static u_char      *ngx_prefix;\n+static u_char      *ngx_error_log;\n static u_char      *ngx_conf_file;\n static u_char      *ngx_conf_params;\n static char        *ngx_signal;\n@@ -244,7 +245,7 @@ main(int argc, char *const *argv)\n     ngx_pid = ngx_getpid();\n     ngx_parent = ngx_getppid();\n \n-    log = ngx_log_init(ngx_prefix);\n+    log = ngx_log_init(ngx_prefix, ngx_error_log);\n     if (log == NULL) {\n         return 1;\n     }\n@@ -407,9 +408,9 @@ ngx_show_version_info(void)\n \n     if (ngx_show_help) {\n         ngx_write_stderr(\n-            \"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] \"\n-                         \"[-p prefix] [-g directives]\" NGX_LINEFEED\n-                         NGX_LINEFEED\n+            \"Usage: nginx [-?hvVtTq] [-s signal] [-p prefix]\" NGX_LINEFEED\n+            \"             [-e filename] [-c filename] [-g directives]\"\n+                          NGX_LINEFEED NGX_LINEFEED\n             \"Options:\" NGX_LINEFEED\n             \"  -?,-h         : this help\" NGX_LINEFEED\n             \"  -v            : show version and exit\" NGX_LINEFEED\n@@ -427,6 +428,12 @@ ngx_show_version_info(void)\n                                NGX_LINEFEED\n #else\n             \"  -p prefix     : set prefix path (default: NONE)\" NGX_LINEFEED\n+#endif\n+            \"  -e filename   : set error log file (default: \"\n+#ifdef NGX_ERROR_LOG_STDERR\n+                               \"stderr)\" NGX_LINEFEED\n+#else\n+                               NGX_ERROR_LOG_PATH \")\" NGX_LINEFEED\n #endif\n             \"  -c filename   : set configuration file (default: \" NGX_CONF_PATH\n                                \")\" NGX_LINEFEED\n@@ -814,6 +821,24 @@ ngx_get_options(int argc, char *const *argv)\n                 ngx_log_stderr(0, \"option \\\"-p\\\" requires directory name\");\n                 return NGX_ERROR;\n \n+            case 'e':\n+                if (*p) {\n+                    ngx_error_log = p;\n+\n+                } else if (argv[++i]) {\n+                    ngx_error_log = (u_char *) argv[i];\n+\n+                } else {\n+                    ngx_log_stderr(0, \"option \\\"-e\\\" requires file name\");\n+                    return NGX_ERROR;\n+                }\n+\n+                if (ngx_strcmp(ngx_error_log, \"stderr\") == 0) {\n+                    ngx_error_log = (u_char *) \"\";\n+                }\n+\n+                goto next;\n+\n             case 'c':\n                 if (*p) {\n                     ngx_conf_file = p;\n@@ -1006,6 +1031,14 @@ ngx_process_options(ngx_cycle_t *cycle)\n         }\n     }\n \n+    if (ngx_error_log) {\n+        cycle->error_log.len = ngx_strlen(ngx_error_log);\n+        cycle->error_log.data = ngx_error_log;\n+\n+    } else {\n+        ngx_str_set(&cycle->error_log, NGX_ERROR_LOG_PATH);\n+    }\n+\n     if (ngx_conf_params) {\n         cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n         cycle->conf_param.data = ngx_conf_params;\nDiff:\n@@ -133,6 +133,15 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n         return NULL;\n     }\n \n+    cycle->error_log.len = old_cycle->error_log.len;\n+    cycle->error_log.data = ngx_pnalloc(pool, old_cycle->error_log.len + 1);\n+    if (cycle->error_log.data == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    ngx_cpystrn(cycle->error_log.data, old_cycle->error_log.data,\n+                old_cycle->error_log.len + 1);\n+\n     cycle->conf_file.len = old_cycle->conf_file.len;\n     cycle->conf_file.data = ngx_pnalloc(pool, old_cycle->conf_file.len + 1);\n     if (cycle->conf_file.data == NULL) {\nDiff:\n@@ -96,6 +96,7 @@ struct ngx_cycle_s {\n     ngx_str_t                 conf_param;\n     ngx_str_t                 conf_prefix;\n     ngx_str_t                 prefix;\n+    ngx_str_t                 error_log;\n     ngx_str_t                 lock_file;\n     ngx_str_t                 hostname;\n     ngx_black_list_t         *black_list;\nDiff:\n@@ -315,21 +315,19 @@ ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err)\n \n \n ngx_log_t *\n-ngx_log_init(u_char *prefix)\n+ngx_log_init(u_char *prefix, u_char *error_log)\n {\n     u_char  *p, *name;\n     size_t   nlen, plen;\n \n     ngx_log.file = &ngx_log_file;\n     ngx_log.log_level = NGX_LOG_NOTICE;\n \n-    name = (u_char *) NGX_ERROR_LOG_PATH;\n-\n-    /*\n-     * we use ngx_strlen() here since BCC warns about\n-     * condition is always false and unreachable code\n-     */\n+    if (error_log == NULL) {\n+        error_log = (u_char *) NGX_ERROR_LOG_PATH;\n+    }\n \n+    name = error_log;\n     nlen = ngx_strlen(name);\n \n     if (nlen == 0) {\n@@ -369,7 +367,7 @@ ngx_log_init(u_char *prefix)\n                 *p++ = '/';\n             }\n \n-            ngx_cpystrn(p, (u_char *) NGX_ERROR_LOG_PATH, nlen + 1);\n+            ngx_cpystrn(p, error_log, nlen + 1);\n \n             p = name;\n         }\n@@ -403,8 +401,7 @@ ngx_log_init(u_char *prefix)\n ngx_int_t\n ngx_log_open_default(ngx_cycle_t *cycle)\n {\n-    ngx_log_t         *log;\n-    static ngx_str_t   error_log = ngx_string(NGX_ERROR_LOG_PATH);\n+    ngx_log_t  *log;\n \n     if (ngx_log_get_file_log(&cycle->new_log) != NULL) {\n         return NGX_OK;\n@@ -425,7 +422,7 @@ ngx_log_open_default(ngx_cycle_t *cycle)\n \n     log->log_level = NGX_LOG_ERR;\n \n-    log->file = ngx_conf_open_file(cycle, &error_log);\n+    log->file = ngx_conf_open_file(cycle, &cycle->error_log);\n     if (log->file == NULL) {\n         return NGX_ERROR;\n     }\nDiff:\n@@ -228,7 +228,7 @@ void ngx_cdecl ngx_log_debug_core(ngx_log_t *log, ngx_err_t err,\n \n /*********************************/\n \n-ngx_log_t *ngx_log_init(u_char *prefix);\n+ngx_log_t *ngx_log_init(u_char *prefix, u_char *error_log);\n void ngx_cdecl ngx_log_abort(ngx_err_t err, const char *fmt, ...);\n void ngx_cdecl ngx_log_stderr(ngx_err_t err, const char *fmt, ...);\n u_char *ngx_log_errno(u_char *buf, u_char *last, ngx_err_t err);\nDiff:\n@@ -1969,6 +1969,7 @@ ngx_http_grpc_filter_init(void *data)\n         }\n \n         u->length = 0;\n+        ctx->done = 1;\n \n     } else {\n         u->length = 1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 57",
        "commit_diff": "Diff:\n@@ -502,6 +502,7 @@ fi\n for ngx_module in $DYNAMIC_MODULES\n do\n     eval ngx_module_srcs=\"\\$${ngx_module}_SRCS\"\n+    eval ngx_module_shrd=\"\\$${ngx_module}_SHRD\"\n     eval eval ngx_module_libs=\"\\\\\\\"\\$${ngx_module}_LIBS\\\\\\\"\"\n \n     eval ngx_module_modules=\"\\$${ngx_module}_MODULES\"\n@@ -567,7 +568,7 @@ END\n         | sed -e \"s/\\(.*\\.\\)c/\\1$ngx_objext/\"`\n \n     ngx_module_objs=\n-    for ngx_src in $ngx_module_srcs\n+    for ngx_src in $ngx_module_srcs $ngx_module_shrd\n     do\n         case \"$ngx_src\" in\n             src/*)\nDiff:\n@@ -17,7 +17,6 @@ if [ \"$ngx_module_link\" = DYNAMIC ]; then\n     done\n \n     DYNAMIC_MODULES=\"$DYNAMIC_MODULES $ngx_module\"\n-    eval ${ngx_module}_SRCS=\\\"$ngx_module_srcs\\\"\n \n     eval ${ngx_module}_MODULES=\\\"$ngx_module_name\\\"\n \n@@ -31,6 +30,30 @@ if [ \"$ngx_module_link\" = DYNAMIC ]; then\n         eval ${ngx_module}_ORDER=\\\"$ngx_module_order\\\"\n     fi\n \n+    srcs=\n+    shrd=\n+    for src in $ngx_module_srcs\n+    do\n+        found=no\n+        for old in $DYNAMIC_MODULES_SRCS\n+        do\n+            if [ $src = $old ]; then\n+                found=yes\n+                break\n+            fi\n+        done\n+\n+        if [ $found = no ]; then\n+            srcs=\"$srcs $src\"\n+        else\n+            shrd=\"$shrd $src\"\n+        fi\n+    done\n+    eval ${ngx_module}_SRCS=\\\"$srcs\\\"\n+    eval ${ngx_module}_SHRD=\\\"$shrd\\\"\n+\n+    DYNAMIC_MODULES_SRCS=\"$DYNAMIC_MODULES_SRCS $srcs\"\n+\n     if test -n \"$ngx_module_incs\"; then\n         CORE_INCS=\"$CORE_INCS $ngx_module_incs\"\n     fi\n@@ -107,7 +130,24 @@ elif [ \"$ngx_module_link\" = ADDON ]; then\n     eval ${ngx_module_type}_MODULES=\\\"\\$${ngx_module_type}_MODULES \\\n                                       $ngx_module_name\\\"\n \n-    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_module_srcs\"\n+    srcs=\n+    for src in $ngx_module_srcs\n+    do\n+        found=no\n+        for old in $NGX_ADDON_SRCS\n+        do\n+            if [ $src = $old ]; then\n+                found=yes\n+                break\n+            fi\n+        done\n+\n+        if [ $found = no ]; then\n+            srcs=\"$srcs $src\"\n+        fi\n+    done\n+\n+    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $srcs\"\n \n     if test -n \"$ngx_module_incs\"; then\n         eval ${ngx_var}_INCS=\\\"\\$${ngx_var}_INCS $ngx_module_incs\\\"\nDiff:\n@@ -132,6 +132,7 @@ STREAM_UPSTREAM_ZONE=YES\n STREAM_SSL_PREREAD=NO\n \n DYNAMIC_MODULES=\n+DYNAMIC_MODULES_SRCS=\n \n NGX_ADDONS=\n NGX_ADDON_SRCS=\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 56",
        "commit_diff": "Diff:\n@@ -313,7 +313,7 @@ $ngx_obj:\t\\$(CORE_DEPS) \\$(HTTP_DEPS)$ngx_cont$ngx_src\n END\n \n         fi\n-     done\n+    done\n \n fi\n \n@@ -343,7 +343,7 @@ $ngx_obj:\t\\$(CORE_DEPS) \\$(MAIL_DEPS)$ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \n@@ -373,7 +373,7 @@ $ngx_obj:\t\\$(CORE_DEPS) \\$(STREAM_DEPS)$ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \n@@ -399,7 +399,7 @@ $ngx_obj:\t\\$(CORE_DEPS) $ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \n@@ -431,7 +431,7 @@ $ngx_obj:\t\\$(ADDON_DEPS)$ngx_cont$ngx_src\n \t$ngx_cc$ngx_tab$ngx_objout$ngx_obj$ngx_tab$ngx_src$NGX_AUX\n \n END\n-     done\n+    done\n \n fi\n \nDiff:\n@@ -134,6 +134,7 @@ STREAM_SSL_PREREAD=NO\n DYNAMIC_MODULES=\n \n NGX_ADDONS=\n+NGX_ADDON_SRCS=\n NGX_ADDON_DEPS=\n DYNAMIC_ADDONS=\n \nDiff:\n@@ -137,8 +137,9 @@ ngx_http_read_client_request_body(ngx_http_request_t *r,\n     } else {\n         /* set rb->rest */\n \n-        if (ngx_http_request_body_filter(r, NULL) != NGX_OK) {\n-            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        rc = ngx_http_request_body_filter(r, NULL);\n+\n+        if (rc != NGX_OK) {\n             goto done;\n         }\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 55",
        "commit_diff": "Diff:\n@@ -53,7 +53,7 @@ static void ngx_http_request_finalizer(ngx_http_request_t *r);\n \n static void ngx_http_set_keepalive(ngx_http_request_t *r);\n static void ngx_http_keepalive_handler(ngx_event_t *ev);\n-static void ngx_http_set_lingering_close(ngx_http_request_t *r);\n+static void ngx_http_set_lingering_close(ngx_connection_t *c);\n static void ngx_http_lingering_close_handler(ngx_event_t *ev);\n static ngx_int_t ngx_http_post_action(ngx_http_request_t *r);\n static void ngx_http_close_request(ngx_http_request_t *r, ngx_int_t error);\n@@ -2773,7 +2773,7 @@ ngx_http_finalize_connection(ngx_http_request_t *r)\n                 || r->header_in->pos < r->header_in->last\n                 || r->connection->read->ready)))\n     {\n-        ngx_http_set_lingering_close(r);\n+        ngx_http_set_lingering_close(r->connection);\n         return;\n     }\n \n@@ -3387,22 +3387,43 @@ ngx_http_keepalive_handler(ngx_event_t *rev)\n \n \n static void\n-ngx_http_set_lingering_close(ngx_http_request_t *r)\n+ngx_http_set_lingering_close(ngx_connection_t *c)\n {\n     ngx_event_t               *rev, *wev;\n-    ngx_connection_t          *c;\n+    ngx_http_request_t        *r;\n     ngx_http_core_loc_conf_t  *clcf;\n \n-    c = r->connection;\n+    r = c->data;\n \n     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n \n+    if (r->lingering_time == 0) {\n+        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n+    }\n+\n+#if (NGX_HTTP_SSL)\n+    if (c->ssl) {\n+        ngx_int_t  rc;\n+\n+        rc = ngx_ssl_shutdown(c);\n+\n+        if (rc == NGX_ERROR) {\n+            ngx_http_close_request(r, 0);\n+            return;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->ssl->handler = ngx_http_set_lingering_close;\n+            return;\n+        }\n+\n+        c->recv = ngx_recv;\n+    }\n+#endif\n+\n     rev = c->read;\n     rev->handler = ngx_http_lingering_close_handler;\n \n-    r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n-    ngx_add_timer(rev, clcf->lingering_timeout);\n-\n     if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n         ngx_http_close_request(r, 0);\n         return;\n@@ -3425,6 +3446,8 @@ ngx_http_set_lingering_close(ngx_http_request_t *r)\n         return;\n     }\n \n+    ngx_add_timer(rev, clcf->lingering_timeout);\n+\n     if (rev->ready) {\n         ngx_http_lingering_close_handler(rev);\n     }\nDiff:\n@@ -305,6 +305,9 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n                         return NGX_AGAIN;\n                     }\n \n+                    ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n+                                  \"busy buffers after request body flush\");\n+\n                     return NGX_HTTP_INTERNAL_SERVER_ERROR;\n                 }\n \n@@ -674,6 +677,7 @@ ngx_http_discarded_request_body_handler(ngx_http_request_t *r)\n     if (rc == NGX_OK) {\n         r->discard_body = 0;\n         r->lingering_close = 0;\n+        r->lingering_time = 0;\n         ngx_http_finalize_request(r, NGX_DONE);\n         return;\n     }\nDiff:\n@@ -60,7 +60,7 @@ typedef struct {\n static void ngx_http_v2_read_handler(ngx_event_t *rev);\n static void ngx_http_v2_write_handler(ngx_event_t *wev);\n static void ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c);\n-static void ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c);\n+static void ngx_http_v2_lingering_close(ngx_connection_t *c);\n static void ngx_http_v2_lingering_close_handler(ngx_event_t *rev);\n \n static u_char *ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c,\n@@ -664,7 +664,7 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n     }\n \n     if (h2c->goaway) {\n-        ngx_http_v2_lingering_close(h2c);\n+        ngx_http_v2_lingering_close(c);\n         return;\n     }\n \n@@ -703,13 +703,13 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n \n \n static void\n-ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n+ngx_http_v2_lingering_close(ngx_connection_t *c)\n {\n     ngx_event_t               *rev, *wev;\n-    ngx_connection_t          *c;\n+    ngx_http_v2_connection_t  *h2c;\n     ngx_http_core_loc_conf_t  *clcf;\n \n-    c = h2c->connection;\n+    h2c = c->data;\n \n     clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n                                         ngx_http_core_module);\n@@ -719,12 +719,34 @@ ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    if (h2c->lingering_time == 0) {\n+        h2c->lingering_time = ngx_time()\n+                              + (time_t) (clcf->lingering_time / 1000);\n+    }\n+\n+#if (NGX_HTTP_SSL)\n+    if (c->ssl) {\n+        ngx_int_t  rc;\n+\n+        rc = ngx_ssl_shutdown(c);\n+\n+        if (rc == NGX_ERROR) {\n+            ngx_http_close_connection(c);\n+            return;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->ssl->handler = ngx_http_v2_lingering_close;\n+            return;\n+        }\n+\n+        c->recv = ngx_recv;\n+    }\n+#endif\n+\n     rev = c->read;\n     rev->handler = ngx_http_v2_lingering_close_handler;\n \n-    h2c->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n-    ngx_add_timer(rev, clcf->lingering_timeout);\n-\n     if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n         ngx_http_close_connection(c);\n         return;\n@@ -747,6 +769,8 @@ ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n         return;\n     }\n \n+    ngx_add_timer(rev, clcf->lingering_timeout);\n+\n     if (rev->ready) {\n         ngx_http_v2_lingering_close_handler(rev);\n     }\n@@ -4757,7 +4781,7 @@ ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n         return;\n     }\n \n-    ngx_http_v2_lingering_close(h2c);\n+    ngx_http_v2_lingering_close(c);\n }\n \n \n",
        "analysis": "Based on the given diffs, we have two newly added entire functions to analyze:\n\n1. `ngx_http_set_lingering_close(ngx_connection_t *c)`\n2. `ngx_http_v2_lingering_close(ngx_connection_t *c)`\n\nLet's analyze them:\n\n### 1. Function `ngx_http_set_lingering_close(ngx_connection_t *c)`\n- Initializes local variables: `rev`, `wev`, `r`, and `clcf`.\n- Assigns `r` from `c->data`.\n- Checks if `r->lingering_time == 0` and updates it with a specific formula involving `ngx_time` and `clcf->lingering_time`.\n- There is a conditional compilation for handling SSL connections. If SSL is present:\n  - Calls `ngx_ssl_shutdown` and checks the result:\n    - If `NGX_ERROR`, it closes the request.\n    - If `NGX_AGAIN`, sets `c->ssl->handler` and exits.\n  - Sets `c->recv` to `ngx_recv`.\n- Configures the read event `rev` handler and adds a timer using `ngx_add_timer`.\n- If `ngx_handle_read_event` is not successful, it closes the request.\n- Checks if the write event `wev` exists, has a pending write, and flushes writes.\n- Finally, if `rev->ready`, calls `ngx_http_lingering_close_handler`.\n\n### 2. Function `ngx_http_v2_lingering_close(ngx_connection_t *c)`\n- Initializes local variables: `rev`, `wev`, and `clcf`.\n- Assigns `h2c` from `c->data`.\n- If `ngx_event_flags` doesn't support level event or `ngx_event_flags` is not clear event, it exits early.\n- Checks if `h2c->lingering_time == 0` and updates it similarly as in the first function.\n- Also has a conditional compilation for SSL handling:\n  - Calls `ngx_ssl_shutdown` and checks the result similarly to the first function.\n- Configures the read event `rev` handler and adds a timer using `ngx_add_timer`.\n- If `ngx_handle_read_event` is not successful, it closes the connection.\n- Checks if the write event `wev` exists, has a pending write, and flushes writes.\n- Finally, calls `ngx_http_v2_lingering_close_handler` if `rev->ready`.\n\n### Analysis\n- Both functions handle connection closure with SSL and non-SSL pathways.\n- They appear to handle the read and write events cautiously, setting timers and checking for readiness.\n- However, without deeper context of `ngx_http_get_module_loc_conf`, potential expansion logic (timers), and SSL handling implications, it's hard to definitively say there is an out-of-bounds write.\n- Possible concerns might arise from improper handling of SSL shutdowns, timers, or read/write readiness checks, but no explicit out-of-bounds writes are evident from the diffs in these functions.\n\nSince there's a possibility (though not confirmed) of out-of-bounds concerns related to unspecified logic in `ngx_http_get_module_loc_conf` or interaction with event handling systems:\n\n```\nTRUE [ngx_http_set_lingering_close] [ngx_http_v2_lingering_close]\n```"
    },
    {
        "commit_index": "Commit 54",
        "commit_diff": "Diff:\n@@ -11,6 +11,8 @@\n \n static u_char *ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64,\n     u_char zero, ngx_uint_t hexadecimal, ngx_uint_t width);\n+static u_char *ngx_sprintf_str(u_char *buf, u_char *last, u_char *src,\n+    size_t len, ngx_uint_t hexadecimal);\n static void ngx_encode_base64_internal(ngx_str_t *dst, ngx_str_t *src,\n     const u_char *basis, ngx_uint_t padding);\n static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst, ngx_str_t *src,\n@@ -101,10 +103,10 @@ ngx_pstrdup(ngx_pool_t *pool, ngx_str_t *src)\n  *    %M                        ngx_msec_t\n  *    %r                        rlim_t\n  *    %p                        void *\n- *    %V                        ngx_str_t *\n- *    %v                        ngx_variable_value_t *\n- *    %s                        null-terminated string\n- *    %*s                       length and string\n+ *    %[x|X]V                   ngx_str_t *\n+ *    %[x|X]v                   ngx_variable_value_t *\n+ *    %[x|X]s                   null-terminated string\n+ *    %*[x|X]s                  length and string\n  *    %Z                        '\\0'\n  *    %N                        '\\n'\n  *    %c                        char\n@@ -165,7 +167,7 @@ ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)\n     u_char                *p, zero;\n     int                    d;\n     double                 f;\n-    size_t                 len, slen;\n+    size_t                 slen;\n     int64_t                i64;\n     uint64_t               ui64, frac;\n     ngx_msec_t             ms;\n@@ -250,34 +252,23 @@ ngx_vslprintf(u_char *buf, u_char *last, const char *fmt, va_list args)\n             case 'V':\n                 v = va_arg(args, ngx_str_t *);\n \n-                len = ngx_min(((size_t) (last - buf)), v->len);\n-                buf = ngx_cpymem(buf, v->data, len);\n+                buf = ngx_sprintf_str(buf, last, v->data, v->len, hex);\n                 fmt++;\n \n                 continue;\n \n             case 'v':\n                 vv = va_arg(args, ngx_variable_value_t *);\n \n-                len = ngx_min(((size_t) (last - buf)), vv->len);\n-                buf = ngx_cpymem(buf, vv->data, len);\n+                buf = ngx_sprintf_str(buf, last, vv->data, vv->len, hex);\n                 fmt++;\n \n                 continue;\n \n             case 's':\n                 p = va_arg(args, u_char *);\n \n-                if (slen == (size_t) -1) {\n-                    while (*p && buf < last) {\n-                        *buf++ = *p++;\n-                    }\n-\n-                } else {\n-                    len = ngx_min(((size_t) (last - buf)), slen);\n-                    buf = ngx_cpymem(buf, p, len);\n-                }\n-\n+                buf = ngx_sprintf_str(buf, last, p, slen, hex);\n                 fmt++;\n \n                 continue;\n@@ -576,6 +567,64 @@ ngx_sprintf_num(u_char *buf, u_char *last, uint64_t ui64, u_char zero,\n }\n \n \n+static u_char *\n+ngx_sprintf_str(u_char *buf, u_char *last, u_char *src, size_t len,\n+    ngx_uint_t hexadecimal)\n+{\n+    static u_char   hex[] = \"0123456789abcdef\";\n+    static u_char   HEX[] = \"0123456789ABCDEF\";\n+\n+    if (hexadecimal == 0) {\n+\n+        if (len == (size_t) -1) {\n+            while (*src && buf < last) {\n+                *buf++ = *src++;\n+            }\n+\n+        } else {\n+            len = ngx_min((size_t) (last - buf), len);\n+            buf = ngx_cpymem(buf, src, len);\n+        }\n+\n+    } else if (hexadecimal == 1) {\n+\n+        if (len == (size_t) -1) {\n+\n+            while (*src && buf < last - 1) {\n+                *buf++ = hex[*src >> 4];\n+                *buf++ = hex[*src++ & 0xf];\n+            }\n+\n+        } else {\n+\n+            while (len-- && buf < last - 1) {\n+                *buf++ = hex[*src >> 4];\n+                *buf++ = hex[*src++ & 0xf];\n+            }\n+        }\n+\n+    } else { /* hexadecimal == 2 */\n+\n+        if (len == (size_t) -1) {\n+\n+            while (*src && buf < last - 1) {\n+                *buf++ = HEX[*src >> 4];\n+                *buf++ = HEX[*src++ & 0xf];\n+            }\n+\n+        } else {\n+\n+            while (len-- && buf < last - 1) {\n+                *buf++ = HEX[*src >> 4];\n+                *buf++ = HEX[*src++ & 0xf];\n+            }\n+        }\n+    }\n+\n+    return buf;\n+}\n+\n+\n /*\n  * We use ngx_strcasecmp()/ngx_strncasecmp() for 7-bit ASCII strings only,\n  * and implement our own ngx_strcasecmp()/ngx_strncasecmp()\nDiff:\n@@ -4057,9 +4057,6 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n     ngx_ssl_session_ticket_key_t  *key;\n     const EVP_MD                  *digest;\n     const EVP_CIPHER              *cipher;\n-#if (NGX_DEBUG)\n-    u_char                         buf[32];\n-#endif\n \n     c = ngx_ssl_get_connection(ssl_conn);\n     ssl_ctx = c->ssl->session_ctx;\n@@ -4081,8 +4078,8 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         /* encrypt session ticket */\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket encrypt, key: \\\"%*s\\\" (%s session)\",\n-                       ngx_hex_dump(buf, key[0].name, 16) - buf, buf,\n+                       \"ssl session ticket encrypt, key: \\\"%*xs\\\" (%s session)\",\n+                       (size_t) 16, key[0].name,\n                        SSL_session_reused(ssl_conn) ? \"reused\" : \"new\");\n \n         if (key[0].size == 48) {\n@@ -4128,17 +4125,16 @@ ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,\n         }\n \n         ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*s\\\" not found\",\n-                       ngx_hex_dump(buf, name, 16) - buf, buf);\n+                       \"ssl session ticket decrypt, key: \\\"%*xs\\\" not found\",\n+                       (size_t) 16, name);\n \n         return 0;\n \n     found:\n \n         ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                       \"ssl session ticket decrypt, key: \\\"%*s\\\"%s\",\n-                       ngx_hex_dump(buf, key[i].name, 16) - buf, buf,\n-                       (i == 0) ? \" (default)\" : \"\");\n+                       \"ssl session ticket decrypt, key: \\\"%*xs\\\"%s\",\n+                       (size_t) 16, key[i].name, (i == 0) ? \" (default)\" : \"\");\n \n         if (key[i].size == 48) {\n             cipher = EVP_aes_128_cbc();\nDiff:\n@@ -2662,16 +2662,8 @@ ngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx)\n     p = ngx_cpymem(p, serial->data, serial->length);\n     ngx_memzero(p, 20 - serial->length);\n \n-#if (NGX_DEBUG)\n-    {\n-        u_char  buf[120];\n-\n-        ngx_hex_dump(buf, ctx->key.data, ctx->key.len);\n-\n-        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n-                       \"ssl ocsp key %*s\", sizeof(buf), buf);\n-    }\n-#endif\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp key %xV\", &ctx->key);\n \n     return NGX_OK;\n }\nDiff:\n@@ -1141,20 +1141,11 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n \n     f->flags |= NGX_HTTP_V2_END_HEADERS_FLAG;\n \n-#if (NGX_DEBUG)\n-    if (r->connection->log->log_level & NGX_LOG_DEBUG_HTTP) {\n-        u_char  buf[512];\n-        size_t  n, m;\n-\n-        n = ngx_min(b->last - b->pos, 256);\n-        m = ngx_hex_dump(buf, b->pos, n) - buf;\n-\n-        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"grpc header: %*s%s, len: %uz\",\n-                       m, buf, b->last - b->pos > 256 ? \"...\" : \"\",\n-                       b->last - b->pos);\n-    }\n-#endif\n+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"grpc header: %*xs%s, len: %uz\",\n+                   (size_t) ngx_min(b->last - b->pos, 256), b->pos,\n+                   b->last - b->pos > 256 ? \"...\" : \"\",\n+                   b->last - b->pos);\n \n     if (r->request_body_no_buffering) {\n \n@@ -1604,20 +1595,11 @@ ngx_http_grpc_process_header(ngx_http_request_t *r)\n     u = r->upstream;\n     b = &u->buffer;\n \n-#if (NGX_DEBUG)\n-    if (r->connection->log->log_level & NGX_LOG_DEBUG_HTTP) {\n-        u_char  buf[512];\n-        size_t  n, m;\n-\n-        n = ngx_min(b->last - b->pos, 256);\n-        m = ngx_hex_dump(buf, b->pos, n) - buf;\n-\n-        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"grpc response: %*s%s, len: %uz\",\n-                       m, buf, b->last - b->pos > 256 ? \"...\" : \"\",\n-                       b->last - b->pos);\n-    }\n-#endif\n+    ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"grpc response: %*xs%s, len: %uz\",\n+                   (size_t) ngx_min(b->last - b->pos, 256),\n+                   b->pos, b->last - b->pos > 256 ? \"...\" : \"\",\n+                   b->last - b->pos);\n \n     ctx = ngx_http_grpc_get_ctx(r);\n \nDiff:\n@@ -3058,13 +3058,6 @@ ngx_http_set_keepalive(ngx_http_request_t *r)\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, \"set http keepalive handler\");\n \n-    if (r->discard_body) {\n-        r->write_event_handler = ngx_http_request_empty_handler;\n-        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n-        ngx_add_timer(rev, clcf->lingering_timeout);\n-        return;\n-    }\n-\n     c->log->action = \"closing request\";\n \n     hc = r->http_connection;\n",
        "analysis": "A new function `ngx_sprintf_str` has been added to the code. Let's analyze it line by line for potential out-of-bounds write vulnerabilities.\n\n```c\nstatic u_char *\nngx_sprintf_str(u_char *buf, u_char *last, u_char *src, size_t len,\n    ngx_uint_t hexadecimal)\n{\n    static u_char   hex[] = \"0123456789abcdef\";\n    static u_char   HEX[] = \"0123456789ABCDEF\";\n    \n    if (hexadecimal == 0) {\n\n        if (len == (size_t) -1) {\n            while (*src && buf < last) {\n                *buf++ = *src++;\n            }\n\n        } else {\n            len = ngx_min((size_t) (last - buf), len);\n            buf = ngx_cpymem(buf, src, len);\n        }\n\n    } else if (hexadecimal == 1) {\n\n        if (len == (size_t) -1) {\n\n            while (*src && buf < last - 1) {\n                *buf++ = hex[*src >> 4];\n                *buf++ = hex[*src++ & 0xf];\n            }\n\n        } else {\n\n            while (len-- && buf < last - 1) {\n                *buf++ = hex[*src >> 4];\n                *buf++ = hex[*src++ & 0xf];\n            }\n        }\n\n    } else { /* hexadecimal == 2 */\n\n        if (len == (size_t) -1) {\n\n            while (*src && buf < last - 1) {\n                *buf++ = HEX[*src >> 4];\n                *buf++ = HEX[*src++ & 0xf];\n            }\n\n        } else {\n\n            while (len-- && buf < last - 1) {\n                *buf++ = HEX[*src >> 4];\n                *buf++ = HEX[*src++ & 0xf];\n            }\n        }\n    }\n\n    return buf;\n}\n```\n\n**Analysis:**\n\n1. **Function Definition:**\n   - The function `ngx_sprintf_str` takes a buffer `buf`, a pointer `last` marking the buffer's end, a source string `src`, a length `len`, and an integer `hexadecimal` flag. The function appears to copy or transform the input string `src` into `buf`, opting for different behaviors depending on `hexadecimal`.\n\n2. **Buffer Limits:**\n   - For copying operations, the function ensures that it does not write beyond `last`. It uses a while loop with the condition `buf < last` when `hexadecimal == 0` or `buf < last - 1` when `hexadecimal != 0`. This is important as writing beyond `last` could result in an out-of-bounds write.\n\n3. **Potential Issues:**\n   - If there's an off-by-one error or if `buf` is manipulated improperly outside this function, there might be potential for out-of-bounds writes, especially since the check for length `len` might not align perfectly with the buffer space `last - buf`.\n\n4. **User-Supplied Parameters:**\n   - The length parameter `len` is user-supplied, so if it is not properly validated outside this function, it could be set incorrectly, potentially leading to buffer overflows even within the bounds-checked loops (though the internal logic seems to handle this by using `ngx_min` to minimize out-of-bounds risks).\n\nThe logic within `ngx_sprintf_str` appears to have put measures in place generally protecting against writing out-of-bounds by limiting the buffer manipulation appropriately. Nevertheless, potential risks always exist if the caller does not ensure the buffer is adequately sized or if there are logical errors elsewhere. Given the context provided, it appears the implementation has some level of safeguards; however, careful external validation of input and buffer sizes is crucial.\n\nBased on this analysis, there's a suspicion of potential vulnerabilities needing verification and strict input validations, which suggest returning \"TRUE\" for further scrutiny.\n\n**Conclusion:**\n\nTRUE [ngx_sprintf_str]"
    },
    {
        "commit_index": "Commit 53",
        "commit_diff": "Diff:\n@@ -453,3 +453,4 @@ cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n 062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\n a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n 3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\n+dc0cc425fa63a80315f6efb68697cadb6626cdf2 release-1.19.4\nDiff:\n@@ -5,6 +5,40 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.4\" date=\"2020-10-27\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директивы ssl_conf_command, proxy_ssl_conf_command, grpc_ssl_conf_command\n+и uwsgi_ssl_conf_command.\n+</para>\n+<para lang=\"en\">\n+the \"ssl_conf_command\", \"proxy_ssl_conf_command\", \"grpc_ssl_conf_command\",\n+and \"uwsgi_ssl_conf_command\" directives.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива ssl_reject_handshake.\n+</para>\n+<para lang=\"en\">\n+the \"ssl_reject_handshake\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива proxy_smtp_auth в почтовом прокси-сервере.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_smtp_auth\" directive in mail proxy.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.3\" date=\"2020-09-29\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019004\n-#define NGINX_VERSION      \"1.19.4\"\n+#define nginx_version      1019005\n+#define NGINX_VERSION      \"1.19.5\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 52",
        "commit_diff": "Diff:\n@@ -1793,6 +1793,13 @@ ngx_ssl_handshake(ngx_connection_t *c)\n         return NGX_ERROR;\n     }\n \n+    if (c->ssl->handshake_rejected) {\n+        ngx_connection_error(c, err, \"handshake rejected\");\n+        ERR_clear_error();\n+\n+        return NGX_ERROR;\n+    }\n+\n     c->read->error = 1;\n \n     ngx_ssl_connection_error(c, sslerr, err, \"SSL_do_handshake() failed\");\n@@ -3354,8 +3361,9 @@ ngx_ssl_session_id_context(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n         }\n     }\n \n-    if (SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index) == NULL) {\n-\n+    if (SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index) == NULL\n+        && certificates != NULL)\n+    {\n         /*\n          * If certificates are loaded dynamically, we use certificate\n          * names as specified in the configuration (with variables).\nDiff:\n@@ -95,6 +95,7 @@ struct ngx_ssl_connection_s {\n     u_char                      early_buf;\n \n     unsigned                    handshaked:1;\n+    unsigned                    handshake_rejected:1;\n     unsigned                    renegotiation:1;\n     unsigned                    buffer:1;\n     unsigned                    no_wait_shutdown:1;\nDiff:\n@@ -294,6 +294,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, conf_commands),\n       &ngx_http_ssl_conf_command_post },\n \n+    { ngx_string(\"ssl_reject_handshake\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, reject_handshake),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -614,6 +621,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->enable = NGX_CONF_UNSET;\n     sscf->prefer_server_ciphers = NGX_CONF_UNSET;\n     sscf->early_data = NGX_CONF_UNSET;\n+    sscf->reject_handshake = NGX_CONF_UNSET;\n     sscf->buffer_size = NGX_CONF_UNSET_SIZE;\n     sscf->verify = NGX_CONF_UNSET_UINT;\n     sscf->verify_depth = NGX_CONF_UNSET_UINT;\n@@ -660,6 +668,7 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                          prev->prefer_server_ciphers, 0);\n \n     ngx_conf_merge_value(conf->early_data, prev->early_data, 0);\n+    ngx_conf_merge_value(conf->reject_handshake, prev->reject_handshake, 0);\n \n     ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,\n                          (NGX_CONF_BITMASK_SET|NGX_SSL_TLSv1\n@@ -707,38 +716,35 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     if (conf->enable) {\n \n-        if (conf->certificates == NULL) {\n-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n-                          \"no \\\"ssl_certificate\\\" is defined for \"\n-                          \"the \\\"ssl\\\" directive in %s:%ui\",\n-                          conf->file, conf->line);\n-            return NGX_CONF_ERROR;\n-        }\n+        if (conf->certificates) {\n+            if (conf->certificate_keys == NULL) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"no \\\"ssl_certificate_key\\\" is defined for \"\n+                              \"the \\\"ssl\\\" directive in %s:%ui\",\n+                              conf->file, conf->line);\n+                return NGX_CONF_ERROR;\n+            }\n \n-        if (conf->certificate_keys == NULL) {\n-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n-                          \"no \\\"ssl_certificate_key\\\" is defined for \"\n-                          \"the \\\"ssl\\\" directive in %s:%ui\",\n-                          conf->file, conf->line);\n-            return NGX_CONF_ERROR;\n-        }\n+            if (conf->certificate_keys->nelts < conf->certificates->nelts) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"no \\\"ssl_certificate_key\\\" is defined \"\n+                              \"for certificate \\\"%V\\\" and \"\n+                              \"the \\\"ssl\\\" directive in %s:%ui\",\n+                              ((ngx_str_t *) conf->certificates->elts)\n+                              + conf->certificates->nelts - 1,\n+                              conf->file, conf->line);\n+                return NGX_CONF_ERROR;\n+            }\n \n-        if (conf->certificate_keys->nelts < conf->certificates->nelts) {\n+        } else if (!conf->reject_handshake) {\n             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n-                          \"no \\\"ssl_certificate_key\\\" is defined \"\n-                          \"for certificate \\\"%V\\\" and \"\n+                          \"no \\\"ssl_certificate\\\" is defined for \"\n                           \"the \\\"ssl\\\" directive in %s:%ui\",\n-                          ((ngx_str_t *) conf->certificates->elts)\n-                          + conf->certificates->nelts - 1,\n                           conf->file, conf->line);\n             return NGX_CONF_ERROR;\n         }\n \n-    } else {\n-\n-        if (conf->certificates == NULL) {\n-            return NGX_CONF_OK;\n-        }\n+    } else if (conf->certificates) {\n \n         if (conf->certificate_keys == NULL\n             || conf->certificate_keys->nelts < conf->certificates->nelts)\n@@ -750,6 +756,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n                           + conf->certificates->nelts - 1);\n             return NGX_CONF_ERROR;\n         }\n+\n+    } else if (!conf->reject_handshake) {\n+        return NGX_CONF_OK;\n     }\n \n     if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {\n@@ -808,7 +817,7 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n #endif\n \n-    } else {\n+    } else if (conf->certificates) {\n \n         /* configure certificates */\n \n@@ -947,6 +956,10 @@ ngx_http_ssl_compile_certificates(ngx_conf_t *cf,\n     ngx_http_complex_value_t          *cv;\n     ngx_http_compile_complex_value_t   ccv;\n \n+    if (conf->certificates == NULL) {\n+        return NGX_OK;\n+    }\n+\n     cert = conf->certificates->elts;\n     key = conf->certificate_keys->elts;\n     nelts = conf->certificates->nelts;\n@@ -1327,7 +1340,33 @@ ngx_http_ssl_init(ngx_conf_t *cf)\n             cscf = addr[a].default_server;\n             sscf = cscf->ctx->srv_conf[ngx_http_ssl_module.ctx_index];\n \n-            if (sscf->certificates == NULL) {\n+            if (sscf->certificates) {\n+                continue;\n+            }\n+\n+            if (!sscf->reject_handshake) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"no \\\"ssl_certificate\\\" is defined for \"\n+                              \"the \\\"listen ... ssl\\\" directive in %s:%ui\",\n+                              cscf->file_name, cscf->line);\n+                return NGX_ERROR;\n+            }\n+\n+            /*\n+             * if no certificates are defined in the default server,\n+             * check all non-default server blocks\n+             */\n+\n+            cscfp = addr[a].servers.elts;\n+            for (s = 0; s < addr[a].servers.nelts; s++) {\n+\n+                cscf = cscfp[s];\n+                sscf = cscf->ctx->srv_conf[ngx_http_ssl_module.ctx_index];\n+\n+                if (sscf->certificates || sscf->reject_handshake) {\n+                    continue;\n+                }\n+\n                 ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                               \"no \\\"ssl_certificate\\\" is defined for \"\n                               \"the \\\"listen ... ssl\\\" directive in %s:%ui\",\nDiff:\n@@ -21,6 +21,7 @@ typedef struct {\n \n     ngx_flag_t                      prefer_server_ciphers;\n     ngx_flag_t                      early_data;\n+    ngx_flag_t                      reject_handshake;\n \n     ngx_uint_t                      protocols;\n \nDiff:\n@@ -885,10 +885,14 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n         return SSL_TLSEXT_ERR_ALERT_FATAL;\n     }\n \n+    hc = c->data;\n+\n     servername = SSL_get_servername(ssl_conn, TLSEXT_NAMETYPE_host_name);\n \n     if (servername == NULL) {\n-        return SSL_TLSEXT_ERR_OK;\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                       \"SSL server name: null\");\n+        goto done;\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n@@ -897,40 +901,35 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n     host.len = ngx_strlen(servername);\n \n     if (host.len == 0) {\n-        return SSL_TLSEXT_ERR_OK;\n+        goto done;\n     }\n \n     host.data = (u_char *) servername;\n \n     rc = ngx_http_validate_host(&host, c->pool, 1);\n \n     if (rc == NGX_ERROR) {\n-        *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        goto error;\n     }\n \n     if (rc == NGX_DECLINED) {\n-        return SSL_TLSEXT_ERR_OK;\n+        goto done;\n     }\n \n-    hc = c->data;\n-\n     rc = ngx_http_find_virtual_server(c, hc->addr_conf->virtual_names, &host,\n                                       NULL, &cscf);\n \n     if (rc == NGX_ERROR) {\n-        *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        goto error;\n     }\n \n     if (rc == NGX_DECLINED) {\n-        return SSL_TLSEXT_ERR_OK;\n+        goto done;\n     }\n \n     hc->ssl_servername = ngx_palloc(c->pool, sizeof(ngx_str_t));\n     if (hc->ssl_servername == NULL) {\n-        *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        goto error;\n     }\n \n     *hc->ssl_servername = host;\n@@ -947,8 +946,7 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n \n     if (sscf->ssl.ctx) {\n         if (SSL_set_SSL_CTX(ssl_conn, sscf->ssl.ctx) == NULL) {\n-            *ad = SSL_AD_INTERNAL_ERROR;\n-            return SSL_TLSEXT_ERR_ALERT_FATAL;\n+            goto error;\n         }\n \n         /*\n@@ -974,7 +972,22 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n #endif\n     }\n \n+done:\n+\n+    sscf = ngx_http_get_module_srv_conf(hc->conf_ctx, ngx_http_ssl_module);\n+\n+    if (sscf->reject_handshake) {\n+        c->ssl->handshake_rejected = 1;\n+        *ad = SSL_AD_UNRECOGNIZED_NAME;\n+        return SSL_TLSEXT_ERR_ALERT_FATAL;\n+    }\n+\n     return SSL_TLSEXT_ERR_OK;\n+\n+error:\n+\n+    *ad = SSL_AD_INTERNAL_ERROR;\n+    return SSL_TLSEXT_ERR_ALERT_FATAL;\n }\n \n #endif\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 51",
        "commit_diff": "Diff:\n@@ -40,6 +40,7 @@ typedef struct {\n     ngx_str_t                  ssl_certificate;\n     ngx_str_t                  ssl_certificate_key;\n     ngx_array_t               *ssl_passwords;\n+    ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_grpc_loc_conf_t;\n \n@@ -208,6 +209,8 @@ static char *ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd,\n #if (NGX_HTTP_SSL)\n static char *ngx_http_grpc_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n+static char *ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n static ngx_int_t ngx_http_grpc_set_ssl(ngx_conf_t *cf,\n     ngx_http_grpc_loc_conf_t *glcf);\n #endif\n@@ -242,6 +245,9 @@ static ngx_conf_bitmask_t  ngx_http_grpc_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_http_grpc_ssl_conf_command_post =\n+    { ngx_http_grpc_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -438,6 +444,13 @@ static ngx_command_t  ngx_http_grpc_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"grpc_ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_grpc_loc_conf_t, ssl_conf_commands),\n+      &ngx_http_grpc_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -4359,6 +4372,7 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     /* the hardcoded values */\n@@ -4469,6 +4483,9 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_certificate_key, \"\");\n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl && ngx_http_grpc_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -4836,6 +4853,17 @@ ngx_http_grpc_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n {\n@@ -4926,6 +4954,12 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)\n \n #endif\n \n+    if (ngx_ssl_conf_commands(cf, glcf->upstream.ssl, glcf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -127,6 +127,7 @@ typedef struct {\n     ngx_str_t                      ssl_certificate;\n     ngx_str_t                      ssl_certificate_key;\n     ngx_array_t                   *ssl_passwords;\n+    ngx_array_t                   *ssl_conf_commands;\n #endif\n } ngx_http_proxy_loc_conf_t;\n \n@@ -229,6 +230,10 @@ static char *ngx_http_proxy_ssl_password_file(ngx_conf_t *cf,\n #endif\n \n static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf, void *post, void *data);\n+#if (NGX_HTTP_SSL)\n+static char *ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+#endif\n \n static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf,\n     ngx_http_proxy_rewrite_t *pr, ngx_str_t *regex, ngx_uint_t caseless);\n@@ -274,6 +279,9 @@ static ngx_conf_bitmask_t  ngx_http_proxy_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_http_proxy_ssl_conf_command_post =\n+    { ngx_http_proxy_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -764,6 +772,13 @@ static ngx_command_t  ngx_http_proxy_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"proxy_ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_proxy_loc_conf_t, ssl_conf_commands),\n+      &ngx_http_proxy_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -3340,6 +3355,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     /* \"proxy_cyclic_temp_file\" is disabled */\n@@ -3687,6 +3703,9 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_certificate_key, \"\");\n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl && ngx_http_proxy_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -4845,6 +4864,17 @@ ngx_http_proxy_lowat_check(ngx_conf_t *cf, void *post, void *data)\n \n #if (NGX_HTTP_SSL)\n \n+static char *\n+ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n {\n@@ -4922,6 +4952,12 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)\n         return NGX_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, plcf->upstream.ssl, plcf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -57,6 +57,7 @@ typedef struct {\n     ngx_str_t                  ssl_certificate;\n     ngx_str_t                  ssl_certificate_key;\n     ngx_array_t               *ssl_passwords;\n+    ngx_array_t               *ssl_conf_commands;\n #endif\n } ngx_http_uwsgi_loc_conf_t;\n \n@@ -96,6 +97,8 @@ static char *ngx_http_uwsgi_cache_key(ngx_conf_t *cf, ngx_command_t *cmd,\n #if (NGX_HTTP_SSL)\n static char *ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n+static char *ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n static ngx_int_t ngx_http_uwsgi_set_ssl(ngx_conf_t *cf,\n     ngx_http_uwsgi_loc_conf_t *uwcf);\n #endif\n@@ -134,6 +137,9 @@ static ngx_conf_bitmask_t  ngx_http_uwsgi_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_http_uwsgi_ssl_conf_command_post =\n+    { ngx_http_uwsgi_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -561,6 +567,13 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"uwsgi_ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_uwsgi_loc_conf_t, ssl_conf_commands),\n+      &ngx_http_uwsgi_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -1500,6 +1513,7 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     /* \"uwsgi_cyclic_temp_file\" is disabled */\n@@ -1830,6 +1844,9 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                               prev->ssl_certificate_key, \"\");\n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl && ngx_http_uwsgi_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -2376,6 +2393,17 @@ ngx_http_uwsgi_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n {\n@@ -2453,6 +2481,12 @@ ngx_http_uwsgi_set_ssl(ngx_conf_t *cf, ngx_http_uwsgi_loc_conf_t *uwcf)\n         return NGX_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, uwcf->upstream.ssl, uwcf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \nDiff:\n@@ -49,6 +49,7 @@ typedef struct {\n     ngx_str_t                        ssl_certificate;\n     ngx_str_t                        ssl_certificate_key;\n     ngx_array_t                     *ssl_passwords;\n+    ngx_array_t                     *ssl_conf_commands;\n \n     ngx_ssl_t                       *ssl;\n #endif\n@@ -94,6 +95,8 @@ static char *ngx_stream_proxy_bind(ngx_conf_t *cf, ngx_command_t *cmd,\n static ngx_int_t ngx_stream_proxy_send_proxy_protocol(ngx_stream_session_t *s);\n static char *ngx_stream_proxy_ssl_password_file(ngx_conf_t *cf,\n     ngx_command_t *cmd, void *conf);\n+static char *ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n static void ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s);\n static void ngx_stream_proxy_ssl_handshake(ngx_connection_t *pc);\n static void ngx_stream_proxy_ssl_save_session(ngx_connection_t *c);\n@@ -112,6 +115,9 @@ static ngx_conf_bitmask_t  ngx_stream_proxy_ssl_protocols[] = {\n     { ngx_null_string, 0 }\n };\n \n+static ngx_conf_post_t  ngx_stream_proxy_ssl_conf_command_post =\n+    { ngx_stream_proxy_ssl_conf_command_check };\n+\n #endif\n \n \n@@ -331,6 +337,13 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"proxy_ssl_conf_command\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_proxy_srv_conf_t, ssl_conf_commands),\n+      &ngx_stream_proxy_ssl_conf_command_post },\n+\n #endif\n \n       ngx_null_command\n@@ -1008,6 +1021,17 @@ ngx_stream_proxy_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n }\n \n \n+static char *\n+ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static void\n ngx_stream_proxy_ssl_init_connection(ngx_stream_session_t *s)\n {\n@@ -1985,6 +2009,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)\n     conf->ssl_verify = NGX_CONF_UNSET;\n     conf->ssl_verify_depth = NGX_CONF_UNSET_UINT;\n     conf->ssl_passwords = NGX_CONF_UNSET_PTR;\n+    conf->ssl_conf_commands = NGX_CONF_UNSET_PTR;\n #endif\n \n     return conf;\n@@ -2072,6 +2097,9 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_ptr_value(conf->ssl_passwords, prev->ssl_passwords, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->ssl_conf_commands,\n+                              prev->ssl_conf_commands, NULL);\n+\n     if (conf->ssl_enable && ngx_stream_proxy_set_ssl(cf, conf) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -2156,6 +2184,12 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)\n         return NGX_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, pscf->ssl, pscf->ssl_conf_commands)\n+        != NGX_OK)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n     return NGX_OK;\n }\n \n",
        "analysis": "The diff contains newly added entire functions, which need to be analyzed for potential out-of-bounds write vulnerabilities. \n\n1. **Function**: `ngx_http_grpc_ssl_conf_command_check`\n   ```c\n   static char *\n   ngx_http_grpc_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n   {\n   #ifndef SSL_CONF_FLAG_FILE\n       return \"is not supported on this platform\";\n   #endif\n\n       return NGX_CONF_OK;\n   }\n   ```\n   - This function is basic in structure, performing a platform capability check for `SSL_CONF_FLAG_FILE`. It returns a static string or `NGX_CONF_OK` based on the condition, with no indications of an out-of-bounds write vulnerability as it does not involve buffer manipulation.\n\n2. **Function**: `ngx_http_proxy_ssl_conf_command_check`\n   ```c\n   static char *\n   ngx_http_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n   {\n   #ifndef SSL_CONF_FLAG_FILE\n       return \"is not supported on this platform\";\n   #endif\n\n       return NGX_CONF_OK;\n   }\n   ```\n   - Similar to the previous function, it checks for `SSL_CONF_FLAG_FILE` and returns strings accordingly, without any buffer operations, suggesting no apparent out-of-bounds vulnerability.\n\n3. **Function**: `ngx_http_uwsgi_ssl_conf_command_check`\n   ```c\n   static char *\n   ngx_http_uwsgi_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n   {\n   #ifndef SSL_CONF_FLAG_FILE\n       return \"is not supported on this platform\";\n   #endif\n\n       return NGX_CONF_OK;\n   }\n   ```\n   - This function is nearly identical to the previous two, performing a conditional check and returning specified strings. There are no buffer-related operations that could lead to an out-of-bounds write.\n\n4. **Function**: `ngx_stream_proxy_ssl_conf_command_check`\n   ```c\n   static char *\n   ngx_stream_proxy_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n   {\n   #ifndef SSL_CONF_FLAG_FILE\n       return \"is not supported on this platform\";\n   #endif\n\n       return NGX_CONF_OK;\n   }\n   ```\n   - Like the others, this function carries out a platform check and behaves similarly with return operations. No buffer manipulations that might cause concern for out-of-bounds writes.\n\nUpon examining the functionality and implementation of these newly added functions, none appear to involve operations that would typically contribute to out-of-bounds writes, such as buffer manipulations or direct memory access. Consequently, there do not appear to be any suspicious functions with potential out-of-bounds write vulnerabilities in the changes noted.\n\n**Result**: FALSE"
    },
    {
        "commit_index": "Commit 50",
        "commit_diff": "Diff:\n@@ -1470,6 +1470,78 @@ ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)\n }\n \n \n+ngx_int_t\n+ngx_ssl_conf_commands(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *commands)\n+{\n+    if (commands == NULL) {\n+        return NGX_OK;\n+    }\n+\n+#ifdef SSL_CONF_FLAG_FILE\n+    {\n+    int            type;\n+    u_char        *key, *value;\n+    ngx_uint_t     i;\n+    ngx_keyval_t  *cmd;\n+    SSL_CONF_CTX  *cctx;\n+\n+    cctx = SSL_CONF_CTX_new();\n+    if (cctx == NULL) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CONF_CTX_new() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_FILE);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SERVER);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CERTIFICATE);\n+    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SHOW_ERRORS);\n+\n+    SSL_CONF_CTX_set_ssl_ctx(cctx, ssl->ctx);\n+\n+    cmd = commands->elts;\n+    for (i = 0; i < commands->nelts; i++) {\n+\n+        key = cmd[i].key.data;\n+        type = SSL_CONF_cmd_value_type(cctx, (char *) key);\n+\n+        if (type == SSL_CONF_TYPE_FILE || type == SSL_CONF_TYPE_DIR) {\n+            if (ngx_conf_full_name(cf->cycle, &cmd[i].value, 1) != NGX_OK) {\n+                SSL_CONF_CTX_free(cctx);\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        value = cmd[i].value.data;\n+\n+        if (SSL_CONF_cmd(cctx, (char *) key, (char *) value) <= 0) {\n+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                          \"SSL_CONF_cmd(\\\"%s\\\", \\\"%s\\\") failed\", key, value);\n+            SSL_CONF_CTX_free(cctx);\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    if (SSL_CONF_CTX_finish(cctx) != 1) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CONF_finish() failed\");\n+        SSL_CONF_CTX_free(cctx);\n+        return NGX_ERROR;\n+    }\n+\n+    SSL_CONF_CTX_free(cctx);\n+\n+    return NGX_OK;\n+    }\n+#else\n+    ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,\n+                  \"SSL_CONF_cmd() is not available on this platform\");\n+    return NGX_ERROR;\n+#endif\n+}\n+\n+\n ngx_int_t\n ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t enable)\n {\nDiff:\n@@ -203,6 +203,9 @@ ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);\n ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);\n ngx_int_t ngx_ssl_early_data(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_uint_t enable);\n+ngx_int_t ngx_ssl_conf_commands(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_array_t *commands);\n+\n ngx_int_t ngx_ssl_client_session_cache(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_uint_t enable);\n ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n@@ -211,6 +214,7 @@ ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,\n ngx_int_t ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_array_t *paths);\n ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n+\n ngx_int_t ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c,\n     ngx_uint_t flags);\n \nDiff:\n@@ -53,6 +53,9 @@ static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n static char *ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \n+static char *ngx_http_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+\n static ngx_int_t ngx_http_ssl_init(ngx_conf_t *cf);\n \n \n@@ -89,6 +92,10 @@ static ngx_conf_deprecated_t  ngx_http_ssl_deprecated = {\n };\n \n \n+static ngx_conf_post_t  ngx_http_ssl_conf_command_post =\n+    { ngx_http_ssl_conf_command_check };\n+\n+\n static ngx_command_t  ngx_http_ssl_commands[] = {\n \n     { ngx_string(\"ssl\"),\n@@ -280,6 +287,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, early_data),\n       NULL },\n \n+    { ngx_string(\"ssl_conf_command\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, conf_commands),\n+      &ngx_http_ssl_conf_command_post },\n+\n       ngx_null_command\n };\n \n@@ -606,6 +620,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->certificates = NGX_CONF_UNSET_PTR;\n     sscf->certificate_keys = NGX_CONF_UNSET_PTR;\n     sscf->passwords = NGX_CONF_UNSET_PTR;\n+    sscf->conf_commands = NGX_CONF_UNSET_PTR;\n     sscf->builtin_session_cache = NGX_CONF_UNSET;\n     sscf->session_timeout = NGX_CONF_UNSET;\n     sscf->session_tickets = NGX_CONF_UNSET;\n@@ -675,6 +690,8 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_ptr_value(conf->conf_commands, prev->conf_commands, NULL);\n+\n     ngx_conf_merge_uint_value(conf->ocsp, prev->ocsp, 0);\n     ngx_conf_merge_str_value(conf->ocsp_responder, prev->ocsp_responder, \"\");\n     ngx_conf_merge_ptr_value(conf->ocsp_cache_zone,\n@@ -913,6 +930,10 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, &conf->ssl, conf->conf_commands) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     return NGX_CONF_OK;\n }\n \n@@ -1235,6 +1256,17 @@ ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_ssl_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -48,6 +48,7 @@ typedef struct {\n     ngx_str_t                       ciphers;\n \n     ngx_array_t                    *passwords;\n+    ngx_array_t                    *conf_commands;\n \n     ngx_shm_zone_t                 *shm_zone;\n \nDiff:\n@@ -26,6 +26,9 @@ static char *ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n static char *ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n \n+static char *ngx_mail_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+\n \n static ngx_conf_enum_t  ngx_mail_starttls_state[] = {\n     { ngx_string(\"off\"), NGX_MAIL_STARTTLS_OFF },\n@@ -61,6 +64,10 @@ static ngx_conf_deprecated_t  ngx_mail_ssl_deprecated = {\n };\n \n \n+static ngx_conf_post_t  ngx_mail_ssl_conf_command_post =\n+    { ngx_mail_ssl_conf_command_check };\n+\n+\n static ngx_command_t  ngx_mail_ssl_commands[] = {\n \n     { ngx_string(\"ssl\"),\n@@ -196,6 +203,13 @@ static ngx_command_t  ngx_mail_ssl_commands[] = {\n       offsetof(ngx_mail_ssl_conf_t, crl),\n       NULL },\n \n+    { ngx_string(\"ssl_conf_command\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_ssl_conf_t, conf_commands),\n+      &ngx_mail_ssl_conf_command_post },\n+\n       ngx_null_command\n };\n \n@@ -259,6 +273,7 @@ ngx_mail_ssl_create_conf(ngx_conf_t *cf)\n     scf->certificates = NGX_CONF_UNSET_PTR;\n     scf->certificate_keys = NGX_CONF_UNSET_PTR;\n     scf->passwords = NGX_CONF_UNSET_PTR;\n+    scf->conf_commands = NGX_CONF_UNSET_PTR;\n     scf->prefer_server_ciphers = NGX_CONF_UNSET;\n     scf->verify = NGX_CONF_UNSET_UINT;\n     scf->verify_depth = NGX_CONF_UNSET_UINT;\n@@ -316,6 +331,8 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_ptr_value(conf->conf_commands, prev->conf_commands, NULL);\n+\n \n     conf->ssl.log = cf->log;\n \n@@ -461,6 +478,10 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, &conf->ssl, conf->conf_commands) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     return NGX_CONF_OK;\n }\n \n@@ -654,3 +675,14 @@ ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     return NGX_CONF_ERROR;\n }\n+\n+\n+static char *\n+ngx_mail_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\nDiff:\n@@ -48,6 +48,7 @@ typedef struct {\n     ngx_str_t        ciphers;\n \n     ngx_array_t     *passwords;\n+    ngx_array_t     *conf_commands;\n \n     ngx_shm_zone_t  *shm_zone;\n \nDiff:\n@@ -45,6 +45,10 @@ static char *ngx_stream_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+\n+static char *ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post,\n+    void *data);\n+\n static ngx_int_t ngx_stream_ssl_init(ngx_conf_t *cf);\n \n \n@@ -68,6 +72,10 @@ static ngx_conf_enum_t  ngx_stream_ssl_verify[] = {\n };\n \n \n+static ngx_conf_post_t  ngx_stream_ssl_conf_command_post =\n+    { ngx_stream_ssl_conf_command_check };\n+\n+\n static ngx_command_t  ngx_stream_ssl_commands[] = {\n \n     { ngx_string(\"ssl_handshake_timeout\"),\n@@ -196,6 +204,13 @@ static ngx_command_t  ngx_stream_ssl_commands[] = {\n       offsetof(ngx_stream_ssl_conf_t, crl),\n       NULL },\n \n+    { ngx_string(\"ssl_conf_command\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_conf_set_keyval_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_ssl_conf_t, conf_commands),\n+      &ngx_stream_ssl_conf_command_post },\n+\n       ngx_null_command\n };\n \n@@ -595,6 +610,7 @@ ngx_stream_ssl_create_conf(ngx_conf_t *cf)\n     scf->certificates = NGX_CONF_UNSET_PTR;\n     scf->certificate_keys = NGX_CONF_UNSET_PTR;\n     scf->passwords = NGX_CONF_UNSET_PTR;\n+    scf->conf_commands = NGX_CONF_UNSET_PTR;\n     scf->prefer_server_ciphers = NGX_CONF_UNSET;\n     scf->verify = NGX_CONF_UNSET_UINT;\n     scf->verify_depth = NGX_CONF_UNSET_UINT;\n@@ -650,6 +666,8 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_ptr_value(conf->conf_commands, prev->conf_commands, NULL);\n+\n \n     conf->ssl.log = cf->log;\n \n@@ -811,6 +829,10 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (ngx_ssl_conf_commands(cf, &conf->ssl, conf->conf_commands) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n     return NGX_CONF_OK;\n }\n \n@@ -1034,6 +1056,17 @@ ngx_stream_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_stream_ssl_conf_command_check(ngx_conf_t *cf, void *post, void *data)\n+{\n+#ifndef SSL_CONF_FLAG_FILE\n+    return \"is not supported on this platform\";\n+#endif\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_stream_ssl_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -46,6 +46,7 @@ typedef struct {\n     ngx_str_t        ciphers;\n \n     ngx_array_t     *passwords;\n+    ngx_array_t     *conf_commands;\n \n     ngx_shm_zone_t  *shm_zone;\n \n",
        "analysis": "Let's analyze the newly added functions:\n\n1. **ngx_ssl_conf_commands(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *commands)**\n\n   - Lines 4-7: Check if `commands` is NULL, if so, return `NGX_OK`.\n   - Lines 14-28: Initialize an SSL configuration context (`SSL_CONF_CTX`) and set various flags.\n   - Line 30: Get the elements of `commands` into `cmd`.\n   - Lines 31-45: Iterate over each element in `commands`. For each element, it retrieves `key` and uses it in `SSL_CONF_cmd_value_type()` to get `type`.\n   - Lines 37-41: If `type` requires a file or directory, it calls `ngx_conf_full_name()`. If it fails, it frees the context and returns `NGX_ERROR`.\n   - Lines 46-51: Passes `key` and `value` to `SSL_CONF_cmd()`. If it fails, the context is freed and `NGX_ERROR` is returned.\n   - Lines 54-64: Finishes the configuration with `SSL_CONF_CTX_finish()` and frees the context before returning `NGX_OK`.\n\nWhile we're unable to find a definitive out-of-bounds write vulnerability in the function, it's worth noting that `SSL_CONF_cmd` and `ngx_conf_full_name` depend on user-provided `commands`, which could be vectors for buffer-related issues if these underlying functions aren't handling them properly internally.\n\nOther newly added functions (`ngx_http_ssl_conf_command_check`, `ngx_mail_ssl_conf_command_check`, `ngx_stream_ssl_conf_command_check`) are much simpler and surrounded by `#ifndef SSL_CONF_FLAG_FILE` preprocessor checks, which limit platform support but do not involve buffer manipulation directly.\n\n\"TRUE [ngx_ssl_conf_commands]\" is the expression of suspicion based on dependability on user input to `SSL_CONF_cmd` function directly. Thus, it potentially merits further manual scrutiny under the possibility of an out-of-bounds write given only superficially analyzed here.\n\n**TRUE [ngx_ssl_conf_commands]**"
    },
    {
        "commit_index": "Commit 49",
        "commit_diff": "Diff:\n@@ -1137,7 +1137,7 @@ ngx_conf_set_keyval_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     a = (ngx_array_t **) (p + cmd->offset);\n \n-    if (*a == NULL) {\n+    if (*a == NGX_CONF_UNSET_PTR || *a == NULL) {\n         *a = ngx_array_create(cf->pool, 4, sizeof(ngx_keyval_t));\n         if (*a == NULL) {\n             return NGX_CONF_ERROR;\nDiff:\n@@ -4324,7 +4324,6 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n      *     conf->upstream.hide_headers_hash = { NULL, 0 };\n      *     conf->upstream.ssl_name = NULL;\n      *\n-     *     conf->headers_source = NULL;\n      *     conf->headers.lengths = NULL;\n      *     conf->headers.values = NULL;\n      *     conf->headers.hash = { NULL, 0 };\n@@ -4377,6 +4376,8 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)\n     conf->upstream.pass_trailers = 1;\n     conf->upstream.preserve_output = 1;\n \n+    conf->headers_source = NGX_CONF_UNSET_PTR;\n+\n     ngx_str_set(&conf->upstream.module, \"grpc\");\n \n     return conf;\n@@ -4507,9 +4508,10 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         clcf->handler = ngx_http_grpc_handler;\n     }\n \n-    if (conf->headers_source == NULL) {\n+    ngx_conf_merge_ptr_value(conf->headers_source, prev->headers_source, NULL);\n+\n+    if (conf->headers_source == prev->headers_source) {\n         conf->headers = prev->headers;\n-        conf->headers_source = prev->headers_source;\n         conf->host_set = prev->host_set;\n     }\n \nDiff:\n@@ -3268,7 +3268,6 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n      *     conf->method = NULL;\n      *     conf->location = NULL;\n      *     conf->url = { 0, NULL };\n-     *     conf->headers_source = NULL;\n      *     conf->headers.lengths = NULL;\n      *     conf->headers.values = NULL;\n      *     conf->headers.hash = { NULL, 0 };\n@@ -3346,6 +3345,8 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n     /* \"proxy_cyclic_temp_file\" is disabled */\n     conf->upstream.cyclic_temp_file = 0;\n \n+    conf->headers_source = NGX_CONF_UNSET_PTR;\n+\n     conf->redirect = NGX_CONF_UNSET;\n     conf->upstream.change_buffering = 1;\n \n@@ -3819,12 +3820,13 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n         }\n     }\n \n-    if (conf->headers_source == NULL) {\n+    ngx_conf_merge_ptr_value(conf->headers_source, prev->headers_source, NULL);\n+\n+    if (conf->headers_source == prev->headers_source) {\n         conf->headers = prev->headers;\n #if (NGX_HTTP_CACHE)\n         conf->headers_cache = prev->headers_cache;\n #endif\n-        conf->headers_source = prev->headers_source;\n     }\n \n     rc = ngx_http_proxy_init_headers(cf, conf, &conf->headers,\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 48",
        "commit_diff": "Diff:\n@@ -69,6 +69,8 @@ static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit,\n     ngx_uint_t hash, ngx_str_t *key, ngx_uint_t *ep, ngx_uint_t account);\n static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits,\n     ngx_uint_t n, ngx_uint_t *ep, ngx_http_limit_req_limit_t **limit);\n+static void ngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits,\n+    ngx_uint_t n);\n static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx,\n     ngx_uint_t n);\n \n@@ -223,6 +225,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n         ctx = limit->shm_zone->data;\n \n         if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {\n+            ngx_http_limit_req_unlock(limits, n);\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n@@ -270,21 +273,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n                         &limit->shm_zone->shm.name);\n         }\n \n-        while (n--) {\n-            ctx = limits[n].shm_zone->data;\n-\n-            if (ctx->node == NULL) {\n-                continue;\n-            }\n-\n-            ngx_shmtx_lock(&ctx->shpool->mutex);\n-\n-            ctx->node->count--;\n-\n-            ngx_shmtx_unlock(&ctx->shpool->mutex);\n-\n-            ctx->node = NULL;\n-        }\n+        ngx_http_limit_req_unlock(limits, n);\n \n         if (lrcf->dry_run) {\n             r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN;\n@@ -612,6 +601,29 @@ ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,\n }\n \n \n+static void\n+ngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits, ngx_uint_t n)\n+{\n+    ngx_http_limit_req_ctx_t  *ctx;\n+\n+    while (n--) {\n+        ctx = limits[n].shm_zone->data;\n+\n+        if (ctx->node == NULL) {\n+            continue;\n+        }\n+\n+        ngx_shmtx_lock(&ctx->shpool->mutex);\n+\n+        ctx->node->count--;\n+\n+        ngx_shmtx_unlock(&ctx->shpool->mutex);\n+\n+        ctx->node = NULL;\n+    }\n+}\n+\n+\n static void\n ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx, ngx_uint_t n)\n {\nDiff:\n@@ -162,10 +162,12 @@ typedef enum {\n     ngx_smtp_auth_external,\n     ngx_smtp_helo,\n     ngx_smtp_helo_xclient,\n+    ngx_smtp_helo_auth,\n     ngx_smtp_helo_from,\n     ngx_smtp_xclient,\n     ngx_smtp_xclient_from,\n     ngx_smtp_xclient_helo,\n+    ngx_smtp_xclient_auth,\n     ngx_smtp_from,\n     ngx_smtp_to\n } ngx_smtp_state_e;\nDiff:\n@@ -16,6 +16,7 @@ typedef struct {\n     ngx_flag_t  enable;\n     ngx_flag_t  pass_error_message;\n     ngx_flag_t  xclient;\n+    ngx_flag_t  smtp_auth;\n     size_t      buffer_size;\n     ngx_msec_t  timeout;\n } ngx_mail_proxy_conf_t;\n@@ -74,6 +75,13 @@ static ngx_command_t  ngx_mail_proxy_commands[] = {\n       offsetof(ngx_mail_proxy_conf_t, xclient),\n       NULL },\n \n+    { ngx_string(\"proxy_smtp_auth\"),\n+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_MAIL_SRV_CONF_OFFSET,\n+      offsetof(ngx_mail_proxy_conf_t, smtp_auth),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -450,7 +458,7 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n {\n     u_char                    *p;\n     ngx_int_t                  rc;\n-    ngx_str_t                  line;\n+    ngx_str_t                  line, auth, encoded;\n     ngx_buf_t                 *b;\n     ngx_connection_t          *c;\n     ngx_mail_session_t        *s;\n@@ -513,6 +521,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         } else if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n             s->mail_state = ngx_smtp_helo_from;\n \n+        } else if (pcf->smtp_auth) {\n+            s->mail_state = ngx_smtp_helo_auth;\n+\n         } else {\n             s->mail_state = ngx_smtp_helo;\n         }\n@@ -552,7 +563,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         p = ngx_copy(p, s->connection->addr_text.data,\n                      s->connection->addr_text.len);\n \n-        if (s->login.len) {\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+        if (s->login.len && !pcf->smtp_auth) {\n             p = ngx_cpymem(p, \" LOGIN=\", sizeof(\" LOGIN=\") - 1);\n             p = ngx_copy(p, s->login.data, s->login.len);\n         }\n@@ -570,6 +583,9 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n         } else if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n             s->mail_state = ngx_smtp_xclient_from;\n \n+        } else if (pcf->smtp_auth) {\n+            s->mail_state = ngx_smtp_xclient_auth;\n+\n         } else {\n             s->mail_state = ngx_smtp_xclient;\n         }\n@@ -595,8 +611,62 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n                        &s->smtp_helo)\n                    - line.data;\n \n-        s->mail_state = (s->auth_method == NGX_MAIL_AUTH_NONE) ?\n-                            ngx_smtp_helo_from : ngx_smtp_helo;\n+        pcf = ngx_mail_get_module_srv_conf(s, ngx_mail_proxy_module);\n+\n+        if (s->auth_method == NGX_MAIL_AUTH_NONE) {\n+            s->mail_state = ngx_smtp_helo_from;\n+\n+        } else if (pcf->smtp_auth) {\n+            s->mail_state = ngx_smtp_helo_auth;\n+\n+        } else {\n+            s->mail_state = ngx_smtp_helo;\n+        }\n+\n+        break;\n+\n+    case ngx_smtp_helo_auth:\n+    case ngx_smtp_xclient_auth:\n+        ngx_log_debug0(NGX_LOG_DEBUG_MAIL, rev->log, 0,\n+                       \"mail proxy send auth\");\n+\n+        s->connection->log->action = \"sending AUTH to upstream\";\n+\n+        if (s->passwd.data == NULL) {\n+            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n+                          \"no password available\");\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        auth.len = 1 + s->login.len + 1 + s->passwd.len;\n+        auth.data = ngx_pnalloc(c->pool, auth.len);\n+        if (auth.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        auth.len = ngx_sprintf(auth.data, \"%Z%V%Z%V\", &s->login, &s->passwd)\n+                   - auth.data;\n+\n+        line.len = sizeof(\"AUTH PLAIN \" CRLF) - 1\n+                   + ngx_base64_encoded_length(auth.len);\n+\n+        line.data = ngx_pnalloc(c->pool, line.len);\n+        if (line.data == NULL) {\n+            ngx_mail_proxy_internal_server_error(s);\n+            return;\n+        }\n+\n+        encoded.data = ngx_cpymem(line.data, \"AUTH PLAIN \",\n+                                  sizeof(\"AUTH PLAIN \") - 1);\n+\n+        ngx_encode_base64(&encoded, &auth);\n+\n+        p = encoded.data + encoded.len;\n+        *p++ = CR; *p = LF;\n+\n+        s->mail_state = ngx_smtp_auth_plain;\n \n         break;\n \n@@ -643,6 +713,7 @@ ngx_mail_proxy_smtp_handler(ngx_event_t *rev)\n \n     case ngx_smtp_helo:\n     case ngx_smtp_xclient:\n+    case ngx_smtp_auth_plain:\n     case ngx_smtp_to:\n \n         b = s->proxy->buffer;\n@@ -824,6 +895,7 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)\n         case ngx_smtp_helo:\n         case ngx_smtp_helo_xclient:\n         case ngx_smtp_helo_from:\n+        case ngx_smtp_helo_auth:\n         case ngx_smtp_from:\n             if (p[0] == '2' && p[1] == '5' && p[2] == '0') {\n                 return NGX_OK;\n@@ -833,11 +905,18 @@ ngx_mail_proxy_read_response(ngx_mail_session_t *s, ngx_uint_t state)\n         case ngx_smtp_xclient:\n         case ngx_smtp_xclient_from:\n         case ngx_smtp_xclient_helo:\n+        case ngx_smtp_xclient_auth:\n             if (p[0] == '2' && (p[1] == '2' || p[1] == '5') && p[2] == '0') {\n                 return NGX_OK;\n             }\n             break;\n \n+        case ngx_smtp_auth_plain:\n+            if (p[0] == '2' && p[1] == '3' && p[2] == '5') {\n+                return NGX_OK;\n+            }\n+            break;\n+\n         case ngx_smtp_to:\n             return NGX_OK;\n         }\n@@ -1102,6 +1181,7 @@ ngx_mail_proxy_create_conf(ngx_conf_t *cf)\n     pcf->enable = NGX_CONF_UNSET;\n     pcf->pass_error_message = NGX_CONF_UNSET;\n     pcf->xclient = NGX_CONF_UNSET;\n+    pcf->smtp_auth = NGX_CONF_UNSET;\n     pcf->buffer_size = NGX_CONF_UNSET_SIZE;\n     pcf->timeout = NGX_CONF_UNSET_MSEC;\n \n@@ -1118,6 +1198,7 @@ ngx_mail_proxy_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_value(conf->enable, prev->enable, 0);\n     ngx_conf_merge_value(conf->pass_error_message, prev->pass_error_message, 0);\n     ngx_conf_merge_value(conf->xclient, prev->xclient, 1);\n+    ngx_conf_merge_value(conf->smtp_auth, prev->smtp_auth, 0);\n     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,\n                               (size_t) ngx_pagesize);\n     ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 24 * 60 * 60000);\nDiff:\n@@ -14,6 +14,8 @@ extern \"C\" {\n   #include <ngx_mail_pop3_module.h>\n   #include <ngx_mail_imap_module.h>\n   #include <ngx_mail_smtp_module.h>\n+\n+  #include <ngx_stream.h>\n }\n \n // nginx header files should go before other, because they define 64-bit off_t\n",
        "analysis": "The added function is:\n```c\nstatic void\nngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits, ngx_uint_t n)\n{\n    ngx_http_limit_req_ctx_t  *ctx;\n\n    while (n--) {\n        ctx = limits[n].shm_zone->data;\n\n        if (ctx->node == NULL) {\n            continue;\n        }\n\n        ngx_shmtx_lock(&ctx->shpool->mutex);\n\n        ctx->node->count--;\n\n        ngx_shmtx_unlock(&ctx->shpool->mutex);\n\n        ctx->node = NULL;\n    }\n}\n```\n\nLine-by-line Analysis:\n1. The function `ngx_http_limit_req_unlock` is defined to handle limit list unlocking.\n2. It takes `limits` (a list of `ngx_http_limit_req_limit_t`) and `n` (the count of limits) as parameters.\n3. Inside a loop, it decrements `n` and uses it as an index to access elements of `limits`.\n4. The function then accesses `shm_zone->data` of each limit and assigns it to `ctx`.\n5. It checks for a null `node` within `ctx`.\n6. If `node` is not null, it locks the mutex in `ctx->shpool`.\n7. The function then decrements `ctx->node->count`.\n8. It unlocks the mutex and sets `ctx->node` to `NULL`.\n\nThere is potential for an out-of-bounds write vulnerability if:\n- `n` does not accurately reflect the number of valid elements in `limits`.\n- Modifications are made to `limits` outside of this function without adequate locking, potentially leading to race conditions.\n\nAlthough there is not definitive proof of out-of-bounds write, given that `n` controls an iteration index and there is a manual count decrement, there is potential risk of incorrect boundary checks leading to an out-of-bounds write under malicious circumstances.\n\nTRUE [ngx_http_limit_req_unlock]"
    },
    {
        "commit_index": "Commit 47",
        "commit_diff": "Diff:\n@@ -452,3 +452,4 @@ c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n 062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\n a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\n+3cbc2602325f0ac08917a4397d76f5155c34b7b1 release-1.19.3\nDiff:\n@@ -5,6 +5,112 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.3\" date=\"2020-09-29\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+модуль ngx_stream_set_module.\n+</para>\n+<para lang=\"en\">\n+the ngx_stream_set_module.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива proxy_cookie_flags.\n+</para>\n+<para lang=\"en\">\n+the \"proxy_cookie_flags\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива userid_flags.\n+</para>\n+<para lang=\"en\">\n+the \"userid_flags\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+расширение управления кэшированием stale-if-error\n+ошибочно применялось, если бэкенд возвращал ответ\n+с кодом 500, 502, 503, 504, 403, 404 или 429.\n+</para>\n+<para lang=\"en\">\n+the \"stale-if-error\" cache control extension\n+was erroneously applied if backend returned a response\n+with status code 500, 502, 503, 504, 403, 404, or 429.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если использовалось кэширование\n+и бэкенд возвращал ответы с строкой заголовка Vary,\n+в логах могли появляться сообщения \"[crit] cache file ... has too long header\".\n+</para>\n+<para lang=\"en\">\n+\"[crit] cache file ... has too long header\" messages might appear in logs\n+if caching was used\n+and the backend returned responses with the \"Vary\" header line.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании OpenSSL 1.1.1\n+в логах могли появляться сообщения \"[crit] SSL_write() failed\".\n+</para>\n+<para lang=\"en\">\n+\"[crit] SSL_write() failed\" messages might appear in logs\n+when using OpenSSL 1.1.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\";\n+ошибка появилась в 1.19.2.\n+</para>\n+<para lang=\"en\">\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\"\n+messages might appear in logs;\n+the bug had appeared in 1.19.2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании HTTP/2\n+в рабочем процессе мог произойти segmentation fault,\n+если ошибки с кодом 400 с помощью директивы error_page\n+перенаправлялись в проксируемый location.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+when using HTTP/2\n+if errors with code 400 were redirected to a proxied location\n+using the \"error_page\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании HTTP/2 и подзапросов в модуле njs.\n+</para>\n+<para lang=\"en\">\n+socket leak when using HTTP/2 and subrequests in the njs module.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.2\" date=\"2020-08-11\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019003\n-#define NGINX_VERSION      \"1.19.3\"\n+#define nginx_version      1019004\n+#define NGINX_VERSION      \"1.19.4\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 46",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1g\n+OPENSSL =\topenssl-1.1.1h\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -2679,7 +2679,9 @@ ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n     ngx_keyval_t               *attr;\n     ngx_http_proxy_loc_conf_t  *plcf;\n \n-    ngx_array_init(&attrs, r->pool, 2, sizeof(ngx_keyval_t));\n+    if (ngx_array_init(&attrs, r->pool, 2, sizeof(ngx_keyval_t)) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n \n     if (ngx_http_proxy_parse_cookie(&h->value, &attrs) != NGX_OK) {\n         return NGX_ERROR;\nDiff:\n@@ -15,12 +15,13 @@\n #define NGX_HTTP_USERID_V1    2\n #define NGX_HTTP_USERID_ON    3\n \n-#define NGX_HTTP_USERID_COOKIE_SECURE           0x0001\n-#define NGX_HTTP_USERID_COOKIE_HTTPONLY         0x0002\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE         0x0004\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT  0x0008\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE_LAX     0x0010\n-#define NGX_HTTP_USERID_COOKIE_SAMESITE_NONE    0x0020\n+#define NGX_HTTP_USERID_COOKIE_OFF              0x0002\n+#define NGX_HTTP_USERID_COOKIE_SECURE           0x0004\n+#define NGX_HTTP_USERID_COOKIE_HTTPONLY         0x0008\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE         0x0010\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT  0x0020\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_LAX     0x0040\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_NONE    0x0080\n \n /* 31 Dec 2037 23:55:55 GMT */\n #define NGX_HTTP_USERID_MAX_EXPIRES  2145916555\n@@ -97,6 +98,7 @@ static ngx_conf_enum_t  ngx_http_userid_state[] = {\n \n \n static ngx_conf_bitmask_t  ngx_http_userid_flags[] = {\n+    { ngx_string(\"off\"), NGX_HTTP_USERID_COOKIE_OFF },\n     { ngx_string(\"secure\"), NGX_HTTP_USERID_COOKIE_SECURE },\n     { ngx_string(\"httponly\"), NGX_HTTP_USERID_COOKIE_HTTPONLY },\n     { ngx_string(\"samesite=strict\"),\n@@ -743,7 +745,7 @@ ngx_http_userid_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n                               NGX_HTTP_USERID_OFF);\n \n     ngx_conf_merge_bitmask_value(conf->flags, prev->flags,\n-                                 NGX_CONF_BITMASK_SET);\n+                            (NGX_CONF_BITMASK_SET|NGX_HTTP_USERID_COOKIE_OFF));\n \n     ngx_conf_merge_str_value(conf->name, prev->name, \"uid\");\n     ngx_conf_merge_str_value(conf->domain, prev->domain, \"\");\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 45",
        "commit_diff": "Diff:\n@@ -128,6 +128,8 @@ struct ngx_connection_s {\n \n     ngx_socket_t        fd;\n \n+    size_t              request_counter; /* total requests to the server */\n+\n     ngx_recv_pt         recv;\n     ngx_send_pt         send;\n     ngx_recv_chain_pt   recv_chain;\nDiff:\n@@ -14,6 +14,7 @@\n \n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_con_his_s         ngx_con_his_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n typedef struct ngx_black_list_s      ngx_black_list_t;\n typedef struct ngx_pool_s            ngx_pool_t;\nDiff:\n@@ -35,6 +35,42 @@ static ngx_connection_t  dumb;\n /* STUB */\n \n \n+void\n+ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con)\n+{\n+    ngx_con_his_t *target = *con_his_list;\n+\n+    if (target) {\n+        while (target->next) {\n+            target = target->next;\n+        }\n+        target->next = new_con;\n+    } else {\n+        *con_his_list = new_con;\n+    }\n+\n+    return;\n+}\n+\n+\n+ngx_con_his_t *\n+ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n+{\n+    ngx_con_his_t *target = con_his_list;\n+    size_t counter = 0;\n+\n+    if (!target || number == 1 || !number) {\n+        return target;\n+    }\n+\n+    for ( ; counter <= number; counter++) {\n+        target = target->next;\n+    }\n+\n+    return target;\n+}\n+\n+\n ngx_cycle_t *\n ngx_init_cycle(ngx_cycle_t *old_cycle)\n {\n@@ -73,6 +109,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n     pool->log = log;\n \n     cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));\n+    ngx_memzero(cycle, sizeof(ngx_cycle_t));\n     if (cycle == NULL) {\n         ngx_destroy_pool(pool);\n         return NULL;\nDiff:\n@@ -43,6 +43,12 @@ typedef struct ngx_black_list_s {\n }ngx_black_list_t;\n \n \n+struct ngx_con_his_s {\n+    ngx_str_t      addr_text;\n+    ngx_con_his_t *next;\n+};\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -83,6 +89,9 @@ struct ngx_cycle_s {\n \n     ngx_cycle_t              *old_cycle;\n \n+    size_t                    connection_counter; /* total connections to the server */\n+    ngx_con_his_t            *connection_history; /* list of all connections made to the server */\n+\n     ngx_str_t                 conf_file;\n     ngx_str_t                 conf_param;\n     ngx_str_t                 conf_prefix;\n@@ -162,6 +171,8 @@ ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n     size_t size, void *tag);\n void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+void ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con);\n+ngx_con_his_t *ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number);\n void ngx_black_list_insert(ngx_black_list_t **black_list,\n     u_char insert_ip[], size_t size, ngx_log_t *log);\n ngx_int_t ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[]);\nDiff:\n@@ -1918,7 +1918,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -1930,7 +1930,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (rn->query6 == NULL || rn->naddrs6 != (u_short) -1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected response for %V\", &name);\n+                          \"unexpected DNS response for %V\", &name);\n             ngx_resolver_free(r, name.data);\n             goto failed;\n         }\n@@ -1949,7 +1949,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (rn->query == NULL || rn->naddrs != (u_short) -1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected response for %V\", &name);\n+                          \"unexpected DNS response for %V\", &name);\n             ngx_resolver_free(r, name.data);\n             goto failed;\n         }\n@@ -1964,7 +1964,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -2149,7 +2149,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -2218,7 +2218,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -2567,7 +2567,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL || rn->query == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -2581,7 +2581,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -2691,7 +2691,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -2734,7 +2734,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -3165,7 +3165,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL || rn->query == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -3174,7 +3174,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -3256,7 +3256,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -3283,7 +3283,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -3952,12 +3952,12 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         }\n \n         if (p >= last) {\n-            err = \"name is out of response\";\n+            err = \"name is out of DNS response\";\n             goto invalid;\n         }\n     }\n \n-    err = \"compression pointers loop\";\n+    err = \"compression pointers loop in DNS response\";\n \n invalid:\n \nDiff:\n@@ -791,6 +791,7 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n     ngx_event_t       *rev, *wev;\n     ngx_queue_t       *queue;\n     ngx_connection_t  *c;\n+    ngx_con_his_t     *new_con_his;\n \n     /* NGX_TIMER_INFINITE == INFTIM */\n \n@@ -898,6 +899,18 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n                 ngx_post_event(rev, queue);\n \n             } else {\n+                if (c->number > cycle->connection_counter) {\n+                    new_con_his = ngx_palloc(cycle->pool, sizeof(ngx_con_his_t));\n+                    ngx_memzero(new_con_his, sizeof(ngx_con_his_t));\n+                    ngx_memcpy(&new_con_his->addr_text, &c->addr_text, sizeof(ngx_str_t));\n+\n+                    ngx_insert_con_his(&cycle->connection_history, new_con_his);\n+\n+                    cycle->connection_counter = c->number;\n+                    rev->connection_counter = c->number;\n+                    rev->connection_history = cycle->connection_history;\n+                }\n+\n                 rev->handler(rev);\n             }\n         }\nDiff:\n@@ -28,6 +28,8 @@ typedef struct {\n \n \n struct ngx_event_s {\n+    size_t           connection_counter;\n+    ngx_con_his_t   *connection_history;\n     void            *data;\n \n     unsigned         write:1;\nDiff:\n@@ -1349,6 +1349,7 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n     c = rev->data;\n     r = c->data;\n     r->cycle = rev->cycle;\n+    r->request_counter = ++c->request_counter;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request header line\");\n@@ -1496,6 +1497,8 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n                 break;\n             }\n \n+            r->connection_counter = rev->connection_counter;\n+            r->connection_history = rev->connection_history;\n             ngx_http_process_request(r);\n \n             break;\nDiff:\n@@ -373,6 +373,9 @@ typedef void (*ngx_http_event_handler_pt)(ngx_http_request_t *r);\n \n \n struct ngx_http_request_s {\n+    size_t                            connection_counter; /* total connections to the server */\n+    size_t                            request_counter; /* total requests to the server */\n+    ngx_con_his_t                    *connection_history;\n     uint32_t                          signature;         /* \"HTTP\" */\n \n     ngx_connection_t                 *connection;\nDiff:\n@@ -2754,6 +2754,10 @@ static ngx_int_t\n ngx_http_get_last_ip_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    ngx_con_his_t *last_ip = ngx_get_con_his(r->connection_history, r->request_counter);\n+    v->data = last_ip->addr_text.data;\n+    v->len = last_ip->addr_text.len;\n+\n     return NGX_OK;\n }\n \n",
        "analysis": "Let's analyze the newly added entire functions one by one: \n\n1. `ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con)`\n\n```c\nvoid ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con) {\n    ngx_con_his_t *target = *con_his_list;\n\n    if (target) {\n        while (target->next) {\n            target = target->next;\n        }\n        target->next = new_con;\n    } else {\n        *con_his_list = new_con;\n    }\n\n    return;\n}\n```\nThis function does not perform any bounds checking because it assumes that `target` and `con_his_list` structures are correctly initialized and linked. Without information on how `new_con` is managed or limits about list size, it's hard to determine a vulnerability just in this function.\n\n2. `ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)`\n\n```c\nngx_con_his_t *ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number) {\n    ngx_con_his_t *target = con_his_list;\n    size_t counter = 0;\n\n    if (!target || number == 1 || !number) {\n        return target;\n    }\n\n    for ( ; counter <= number; counter++) {\n        target = target->next;\n    }\n\n    return target;\n}\n```\n\nThis function traverses a linked list up to `number` nodes by walking through `target->next`. It does not check whether `target->next` becomes NULL before the target index is reached, which might cause an out-of-bounds access when accessing `target->next`.\n\nBased on this analysis, the function `ngx_get_con_his` could potentially lead to an out-of-bounds write due to not correctly handling the end of the list. Therefore, it raises suspicion for the vulnerability.\n\nTherefore, the result is:\n\n```\nTRUE [ngx_get_con_his]\n```"
    },
    {
        "commit_index": "Commit 44",
        "commit_diff": "Diff:\n@@ -1119,6 +1119,16 @@ if [ $STREAM != NO ]; then\n         . auto/module\n     fi\n \n+    if [ $STREAM_SET = YES ]; then\n+        ngx_module_name=ngx_stream_set_module\n+        ngx_module_deps=\n+        ngx_module_srcs=src/stream/ngx_stream_set_module.c\n+        ngx_module_libs=\n+        ngx_module_link=$STREAM_SET\n+\n+        . auto/module\n+    fi\n+\n     if [ $STREAM_UPSTREAM_HASH = YES ]; then\n         ngx_module_name=ngx_stream_upstream_hash_module\n         ngx_module_deps=\nDiff:\n@@ -124,6 +124,7 @@ STREAM_GEOIP=NO\n STREAM_MAP=YES\n STREAM_SPLIT_CLIENTS=YES\n STREAM_RETURN=YES\n+STREAM_SET=YES\n STREAM_UPSTREAM_HASH=YES\n STREAM_UPSTREAM_LEAST_CONN=YES\n STREAM_UPSTREAM_RANDOM=YES\n@@ -324,6 +325,7 @@ use the \\\"--with-mail_ssl_module\\\" option instead\"\n         --without-stream_split_clients_module)\n                                          STREAM_SPLIT_CLIENTS=NO    ;;\n         --without-stream_return_module)  STREAM_RETURN=NO           ;;\n+        --without-stream_set_module)     STREAM_SET=NO              ;;\n         --without-stream_upstream_hash_module)\n                                          STREAM_UPSTREAM_HASH=NO    ;;\n         --without-stream_upstream_least_conn_module)\n@@ -538,6 +540,7 @@ cat << END\n   --without-stream_split_clients_module\n                                      disable ngx_stream_split_clients_module\n   --without-stream_return_module     disable ngx_stream_return_module\n+  --without-stream_set_module        disable ngx_stream_set_module\n   --without-stream_upstream_hash_module\n                                      disable ngx_stream_upstream_hash_module\n   --without-stream_upstream_least_conn_module\nDiff:\n@@ -10,6 +10,19 @@\n #include <ngx_http.h>\n \n \n+#define  NGX_HTTP_PROXY_COOKIE_SECURE           0x0001\n+#define  NGX_HTTP_PROXY_COOKIE_SECURE_ON        0x0002\n+#define  NGX_HTTP_PROXY_COOKIE_SECURE_OFF       0x0004\n+#define  NGX_HTTP_PROXY_COOKIE_HTTPONLY         0x0008\n+#define  NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON      0x0010\n+#define  NGX_HTTP_PROXY_COOKIE_HTTPONLY_OFF     0x0020\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE         0x0040\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT  0x0080\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX     0x0100\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE    0x0200\n+#define  NGX_HTTP_PROXY_COOKIE_SAMESITE_OFF     0x0400\n+\n+\n typedef struct {\n     ngx_array_t                    caches;  /* ngx_http_file_cache_t * */\n } ngx_http_proxy_main_conf_t;\n@@ -18,7 +31,7 @@ typedef struct {\n typedef struct ngx_http_proxy_rewrite_s  ngx_http_proxy_rewrite_t;\n \n typedef ngx_int_t (*ngx_http_proxy_rewrite_pt)(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len,\n+    ngx_str_t *value, size_t prefix, size_t len,\n     ngx_http_proxy_rewrite_t *pr);\n \n struct ngx_http_proxy_rewrite_s {\n@@ -35,6 +48,19 @@ struct ngx_http_proxy_rewrite_s {\n };\n \n \n+typedef struct {\n+    union {\n+        ngx_http_complex_value_t   complex;\n+#if (NGX_PCRE)\n+        ngx_http_regex_t          *regex;\n+#endif\n+    } cookie;\n+\n+    ngx_uint_t                     flags;\n+    ngx_uint_t                     regex;\n+} ngx_http_proxy_cookie_flags_t;\n+\n+\n typedef struct {\n     ngx_str_t                      key_start;\n     ngx_str_t                      schema;\n@@ -72,6 +98,7 @@ typedef struct {\n     ngx_array_t                   *redirects;\n     ngx_array_t                   *cookie_domains;\n     ngx_array_t                   *cookie_paths;\n+    ngx_array_t                   *cookie_flags;\n \n     ngx_http_complex_value_t      *method;\n     ngx_str_t                      location;\n@@ -158,10 +185,16 @@ static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r,\n     ngx_table_elt_t *h, size_t prefix);\n static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r,\n     ngx_table_elt_t *h);\n+static ngx_int_t ngx_http_proxy_parse_cookie(ngx_str_t *value,\n+    ngx_array_t *attrs);\n static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, u_char *value, ngx_array_t *rewrites);\n+    ngx_str_t *value, ngx_array_t *rewrites);\n+static ngx_int_t ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r,\n+    ngx_array_t *attrs, ngx_array_t *flags);\n+static ngx_int_t ngx_http_proxy_edit_cookie_flags(ngx_http_request_t *r,\n+    ngx_array_t *attrs, ngx_uint_t flags);\n static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_str_t *replacement);\n+    ngx_str_t *value, size_t prefix, size_t len, ngx_str_t *replacement);\n \n static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf);\n static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf);\n@@ -180,6 +213,8 @@ static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static char *ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n static char *ngx_http_proxy_store(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n #if (NGX_HTTP_CACHE)\n@@ -282,6 +317,13 @@ static ngx_command_t  ngx_http_proxy_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"proxy_cookie_flags\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1234,\n+      ngx_http_proxy_cookie_flags,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n     { ngx_string(\"proxy_store\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n       ngx_http_proxy_store,\n@@ -845,6 +887,36 @@ static ngx_path_init_t  ngx_http_proxy_temp_path = {\n };\n \n \n+static ngx_conf_bitmask_t  ngx_http_proxy_cookie_flags_masks[] = {\n+\n+    { ngx_string(\"secure\"),\n+      NGX_HTTP_PROXY_COOKIE_SECURE|NGX_HTTP_PROXY_COOKIE_SECURE_ON },\n+\n+    { ngx_string(\"nosecure\"),\n+      NGX_HTTP_PROXY_COOKIE_SECURE|NGX_HTTP_PROXY_COOKIE_SECURE_OFF },\n+\n+    { ngx_string(\"httponly\"),\n+      NGX_HTTP_PROXY_COOKIE_HTTPONLY|NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON },\n+\n+    { ngx_string(\"nohttponly\"),\n+      NGX_HTTP_PROXY_COOKIE_HTTPONLY|NGX_HTTP_PROXY_COOKIE_HTTPONLY_OFF },\n+\n+    { ngx_string(\"samesite=strict\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT },\n+\n+    { ngx_string(\"samesite=lax\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX },\n+\n+    { ngx_string(\"samesite=none\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE },\n+\n+    { ngx_string(\"nosamesite\"),\n+      NGX_HTTP_PROXY_COOKIE_SAMESITE|NGX_HTTP_PROXY_COOKIE_SAMESITE_OFF },\n+\n+    { ngx_null_string, 0 }\n+};\n+\n+\n static ngx_int_t\n ngx_http_proxy_handler(ngx_http_request_t *r)\n {\n@@ -906,7 +978,7 @@ ngx_http_proxy_handler(ngx_http_request_t *r)\n         u->rewrite_redirect = ngx_http_proxy_rewrite_redirect;\n     }\n \n-    if (plcf->cookie_domains || plcf->cookie_paths) {\n+    if (plcf->cookie_domains || plcf->cookie_paths || plcf->cookie_flags) {\n         u->rewrite_cookie = ngx_http_proxy_rewrite_cookie;\n     }\n \n@@ -2584,7 +2656,7 @@ ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r, ngx_table_elt_t *h,\n     len = h->value.len - prefix;\n \n     for (i = 0; i < plcf->redirects->nelts; i++) {\n-        rc = pr[i].handler(r, h, prefix, len, &pr[i]);\n+        rc = pr[i].handler(r, &h->value, prefix, len, &pr[i]);\n \n         if (rc != NGX_DECLINED) {\n             return rc;\n@@ -2598,27 +2670,41 @@ ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r, ngx_table_elt_t *h,\n static ngx_int_t\n ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n {\n-    size_t                      prefix;\n     u_char                     *p;\n+    size_t                      len;\n     ngx_int_t                   rc, rv;\n+    ngx_str_t                  *key, *value;\n+    ngx_uint_t                  i;\n+    ngx_array_t                 attrs;\n+    ngx_keyval_t               *attr;\n     ngx_http_proxy_loc_conf_t  *plcf;\n \n-    p = (u_char *) ngx_strchr(h->value.data, ';');\n-    if (p == NULL) {\n-        return NGX_DECLINED;\n+    ngx_array_init(&attrs, r->pool, 2, sizeof(ngx_keyval_t));\n+\n+    if (ngx_http_proxy_parse_cookie(&h->value, &attrs) != NGX_OK) {\n+        return NGX_ERROR;\n     }\n \n-    prefix = p + 1 - h->value.data;\n+    attr = attrs.elts;\n+\n+    if (attr[0].value.data == NULL) {\n+        return NGX_DECLINED;\n+    }\n \n     rv = NGX_DECLINED;\n \n     plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);\n \n-    if (plcf->cookie_domains) {\n-        p = ngx_strcasestrn(h->value.data + prefix, \"domain=\", 7 - 1);\n+    for (i = 1; i < attrs.nelts; i++) {\n+\n+        key = &attr[i].key;\n+        value = &attr[i].value;\n \n-        if (p) {\n-            rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 7,\n+        if (plcf->cookie_domains && key->len == 6\n+            && ngx_strncasecmp(key->data, (u_char *) \"domain\", 6) == 0\n+            && value->data)\n+        {\n+            rc = ngx_http_proxy_rewrite_cookie_value(r, value,\n                                                      plcf->cookie_domains);\n             if (rc == NGX_ERROR) {\n                 return NGX_ERROR;\n@@ -2628,13 +2714,12 @@ ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n                 rv = rc;\n             }\n         }\n-    }\n \n-    if (plcf->cookie_paths) {\n-        p = ngx_strcasestrn(h->value.data + prefix, \"path=\", 5 - 1);\n-\n-        if (p) {\n-            rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 5,\n+        if (plcf->cookie_paths && key->len == 4\n+            && ngx_strncasecmp(key->data, (u_char *) \"path\", 4) == 0\n+            && value->data)\n+        {\n+            rc = ngx_http_proxy_rewrite_cookie_value(r, value,\n                                                      plcf->cookie_paths);\n             if (rc == NGX_ERROR) {\n                 return NGX_ERROR;\n@@ -2646,30 +2731,153 @@ ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r, ngx_table_elt_t *h)\n         }\n     }\n \n-    return rv;\n+    if (plcf->cookie_flags) {\n+        rc = ngx_http_proxy_rewrite_cookie_flags(r, &attrs,\n+                                                 plcf->cookie_flags);\n+        if (rc == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (rc != NGX_DECLINED) {\n+            rv = rc;\n+        }\n+\n+        attr = attrs.elts;\n+    }\n+\n+    if (rv != NGX_OK) {\n+        return rv;\n+    }\n+\n+    len = 0;\n+\n+    for (i = 0; i < attrs.nelts; i++) {\n+\n+        if (attr[i].key.data == NULL) {\n+            continue;\n+        }\n+\n+        if (i > 0) {\n+            len += 2;\n+        }\n+\n+        len += attr[i].key.len;\n+\n+        if (attr[i].value.data) {\n+            len += 1 + attr[i].value.len;\n+        }\n+    }\n+\n+    p = ngx_pnalloc(r->pool, len + 1);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    h->value.data = p;\n+    h->value.len = len;\n+\n+    for (i = 0; i < attrs.nelts; i++) {\n+\n+        if (attr[i].key.data == NULL) {\n+            continue;\n+        }\n+\n+        if (i > 0) {\n+            *p++ = ';';\n+            *p++ = ' ';\n+        }\n+\n+        p = ngx_cpymem(p, attr[i].key.data, attr[i].key.len);\n+\n+        if (attr[i].value.data) {\n+            *p++ = '=';\n+            p = ngx_cpymem(p, attr[i].value.data, attr[i].value.len);\n+        }\n+    }\n+\n+    *p = '\\0';\n+\n+    return NGX_OK;\n }\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_table_elt_t *h,\n-    u_char *value, ngx_array_t *rewrites)\n+ngx_http_proxy_parse_cookie(ngx_str_t *value, ngx_array_t *attrs)\n {\n-    size_t                     len, prefix;\n-    u_char                    *p;\n-    ngx_int_t                  rc;\n-    ngx_uint_t                 i;\n-    ngx_http_proxy_rewrite_t  *pr;\n+    u_char        *start, *end, *p, *last;\n+    ngx_str_t      name, val;\n+    ngx_keyval_t  *attr;\n+\n+    start = value->data;\n+    end = value->data + value->len;\n+\n+    for ( ;; ) {\n+\n+        last = (u_char *) ngx_strchr(start, ';');\n+\n+        if (last == NULL) {\n+            last = end;\n+        }\n+\n+        while (start < last && *start == ' ') { start++; }\n+\n+        for (p = start; p < last && *p != '='; p++) { /* void */ }\n+\n+        name.data = start;\n+        name.len = p - start;\n+\n+        while (name.len && name.data[name.len - 1] == ' ') {\n+            name.len--;\n+        }\n+\n+        if (p < last) {\n+\n+            p++;\n+\n+            while (p < last && *p == ' ') { p++; }\n+\n+            val.data = p;\n+            val.len = last - val.data;\n+\n+            while (val.len && val.data[val.len - 1] == ' ') {\n+                val.len--;\n+            }\n+\n+        } else {\n+            ngx_str_null(&val);\n+        }\n+\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n \n-    prefix = value - h->value.data;\n+        attr->key = name;\n+        attr->value = val;\n \n-    p = (u_char *) ngx_strchr(value, ';');\n+        if (last == end) {\n+            break;\n+        }\n+\n+        start = last + 1;\n+    }\n+\n+    return NGX_OK;\n+}\n \n-    len = p ? (size_t) (p - value) : (h->value.len - prefix);\n+\n+static ngx_int_t\n+ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_str_t *value,\n+    ngx_array_t *rewrites)\n+{\n+    ngx_int_t                  rc;\n+    ngx_uint_t                 i;\n+    ngx_http_proxy_rewrite_t  *pr;\n \n     pr = rewrites->elts;\n \n     for (i = 0; i < rewrites->nelts; i++) {\n-        rc = pr[i].handler(r, h, prefix, len, &pr[i]);\n+        rc = pr[i].handler(r, value, 0, value->len, &pr[i]);\n \n         if (rc != NGX_DECLINED) {\n             return rc;\n@@ -2681,8 +2889,194 @@ ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n+ngx_http_proxy_rewrite_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n+    ngx_array_t *flags)\n+{\n+    ngx_str_t                       pattern;\n+#if (NGX_PCRE)\n+    ngx_int_t                       rc;\n+#endif\n+    ngx_uint_t                      i;\n+    ngx_keyval_t                   *attr;\n+    ngx_http_proxy_cookie_flags_t  *pcf;\n+\n+    attr = attrs->elts;\n+    pcf = flags->elts;\n+\n+    for (i = 0; i < flags->nelts; i++) {\n+\n+#if (NGX_PCRE)\n+        if (pcf[i].regex) {\n+            rc = ngx_http_regex_exec(r, pcf[i].cookie.regex, &attr[0].key);\n+\n+            if (rc == NGX_ERROR) {\n+                return NGX_ERROR;\n+            }\n+\n+            if (rc == NGX_OK) {\n+                break;\n+            }\n+\n+            /* NGX_DECLINED */\n+\n+            continue;\n+        }\n+#endif\n+\n+        if (ngx_http_complex_value(r, &pcf[i].cookie.complex, &pattern)\n+            != NGX_OK)\n+        {\n+            return NGX_ERROR;\n+        }\n+\n+        if (pattern.len == attr[0].key.len\n+            && ngx_strncasecmp(attr[0].key.data, pattern.data, pattern.len)\n+               == 0)\n+        {\n+            break;\n+        }\n+    }\n+\n+    if (i == flags->nelts) {\n+        return NGX_DECLINED;\n+    }\n+\n+    return ngx_http_proxy_edit_cookie_flags(r, attrs, pcf[i].flags);\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_proxy_edit_cookie_flags(ngx_http_request_t *r, ngx_array_t *attrs,\n+    ngx_uint_t flags)\n+{\n+    ngx_str_t     *key, *value;\n+    ngx_uint_t     i;\n+    ngx_keyval_t  *attr;\n+\n+    attr = attrs->elts;\n+\n+    for (i = 1; i < attrs->nelts; i++) {\n+        key = &attr[i].key;\n+\n+        if (key->len == 6\n+            && ngx_strncasecmp(key->data, (u_char *) \"secure\", 6) == 0)\n+        {\n+            if (flags & NGX_HTTP_PROXY_COOKIE_SECURE_ON) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SECURE_ON;\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SECURE_OFF) {\n+                key->data = NULL;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (key->len == 8\n+            && ngx_strncasecmp(key->data, (u_char *) \"httponly\", 8) == 0)\n+        {\n+            if (flags & NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON;\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_HTTPONLY_OFF) {\n+                key->data = NULL;\n+            }\n+\n+            continue;\n+        }\n+\n+        if (key->len == 8\n+            && ngx_strncasecmp(key->data, (u_char *) \"samesite\", 8) == 0)\n+        {\n+            value = &attr[i].value;\n+\n+            if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT;\n+\n+                if (value->len != 6\n+                    || ngx_strncasecmp(value->data, (u_char *) \"strict\", 6)\n+                       != 0)\n+                {\n+                    ngx_str_set(key, \"SameSite\");\n+                    ngx_str_set(value, \"Strict\");\n+                }\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX;\n+\n+                if (value->len != 3\n+                    || ngx_strncasecmp(value->data, (u_char *) \"lax\", 3) != 0)\n+                {\n+                    ngx_str_set(key, \"SameSite\");\n+                    ngx_str_set(value, \"Lax\");\n+                }\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE) {\n+                flags &= ~NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE;\n+\n+                if (value->len != 4\n+                    || ngx_strncasecmp(value->data, (u_char *) \"none\", 4) != 0)\n+                {\n+                    ngx_str_set(key, \"SameSite\");\n+                    ngx_str_set(value, \"None\");\n+                }\n+\n+            } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_OFF) {\n+                key->data = NULL;\n+            }\n+\n+            continue;\n+        }\n+    }\n+\n+    if (flags & NGX_HTTP_PROXY_COOKIE_SECURE_ON) {\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_str_set(&attr->key, \"Secure\");\n+        ngx_str_null(&attr->value);\n+    }\n+\n+    if (flags & NGX_HTTP_PROXY_COOKIE_HTTPONLY_ON) {\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_str_set(&attr->key, \"HttpOnly\");\n+        ngx_str_null(&attr->value);\n+    }\n+\n+    if (flags & (NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT\n+                 |NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX\n+                 |NGX_HTTP_PROXY_COOKIE_SAMESITE_NONE))\n+    {\n+        attr = ngx_array_push(attrs);\n+        if (attr == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_str_set(&attr->key, \"SameSite\");\n+\n+        if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_STRICT) {\n+            ngx_str_set(&attr->value, \"Strict\");\n+\n+        } else if (flags & NGX_HTTP_PROXY_COOKIE_SAMESITE_LAX) {\n+            ngx_str_set(&attr->value, \"Lax\");\n+\n+        } else {\n+            ngx_str_set(&attr->value, \"None\");\n+        }\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r, ngx_str_t *value,\n+    size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n {\n     ngx_str_t  pattern, replacement;\n \n@@ -2691,8 +3085,7 @@ ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,\n     }\n \n     if (pattern.len > len\n-        || ngx_rstrncmp(h->value.data + prefix, pattern.data,\n-                        pattern.len) != 0)\n+        || ngx_rstrncmp(value->data + prefix, pattern.data, pattern.len) != 0)\n     {\n         return NGX_DECLINED;\n     }\n@@ -2701,20 +3094,20 @@ ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    return ngx_http_proxy_rewrite(r, h, prefix, pattern.len, &replacement);\n+    return ngx_http_proxy_rewrite(r, value, prefix, pattern.len, &replacement);\n }\n \n \n #if (NGX_PCRE)\n \n static ngx_int_t\n-ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r, ngx_table_elt_t *h,\n+ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r, ngx_str_t *value,\n     size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n {\n     ngx_str_t  pattern, replacement;\n \n     pattern.len = len;\n-    pattern.data = h->value.data + prefix;\n+    pattern.data = value->data + prefix;\n \n     if (ngx_http_regex_exec(r, pr->pattern.regex, &pattern) != NGX_OK) {\n         return NGX_DECLINED;\n@@ -2724,20 +3117,15 @@ ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r, ngx_table_elt_t *h,\n         return NGX_ERROR;\n     }\n \n-    if (prefix == 0 && h->value.len == len) {\n-        h->value = replacement;\n-        return NGX_OK;\n-    }\n-\n-    return ngx_http_proxy_rewrite(r, h, prefix, len, &replacement);\n+    return ngx_http_proxy_rewrite(r, value, prefix, len, &replacement);\n }\n \n #endif\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,\n-    ngx_table_elt_t *h, size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n+ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r, ngx_str_t *value,\n+    size_t prefix, size_t len, ngx_http_proxy_rewrite_t *pr)\n {\n     u_char     *p;\n     ngx_str_t   pattern, replacement;\n@@ -2746,9 +3134,9 @@ ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    p = h->value.data + prefix;\n+    p = value->data + prefix;\n \n-    if (p[0] == '.') {\n+    if (len && p[0] == '.') {\n         p++;\n         prefix++;\n         len--;\n@@ -2762,18 +3150,23 @@ ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    return ngx_http_proxy_rewrite(r, h, prefix, len, &replacement);\n+    return ngx_http_proxy_rewrite(r, value, prefix, len, &replacement);\n }\n \n \n static ngx_int_t\n-ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_table_elt_t *h, size_t prefix,\n+ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_str_t *value, size_t prefix,\n     size_t len, ngx_str_t *replacement)\n {\n     u_char  *p, *data;\n     size_t   new_len;\n \n-    new_len = replacement->len + h->value.len - len;\n+    if (len == value->len) {\n+        *value = *replacement;\n+        return NGX_OK;\n+    }\n+\n+    new_len = replacement->len + value->len - len;\n \n     if (replacement->len > len) {\n \n@@ -2782,23 +3175,22 @@ ngx_http_proxy_rewrite(ngx_http_request_t *r, ngx_table_elt_t *h, size_t prefix,\n             return NGX_ERROR;\n         }\n \n-        p = ngx_copy(data, h->value.data, prefix);\n+        p = ngx_copy(data, value->data, prefix);\n         p = ngx_copy(p, replacement->data, replacement->len);\n \n-        ngx_memcpy(p, h->value.data + prefix + len,\n-                   h->value.len - len - prefix + 1);\n+        ngx_memcpy(p, value->data + prefix + len,\n+                   value->len - len - prefix + 1);\n \n-        h->value.data = data;\n+        value->data = data;\n \n     } else {\n-        p = ngx_copy(h->value.data + prefix, replacement->data,\n-                     replacement->len);\n+        p = ngx_copy(value->data + prefix, replacement->data, replacement->len);\n \n-        ngx_memmove(p, h->value.data + prefix + len,\n-                    h->value.len - len - prefix + 1);\n+        ngx_memmove(p, value->data + prefix + len,\n+                    value->len - len - prefix + 1);\n     }\n \n-    h->value.len = new_len;\n+    value->len = new_len;\n \n     return NGX_OK;\n }\n@@ -2957,6 +3349,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)\n \n     conf->cookie_domains = NGX_CONF_UNSET_PTR;\n     conf->cookie_paths = NGX_CONF_UNSET_PTR;\n+    conf->cookie_flags = NGX_CONF_UNSET_PTR;\n \n     conf->http_version = NGX_CONF_UNSET_UINT;\n \n@@ -3352,6 +3745,8 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_ptr_value(conf->cookie_paths, prev->cookie_paths, NULL);\n \n+    ngx_conf_merge_ptr_value(conf->cookie_flags, prev->cookie_flags, NULL);\n+\n     ngx_conf_merge_uint_value(conf->http_version, prev->http_version,\n                               NGX_HTTP_VERSION_10);\n \n@@ -3766,7 +4161,7 @@ ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_compile_complex_value_t   ccv;\n \n     if (plcf->redirect == 0) {\n-        return NGX_CONF_OK;\n+        return \"is duplicate\";\n     }\n \n     plcf->redirect = 1;\n@@ -3775,16 +4170,12 @@ ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     if (cf->args->nelts == 2) {\n         if (ngx_strcmp(value[1].data, \"off\") == 0) {\n-            plcf->redirect = 0;\n-            plcf->redirects = NULL;\n-            return NGX_CONF_OK;\n-        }\n \n-        if (ngx_strcmp(value[1].data, \"false\") == 0) {\n-            ngx_conf_log_error(NGX_LOG_ERR, cf, 0,\n-                           \"invalid parameter \\\"false\\\", use \\\"off\\\" instead\");\n+            if (plcf->redirects) {\n+                return \"is duplicate\";\n+            }\n+\n             plcf->redirect = 0;\n-            plcf->redirects = NULL;\n             return NGX_CONF_OK;\n         }\n \n@@ -3808,7 +4199,9 @@ ngx_http_proxy_redirect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         return NGX_CONF_ERROR;\n     }\n \n-    if (ngx_strcmp(value[1].data, \"default\") == 0) {\n+    if (cf->args->nelts == 2\n+        && ngx_strcmp(value[1].data, \"default\") == 0)\n+    {\n         if (plcf->proxy_lengths) {\n             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                \"\\\"proxy_redirect default\\\" cannot be used \"\n@@ -3911,14 +4304,19 @@ ngx_http_proxy_cookie_domain(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_compile_complex_value_t   ccv;\n \n     if (plcf->cookie_domains == NULL) {\n-        return NGX_CONF_OK;\n+        return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n     if (cf->args->nelts == 2) {\n \n         if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+\n+            if (plcf->cookie_domains != NGX_CONF_UNSET_PTR) {\n+                return \"is duplicate\";\n+            }\n+\n             plcf->cookie_domains = NULL;\n             return NGX_CONF_OK;\n         }\n@@ -3998,14 +4396,19 @@ ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     ngx_http_compile_complex_value_t   ccv;\n \n     if (plcf->cookie_paths == NULL) {\n-        return NGX_CONF_OK;\n+        return \"is duplicate\";\n     }\n \n     value = cf->args->elts;\n \n     if (cf->args->nelts == 2) {\n \n         if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+\n+            if (plcf->cookie_paths != NGX_CONF_UNSET_PTR) {\n+                return \"is duplicate\";\n+            }\n+\n             plcf->cookie_paths = NULL;\n             return NGX_CONF_OK;\n         }\n@@ -4075,6 +4478,131 @@ ngx_http_proxy_cookie_path(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_proxy_cookie_flags(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_http_proxy_loc_conf_t *plcf = conf;\n+\n+    ngx_str_t                         *value;\n+    ngx_uint_t                         i, m;\n+    ngx_conf_bitmask_t                *mask;\n+    ngx_http_proxy_cookie_flags_t     *pcf;\n+    ngx_http_compile_complex_value_t   ccv;\n+#if (NGX_PCRE)\n+    ngx_regex_compile_t                rc;\n+    u_char                             errstr[NGX_MAX_CONF_ERRSTR];\n+#endif\n+\n+    if (plcf->cookie_flags == NULL) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (cf->args->nelts == 2) {\n+\n+        if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+\n+            if (plcf->cookie_flags != NGX_CONF_UNSET_PTR) {\n+                return \"is duplicate\";\n+            }\n+\n+            plcf->cookie_flags = NULL;\n+            return NGX_CONF_OK;\n+        }\n+\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"invalid parameter \\\"%V\\\"\", &value[1]);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (plcf->cookie_flags == NGX_CONF_UNSET_PTR) {\n+        plcf->cookie_flags = ngx_array_create(cf->pool, 1,\n+                                        sizeof(ngx_http_proxy_cookie_flags_t));\n+        if (plcf->cookie_flags == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    pcf = ngx_array_push(plcf->cookie_flags);\n+    if (pcf == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    pcf->regex = 0;\n+\n+    if (value[1].data[0] == '~') {\n+        value[1].len--;\n+        value[1].data++;\n+\n+#if (NGX_PCRE)\n+        ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n+\n+        rc.pattern = value[1];\n+        rc.err.len = NGX_MAX_CONF_ERRSTR;\n+        rc.err.data = errstr;\n+        rc.options = NGX_REGEX_CASELESS;\n+\n+        pcf->cookie.regex = ngx_http_regex_compile(cf, &rc);\n+        if (pcf->cookie.regex == NULL) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        pcf->regex = 1;\n+#else\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"using regex \\\"%V\\\" requires PCRE library\",\n+                           &value[1]);\n+        return NGX_CONF_ERROR;\n+#endif\n+\n+    } else {\n+\n+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n+\n+        ccv.cf = cf;\n+        ccv.value = &value[1];\n+        ccv.complex_value = &pcf->cookie.complex;\n+\n+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    mask = ngx_http_proxy_cookie_flags_masks;\n+    pcf->flags = 0;\n+\n+    for (i = 2; i < cf->args->nelts; i++) {\n+        for (m = 0; mask[m].name.len != 0; m++) {\n+\n+            if (mask[m].name.len != value[i].len\n+                || ngx_strcasecmp(mask[m].name.data, value[i].data) != 0)\n+            {\n+                continue;\n+            }\n+\n+            if (pcf->flags & mask[m].mask) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"duplicate parameter \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+            pcf->flags |= mask[m].mask;\n+\n+            break;\n+        }\n+\n+        if (mask[m].name.len == 0) {\n+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                               \"invalid parameter \\\"%V\\\"\", &value[i]);\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_proxy_rewrite_regex(ngx_conf_t *cf, ngx_http_proxy_rewrite_t *pr,\n     ngx_str_t *regex, ngx_uint_t caseless)\nDiff:\n@@ -15,12 +15,20 @@\n #define NGX_HTTP_USERID_V1    2\n #define NGX_HTTP_USERID_ON    3\n \n+#define NGX_HTTP_USERID_COOKIE_SECURE           0x0001\n+#define NGX_HTTP_USERID_COOKIE_HTTPONLY         0x0002\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE         0x0004\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT  0x0008\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_LAX     0x0010\n+#define NGX_HTTP_USERID_COOKIE_SAMESITE_NONE    0x0020\n+\n /* 31 Dec 2037 23:55:55 GMT */\n #define NGX_HTTP_USERID_MAX_EXPIRES  2145916555\n \n \n typedef struct {\n     ngx_uint_t  enable;\n+    ngx_uint_t  flags;\n \n     ngx_int_t   service;\n \n@@ -88,6 +96,19 @@ static ngx_conf_enum_t  ngx_http_userid_state[] = {\n };\n \n \n+static ngx_conf_bitmask_t  ngx_http_userid_flags[] = {\n+    { ngx_string(\"secure\"), NGX_HTTP_USERID_COOKIE_SECURE },\n+    { ngx_string(\"httponly\"), NGX_HTTP_USERID_COOKIE_HTTPONLY },\n+    { ngx_string(\"samesite=strict\"),\n+      NGX_HTTP_USERID_COOKIE_SAMESITE|NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT },\n+    { ngx_string(\"samesite=lax\"),\n+      NGX_HTTP_USERID_COOKIE_SAMESITE|NGX_HTTP_USERID_COOKIE_SAMESITE_LAX },\n+    { ngx_string(\"samesite=none\"),\n+      NGX_HTTP_USERID_COOKIE_SAMESITE|NGX_HTTP_USERID_COOKIE_SAMESITE_NONE },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n static ngx_conf_post_handler_pt  ngx_http_userid_domain_p =\n     ngx_http_userid_domain;\n static ngx_conf_post_handler_pt  ngx_http_userid_path_p = ngx_http_userid_path;\n@@ -138,6 +159,13 @@ static ngx_command_t  ngx_http_userid_commands[] = {\n       0,\n       NULL },\n \n+    { ngx_string(\"userid_flags\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE123,\n+      ngx_conf_set_bitmask_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_userid_conf_t, flags),\n+      &ngx_http_userid_flags },\n+\n     { ngx_string(\"userid_p3p\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n       ngx_conf_set_str_slot,\n@@ -374,6 +402,26 @@ ngx_http_userid_set_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,\n         len += conf->domain.len;\n     }\n \n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SECURE) {\n+        len += sizeof(\"; secure\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_HTTPONLY) {\n+        len += sizeof(\"; httponly\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT) {\n+        len += sizeof(\"; samesite=strict\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_LAX) {\n+        len += sizeof(\"; samesite=lax\") - 1;\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_NONE) {\n+        len += sizeof(\"; samesite=none\") - 1;\n+    }\n+\n     cookie = ngx_pnalloc(r->pool, len);\n     if (cookie == NULL) {\n         return NGX_ERROR;\n@@ -413,6 +461,26 @@ ngx_http_userid_set_uid(ngx_http_request_t *r, ngx_http_userid_ctx_t *ctx,\n \n     p = ngx_copy(p, conf->path.data, conf->path.len);\n \n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SECURE) {\n+        p = ngx_cpymem(p, \"; secure\", sizeof(\"; secure\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_HTTPONLY) {\n+        p = ngx_cpymem(p, \"; httponly\", sizeof(\"; httponly\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_STRICT) {\n+        p = ngx_cpymem(p, \"; samesite=strict\", sizeof(\"; samesite=strict\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_LAX) {\n+        p = ngx_cpymem(p, \"; samesite=lax\", sizeof(\"; samesite=lax\") - 1);\n+    }\n+\n+    if (conf->flags & NGX_HTTP_USERID_COOKIE_SAMESITE_NONE) {\n+        p = ngx_cpymem(p, \"; samesite=none\", sizeof(\"; samesite=none\") - 1);\n+    }\n+\n     set_cookie = ngx_list_push(&r->headers_out.headers);\n     if (set_cookie == NULL) {\n         return NGX_ERROR;\n@@ -649,6 +717,7 @@ ngx_http_userid_create_conf(ngx_conf_t *cf)\n     /*\n      * set by ngx_pcalloc():\n      *\n+     *     conf->flags = 0;\n      *     conf->name = { 0, NULL };\n      *     conf->domain = { 0, NULL };\n      *     conf->path = { 0, NULL };\n@@ -673,6 +742,9 @@ ngx_http_userid_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->enable, prev->enable,\n                               NGX_HTTP_USERID_OFF);\n \n+    ngx_conf_merge_bitmask_value(conf->flags, prev->flags,\n+                                 NGX_CONF_BITMASK_SET);\n+\n     ngx_conf_merge_str_value(conf->name, prev->name, \"uid\");\n     ngx_conf_merge_str_value(conf->domain, prev->domain, \"\");\n     ngx_conf_merge_str_value(conf->path, prev->path, \"; path=/\");\nDiff:\n@@ -0,0 +1,226 @@\n+\n+/*\n+ * Copyright (C) Pavel Pautov\n+ * Copyright (C) Nginx, Inc.\n+ */\n+\n+\n+#include <ngx_config.h>\n+#include <ngx_core.h>\n+#include <ngx_stream.h>\n+\n+\n+typedef struct {\n+    ngx_int_t                   index;\n+    ngx_stream_set_variable_pt  set_handler;\n+    uintptr_t                   data;\n+    ngx_stream_complex_value_t  value;\n+} ngx_stream_set_cmd_t;\n+\n+\n+typedef struct {\n+    ngx_array_t                 commands;\n+} ngx_stream_set_srv_conf_t;\n+\n+\n+static ngx_int_t ngx_stream_set_handler(ngx_stream_session_t *s);\n+static ngx_int_t ngx_stream_set_var(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data);\n+static ngx_int_t ngx_stream_set_init(ngx_conf_t *cf);\n+static void *ngx_stream_set_create_srv_conf(ngx_conf_t *cf);\n+static char *ngx_stream_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n+\n+\n+static ngx_command_t  ngx_stream_set_commands[] = {\n+\n+    { ngx_string(\"set\"),\n+      NGX_STREAM_SRV_CONF|NGX_CONF_TAKE2,\n+      ngx_stream_set,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n+      ngx_null_command\n+};\n+\n+\n+static ngx_stream_module_t  ngx_stream_set_module_ctx = {\n+    NULL,                                  /* preconfiguration */\n+    ngx_stream_set_init,                   /* postconfiguration */\n+\n+    NULL,                                  /* create main configuration */\n+    NULL,                                  /* init main configuration */\n+\n+    ngx_stream_set_create_srv_conf,        /* create server configuration */\n+    NULL                                   /* merge server configuration */\n+};\n+\n+\n+ngx_module_t  ngx_stream_set_module = {\n+    NGX_MODULE_V1,\n+    &ngx_stream_set_module_ctx,            /* module context */\n+    ngx_stream_set_commands,               /* module directives */\n+    NGX_STREAM_MODULE,                     /* module type */\n+    NULL,                                  /* init master */\n+    NULL,                                  /* init module */\n+    NULL,                                  /* init process */\n+    NULL,                                  /* init thread */\n+    NULL,                                  /* exit thread */\n+    NULL,                                  /* exit process */\n+    NULL,                                  /* exit master */\n+    NGX_MODULE_V1_PADDING\n+};\n+\n+\n+static ngx_int_t\n+ngx_stream_set_handler(ngx_stream_session_t *s)\n+{\n+    ngx_str_t                     str;\n+    ngx_uint_t                    i;\n+    ngx_stream_set_cmd_t         *cmds;\n+    ngx_stream_set_srv_conf_t    *scf;\n+    ngx_stream_variable_value_t   vv;\n+\n+    scf = ngx_stream_get_module_srv_conf(s, ngx_stream_set_module);\n+    cmds = scf->commands.elts;\n+    vv = ngx_stream_variable_null_value;\n+\n+    for (i = 0; i < scf->commands.nelts; i++) {\n+        if (ngx_stream_complex_value(s, &cmds[i].value, &str) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (cmds[i].set_handler != NULL) {\n+            vv.len = str.len;\n+            vv.data = str.data;\n+            cmds[i].set_handler(s, &vv, cmds[i].data);\n+\n+        } else {\n+            s->variables[cmds[i].index].len = str.len;\n+            s->variables[cmds[i].index].valid = 1;\n+            s->variables[cmds[i].index].no_cacheable = 0;\n+            s->variables[cmds[i].index].not_found = 0;\n+            s->variables[cmds[i].index].data = str.data;\n+        }\n+    }\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+static ngx_int_t\n+ngx_stream_set_var(ngx_stream_session_t *s, ngx_stream_variable_value_t *v,\n+    uintptr_t data)\n+{\n+    *v = ngx_stream_variable_null_value;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_stream_set_init(ngx_conf_t *cf)\n+{\n+    ngx_stream_handler_pt        *h;\n+    ngx_stream_core_main_conf_t  *cmcf;\n+\n+    cmcf = ngx_stream_conf_get_module_main_conf(cf, ngx_stream_core_module);\n+\n+    h = ngx_array_push(&cmcf->phases[NGX_STREAM_PREACCESS_PHASE].handlers);\n+    if (h == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    *h = ngx_stream_set_handler;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void *\n+ngx_stream_set_create_srv_conf(ngx_conf_t *cf)\n+{\n+    ngx_stream_set_srv_conf_t  *conf;\n+\n+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_stream_set_srv_conf_t));\n+    if (conf == NULL) {\n+        return NULL;\n+    }\n+\n+    /*\n+     * set by ngx_pcalloc():\n+     *\n+     *     conf->commands = { NULL };\n+     */\n+\n+    return conf;\n+}\n+\n+\n+static char *\n+ngx_stream_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_stream_set_srv_conf_t  *scf = conf;\n+\n+    ngx_str_t                           *args;\n+    ngx_int_t                            index;\n+    ngx_stream_set_cmd_t                *set_cmd;\n+    ngx_stream_variable_t               *v;\n+    ngx_stream_compile_complex_value_t   ccv;\n+\n+    args = cf->args->elts;\n+\n+    if (args[1].data[0] != '$') {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"invalid variable name \\\"%V\\\"\", &args[1]);\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    args[1].len--;\n+    args[1].data++;\n+\n+    v = ngx_stream_add_variable(cf, &args[1],\n+                                NGX_STREAM_VAR_CHANGEABLE|NGX_STREAM_VAR_WEAK);\n+    if (v == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    index = ngx_stream_get_variable_index(cf, &args[1]);\n+    if (index == NGX_ERROR) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    if (v->get_handler == NULL) {\n+        v->get_handler = ngx_stream_set_var;\n+    }\n+\n+    if (scf->commands.elts == NULL) {\n+        if (ngx_array_init(&scf->commands, cf->pool, 1,\n+                           sizeof(ngx_stream_set_cmd_t))\n+            != NGX_OK)\n+        {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n+    set_cmd = ngx_array_push(&scf->commands);\n+    if (set_cmd == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    set_cmd->index = index;\n+    set_cmd->set_handler = v->set_handler;\n+    set_cmd->data = v->data;\n+\n+    ngx_memzero(&ccv, sizeof(ngx_stream_compile_complex_value_t));\n+\n+    ccv.cf = cf;\n+    ccv.value = &args[2];\n+    ccv.complex_value = &set_cmd->value;\n+\n+    if (ngx_stream_compile_complex_value(&ccv) != NGX_OK) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    return NGX_CONF_OK;\n+}\n",
        "analysis": "Here is the analysis of newly added entire functions for possible out-of-bounds write:\n\n1. **Function: ngx_http_proxy_parse_cookie**\n   - This function iterates over the input `value` to parse its attributes and populate an `attrs` array. The parsing handles finding separators (`;`) and determining key-value pairs. The function is mainly array manipulations with possible pointer arithmetic, however, proper checks ensure that the parsing stops at the end of the input data without accessing beyond the buffer. \n\n2. **Function: ngx_http_proxy_cookie_flags**\n   - This function manages the configuration of cookie flags. It initializes arrays, iterates over them, and uses logic to apply specific flags based on user input. It appears to handle array sizes and indices carefully, but manipulates inputs (`value`) extensively.\n\n3. **Function: ngx_http_proxy_edit_cookie_flags**\n   - This function processes cookie attributes and ensures specific flags are set accordingly. It performs iteration over attributes and modifies keys and values based on conditions. The logic seems cautious with buffer lengths and manipulations.\n\n4. **Function: ngx_stream_set_handler**\n   - Manages setting stream variables based on commands. It iterates over commands and sets values in session variables. The function properly utilizes lengths and buffers without obvious misuse.\n\n5. **Function: ngx_stream_set**\n   - Configures server variables and checks for valid inputs. Uses ngx_stream_compile_complex_value cautiously to handle complex variable values.\n\nIn conclusion, none of the newly added functions demonstrate a definitive out-of-bounds write vulnerability given the current analysis. The functions appear to manage and manipulate memory and buffers with appropriate checks and balances. \n\nTherefore, based on the analyzed newly added functions, there is no indication of a potential out-of-bounds write vulnerability. The result is:\n\nFALSE"
    },
    {
        "commit_index": "Commit 43",
        "commit_diff": "Diff:\n@@ -2805,7 +2805,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         return NGX_OK;\n     }\n \n-    if (c->timedout || c->error) {\n+    if (c->timedout || c->error || c->buffered) {\n         mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;\n         SSL_set_quiet_shutdown(c->ssl->connection, 1);\n \nDiff:\n@@ -946,7 +946,10 @@ ngx_http_ssl_servername(ngx_ssl_conn_t *ssl_conn, int *ad, void *arg)\n     c->ssl->buffer_size = sscf->buffer_size;\n \n     if (sscf->ssl.ctx) {\n-        SSL_set_SSL_CTX(ssl_conn, sscf->ssl.ctx);\n+        if (SSL_set_SSL_CTX(ssl_conn, sscf->ssl.ctx) == NULL) {\n+            *ad = SSL_AD_INTERNAL_ERROR;\n+            return SSL_TLSEXT_ERR_ALERT_FATAL;\n+        }\n \n         /*\n          * SSL_set_SSL_CTX() only changes certs as of 1.0.0d\nDiff:\n@@ -1058,6 +1058,7 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     size_t                   size;\n     ngx_buf_t               *buf;\n     ngx_int_t                rc;\n+    ngx_connection_t        *fc;\n     ngx_http_request_t      *r;\n     ngx_http_v2_stream_t    *stream;\n     ngx_http_v2_srv_conf_t  *h2scf;\n@@ -1076,6 +1077,7 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     r = stream->request;\n+    fc = r->connection;\n \n     if (r->reading_body && !r->request_body_no_buffering) {\n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n@@ -1084,6 +1086,13 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_state_skip_padded(h2c, pos, end);\n     }\n \n+    if (r->headers_in.content_length_n < 0 && !r->headers_in.chunked) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n+                       \"skipping http2 DATA frame\");\n+\n+        return ngx_http_v2_state_skip_padded(h2c, pos, end);\n+    }\n+\n     size = end - pos;\n \n     if (size >= h2c->state.length) {\n@@ -1101,6 +1110,8 @@ ngx_http_v2_state_read_data(ngx_http_v2_connection_t *h2c, u_char *pos,\n             ngx_http_finalize_request(r, rc);\n         }\n \n+        ngx_http_run_posted_requests(fc);\n+\n     } else if (size) {\n         buf = stream->preread;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 42",
        "commit_diff": "Diff:\n@@ -2573,6 +2573,18 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)\n \n     sslerr = SSL_get_error(c->ssl->connection, n);\n \n+    if (sslerr == SSL_ERROR_ZERO_RETURN) {\n+\n+        /*\n+         * OpenSSL 1.1.1 fails to return SSL_ERROR_SYSCALL if an error\n+         * happens during SSL_write() after close_notify alert from the\n+         * peer, and returns SSL_ERROR_ZERO_RETURN instead,\n+         * https://git.openssl.org/?p=openssl.git;a=commitdiff;h=8051ab2\n+         */\n+\n+        sslerr = SSL_ERROR_SYSCALL;\n+    }\n+\n     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_get_error: %d\", sslerr);\n@@ -2793,7 +2805,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         return NGX_OK;\n     }\n \n-    if (c->timedout) {\n+    if (c->timedout || c->error) {\n         mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;\n         SSL_set_quiet_shutdown(c->ssl->connection, 1);\n \n@@ -2853,6 +2865,13 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n             c->read->handler = ngx_ssl_shutdown_handler;\n             c->write->handler = ngx_ssl_shutdown_handler;\n \n+            if (sslerr == SSL_ERROR_WANT_READ) {\n+                c->read->ready = 0;\n+\n+            } else {\n+                c->write->ready = 0;\n+            }\n+\n             if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                 return NGX_ERROR;\n             }\nDiff:\n@@ -117,6 +117,7 @@ struct ngx_http_cache_s {\n     unsigned                         purged:1;\n     unsigned                         reading:1;\n     unsigned                         secondary:1;\n+    unsigned                         update_variant:1;\n     unsigned                         background:1;\n \n     unsigned                         stale_updating:1;\nDiff:\n@@ -854,7 +854,7 @@ ngx_http_file_cache_exists(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)\n         if (fcn->exists || fcn->uses >= c->min_uses) {\n \n             c->exists = fcn->exists;\n-            if (fcn->body_start) {\n+            if (fcn->body_start && !c->update_variant) {\n                 c->body_start = fcn->body_start;\n             }\n \n@@ -1339,6 +1339,7 @@ ngx_http_file_cache_update_variant(ngx_http_request_t *r, ngx_http_cache_t *c)\n     ngx_shmtx_unlock(&cache->shpool->mutex);\n \n     c->file.name.len = 0;\n+    c->update_variant = 1;\n \n     ngx_memcpy(c->key, c->main, NGX_HTTP_CACHE_KEY_LEN);\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 41",
        "commit_diff": "Diff:\n@@ -80,6 +80,7 @@ struct ngx_http_cache_s {\n     ngx_str_t                        vary;\n     u_char                           variant[NGX_HTTP_CACHE_KEY_LEN];\n \n+    size_t                           buffer_size;\n     size_t                           header_start;\n     size_t                           body_start;\n     off_t                            length;\nDiff:\n@@ -294,6 +294,8 @@ ngx_http_file_cache_open(ngx_http_request_t *r)\n         cln->data = c;\n     }\n \n+    c->buffer_size = c->body_start;\n+\n     rc = ngx_http_file_cache_exists(cache, c);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n@@ -1230,7 +1232,7 @@ ngx_http_file_cache_reopen(ngx_http_request_t *r, ngx_http_cache_t *c)\n \n     c->secondary = 1;\n     c->file.name.len = 0;\n-    c->body_start = c->buf->end - c->buf->start;\n+    c->body_start = c->buffer_size;\n \n     ngx_memcpy(c->key, c->variant, NGX_HTTP_CACHE_KEY_LEN);\n \nDiff:\n@@ -953,6 +953,13 @@ ngx_http_v2_state_data(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                    \"http2 DATA frame\");\n \n+    if (h2c->state.sid == 0) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent DATA frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n     if (size > h2c->recv_window) {\n         ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                       \"client violated connection flow control: \"\n@@ -2095,6 +2102,16 @@ static u_char *\n ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n {\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n+                   \"http2 SETTINGS frame\");\n+\n+    if (h2c->state.sid) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent SETTINGS frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n     if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {\n \n         if (h2c->state.length != 0) {\n@@ -2118,9 +2135,6 @@ ngx_http_v2_state_settings(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n     }\n \n-    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n-                   \"http2 SETTINGS frame\");\n-\n     return ngx_http_v2_state_settings_params(h2c, pos, end);\n }\n \n@@ -2269,6 +2283,13 @@ ngx_http_v2_state_ping(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end)\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                    \"http2 PING frame\");\n \n+    if (h2c->state.sid) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent PING frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n     if (h2c->state.flags & NGX_HTTP_V2_ACK_FLAG) {\n         return ngx_http_v2_state_skip(h2c, pos, end);\n     }\n@@ -2310,6 +2331,13 @@ ngx_http_v2_state_goaway(ngx_http_v2_connection_t *h2c, u_char *pos,\n         return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_goaway);\n     }\n \n+    if (h2c->state.sid) {\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"client sent GOAWAY frame with incorrect identifier\");\n+\n+        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n+    }\n+\n #if (NGX_DEBUG)\n     h2c->state.length -= NGX_HTTP_V2_GOAWAY_SIZE;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 40",
        "commit_diff": "Diff:\n@@ -451,3 +451,4 @@ fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n 062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\n+a7b46539f507e6c64efa0efda69ad60b6f4ffbce release-1.19.2\nDiff:\n@@ -5,6 +5,108 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.2\" date=\"2020-08-11\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx начинает закрывать keepalive-соединения,\n+не дожидаясь исчерпания всех свободных соединений,\n+а также пишет об этом предупреждение в лог ошибок.\n+</para>\n+<para lang=\"en\">\n+now nginx starts closing keepalive connections\n+before all free worker connections are exhausted,\n+and logs a warning about this to the error log.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+оптимизация чтения тела запроса\n+при использовании chunked transfer encoding.\n+</para>\n+<para lang=\"en\">\n+optimization of client request body reading\n+when using chunked transfer encoding.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки памяти при использовании директивы ssl_ocsp.\n+</para>\n+<para lang=\"en\">\n+memory leak if the \"ssl_ocsp\" directive was used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения \"zero size buf in output\",\n+если FastCGI-сервер возвращал некорректный ответ;\n+ошибка появилась в 1.19.1.\n+</para>\n+<para lang=\"en\">\n+\"zero size buf in output\" alerts might appear in logs\n+if a FastCGI server returned an incorrect response;\n+the bug had appeared in 1.19.1.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в рабочем процессе мог произойти segmentation fault,\n+если размеры large_client_header_buffers отличались\n+в разных виртуальных серверах.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+if different large_client_header_buffers sizes were used\n+in different virtual servers.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+SSL shutdown мог не работать.\n+</para>\n+<para lang=\"en\">\n+SSL shutdown might not work.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логах могли появляться сообщения\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\".\n+</para>\n+<para lang=\"en\">\n+\"SSL_shutdown() failed (SSL: ... bad write retry)\"\n+messages might appear in logs.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_slice_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_slice_module.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_xslt_filter_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_xslt_filter_module.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.1\" date=\"2020-07-07\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019002\n-#define NGINX_VERSION      \"1.19.2\"\n+#define nginx_version      1019003\n+#define NGINX_VERSION      \"1.19.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -2473,7 +2473,7 @@ ngx_http_upstream_test_next(ngx_http_request_t *r, ngx_http_upstream_t *u)\n #if (NGX_HTTP_CACHE)\n \n         if (u->cache_status == NGX_HTTP_CACHE_EXPIRED\n-            && ((u->conf->cache_use_stale & un->mask) || r->cache->stale_error))\n+            && (u->conf->cache_use_stale & un->mask))\n         {\n             ngx_int_t  rc;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 39",
        "commit_diff": "Diff:\n@@ -1107,12 +1107,9 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)\n         return NULL;\n     }\n \n-    c = ngx_cycle->free_connections;\n+    ngx_drain_connections((ngx_cycle_t *) ngx_cycle);\n \n-    if (c == NULL) {\n-        ngx_drain_connections((ngx_cycle_t *) ngx_cycle);\n-        c = ngx_cycle->free_connections;\n-    }\n+    c = ngx_cycle->free_connections;\n \n     if (c == NULL) {\n         ngx_log_error(NGX_LOG_ALERT, log, 0,\n@@ -1301,6 +1298,21 @@ ngx_drain_connections(ngx_cycle_t *cycle)\n     ngx_queue_t       *q;\n     ngx_connection_t  *c;\n \n+    if (cycle->free_connection_n > cycle->connection_n / 16\n+        || cycle->reusable_connections_n == 0)\n+    {\n+        return;\n+    }\n+\n+    if (cycle->connections_reuse_time != ngx_time()) {\n+        cycle->connections_reuse_time = ngx_time();\n+\n+        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n+                      \"%ui worker_connections are not enough, \"\n+                      \"reusing connections\",\n+                      cycle->connection_n);\n+    }\n+\n     n = ngx_max(ngx_min(32, cycle->reusable_connections_n / 8), 1);\n \n     for (i = 0; i < n; i++) {\nDiff:\n@@ -62,6 +62,7 @@ struct ngx_cycle_s {\n \n     ngx_queue_t               reusable_connections_queue;\n     ngx_uint_t                reusable_connections_n;\n+    time_t                    connections_reuse_time;\n \n     ngx_array_t               listening;\n     ngx_array_t               paths;\nDiff:\n@@ -3008,6 +3008,12 @@ ngx_http_test_reading(ngx_http_request_t *r)\n         rev->error = 1;\n     }\n \n+#if (NGX_HTTP_SSL)\n+    if (c->ssl) {\n+        c->ssl->no_send_shutdown = 1;\n+    }\n+#endif\n+\n     ngx_log_error(NGX_LOG_INFO, c->log, err,\n                   \"client prematurely closed connection\");\n \n",
        "analysis": "Based on the provided diffs, we need to identify any newly added entire functions. Let's analyze the diffs for newly added functions:\n\n1. In the first diff, the block of code added is part of an existing function `ngx_drain_connections` rather than entirely new functions, so this doesn't constitute a new function as per the requirements.\n\n2. The second diff shows an addition to the `ngx_cycle_s` structure and does not represent a function addition.\n\n3. The third diff includes a code block added under a pre-existing `ngx_http_test_reading` function and also does not represent a new function overall.\n\nSince there are no newly added entire functions in the provided diffs, the result is:\n\n\"FALSE\""
    },
    {
        "commit_index": "Commit 38",
        "commit_diff": "Diff:\n@@ -2774,8 +2774,9 @@ ngx_ssl_free_buffer(ngx_connection_t *c)\n ngx_int_t\n ngx_ssl_shutdown(ngx_connection_t *c)\n {\n-    int        n, sslerr, mode;\n-    ngx_err_t  err;\n+    int         n, sslerr, mode;\n+    ngx_err_t   err;\n+    ngx_uint_t  tries;\n \n     ngx_ssl_ocsp_cleanup(c);\n \n@@ -2816,55 +2817,71 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n \n     ngx_ssl_clear_error(c->log);\n \n-    n = SSL_shutdown(c->ssl->connection);\n+    tries = 2;\n+\n+    for ( ;; ) {\n+\n+        /*\n+         * For bidirectional shutdown, SSL_shutdown() needs to be called\n+         * twice: first call sends the \"close notify\" alert and returns 0,\n+         * second call waits for the peer's \"close notify\" alert.\n+         */\n \n-    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n+        n = SSL_shutdown(c->ssl->connection);\n \n-    sslerr = 0;\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n \n-    /* before 0.9.8m SSL_shutdown() returned 0 instead of -1 on errors */\n+        if (n == 1) {\n+            SSL_free(c->ssl->connection);\n+            c->ssl = NULL;\n+\n+            return NGX_OK;\n+        }\n+\n+        if (n == 0 && tries-- > 1) {\n+            continue;\n+        }\n+\n+        /* before 0.9.8m SSL_shutdown() returned 0 instead of -1 on errors */\n \n-    if (n != 1 && ERR_peek_error()) {\n         sslerr = SSL_get_error(c->ssl->connection, n);\n \n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                        \"SSL_get_error: %d\", sslerr);\n-    }\n \n-    if (n == 1 || sslerr == 0 || sslerr == SSL_ERROR_ZERO_RETURN) {\n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n+        if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {\n+            c->read->handler = ngx_ssl_shutdown_handler;\n+            c->write->handler = ngx_ssl_shutdown_handler;\n \n-        return NGX_OK;\n-    }\n+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n \n-    if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {\n-        c->read->handler = ngx_ssl_shutdown_handler;\n-        c->write->handler = ngx_ssl_shutdown_handler;\n+            if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+                return NGX_ERROR;\n+            }\n \n-        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-            return NGX_ERROR;\n-        }\n+            ngx_add_timer(c->read, 3000);\n \n-        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n-            return NGX_ERROR;\n+            return NGX_AGAIN;\n         }\n \n-        if (sslerr == SSL_ERROR_WANT_READ) {\n-            ngx_add_timer(c->read, 30000);\n-        }\n+        if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n+            SSL_free(c->ssl->connection);\n+            c->ssl = NULL;\n \n-        return NGX_AGAIN;\n-    }\n+            return NGX_OK;\n+        }\n \n-    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n+        err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n-    ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n+        ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n \n-    SSL_free(c->ssl->connection);\n-    c->ssl = NULL;\n+        SSL_free(c->ssl->connection);\n+        c->ssl = NULL;\n \n-    return NGX_ERROR;\n+        return NGX_ERROR;\n+    }\n }\n \n \nDiff:\n@@ -1027,6 +1027,8 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n     for (cl = in; cl; cl = cl->next) {\n \n+        b = NULL;\n+\n         for ( ;; ) {\n \n             ngx_log_debug7(NGX_LOG_DEBUG_EVENT, r->connection->log, 0,\n@@ -1061,6 +1063,29 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n                     return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;\n                 }\n \n+                if (b\n+                    && rb->chunked->size <= 128\n+                    && cl->buf->last - cl->buf->pos >= rb->chunked->size)\n+                {\n+                    r->headers_in.content_length_n += rb->chunked->size;\n+\n+                    if (rb->chunked->size < 8) {\n+\n+                        while (rb->chunked->size) {\n+                            *b->last++ = *cl->buf->pos++;\n+                            rb->chunked->size--;\n+                        }\n+\n+                    } else {\n+                        ngx_memmove(b->last, cl->buf->pos, rb->chunked->size);\n+                        b->last += rb->chunked->size;\n+                        cl->buf->pos += rb->chunked->size;\n+                        rb->chunked->size = 0;\n+                    }\n+\n+                    continue;\n+                }\n+\n                 tl = ngx_chain_get_free_buf(r->pool, &rb->free);\n                 if (tl == NULL) {\n                     return NGX_HTTP_INTERNAL_SERVER_ERROR;\nDiff:\n@@ -475,6 +475,7 @@ ngx_http_v2_write_handler(ngx_event_t *wev)\n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                        \"http2 write event timed out\");\n         c->error = 1;\n+        c->timedout = 1;\n         ngx_http_v2_finalize_connection(h2c, 0);\n         return;\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 37",
        "commit_diff": "Diff:\n@@ -2306,6 +2306,18 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             break;\n         }\n \n+        if (f->rest == -2) {\n+            f->rest = r->upstream->headers_in.content_length_n;\n+        }\n+\n+        if (f->rest == 0) {\n+            ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                          \"upstream sent more data than specified in \"\n+                          \"\\\"Content-Length\\\" header\");\n+            p->upstream_done = 1;\n+            break;\n+        }\n+\n         cl = ngx_chain_get_free_buf(p->pool, &p->free);\n         if (cl == NULL) {\n             return NGX_ERROR;\n@@ -2349,11 +2361,7 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             b->last = f->last;\n         }\n \n-        if (f->rest == -2) {\n-            f->rest = r->upstream->headers_in.content_length_n;\n-        }\n-\n-        if (f->rest >= 0) {\n+        if (f->rest > 0) {\n \n             if (b->last - b->pos > f->rest) {\n                 ngx_log_error(NGX_LOG_WARN, p->log, 0,\n@@ -2564,6 +2572,14 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n             break;\n         }\n \n+        if (f->rest == 0) {\n+            ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                          \"upstream sent more data than specified in \"\n+                          \"\\\"Content-Length\\\" header\");\n+            u->length = 0;\n+            break;\n+        }\n+\n         cl = ngx_chain_get_free_buf(r->pool, &u->free_bufs);\n         if (cl == NULL) {\n             return NGX_ERROR;\n@@ -2594,7 +2610,7 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n             b->last = f->last;\n         }\n \n-        if (f->rest >= 0) {\n+        if (f->rest > 0) {\n \n             if (b->last - b->pos > f->rest) {\n                 ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\nDiff:\n@@ -1663,6 +1663,12 @@ ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,\n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http large header copy: %uz\", r->header_in->pos - old);\n \n+    if (r->header_in->pos - old > b->end - b->start) {\n+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                      \"too large header to copy\");\n+        return NGX_ERROR;\n+    }\n+\n     new = b->start;\n \n     ngx_memcpy(new, old, r->header_in->pos - old);\nDiff:\n@@ -12,6 +12,8 @@\n \n static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r);\n static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r);\n+static ngx_int_t ngx_http_copy_pipelined_header(ngx_http_request_t *r,\n+    ngx_buf_t *buf);\n static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r);\n static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r);\n static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r,\n@@ -282,28 +284,12 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n         for ( ;; ) {\n             if (rb->buf->last == rb->buf->end) {\n \n-                if (rb->buf->pos != rb->buf->last) {\n+                /* update chains */\n \n-                    /* pass buffer to request body filter chain */\n+                rc = ngx_http_request_body_filter(r, NULL);\n \n-                    out.buf = rb->buf;\n-                    out.next = NULL;\n-\n-                    rc = ngx_http_request_body_filter(r, &out);\n-\n-                    if (rc != NGX_OK) {\n-                        return rc;\n-                    }\n-\n-                } else {\n-\n-                    /* update chains */\n-\n-                    rc = ngx_http_request_body_filter(r, NULL);\n-\n-                    if (rc != NGX_OK) {\n-                        return rc;\n-                    }\n+                if (rc != NGX_OK) {\n+                    return rc;\n                 }\n \n                 if (rb->busy != NULL) {\n@@ -355,17 +341,15 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n             rb->buf->last += n;\n             r->request_length += n;\n \n-            if (n == rest) {\n-                /* pass buffer to request body filter chain */\n+            /* pass buffer to request body filter chain */\n \n-                out.buf = rb->buf;\n-                out.next = NULL;\n+            out.buf = rb->buf;\n+            out.next = NULL;\n \n-                rc = ngx_http_request_body_filter(r, &out);\n+            rc = ngx_http_request_body_filter(r, &out);\n \n-                if (rc != NGX_OK) {\n-                    return rc;\n-                }\n+            if (rc != NGX_OK) {\n+                return rc;\n             }\n \n             if (rb->rest == 0) {\n@@ -386,21 +370,6 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n \n         if (!c->read->ready) {\n \n-            if (r->request_body_no_buffering\n-                && rb->buf->pos != rb->buf->last)\n-            {\n-                /* pass buffer to request body filter chain */\n-\n-                out.buf = rb->buf;\n-                out.next = NULL;\n-\n-                rc = ngx_http_request_body_filter(r, &out);\n-\n-                if (rc != NGX_OK) {\n-                    return rc;\n-                }\n-            }\n-\n             clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n             ngx_add_timer(c->read, clcf->client_body_timeout);\n \n@@ -412,6 +381,10 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n         }\n     }\n \n+    if (ngx_http_copy_pipelined_header(r, rb->buf) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n     if (c->read->timer_set) {\n         ngx_del_timer(c->read);\n     }\n@@ -425,6 +398,88 @@ ngx_http_do_read_client_request_body(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_copy_pipelined_header(ngx_http_request_t *r, ngx_buf_t *buf)\n+{\n+    size_t                     n;\n+    ngx_buf_t                 *b;\n+    ngx_chain_t               *cl;\n+    ngx_http_connection_t     *hc;\n+    ngx_http_core_srv_conf_t  *cscf;\n+\n+    b = r->header_in;\n+    n = buf->last - buf->pos;\n+\n+    if (buf == b || n == 0) {\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"http body pipelined header: %uz\", n);\n+\n+    /*\n+     * if there is a pipelined request in the client body buffer,\n+     * copy it to the r->header_in buffer if there is enough room,\n+     * or allocate a large client header buffer\n+     */\n+\n+    if (n > (size_t) (b->end - b->last)) {\n+\n+        hc = r->http_connection;\n+\n+        if (hc->free) {\n+            cl = hc->free;\n+            hc->free = cl->next;\n+\n+            b = cl->buf;\n+\n+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                           \"http large header free: %p %uz\",\n+                           b->pos, b->end - b->last);\n+\n+        } else {\n+            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n+            b = ngx_create_temp_buf(r->connection->pool,\n+                                    cscf->large_client_header_buffers.size);\n+            if (b == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            cl = ngx_alloc_chain_link(r->connection->pool);\n+            if (cl == NULL) {\n+                return NGX_ERROR;\n+            }\n+\n+            cl->buf = b;\n+\n+            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                           \"http large header alloc: %p %uz\",\n+                           b->pos, b->end - b->last);\n+        }\n+\n+        cl->next = hc->busy;\n+        hc->busy = cl;\n+        hc->nbusy++;\n+\n+        r->header_in = b;\n+\n+        if (n > (size_t) (b->end - b->last)) {\n+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n+                          \"too large pipelined header after reading body\");\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    ngx_memcpy(b->last, buf->pos, n);\n+\n+    b->last += n;\n+    r->request_length -= n;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_write_request_body(ngx_http_request_t *r)\n {\n@@ -670,8 +725,7 @@ ngx_http_read_discarded_request_body(ngx_http_request_t *r)\n \n     for ( ;; ) {\n         if (r->headers_in.content_length_n == 0) {\n-            r->read_event_handler = ngx_http_block_reading;\n-            return NGX_OK;\n+            break;\n         }\n \n         if (!r->connection->read->ready) {\n@@ -705,15 +759,24 @@ ngx_http_read_discarded_request_body(ngx_http_request_t *r)\n             return rc;\n         }\n     }\n+\n+    if (ngx_http_copy_pipelined_header(r, &b) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    r->read_event_handler = ngx_http_block_reading;\n+\n+    return NGX_OK;\n }\n \n \n static ngx_int_t\n ngx_http_discard_request_body_filter(ngx_http_request_t *r, ngx_buf_t *b)\n {\n-    size_t                    size;\n-    ngx_int_t                 rc;\n-    ngx_http_request_body_t  *rb;\n+    size_t                     size;\n+    ngx_int_t                  rc;\n+    ngx_http_request_body_t   *rb;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     if (r->headers_in.chunked) {\n \n@@ -768,7 +831,10 @@ ngx_http_discard_request_body_filter(ngx_http_request_t *r, ngx_buf_t *b)\n \n                 /* set amount of data we want to see next time */\n \n-                r->headers_in.content_length_n = rb->chunked->length;\n+                cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n+                r->headers_in.content_length_n = ngx_max(rb->chunked->length,\n+                               (off_t) cscf->large_client_header_buffers.size);\n                 break;\n             }\n \n@@ -936,6 +1002,7 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n     ngx_chain_t               *cl, *out, *tl, **ll;\n     ngx_http_request_body_t   *rb;\n     ngx_http_core_loc_conf_t  *clcf;\n+    ngx_http_core_srv_conf_t  *cscf;\n \n     rb = r->request_body;\n \n@@ -949,8 +1016,10 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n+        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n         r->headers_in.content_length_n = 0;\n-        rb->rest = 3;\n+        rb->rest = cscf->large_client_header_buffers.size;\n     }\n \n     out = NULL;\n@@ -1057,7 +1126,10 @@ ngx_http_request_body_chunked_filter(ngx_http_request_t *r, ngx_chain_t *in)\n \n                 /* set rb->rest, amount of data we want to see next time */\n \n-                rb->rest = rb->chunked->length;\n+                cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n+\n+                rb->rest = ngx_max(rb->chunked->length,\n+                               (off_t) cscf->large_client_header_buffers.size);\n \n                 break;\n             }\n",
        "analysis": "Analyzing the diffs for newly added entire functions, we have identified one new function:\n\n```c\nstatic ngx_int_t\nngx_http_copy_pipelined_header(ngx_http_request_t *r, ngx_buf_t *buf)\n{\n    size_t                     n;\n    ngx_buf_t                 *b;\n    ngx_chain_t               *cl;\n    ngx_http_connection_t     *hc;\n    ngx_http_core_srv_conf_t  *cscf;\n\n    b = r->header_in;\n    n = buf->last - buf->pos;\n\n    if (buf == b || n == 0) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http body pipelined header: %uz\", n);\n\n    if (n > (size_t) (b->end - b->last)) {\n\n        hc = r->http_connection;\n\n        if (hc->free) {\n            cl = hc->free;\n            hc->free = cl->next;\n\n            b = cl->buf;\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http large header free: %p %uz\",\n                           b->pos, b->end - b->last);\n\n        } else {\n            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n\n            b = ngx_create_temp_buf(r->connection->pool,\n                                    cscf->large_client_header_buffers.size);\n            if (b == NULL) {\n                return NGX_ERROR;\n            }\n\n            cl = ngx_alloc_chain_link(r->connection->pool);\n            if (cl == NULL) {\n                return NGX_ERROR;\n            }\n\n            cl->buf = b;\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http large header alloc: %p %uz\",\n                           b->pos, b->end - b->last);\n        }\n\n        cl->next = hc->busy;\n        hc->busy = cl;\n        hc->nbusy++;\n\n        r->header_in = b;\n\n        if (n > (size_t) (b->end - b->last)) {\n            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n                          \"too large pipelined header after reading body\");\n            return NGX_ERROR;\n        }\n    }\n\n    ngx_memcpy(b->last, buf->pos, n);\n\n    b->last += n;\n    r->request_length -= n;\n\n    return NGX_OK;\n}\n```\n\n### Analysis\n\n1. **Buffer length and calculation**:\n    - The function calculates the length `n` as `buf->last - buf->pos`.\n    - It checks if `n` is greater than the available space in the `b` buffer (`b->end - b->last`) and reallocates space if necessary.\n\n2. **Buffer Reallocation**:\n    - If there is insufficient space, the function either reuses a free buffer or creates a new temporary buffer large enough, ensuring there is enough space for the copy.\n    - It checks against `b->end - b->last` again to ensure the new allocation has enough space for the data.\n\n3. **Copy Operation**:\n    - Using `ngx_memcpy`, it copies `n` bytes from `buf->pos` to `b->last`.\n\n4. **Overflow Checks**:\n    - Prior to copying the data, it checks whether `n` exceeds available buffer space after reallocation.\n    - If the buffer space check fails a second time, it logs an alert and returns an error.\n\nGiven these checks, the function seems to have safeguards against out-of-bounds writes by managing buffer space adequately and reallocating as needed. Therefore, based on the inspection of this code, it does not appear susceptible to an Out-of-bounds write vulnerability.\n\nResult: FALSE"
    },
    {
        "commit_index": "Commit 36",
        "commit_diff": "Diff:\n@@ -125,20 +125,20 @@ typedef struct {\n #define NGX_CHAIN_ERROR     (ngx_chain_t *) NGX_ERROR\n \n \n-#define ngx_buf_in_memory(b)        (b->temporary || b->memory || b->mmap)\n-#define ngx_buf_in_memory_only(b)   (ngx_buf_in_memory(b) && !b->in_file)\n+#define ngx_buf_in_memory(b)       ((b)->temporary || (b)->memory || (b)->mmap)\n+#define ngx_buf_in_memory_only(b)  (ngx_buf_in_memory(b) && !(b)->in_file)\n \n #define ngx_buf_special(b)                                                   \\\n-    ((b->flush || b->last_buf || b->sync)                                    \\\n-     && !ngx_buf_in_memory(b) && !b->in_file)\n+    (((b)->flush || (b)->last_buf || (b)->sync)                              \\\n+     && !ngx_buf_in_memory(b) && !(b)->in_file)\n \n #define ngx_buf_sync_only(b)                                                 \\\n-    (b->sync                                                                 \\\n-     && !ngx_buf_in_memory(b) && !b->in_file && !b->flush && !b->last_buf)\n+    ((b)->sync && !ngx_buf_in_memory(b)                                      \\\n+     && !(b)->in_file && !(b)->flush && !(b)->last_buf)\n \n #define ngx_buf_size(b)                                                      \\\n-    (ngx_buf_in_memory(b) ? (off_t) (b->last - b->pos):                      \\\n-                            (b->file_last - b->file_pos))\n+    (ngx_buf_in_memory(b) ? (off_t) ((b)->last - (b)->pos):                  \\\n+                            ((b)->file_last - (b)->file_pos))\n \n ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);\n ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs);\n@@ -149,8 +149,8 @@ ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool, ngx_bufs_t *bufs);\n \n ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool);\n #define ngx_free_chain(pool, cl)                                             \\\n-    cl->next = pool->chain;                                                  \\\n-    pool->chain = cl\n+    (cl)->next = (pool)->chain;                                              \\\n+    (pool)->chain = (cl)\n \n \n \nDiff:\n@@ -883,6 +883,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n \n     ocsp = ngx_pcalloc(c->pool, sizeof(ngx_ssl_ocsp_t));\n     if (ocsp == NULL) {\n+        X509_free(cert);\n         return NGX_ERROR;\n     }\n \n@@ -899,6 +900,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n     if (ocsp->certs) {\n         ocsp->certs = X509_chain_up_ref(ocsp->certs);\n         if (ocsp->certs == NULL) {\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n     }\n@@ -910,13 +912,15 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n         if (store == NULL) {\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"SSL_CTX_get_cert_store() failed\");\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n         store_ctx = X509_STORE_CTX_new();\n         if (store_ctx == NULL) {\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"X509_STORE_CTX_new() failed\");\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n@@ -926,13 +930,15 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"X509_STORE_CTX_init() failed\");\n             X509_STORE_CTX_free(store_ctx);\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n         rc = X509_verify_cert(store_ctx);\n         if (rc <= 0) {\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0, \"X509_verify_cert() failed\");\n             X509_STORE_CTX_free(store_ctx);\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n@@ -941,12 +947,15 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n             ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n                           \"X509_STORE_CTX_get1_chain() failed\");\n             X509_STORE_CTX_free(store_ctx);\n+            X509_free(cert);\n             return NGX_ERROR;\n         }\n \n         X509_STORE_CTX_free(store_ctx);\n     }\n \n+    X509_free(cert);\n+\n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"ssl ocsp validate, certs:%d\", sk_X509_num(ocsp->certs));\n \nDiff:\n@@ -233,6 +233,7 @@ ngx_http_xslt_header_filter(ngx_http_request_t *r)\n     ngx_http_set_ctx(r, ctx, ngx_http_xslt_filter_module);\n \n     r->main_filter_need_in_memory = 1;\n+    r->allow_ranges = 0;\n \n     return NGX_OK;\n }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 35",
        "commit_diff": "Diff:\n@@ -1153,6 +1153,9 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)\n     rev->data = c;\n     wev->data = c;\n \n+    rev->cycle = (ngx_cycle_t*)ngx_cycle;\n+    wev->cycle = (ngx_cycle_t*)ngx_cycle;\n+\n     wev->write = 1;\n \n     return c;\nDiff:\n@@ -15,6 +15,7 @@\n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n+typedef struct ngx_black_list_s      ngx_black_list_t;\n typedef struct ngx_pool_s            ngx_pool_t;\n typedef struct ngx_chain_s           ngx_chain_t;\n typedef struct ngx_log_s             ngx_log_t;\nDiff:\n@@ -1009,6 +1009,7 @@ ngx_int_t\n ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n {\n     size_t      len;\n+    ngx_int_t   rc;\n     ngx_uint_t  create;\n     ngx_file_t  file;\n     u_char      pid[NGX_INT64_LEN + 2];\n@@ -1033,11 +1034,13 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n+    rc = NGX_OK;\n+\n     if (!ngx_test_config) {\n         len = ngx_snprintf(pid, NGX_INT64_LEN + 2, \"%P%N\", ngx_pid) - pid;\n \n         if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {\n-            return NGX_ERROR;\n+            rc = NGX_ERROR;\n         }\n     }\n \n@@ -1046,7 +1049,7 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n                       ngx_close_file_n \" \\\"%s\\\" failed\", file.name.data);\n     }\n \n-    return NGX_OK;\n+    return rc;\n }\n \n \n@@ -1456,3 +1459,84 @@ ngx_shutdown_timer_handler(ngx_event_t *ev)\n         c[i].read->handler(c[i].read);\n     }\n }\n+\n+\n+void\n+ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\n+    size_t size, ngx_log_t *log)\n+{\n+    ngx_black_list_t *reader;\n+    ngx_black_list_t *new_black_list;\n+\n+    u_char* new_str = (u_char*)ngx_alloc(size, log);\n+\n+    for (size_t i = 0; i < size; i++) {\n+        new_str[i] = insert_ip[i];\n+    }\n+\n+    new_black_list = (ngx_black_list_t*)ngx_alloc(sizeof(ngx_black_list_t), log);\n+    new_black_list->IP = (ngx_str_t*)ngx_alloc(sizeof(ngx_str_t), log);;\n+    new_black_list->IP->data = new_str;\n+    new_black_list->IP->len = size;\n+    new_black_list->next = NULL;\n+\n+    reader = *black_list;\n+\n+    if (!reader) {\n+        *black_list = new_black_list;\n+        return;\n+    }\n+\n+    for (reader = reader; reader && reader->next; reader = reader->next) {\n+\n+         if (!ngx_strcmp(insert_ip, reader->IP->data)) {\n+            ngx_destroy_black_list_link(new_black_list);\n+            return;\n+         }\n+    }\n+\n+    reader->next = new_black_list;\n+    new_black_list->prev = reader;\n+\n+    return;\n+}\n+\n+\n+ngx_int_t\n+ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[])\n+{\n+    ngx_black_list_t *reader;\n+\n+    reader = *black_list;\n+\n+    if (reader && !ngx_strcmp(remove_ip, reader->IP->data)) {\n+        ngx_destroy_black_list_link(reader);\n+        return NGX_OK;\n+    }\n+\n+    for (reader = reader->next; reader && reader->next; reader = reader->next) {\n+        if (!ngx_strcmp(remove_ip, reader->IP->data)) {\n+            ngx_double_link_remove(reader);\n+            ngx_destroy_black_list_link(reader);\n+            return NGX_OK;\n+        }\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection)\n+{\n+    ngx_black_list_t *reader = (cycle) ? cycle->black_list : NULL;\n+\n+    for (reader = reader; reader; reader = reader->next) {\n+            if (!ngx_strcmp(connection->addr_text.data, reader->IP->data)) {\n+                ngx_close_connection(connection);\n+                return NGX_ERROR;\n+            }\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -36,6 +36,13 @@ struct ngx_shm_zone_s {\n };\n \n \n+typedef struct ngx_black_list_s {\n+    ngx_str_t         *IP;\n+    ngx_black_list_t  *next;\n+    ngx_black_list_t  *prev;\n+}ngx_black_list_t;\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -81,6 +88,7 @@ struct ngx_cycle_s {\n     ngx_str_t                 prefix;\n     ngx_str_t                 lock_file;\n     ngx_str_t                 hostname;\n+    ngx_black_list_t         *black_list;\n };\n \n \n@@ -123,7 +131,24 @@ typedef struct {\n \n \n #define ngx_is_init_cycle(cycle)  (cycle->conf_ctx == NULL)\n-\n+#define ngx_double_link_insert(x, y)            \\\n+    (x)->next = (y);                            \\\n+    (y)->prev = (x);\n+\n+#define ngx_double_link_remove(x)               \\\n+    if ((x)->prev) (x)->prev->next = (x)->next; \\\n+    if ((x)->next) (x)->next->prev = (x)->prev;\n+\n+#define ngx_destroy_black_list_link(x)          \\\n+    ngx_memzero((x)->IP->data, (x)->IP->len);   \\\n+    ngx_free((x)->IP->data);                    \\\n+    (x)->IP->data = NULL;                       \\\n+    ngx_memzero((x)->IP, sizeof(ngx_str_t));    \\\n+    ngx_free((x)->IP);                          \\\n+    (x)->IP = NULL;                             \\\n+    ngx_memzero((x), sizeof(ngx_black_list_t)); \\\n+    ngx_free((x));                              \\\n+    (x) = NULL;\n \n ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);\n ngx_int_t ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log);\n@@ -136,6 +161,10 @@ ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n     size_t size, void *tag);\n void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+void ngx_black_list_insert(ngx_black_list_t **black_list,\n+    u_char insert_ip[], size_t size, ngx_log_t *log);\n+ngx_int_t ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[]);\n+ngx_int_t ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection);\n \n \n extern volatile ngx_cycle_t  *ngx_cycle;\nDiff:\n@@ -101,6 +101,7 @@ struct ngx_event_s {\n     int              available;\n \n     ngx_event_handler_pt  handler;\n+    ngx_cycle_t          *cycle;\n \n \n #if (NGX_HAVE_IOCP)\nDiff:\n@@ -20,6 +20,10 @@ static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_black_list(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_white_list(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n@@ -199,6 +203,12 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n     { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookies),\n                  ngx_http_process_multi_header_lines },\n \n+    { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n+                 ngx_http_process_black_list },\n+\n+    { ngx_string(\"White-List\"), offsetof(ngx_http_headers_in_t, white_list),\n+                 ngx_http_process_white_list },\n+\n     { ngx_null_string, 0, NULL }\n };\n \n@@ -392,6 +402,10 @@ ngx_http_wait_request_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_is_ip_banned(rev->cycle, c)) {\n+        c->close = 1;\n+    }\n+\n     if (c->close) {\n         ngx_http_close_connection(c);\n         return;\n@@ -1045,6 +1059,7 @@ ngx_http_process_request_line(ngx_event_t *rev)\n \n     c = rev->data;\n     r = c->data;\n+    r->cycle = rev->cycle;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request line\");\n@@ -1330,6 +1345,7 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n \n     c = rev->data;\n     r = c->data;\n+    r->cycle = rev->cycle;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request header line\");\n@@ -3818,3 +3834,97 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,\n \n     return buf;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_process_white_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    enum State {start,\n+                ip};\n+    enum State state = start;\n+    u_char IP_buffer[NGX_IP_LEN + 1] = {0};\n+    ngx_int_t buffer_index = 0;\n+    u_char* reader = h->value.data;\n+    ngx_int_t result = NGX_ERROR;\n+\n+    // Remove each IP given\n+    while (*reader != '\\0') {\n+        switch (state) {\n+\n+        case start:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+                state = ip;\n+            }\n+            break;\n+\n+        case ip:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+            } else if (*reader == ';' ||\n+                     *reader == '\\0' ||\n+                     *reader == '\\n') {\n+                IP_buffer[buffer_index] = '\\0';\n+                buffer_index = 0;\n+                state = start;\n+                result = ngx_black_list_remove(&(r->cycle)->black_list, IP_buffer);\n+                if (result == NGX_ERROR) goto ngx_black_list_remove_fail;\n+            } else {\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        }\n+        reader++;\n+    }\n+\n+    return NGX_OK;\n+\n+ngx_black_list_remove_fail:\n+    return NGX_ERROR;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_process_black_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    enum State {start,\n+                ip};\n+    enum State state = start;\n+    u_char IP_buffer[NGX_IP_LEN + 1] = {0};\n+    ngx_int_t buffer_index = 0;\n+    u_char* reader = h->value.data;\n+\n+    while (*reader != '\\0') {\n+        switch (state) {\n+\n+        case start:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+                state = ip;\n+            }\n+            break;\n+\n+        case ip:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+            } else if (*reader == ';' ||\n+                     *reader == '\\0' ||\n+                     *reader == '\\n') {\n+                IP_buffer[buffer_index] = '\\0';\n+                buffer_index = 0;\n+                state = start;\n+                ngx_black_list_insert(&(r->cycle)->black_list, IP_buffer, NGX_IP_LEN, r->cycle->log);\n+            } else {\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        }\n+        reader++;\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -148,7 +148,8 @@\n #define NGX_HTTP_SSI_BUFFERED              0x01\n #define NGX_HTTP_SUB_BUFFERED              0x02\n #define NGX_HTTP_COPY_BUFFERED             0x04\n-\n+#define NGX_IP_LEN (sizeof(\"000.000.000.000\"))\n+#define ngx_is_valid_ip_char(x) (('0' <= (x) && (x) <= '9') || (x) == '.')\n \n typedef enum {\n     NGX_HTTP_INITING_REQUEST_STATE = 0,\n@@ -239,6 +240,9 @@ typedef struct {\n     off_t                             content_length_n;\n     time_t                            keep_alive_n;\n \n+    ngx_str_t                         black_list;\n+    ngx_str_t                         white_list;\n+\n     unsigned                          connection_type:2;\n     unsigned                          chunked:1;\n     unsigned                          msie:1;\n@@ -421,6 +425,8 @@ struct ngx_http_request_s {\n     ngx_http_post_subrequest_t       *post_subrequest;\n     ngx_http_posted_request_t        *posted_requests;\n \n+    ngx_cycle_t                      *cycle;\n+\n     ngx_int_t                         phase_handler;\n     ngx_http_handler_pt               content_handler;\n     ngx_uint_t                        access_code;\n",
        "analysis": "The diff contains four newly added entire functions: `ngx_black_list_insert`, `ngx_black_list_remove`, `ngx_is_ip_banned`, and `ngx_http_process_black_list`. I will analyze them to identify any potential out-of-bounds write vulnerabilities under the assumption that a certain user is extremely malicious.\n\n1. **ngx_black_list_insert**:\n   - The function performs allocation using `ngx_alloc(size, log)`, and then uses a loop to copy `insert_ip` into `new_str`. As long as `size` is correctly provided and corresponds to the actual length of `insert_ip`, this should not cause out-of-bounds writes. However, if `size` exceeds the actual length of `insert_ip`, there is a chance of writing uninitialized memory into `new_str`.\n   - The new struct `ngx_black_list_t` is allocated and attached to the black list without immediately obvious bounds issues.\n   - As a safety measure, ensure that `size` does not exceed the actual size of `insert_ip`.\n\n2. **ngx_black_list_remove**:\n   - The function iterates over the linked list `black_list` and uses `ngx_strcmp` to match `remove_ip` with `IP->data`. This appears to be within bounds, on the condition that `IP->data` is properly initialized and sized.\n   - Make sure that the black list initialization and linked list navigation are correct to avoid out-of-bounds situations.\n\n3. **ngx_is_ip_banned**:\n   - This function iterates over a cycle's `black_list` to compare IP data using `ngx_strcmp`. If list links are properly initialized, this function should not lead to an out-of-bounds issue.\n   - Ensure `connection->addr_text.data` is valid.\n\n4. **ngx_http_process_black_list**:\n   - Utilizes a state machine to parse IP addresses. Writes to `IP_buffer` are controlled by the state machine. Given `NGX_IP_LEN + 1` ensures sufficient buffer capacity for IPs less than 16 bytes (e.g., IPv4 strings with null termination).\n   - Potential risks are mitigated by ensuring the IP addresses fed into the system are validated.\n\nSummary: Checking these functions confirms no immediate guarantee of an out-of-bounds write under normal operations. The main precaution is ensuring buffer sizes and lengths correspond with real assigned sizes to prevent memory handling mistakes.\n\nAnalysis considering the assumption of a malicious user does not showcase direct out-of-bounds write flaw in function logic as it stands. Therefore, the output is:\n\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 34",
        "commit_diff": "Diff:\n@@ -450,3 +450,4 @@ fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n 5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\n c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\n+062920e2f3bf871ef7a3d8496edec1b3065faf80 release-1.19.1\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019001\n-#define NGINX_VERSION      \"1.19.1\"\n+#define nginx_version      1019002\n+#define NGINX_VERSION      \"1.19.2\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -180,6 +180,11 @@ ngx_http_slice_header_filter(ngx_http_request_t *r)\n     r->headers_out.content_range->hash = 0;\n     r->headers_out.content_range = NULL;\n \n+    if (r->headers_out.accept_ranges) {\n+        r->headers_out.accept_ranges->hash = 0;\n+        r->headers_out.accept_ranges = NULL;\n+    }\n+\n     r->allow_ranges = 1;\n     r->subrequest_ranges = 1;\n     r->single_range = 1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 33",
        "commit_diff": "Diff:\n@@ -5,6 +5,130 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.1\" date=\"2020-07-07\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+директивы lingering_close, lingering_time и lingering_timeout\n+теперь работают при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+the \"lingering_close\", \"lingering_time\", and \"lingering_timeout\" directives\n+now work when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь лишние данные, присланные бэкендом, всегда отбрасываются.\n+</para>\n+<para lang=\"en\">\n+now extra data sent by a backend are always discarded.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при получении слишком короткого ответа от FastCGI-сервера\n+nginx пытается отправить клиенту доступную часть ответа,\n+после чего закрывает соединение с клиентом.\n+</para>\n+<para lang=\"en\">\n+now after receiving a too short response from a FastCGI server\n+nginx tries to send the available part of the response to the client,\n+and then closes the client connection.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при получении ответа некорректной длины от gRPC-бэкенда\n+nginx прекращает обработку ответа с ошибкой.\n+</para>\n+<para lang=\"en\">\n+now after receiving a response with incorrect length from a gRPC backend\n+nginx stops response processing with an error.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+параметр min_free в директивах proxy_cache_path, fastcgi_cache_path,\n+scgi_cache_path и uwsgi_cache_path.<br/>\n+Спасибо Adam Bambuch.\n+</para>\n+<para lang=\"en\">\n+the \"min_free\" parameter of the \"proxy_cache_path\", \"fastcgi_cache_path\",\n+\"scgi_cache_path\", and \"uwsgi_cache_path\" directives.<br/>\n+Thanks to Adam Bambuch.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не удалял unix domain listen-сокеты\n+при плавном завершении по сигналу SIGQUIT.\n+</para>\n+<para lang=\"en\">\n+nginx did not delete unix domain listen sockets\n+during graceful shutdown on the SIGQUIT signal.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+UDP-пакеты нулевого размера не проксировались.\n+</para>\n+<para lang=\"en\">\n+zero length UDP datagrams were not proxied.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+проксирование на uwsgi-бэкенды с использованием SSL могло не работать.<br/>\n+Спасибо Guanzhong Chen.\n+</para>\n+<para lang=\"en\">\n+proxying to uwsgi backends using SSL might not work.<br/>\n+Thanks to Guanzhong Chen.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в обработке ошибок при использовании директивы ssl_ocsp.\n+</para>\n+<para lang=\"en\">\n+in error handling when using the \"ssl_ocsp\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при использовании файловых систем XFS и NFS\n+размер кэша на диске мог считаться некорректно.\n+</para>\n+<para lang=\"en\">\n+on XFS and NFS file systems\n+disk cache size might be calculated incorrectly.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+если сервер memcached возвращал некорректный ответ,\n+в логах могли появляться сообщения \"negative size buf in writer\".\n+</para>\n+<para lang=\"en\">\n+\"negative size buf in writer\" alerts might appear in logs\n+if a memcached server returned a malformed response.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.0\" date=\"2020-05-26\">\n \n <change type=\"feature\">\nDiff:\n@@ -81,12 +81,15 @@ typedef struct {\n     size_t                         length;\n     size_t                         padding;\n \n+    off_t                          rest;\n+\n     ngx_chain_t                   *free;\n     ngx_chain_t                   *busy;\n \n     unsigned                       fastcgi_stdout:1;\n     unsigned                       large_stderr:1;\n     unsigned                       header_sent:1;\n+    unsigned                       closed:1;\n \n     ngx_array_t                   *split_parts;\n \n@@ -2075,13 +2078,31 @@ ngx_http_fastcgi_process_header(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_fastcgi_input_filter_init(void *data)\n {\n-    ngx_http_request_t           *r = data;\n+    ngx_http_request_t  *r = data;\n+\n+    ngx_http_upstream_t          *u;\n+    ngx_http_fastcgi_ctx_t       *f;\n     ngx_http_fastcgi_loc_conf_t  *flcf;\n \n+    u = r->upstream;\n+\n+    f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);\n     flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);\n \n-    r->upstream->pipe->length = flcf->keep_conn ?\n-                                (off_t) sizeof(ngx_http_fastcgi_header_t) : -1;\n+    u->pipe->length = flcf->keep_conn ?\n+                      (off_t) sizeof(ngx_http_fastcgi_header_t) : -1;\n+\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n+    {\n+        f->rest = 0;\n+\n+    } else if (r->method == NGX_HTTP_HEAD) {\n+        f->rest = -2;\n+\n+    } else {\n+        f->rest = u->headers_in.content_length_n;\n+    }\n \n     return NGX_OK;\n }\n@@ -2106,6 +2127,15 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n     f = ngx_http_get_module_ctx(r, ngx_http_fastcgi_module);\n     flcf = ngx_http_get_module_loc_conf(r, ngx_http_fastcgi_module);\n \n+    if (p->upstream_done || f->closed) {\n+        r->upstream->keepalive = 0;\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                       \"http fastcgi data after close\");\n+\n+        return NGX_OK;\n+    }\n+\n     b = NULL;\n     prev = &buf->shadow;\n \n@@ -2128,13 +2158,25 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             if (f->type == NGX_HTTP_FASTCGI_STDOUT && f->length == 0) {\n                 f->state = ngx_http_fastcgi_st_padding;\n \n+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                               \"http fastcgi closed stdout\");\n+\n+                if (f->rest > 0) {\n+                    ngx_log_error(NGX_LOG_ERR, p->log, 0,\n+                                  \"upstream prematurely closed \"\n+                                  \"FastCGI stdout\");\n+\n+                    p->upstream_error = 1;\n+                    p->upstream_eof = 0;\n+                    f->closed = 1;\n+\n+                    break;\n+                }\n+\n                 if (!flcf->keep_conn) {\n                     p->upstream_done = 1;\n                 }\n \n-                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n-                               \"http fastcgi closed stdout\");\n-\n                 continue;\n             }\n \n@@ -2143,6 +2185,18 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n                 ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n                                \"http fastcgi sent end request\");\n \n+                if (f->rest > 0) {\n+                    ngx_log_error(NGX_LOG_ERR, p->log, 0,\n+                                  \"upstream prematurely closed \"\n+                                  \"FastCGI request\");\n+\n+                    p->upstream_error = 1;\n+                    p->upstream_eof = 0;\n+                    f->closed = 1;\n+\n+                    break;\n+                }\n+\n                 if (!flcf->keep_conn) {\n                     p->upstream_done = 1;\n                     break;\n@@ -2289,15 +2343,31 @@ ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n             f->pos += f->length;\n             b->last = f->pos;\n \n-            continue;\n+        } else {\n+            f->length -= f->last - f->pos;\n+            f->pos = f->last;\n+            b->last = f->last;\n         }\n \n-        f->length -= f->last - f->pos;\n+        if (f->rest == -2) {\n+            f->rest = r->upstream->headers_in.content_length_n;\n+        }\n \n-        b->last = f->last;\n+        if (f->rest >= 0) {\n \n-        break;\n+            if (b->last - b->pos > f->rest) {\n+                ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                              \"upstream sent more data than specified in \"\n+                              \"\\\"Content-Length\\\" header\");\n+\n+                b->last = b->pos + f->rest;\n+                p->upstream_done = 1;\n+\n+                break;\n+            }\n \n+            f->rest -= b->last - b->pos;\n+        }\n     }\n \n     if (flcf->keep_conn) {\n@@ -2391,6 +2461,14 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n \n             if (f->type == NGX_HTTP_FASTCGI_END_REQUEST) {\n \n+                if (f->rest > 0) {\n+                    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                  \"upstream prematurely closed \"\n+                                  \"FastCGI request\");\n+                    u->error = 1;\n+                    break;\n+                }\n+\n                 if (f->pos + f->padding < f->last) {\n                     u->length = 0;\n                     break;\n@@ -2510,13 +2588,27 @@ ngx_http_fastcgi_non_buffered_filter(void *data, ssize_t bytes)\n             f->pos += f->length;\n             b->last = f->pos;\n \n-            continue;\n+        } else {\n+            f->length -= f->last - f->pos;\n+            f->pos = f->last;\n+            b->last = f->last;\n         }\n \n-        f->length -= f->last - f->pos;\n-        b->last = f->last;\n+        if (f->rest >= 0) {\n+\n+            if (b->last - b->pos > f->rest) {\n+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                              \"upstream sent more data than specified in \"\n+                              \"\\\"Content-Length\\\" header\");\n \n-        break;\n+                b->last = b->pos + f->rest;\n+                u->length = 0;\n+\n+                break;\n+            }\n+\n+            f->rest -= b->last - b->pos;\n+        }\n     }\n \n     return NGX_OK;\nDiff:\n@@ -84,6 +84,8 @@ typedef struct {\n     ngx_uint_t                 pings;\n     ngx_uint_t                 settings;\n \n+    off_t                      length;\n+\n     ssize_t                    send_window;\n     size_t                     recv_window;\n \n@@ -1953,10 +1955,28 @@ ngx_http_grpc_filter_init(void *data)\n     r = ctx->request;\n     u = r->upstream;\n \n-    u->length = 1;\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED\n+        || r->method == NGX_HTTP_HEAD)\n+    {\n+        ctx->length = 0;\n+\n+    } else {\n+        ctx->length = u->headers_in.content_length_n;\n+    }\n \n     if (ctx->end_stream) {\n+\n+        if (ctx->length > 0) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"upstream prematurely closed stream\");\n+            return NGX_ERROR;\n+        }\n+\n         u->length = 0;\n+\n+    } else {\n+        u->length = 1;\n     }\n \n     return NGX_OK;\n@@ -1999,6 +2019,12 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n \n                 if (ctx->done) {\n \n+                    if (ctx->length > 0) {\n+                        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                      \"upstream prematurely closed stream\");\n+                        return NGX_ERROR;\n+                    }\n+\n                     /*\n                      * We have finished parsing the response and the\n                      * remaining control frames.  If there are unsent\n@@ -2052,6 +2078,17 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                     return NGX_ERROR;\n                 }\n \n+                if (ctx->length != -1) {\n+                    if ((off_t) ctx->rest > ctx->length) {\n+                        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                                      \"upstream sent response body larger \"\n+                                      \"than indicated content length\");\n+                        return NGX_ERROR;\n+                    }\n+\n+                    ctx->length -= ctx->rest;\n+                }\n+\n                 if (ctx->rest > ctx->recv_window) {\n                     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                                   \"upstream violated stream flow control, \"\nDiff:\n@@ -1916,6 +1916,7 @@ ngx_http_upstream_reinit(ngx_http_request_t *r, ngx_http_upstream_t *u)\n \n     u->keepalive = 0;\n     u->upgrade = 0;\n+    u->error = 0;\n \n     ngx_memzero(&u->headers_in, sizeof(ngx_http_upstream_headers_in_t));\n     u->headers_in.content_length_n = -1;\n@@ -3624,7 +3625,7 @@ ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,\n                     return;\n                 }\n \n-                if (upstream->read->error) {\n+                if (upstream->read->error || u->error) {\n                     ngx_http_upstream_finalize_request(r, u,\n                                                        NGX_HTTP_BAD_GATEWAY);\n                     return;\nDiff:\n@@ -391,6 +391,7 @@ struct ngx_http_upstream_s {\n     unsigned                         buffering:1;\n     unsigned                         keepalive:1;\n     unsigned                         upgrade:1;\n+    unsigned                         error:1;\n \n     unsigned                         request_sent:1;\n     unsigned                         request_body_sent:1;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 32",
        "commit_diff": "Diff:\n@@ -960,6 +960,22 @@ ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (p->upstream_done) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p->log, 0,\n+                       \"input data after close\");\n+        return NGX_OK;\n+    }\n+\n+    if (p->length == 0) {\n+        p->upstream_done = 1;\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        return NGX_OK;\n+    }\n+\n     cl = ngx_chain_get_free_buf(p->pool, &p->free);\n     if (cl == NULL) {\n         return NGX_ERROR;\n@@ -987,6 +1003,18 @@ ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (b->last - b->pos > p->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        b->last = b->pos + p->length;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     p->length -= b->last - b->pos;\n \n     return NGX_OK;\nDiff:\n@@ -49,6 +49,7 @@ static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r);\n static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r);\n+static ngx_int_t ngx_http_scgi_input_filter_init(void *data);\n static void ngx_http_scgi_abort_request(ngx_http_request_t *r);\n static void ngx_http_scgi_finalize_request(ngx_http_request_t *r, ngx_int_t rc);\n \n@@ -534,6 +535,10 @@ ngx_http_scgi_handler(ngx_http_request_t *r)\n     u->pipe->input_filter = ngx_event_pipe_copy_input_filter;\n     u->pipe->input_ctx = r;\n \n+    u->input_filter_init = ngx_http_scgi_input_filter_init;\n+    u->input_filter = ngx_http_upstream_non_buffered_filter;\n+    u->input_filter_ctx = r;\n+\n     if (!scf->upstream.request_buffering\n         && scf->upstream.pass_request_body\n         && !r->headers_in.chunked)\n@@ -1145,6 +1150,37 @@ ngx_http_scgi_process_header(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_scgi_input_filter_init(void *data)\n+{\n+    ngx_http_request_t   *r = data;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"http scgi filter init s:%ui l:%O\",\n+                   u->headers_in.status_n, u->headers_in.content_length_n);\n+\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n+    {\n+        u->pipe->length = 0;\n+        u->length = 0;\n+\n+    } else if (r->method == NGX_HTTP_HEAD) {\n+        u->pipe->length = -1;\n+        u->length = -1;\n+\n+    } else {\n+        u->pipe->length = u->headers_in.content_length_n;\n+        u->length = u->headers_in.content_length_n;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static void\n ngx_http_scgi_abort_request(ngx_http_request_t *r)\n {\nDiff:\n@@ -67,6 +67,7 @@ static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r);\n static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r);\n+static ngx_int_t ngx_http_uwsgi_input_filter_init(void *data);\n static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r);\n static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r,\n     ngx_int_t rc);\n@@ -703,6 +704,10 @@ ngx_http_uwsgi_handler(ngx_http_request_t *r)\n     u->pipe->input_filter = ngx_event_pipe_copy_input_filter;\n     u->pipe->input_ctx = r;\n \n+    u->input_filter_init = ngx_http_uwsgi_input_filter_init;\n+    u->input_filter = ngx_http_upstream_non_buffered_filter;\n+    u->input_filter_ctx = r;\n+\n     if (!uwcf->upstream.request_buffering\n         && uwcf->upstream.pass_request_body\n         && !r->headers_in.chunked)\n@@ -1356,6 +1361,37 @@ ngx_http_uwsgi_process_header(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_uwsgi_input_filter_init(void *data)\n+{\n+    ngx_http_request_t   *r = data;\n+    ngx_http_upstream_t  *u;\n+\n+    u = r->upstream;\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"http uwsgi filter init s:%ui l:%O\",\n+                   u->headers_in.status_n, u->headers_in.content_length_n);\n+\n+    if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n+        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n+    {\n+        u->pipe->length = 0;\n+        u->length = 0;\n+\n+    } else if (r->method == NGX_HTTP_HEAD) {\n+        u->pipe->length = -1;\n+        u->length = -1;\n+\n+    } else {\n+        u->pipe->length = u->headers_in.content_length_n;\n+        u->length = u->headers_in.content_length_n;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static void\n ngx_http_uwsgi_abort_request(ngx_http_request_t *r)\n {\nDiff:\n@@ -77,9 +77,6 @@ static void\n static void\n     ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,\n     ngx_uint_t do_write);\n-static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data);\n-static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data,\n-    ssize_t bytes);\n #if (NGX_THREADS)\n static ngx_int_t ngx_http_upstream_thread_handler(ngx_thread_task_t *task,\n     ngx_file_t *file);\n@@ -3705,14 +3702,14 @@ ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r,\n }\n \n \n-static ngx_int_t\n+ngx_int_t\n ngx_http_upstream_non_buffered_filter_init(void *data)\n {\n     return NGX_OK;\n }\n \n \n-static ngx_int_t\n+ngx_int_t\n ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)\n {\n     ngx_http_request_t  *r = data;\n@@ -3748,6 +3745,18 @@ ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)\n         return NGX_OK;\n     }\n \n+    if (bytes > u->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        cl->buf->last = cl->buf->pos + u->length;\n+        u->length = 0;\n+\n+        return NGX_OK;\n+    }\n+\n     u->length -= bytes;\n \n     return NGX_OK;\nDiff:\n@@ -414,6 +414,8 @@ typedef struct {\n \n ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r);\n void ngx_http_upstream_init(ngx_http_request_t *r);\n+ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data);\n+ngx_int_t ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes);\n ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf,\n     ngx_url_t *u, ngx_uint_t flags);\n char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 31",
        "commit_diff": "Diff:\n@@ -485,10 +485,11 @@ ngx_http_memcached_filter(void *data, ssize_t bytes)\n \n     if (u->length == (ssize_t) ctx->rest) {\n \n-        if (ngx_strncmp(b->last,\n+        if (bytes > u->length\n+            || ngx_strncmp(b->last,\n                    ngx_http_memcached_end + NGX_HTTP_MEMCACHED_END - ctx->rest,\n                    bytes)\n-            != 0)\n+               != 0)\n         {\n             ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,\n                           \"memcached sent invalid trailer\");\n@@ -540,7 +541,9 @@ ngx_http_memcached_filter(void *data, ssize_t bytes)\n \n     last += (size_t) (u->length - NGX_HTTP_MEMCACHED_END);\n \n-    if (ngx_strncmp(last, ngx_http_memcached_end, b->last - last) != 0) {\n+    if (bytes > u->length\n+        || ngx_strncmp(last, ngx_http_memcached_end, b->last - last) != 0)\n+    {\n         ngx_log_error(NGX_LOG_ERR, ctx->request->connection->log, 0,\n                       \"memcached sent invalid trailer\");\n \nDiff:\n@@ -2015,6 +2015,25 @@ ngx_http_proxy_copy_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (p->upstream_done) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                       \"http proxy data after close\");\n+        return NGX_OK;\n+    }\n+\n+    if (p->length == 0) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        r = p->input_ctx;\n+        r->upstream->keepalive = 0;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     cl = ngx_chain_get_free_buf(p->pool, &p->free);\n     if (cl == NULL) {\n         return NGX_ERROR;\n@@ -2042,20 +2061,23 @@ ngx_http_proxy_copy_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_OK;\n     }\n \n+    if (b->last - b->pos > p->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        b->last = b->pos + p->length;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     p->length -= b->last - b->pos;\n \n     if (p->length == 0) {\n         r = p->input_ctx;\n-        p->upstream_done = 1;\n         r->upstream->keepalive = !r->upstream->headers_in.connection_close;\n-\n-    } else if (p->length < 0) {\n-        r = p->input_ctx;\n-        p->upstream_done = 1;\n-\n-        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n-                      \"upstream sent more data than specified in \"\n-                      \"\\\"Content-Length\\\" header\");\n     }\n \n     return NGX_OK;\n@@ -2082,6 +2104,23 @@ ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n         return NGX_ERROR;\n     }\n \n+    if (p->upstream_done) {\n+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, p->log, 0,\n+                       \"http proxy data after close\");\n+        return NGX_OK;\n+    }\n+\n+    if (p->length == 0) {\n+\n+        ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                      \"upstream sent data after final chunk\");\n+\n+        r->upstream->keepalive = 0;\n+        p->upstream_done = 1;\n+\n+        return NGX_OK;\n+    }\n+\n     b = NULL;\n     prev = &buf->shadow;\n \n@@ -2144,9 +2183,15 @@ ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n \n             /* a whole response has been parsed successfully */\n \n-            p->upstream_done = 1;\n+            p->length = 0;\n             r->upstream->keepalive = !r->upstream->headers_in.connection_close;\n \n+            if (buf->pos != buf->last) {\n+                ngx_log_error(NGX_LOG_WARN, p->log, 0,\n+                              \"upstream sent data after final chunk\");\n+                r->upstream->keepalive = 0;\n+            }\n+\n             break;\n         }\n \n@@ -2161,13 +2206,13 @@ ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p, ngx_buf_t *buf)\n \n         /* invalid response */\n \n-        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+        ngx_log_error(NGX_LOG_ERR, p->log, 0,\n                       \"upstream sent invalid chunked response\");\n \n         return NGX_ERROR;\n     }\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, p->log, 0,\n                    \"http proxy chunked state %ui, length %O\",\n                    ctx->chunked.state, p->length);\n \n@@ -2227,6 +2272,18 @@ ngx_http_proxy_non_buffered_copy_filter(void *data, ssize_t bytes)\n         return NGX_OK;\n     }\n \n+    if (bytes > u->length) {\n+\n+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                      \"upstream sent more data than specified in \"\n+                      \"\\\"Content-Length\\\" header\");\n+\n+        cl->buf->last = cl->buf->pos + u->length;\n+        u->length = 0;\n+\n+        return NGX_OK;\n+    }\n+\n     u->length -= bytes;\n \n     if (u->length == 0) {\n@@ -2313,6 +2370,12 @@ ngx_http_proxy_non_buffered_chunked_filter(void *data, ssize_t bytes)\n             u->keepalive = !u->headers_in.connection_close;\n             u->length = 0;\n \n+            if (buf->pos != buf->last) {\n+                ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n+                              \"upstream sent data after final chunk\");\n+                u->keepalive = 0;\n+            }\n+\n             break;\n         }\n \nDiff:\n@@ -60,6 +60,8 @@ typedef struct {\n static void ngx_http_v2_read_handler(ngx_event_t *rev);\n static void ngx_http_v2_write_handler(ngx_event_t *wev);\n static void ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c);\n+static void ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c);\n+static void ngx_http_v2_lingering_close_handler(ngx_event_t *rev);\n \n static u_char *ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c,\n     u_char *pos, u_char *end);\n@@ -661,7 +663,7 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n     }\n \n     if (h2c->goaway) {\n-        ngx_http_close_connection(c);\n+        ngx_http_v2_lingering_close(h2c);\n         return;\n     }\n \n@@ -699,6 +701,113 @@ ngx_http_v2_handle_connection(ngx_http_v2_connection_t *h2c)\n }\n \n \n+static void\n+ngx_http_v2_lingering_close(ngx_http_v2_connection_t *h2c)\n+{\n+    ngx_event_t               *rev, *wev;\n+    ngx_connection_t          *c;\n+    ngx_http_core_loc_conf_t  *clcf;\n+\n+    c = h2c->connection;\n+\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+\n+    if (clcf->lingering_close == NGX_HTTP_LINGERING_OFF) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    rev = c->read;\n+    rev->handler = ngx_http_v2_lingering_close_handler;\n+\n+    h2c->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n+    ngx_add_timer(rev, clcf->lingering_timeout);\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    wev = c->write;\n+    wev->handler = ngx_http_empty_handler;\n+\n+    if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {\n+        if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {\n+            ngx_http_close_connection(c);\n+            return;\n+        }\n+    }\n+\n+    if (ngx_shutdown_socket(c->fd, NGX_WRITE_SHUTDOWN) == -1) {\n+        ngx_connection_error(c, ngx_socket_errno,\n+                             ngx_shutdown_socket_n \" failed\");\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    if (rev->ready) {\n+        ngx_http_v2_lingering_close_handler(rev);\n+    }\n+}\n+\n+\n+static void\n+ngx_http_v2_lingering_close_handler(ngx_event_t *rev)\n+{\n+    ssize_t                    n;\n+    ngx_msec_t                 timer;\n+    ngx_connection_t          *c;\n+    ngx_http_core_loc_conf_t  *clcf;\n+    ngx_http_v2_connection_t  *h2c;\n+    u_char                     buffer[NGX_HTTP_LINGERING_BUFFER_SIZE];\n+\n+    c = rev->data;\n+    h2c = c->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n+                   \"http2 lingering close handler\");\n+\n+    if (rev->timedout) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    timer = (ngx_msec_t) h2c->lingering_time - (ngx_msec_t) ngx_time();\n+    if ((ngx_msec_int_t) timer <= 0) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    do {\n+        n = c->recv(c, buffer, NGX_HTTP_LINGERING_BUFFER_SIZE);\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, \"lingering read: %z\", n);\n+\n+        if (n == NGX_ERROR || n == 0) {\n+            ngx_http_close_connection(c);\n+            return;\n+        }\n+\n+    } while (rev->ready);\n+\n+    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n+        ngx_http_close_connection(c);\n+        return;\n+    }\n+\n+    clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx,\n+                                        ngx_http_core_module);\n+    timer *= 1000;\n+\n+    if (timer > clcf->lingering_timeout) {\n+        timer = clcf->lingering_timeout;\n+    }\n+\n+    ngx_add_timer(rev, timer);\n+}\n+\n+\n static u_char *\n ngx_http_v2_state_proxy_protocol(ngx_http_v2_connection_t *h2c, u_char *pos,\n     u_char *end)\n@@ -4541,16 +4650,15 @@ ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n     h2c->blocked = 1;\n \n     if (!c->error && !h2c->goaway) {\n+        h2c->goaway = 1;\n+\n         if (ngx_http_v2_send_goaway(h2c, status) != NGX_ERROR) {\n             (void) ngx_http_v2_send_output_queue(h2c);\n         }\n     }\n \n-    c->error = 1;\n-\n     if (!h2c->processing && !h2c->pushing) {\n-        ngx_http_close_connection(c);\n-        return;\n+        goto done;\n     }\n \n     c->read->handler = ngx_http_empty_handler;\n@@ -4598,10 +4706,18 @@ ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n     h2c->blocked = 0;\n \n     if (h2c->processing || h2c->pushing) {\n+        c->error = 1;\n+        return;\n+    }\n+\n+done:\n+\n+    if (c->error) {\n+        ngx_http_close_connection(c);\n         return;\n     }\n \n-    ngx_http_close_connection(c);\n+    ngx_http_v2_lingering_close(h2c);\n }\n \n \nDiff:\n@@ -157,6 +157,8 @@ struct ngx_http_v2_connection_s {\n     ngx_uint_t                       last_sid;\n     ngx_uint_t                       last_push;\n \n+    time_t                           lingering_time;\n+\n     unsigned                         closed_nodes:8;\n     unsigned                         settings_ack:1;\n     unsigned                         table_update:1;\n",
        "analysis": "TRUE [ngx_http_v2_lingering_close] [ngx_http_v2_lingering_close_handler]"
    },
    {
        "commit_index": "Commit 30",
        "commit_diff": "Diff:\n@@ -920,7 +920,8 @@ ngx_int_t\n ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,\n     ngx_int_t depth)\n {\n-    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);\n+    SSL_CTX_set_verify(ssl->ctx, SSL_CTX_get_verify_mode(ssl->ctx),\n+                       ngx_ssl_verify_callback);\n \n     SSL_CTX_set_verify_depth(ssl->ctx, depth);\n \nDiff:\n@@ -1469,14 +1469,14 @@ ngx_http_server_names(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf,\n                                   NGX_HASH_WILDCARD_KEY);\n \n             if (rc == NGX_ERROR) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (rc == NGX_DECLINED) {\n                 ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                               \"invalid server name or wildcard \\\"%V\\\" on %V\",\n                               &name[n].name, &addr->opt.addr_text);\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (rc == NGX_BUSY) {\nDiff:\n@@ -160,6 +160,7 @@ struct ngx_http_file_cache_s {\n \n     ngx_path_t                      *path;\n \n+    off_t                            min_free;\n     off_t                            max_size;\n     size_t                           bsize;\n \nDiff:\n@@ -1959,7 +1959,7 @@ ngx_http_file_cache_manager(void *data)\n {\n     ngx_http_file_cache_t  *cache = data;\n \n-    off_t       size;\n+    off_t       size, free;\n     time_t      wait;\n     ngx_msec_t  elapsed, next;\n     ngx_uint_t  count, watermark;\n@@ -1988,7 +1988,19 @@ ngx_http_file_cache_manager(void *data)\n                        size, count, (ngx_int_t) watermark);\n \n         if (size < cache->max_size && count < watermark) {\n-            break;\n+\n+            if (!cache->min_free) {\n+                break;\n+            }\n+\n+            free = ngx_fs_available(cache->path->name.data);\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle->log, 0,\n+                           \"http file cache free: %O\", free);\n+\n+            if (free > cache->min_free) {\n+                break;\n+            }\n         }\n \n         wait = ngx_http_file_cache_forced_expire(cache);\n@@ -2304,7 +2316,7 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n {\n     char  *confp = conf;\n \n-    off_t                   max_size;\n+    off_t                   max_size, min_free;\n     u_char                 *last, *p;\n     time_t                  inactive;\n     ssize_t                 size;\n@@ -2341,6 +2353,7 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n     name.len = 0;\n     size = 0;\n     max_size = NGX_MAX_OFF_T_VALUE;\n+    min_free = 0;\n \n     value = cf->args->elts;\n \n@@ -2476,6 +2489,29 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n             continue;\n         }\n \n+        if (ngx_strncmp(value[i].data, \"min_free=\", 9) == 0) {\n+\n+#if (NGX_WIN32 || NGX_HAVE_STATFS || NGX_HAVE_STATVFS)\n+\n+            s.len = value[i].len - 9;\n+            s.data = value[i].data + 9;\n+\n+            min_free = ngx_parse_offset(&s);\n+            if (min_free < 0) {\n+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                                   \"invalid min_free value \\\"%V\\\"\", &value[i]);\n+                return NGX_CONF_ERROR;\n+            }\n+\n+#else\n+            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n+                               \"min_free is not supported \"\n+                               \"on this platform, ignored\");\n+#endif\n+\n+            continue;\n+        }\n+\n         if (ngx_strncmp(value[i].data, \"loader_files=\", 13) == 0) {\n \n             loader_files = ngx_atoi(value[i].data + 13, value[i].len - 13);\n@@ -2607,6 +2643,7 @@ ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     cache->inactive = inactive;\n     cache->max_size = max_size;\n+    cache->min_free = min_free;\n \n     caches = (ngx_array_t *) (confp + cmd->offset);\n \nDiff:\n@@ -884,6 +884,19 @@ ngx_fs_bsize(u_char *name)\n     return (size_t) fs.f_bsize;\n }\n \n+\n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    struct statfs  fs;\n+\n+    if (statfs((char *) name, &fs) == -1) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    return (off_t) fs.f_bavail * fs.f_bsize;\n+}\n+\n #elif (NGX_HAVE_STATVFS)\n \n size_t\n@@ -908,6 +921,19 @@ ngx_fs_bsize(u_char *name)\n     return (size_t) fs.f_frsize;\n }\n \n+\n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    struct statvfs  fs;\n+\n+    if (statvfs((char *) name, &fs) == -1) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    return (off_t) fs.f_bavail * fs.f_frsize;\n+}\n+\n #else\n \n size_t\n@@ -916,4 +942,11 @@ ngx_fs_bsize(u_char *name)\n     return 512;\n }\n \n+\n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    return NGX_MAX_OFF_T_VALUE;\n+}\n+\n #endif\nDiff:\n@@ -349,6 +349,7 @@ ngx_int_t ngx_directio_off(ngx_fd_t fd);\n #endif\n \n size_t ngx_fs_bsize(u_char *name);\n+off_t ngx_fs_available(u_char *name);\n \n \n #if (NGX_HAVE_OPENAT)\nDiff:\n@@ -658,6 +658,19 @@ ngx_fs_bsize(u_char *name)\n }\n \n \n+off_t\n+ngx_fs_available(u_char *name)\n+{\n+    ULARGE_INTEGER  navail;\n+\n+    if (GetDiskFreeSpaceEx((const char *) name, &navail, NULL, NULL) == 0) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    return (off_t) navail.QuadPart;\n+}\n+\n+\n static ngx_int_t\n ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n {\nDiff:\n@@ -259,6 +259,7 @@ ngx_int_t ngx_directio_off(ngx_fd_t fd);\n #define ngx_directio_off_n          \"ngx_directio_off_n\"\n \n size_t ngx_fs_bsize(u_char *name);\n+off_t ngx_fs_available(u_char *name);\n \n \n #define ngx_stdout               GetStdHandle(STD_OUTPUT_HANDLE)\n",
        "analysis": "The diff contains multiple newly added functions. Let's analyze them individually:\n\n1. **Function: ngx_fs_available(u_char *name)**\n   - **Platform 1:**\n     ```c\n     off_t ngx_fs_available(u_char *name) {\n         struct statfs  fs;\n     \n         if (statfs((char *) name, &fs) == -1) {\n             return NGX_MAX_OFF_T_VALUE;\n         }\n     \n         return (off_t) fs.f_bavail * fs.f_bsize;\n     }\n     ```\n     Here, the function attempts to retrieve the available disk space using `statfs`. It returns a calculated value based on the available blocks and block size. The calculation seems safe given the context, as it doesn't involve manipulating buffers.\n\n   - **Platform 2:**\n     ```c\n     off_t ngx_fs_available(u_char *name) {\n         struct statvfs  fs;\n     \n         if (statvfs((char *) name, &fs) == -1) {\n             return NGX_MAX_OFF_T_VALUE;\n         }\n     \n         return (off_t) fs.f_bavail * fs.f_frsize;\n     }\n     ```\n     Similar to Platform 1, `statvfs` is used. The resulting calculation appears secure as it concerns arithmetic operations rather than buffer manipulation.\n\n   - **Fallback:**\n     ```c\n     off_t ngx_fs_available(u_char *name) {\n         return NGX_MAX_OFF_T_VALUE;\n     }\n     ```\n     This implementation effectively provides a placeholder return value, with no operations that can cause an out-of-bounds write.\n\n   - **Windows-specific:**\n     ```c\n     off_t ngx_fs_available(u_char *name) {\n         ULARGE_INTEGER  navail;\n     \n         if (GetDiskFreeSpaceEx((const char *) name, &navail, NULL, NULL) == 0) {\n             return NGX_MAX_OFF_T_VALUE;\n         }\n     \n         return (off_t) navail.QuadPart;\n     }\n     ```\n     In this implementation, Windows API `GetDiskFreeSpaceEx` is used, which should handle buffer sizes internally. The return value is based on a structure field, which seems safe.\n\nUpon reviewing these functions individually, none appear to involve operations that could lead to out-of-bounds writes. They predominantly involve obtaining and returning available disk space information with controlled data structures and system calls.\n\nThus, after analyzing the newly added functions, there doesn't appear any evident out-of-bounds write vulnerability.\n\n**FALSE**"
    },
    {
        "commit_index": "Commit 29",
        "commit_diff": "Diff:\n@@ -980,6 +980,7 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         if (ocsp->ncert == n - 1 || (ocf->depth == 2 && ocsp->ncert == 1)) {\n             ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                            \"ssl ocsp validated, certs:%ui\", ocsp->ncert);\n+            rc = NGX_OK;\n             goto done;\n         }\n \n@@ -988,7 +989,8 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n \n         ctx = ngx_ssl_ocsp_start(c->log);\n         if (ctx == NULL) {\n-            goto failed;\n+            rc = NGX_ERROR;\n+            goto done;\n         }\n \n         ocsp->ctx = ctx;\n@@ -1012,8 +1014,9 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         ctx->uri = ocf->uri;\n         ctx->port = ocf->port;\n \n-        if (ngx_ssl_ocsp_responder(c, ctx) != NGX_OK) {\n-            goto failed;\n+        rc = ngx_ssl_ocsp_responder(c, ctx);\n+        if (rc != NGX_OK) {\n+            goto done;\n         }\n \n         if (ctx->uri.len == 0) {\n@@ -1025,7 +1028,7 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         rc = ngx_ssl_ocsp_cache_lookup(ctx);\n \n         if (rc == NGX_ERROR) {\n-            goto failed;\n+            goto done;\n         }\n \n         if (rc == NGX_DECLINED) {\n@@ -1051,12 +1054,12 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n \n done:\n \n-    ocsp->status = NGX_OK;\n-    return;\n-\n-failed:\n+    ocsp->status = rc;\n \n-    ocsp->status = NGX_ERROR;\n+    if (c->ssl->in_ocsp) {\n+        c->ssl->handshaked = 1;\n+        c->ssl->handler(c);\n+    }\n }\n \n \n@@ -1073,38 +1076,34 @@ ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n \n     rc = ngx_ssl_ocsp_verify(ctx);\n     if (rc != NGX_OK) {\n-        ocsp->status = rc;\n-        ngx_ssl_ocsp_done(ctx);\n         goto done;\n     }\n \n     rc = ngx_ssl_ocsp_cache_store(ctx);\n     if (rc != NGX_OK) {\n-        ocsp->status = rc;\n-        ngx_ssl_ocsp_done(ctx);\n         goto done;\n     }\n \n     if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n         ocsp->cert_status = ctx->status;\n-        ocsp->status = NGX_OK;\n-        ngx_ssl_ocsp_done(ctx);\n         goto done;\n     }\n \n     ngx_ssl_ocsp_done(ctx);\n \n     ngx_ssl_ocsp_validate_next(c);\n \n-done:\n+    return;\n \n-    if (ocsp->status == NGX_AGAIN || !c->ssl->in_ocsp) {\n-        return;\n-    }\n+done:\n \n-    c->ssl->handshaked = 1;\n+    ocsp->status = rc;\n+    ngx_ssl_ocsp_done(ctx);\n \n-    c->ssl->handler(c);\n+    if (c->ssl->in_ocsp) {\n+        c->ssl->handshaked = 1;\n+        c->ssl->handler(c);\n+    }\n }\n \n \nDiff:\n@@ -875,6 +875,12 @@ ngx_fs_bsize(u_char *name)\n         return 512;\n     }\n \n+#if (NGX_LINUX)\n+    if ((size_t) fs.f_bsize > ngx_pagesize) {\n+        return 512;\n+    }\n+#endif\n+\n     return (size_t) fs.f_bsize;\n }\n \n@@ -893,6 +899,12 @@ ngx_fs_bsize(u_char *name)\n         return 512;\n     }\n \n+#if (NGX_LINUX)\n+    if ((size_t) fs.f_frsize > ngx_pagesize) {\n+        return 512;\n+    }\n+#endif\n+\n     return (size_t) fs.f_frsize;\n }\n \nDiff:\n@@ -185,7 +185,10 @@ ngx_int_t ngx_set_file_time(u_char *name, ngx_fd_t fd, time_t s);\n #define ngx_is_exec(sb)          (((sb)->st_mode & S_IXUSR) == S_IXUSR)\n #define ngx_file_access(sb)      ((sb)->st_mode & 0777)\n #define ngx_file_size(sb)        (sb)->st_size\n-#define ngx_file_fs_size(sb)     ngx_max((sb)->st_size, (sb)->st_blocks * 512)\n+#define ngx_file_fs_size(sb)                                                 \\\n+    (((sb)->st_blocks * 512 > (sb)->st_size                                  \\\n+     && (sb)->st_blocks * 512 < (sb)->st_size + 8 * (sb)->st_blksize)        \\\n+     ? (sb)->st_blocks * 512 : (sb)->st_size)\n #define ngx_file_mtime(sb)       (sb)->st_mtime\n #define ngx_file_uniq(sb)        (sb)->st_ino\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 28",
        "commit_diff": "Diff:\n@@ -1141,6 +1141,7 @@ ngx_http_uwsgi_create_request(ngx_http_request_t *r)\n         r->upstream->request_bufs = cl;\n     }\n \n+    b->flush = 1;\n     cl->next = NULL;\n \n     return NGX_OK;\nDiff:\n@@ -189,6 +189,13 @@ ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, ngx_log_t *log)\n         return cl;\n     }\n \n+    /* zero-sized datagram; pretend to have at least 1 iov */\n+    if (n == 0) {\n+        iov = &vec->iovs[n++];\n+        iov->iov_base = NULL;\n+        iov->iov_len = 0;\n+    }\n+\n     vec->count = n;\n     vec->size = total;\n \nDiff:\n@@ -839,7 +839,7 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n         u->upstream_buf.last = p;\n     }\n \n-    if (c->buffer && c->buffer->pos < c->buffer->last) {\n+    if (c->buffer && c->buffer->pos <= c->buffer->last) {\n         ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c->log, 0,\n                        \"stream proxy add preread buffer: %uz\",\n                        c->buffer->last - c->buffer->pos);\n@@ -853,6 +853,7 @@ ngx_stream_proxy_init_upstream(ngx_stream_session_t *s)\n         *cl->buf = *c->buffer;\n \n         cl->buf->tag = (ngx_buf_tag_t) &ngx_stream_proxy_module;\n+        cl->buf->temporary = (cl->buf->pos == cl->buf->last) ? 0 : 1;\n         cl->buf->flush = 1;\n \n         cl->next = u->upstream_out;\nDiff:\n@@ -234,7 +234,8 @@ ngx_stream_write_filter(ngx_stream_session_t *s, ngx_chain_t *in,\n \n     if (size == 0\n         && !(c->buffered & NGX_LOWLEVEL_BUFFERED)\n-        && !(last && c->need_last_buf))\n+        && !(last && c->need_last_buf)\n+        && !(c->type == SOCK_DGRAM && flush))\n     {\n         if (last || flush || sync) {\n             for (cl = *out; cl; /* void */) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 27",
        "commit_diff": "Diff:\n@@ -506,6 +506,7 @@ ngx_add_inherited_sockets(ngx_cycle_t *cycle)\n             ngx_memzero(ls, sizeof(ngx_listening_t));\n \n             ls->fd = (ngx_socket_t) s;\n+            ls->inherited = 1;\n         }\n     }\n \nDiff:\n@@ -1070,7 +1070,8 @@ ngx_close_listening_sockets(ngx_cycle_t *cycle)\n \n         if (ls[i].sockaddr->sa_family == AF_UNIX\n             && ngx_process <= NGX_PROCESS_MASTER\n-            && ngx_new_binary == 0)\n+            && ngx_new_binary == 0\n+            && (!ls[i].inherited || ngx_getppid() != ngx_parent))\n         {\n             u_char *name = ls[i].addr_text.data + sizeof(\"unix:\") - 1;\n \nDiff:\n@@ -520,6 +520,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n                     == NGX_OK)\n                 {\n                     nls[n].fd = ls[i].fd;\n+                    nls[n].inherited = ls[i].inherited;\n                     nls[n].previous = &ls[i];\n                     ls[i].remain = 1;\n \nDiff:\n@@ -920,6 +920,8 @@ ngx_int_t\n ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,\n     ngx_int_t depth)\n {\n+    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);\n+\n     SSL_CTX_set_verify_depth(ssl->ctx, depth);\n \n     if (cert->len == 0) {\nDiff:\n@@ -77,12 +77,11 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)\n     u_char            *p;\n     size_t             size;\n     ngx_int_t          i;\n-    ngx_uint_t         n, sigio;\n+    ngx_uint_t         sigio;\n     sigset_t           set;\n     struct itimerval   itv;\n     ngx_uint_t         live;\n     ngx_msec_t         delay;\n-    ngx_listening_t   *ls;\n     ngx_core_conf_t   *ccf;\n \n     sigemptyset(&set);\n@@ -204,16 +203,7 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)\n         if (ngx_quit) {\n             ngx_signal_worker_processes(cycle,\n                                         ngx_signal_value(NGX_SHUTDOWN_SIGNAL));\n-\n-            ls = cycle->listening.elts;\n-            for (n = 0; n < cycle->listening.nelts; n++) {\n-                if (ngx_close_socket(ls[n].fd) == -1) {\n-                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n-                                  ngx_close_socket_n \" %V failed\",\n-                                  &ls[n].addr_text);\n-                }\n-            }\n-            cycle->listening.nelts = 0;\n+            ngx_close_listening_sockets(cycle);\n \n             continue;\n         }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 26",
        "commit_diff": "Diff:\n@@ -449,3 +449,4 @@ e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n 5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\n c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\n+cbe6ba650211541310618849168631ce0b788f35 release-1.19.0\nDiff:\n@@ -141,6 +141,7 @@ syn keyword ngxDirective contained ancient_browser_value\n syn keyword ngxDirective contained api\n syn keyword ngxDirective contained auth_basic\n syn keyword ngxDirective contained auth_basic_user_file\n+syn keyword ngxDirective contained auth_delay\n syn keyword ngxDirective contained auth_http\n syn keyword ngxDirective contained auth_http_header\n syn keyword ngxDirective contained auth_http_pass_client_cert\n@@ -332,6 +333,7 @@ syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n syn keyword ngxDirective contained js_content\n syn keyword ngxDirective contained js_filter\n+syn keyword ngxDirective contained js_import\n syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n@@ -348,6 +350,7 @@ syn keyword ngxDirective contained large_client_header_buffers\n syn keyword ngxDirective contained least_conn\n syn keyword ngxDirective contained least_time\n syn keyword ngxDirective contained limit_conn\n+syn keyword ngxDirective contained limit_conn_dry_run\n syn keyword ngxDirective contained limit_conn_log_level\n syn keyword ngxDirective contained limit_conn_status\n syn keyword ngxDirective contained limit_conn_zone\n@@ -595,6 +598,9 @@ syn keyword ngxDirective contained ssl_early_data\n syn keyword ngxDirective contained ssl_ecdh_curve\n syn keyword ngxDirective contained ssl_engine\n syn keyword ngxDirective contained ssl_handshake_timeout\n+syn keyword ngxDirective contained ssl_ocsp\n+syn keyword ngxDirective contained ssl_ocsp_cache\n+syn keyword ngxDirective contained ssl_ocsp_responder\n syn keyword ngxDirective contained ssl_password_file\n syn keyword ngxDirective contained ssl_prefer_server_ciphers\n syn keyword ngxDirective contained ssl_preread\n@@ -770,6 +776,7 @@ syn keyword ngxDirectiveThirdParty contained auth_gss_authorized_principal\n syn keyword ngxDirectiveThirdParty contained auth_gss_force_realm\n syn keyword ngxDirectiveThirdParty contained auth_gss_format_full\n syn keyword ngxDirectiveThirdParty contained auth_gss_keytab\n+syn keyword ngxDirectiveThirdParty contained auth_gss_map_to_local\n syn keyword ngxDirectiveThirdParty contained auth_gss_realm\n syn keyword ngxDirectiveThirdParty contained auth_gss_service_name\n \n@@ -791,8 +798,8 @@ syn keyword ngxDirectiveThirdParty contained auth_pam_set_pam_env\n \n \" AJP protocol proxy\n \" https://github.com/yaoweibin/nginx_ajp_module\n-syn keyword ngxDirectiveThirdParty contained ajp_buffer_size\n syn keyword ngxDirectiveThirdParty contained ajp_buffers\n+syn keyword ngxDirectiveThirdParty contained ajp_buffer_size\n syn keyword ngxDirectiveThirdParty contained ajp_busy_buffers_size\n syn keyword ngxDirectiveThirdParty contained ajp_cache\n syn keyword ngxDirectiveThirdParty contained ajp_cache_key\n@@ -818,6 +825,7 @@ syn keyword ngxDirectiveThirdParty contained ajp_pass_header\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_body\n syn keyword ngxDirectiveThirdParty contained ajp_pass_request_headers\n syn keyword ngxDirectiveThirdParty contained ajp_read_timeout\n+syn keyword ngxDirectiveThirdParty contained ajp_secret\n syn keyword ngxDirectiveThirdParty contained ajp_send_lowat\n syn keyword ngxDirectiveThirdParty contained ajp_send_timeout\n syn keyword ngxDirectiveThirdParty contained ajp_store\n@@ -854,8 +862,8 @@ syn keyword ngxDirectiveThirdParty contained content_handler_property\n syn keyword ngxDirectiveThirdParty contained content_handler_type\n syn keyword ngxDirectiveThirdParty contained handler_code\n syn keyword ngxDirectiveThirdParty contained handler_name\n-syn keyword ngxDirectiveThirdParty contained handler_type\n syn keyword ngxDirectiveThirdParty contained handlers_lazy_init\n+syn keyword ngxDirectiveThirdParty contained handler_type\n syn keyword ngxDirectiveThirdParty contained header_filter_code\n syn keyword ngxDirectiveThirdParty contained header_filter_name\n syn keyword ngxDirectiveThirdParty contained header_filter_property\n@@ -871,6 +879,10 @@ syn keyword ngxDirectiveThirdParty contained jvm_options\n syn keyword ngxDirectiveThirdParty contained jvm_path\n syn keyword ngxDirectiveThirdParty contained jvm_var\n syn keyword ngxDirectiveThirdParty contained jvm_workers\n+syn keyword ngxDirectiveThirdParty contained log_handler_code\n+syn keyword ngxDirectiveThirdParty contained log_handler_name\n+syn keyword ngxDirectiveThirdParty contained log_handler_property\n+syn keyword ngxDirectiveThirdParty contained log_handler_type\n syn keyword ngxDirectiveThirdParty contained max_balanced_tcp_connections\n syn keyword ngxDirectiveThirdParty contained rewrite_handler_code\n syn keyword ngxDirectiveThirdParty contained rewrite_handler_name\n@@ -879,6 +891,7 @@ syn keyword ngxDirectiveThirdParty contained rewrite_handler_type\n syn keyword ngxDirectiveThirdParty contained shared_map\n syn keyword ngxDirectiveThirdParty contained write_page_size\n \n+\n \" Certificate Transparency\n \" https://github.com/grahamedgecombe/nginx-ct\n syn keyword ngxDirectiveThirdParty contained ssl_ct\n@@ -942,6 +955,7 @@ syn keyword ngxDirectiveThirdParty contained fancyindex_hide_symlinks\n syn keyword ngxDirectiveThirdParty contained fancyindex_ignore\n syn keyword ngxDirectiveThirdParty contained fancyindex_localtime\n syn keyword ngxDirectiveThirdParty contained fancyindex_name_length\n+syn keyword ngxDirectiveThirdParty contained fancyindex_show_dotfiles\n syn keyword ngxDirectiveThirdParty contained fancyindex_show_path\n syn keyword ngxDirectiveThirdParty contained fancyindex_time_format\n \n@@ -991,15 +1005,19 @@ syn keyword ngxDirectiveThirdParty contained nchan_benchmark_publisher_distribut\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscriber_distribution\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_subscribers_per_channel\n syn keyword ngxDirectiveThirdParty contained nchan_benchmark_time\n-syn keyword ngxDirectiveThirdParty contained nchan_channel_event_string\n syn keyword ngxDirectiveThirdParty contained nchan_channel_events_channel_id\n+syn keyword ngxDirectiveThirdParty contained nchan_channel_event_string\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group\n syn keyword ngxDirectiveThirdParty contained nchan_channel_group_accounting\n syn keyword ngxDirectiveThirdParty contained nchan_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_channel_id_split_delimiter\n syn keyword ngxDirectiveThirdParty contained nchan_channel_timeout\n syn keyword ngxDirectiveThirdParty contained nchan_deflate_message_for_websocket\n syn keyword ngxDirectiveThirdParty contained nchan_eventsource_event\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_comment\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_data\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_event\n+syn keyword ngxDirectiveThirdParty contained nchan_eventsource_ping_interval\n syn keyword ngxDirectiveThirdParty contained nchan_group_location\n syn keyword ngxDirectiveThirdParty contained nchan_group_max_channels\n syn keyword ngxDirectiveThirdParty contained nchan_group_max_messages\n@@ -1047,10 +1065,10 @@ syn keyword ngxDirectiveThirdParty contained nchan_store_messages\n syn keyword ngxDirectiveThirdParty contained nchan_stub_status\n syn keyword ngxDirectiveThirdParty contained nchan_sub_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_existing_channels_only\n-syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_channel_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_message_id\n+syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_last_message_id\n@@ -1987,11 +2005,7 @@ syn keyword ngxDirectiveThirdParty contained concat_unique\n \" update upstreams' config by restful interface\n \" https://github.com/yzprofile/ngx_http_dyups_module\n syn keyword ngxDirectiveThirdParty contained dyups_interface\n-syn keyword ngxDirectiveThirdParty contained dyups_read_msg_log\n-syn keyword ngxDirectiveThirdParty contained dyups_read_msg_timeout\n syn keyword ngxDirectiveThirdParty contained dyups_shm_zone_size\n-syn keyword ngxDirectiveThirdParty contained dyups_trylock\n-syn keyword ngxDirectiveThirdParty contained dyups_upstream_conf\n \n \" add given content to the end of the response according to the condition specified\n \" https://github.com/flygoast/ngx_http_footer_if_filter\n@@ -2308,6 +2322,62 @@ syn keyword ngxDirectiveThirdParty contained user_agent\n \" https://github.com/flygoast/ngx_http_upstream_ketama_chash\n syn keyword ngxDirectiveThirdParty contained ketama_chash\n \n+\" nginx-sticky-module-ng\n+\" https://github.com/ayty-adrianomartins/nginx-sticky-module-ng\n+syn keyword ngxDirectiveThirdParty contained sticky_no_fallback\n+\n+\" dynamic linking and call the function of your application\n+\" https://github.com/Taymindis/nginx-link-function\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_prop\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_add_req_header\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_ca_cert\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_call\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_download_link_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_lib\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_shm_size\n+syn keyword ngxDirectiveThirdParty contained ngx_link_func_subrequest\n+\n+\" purge content from FastCGI, proxy, SCGI and uWSGI caches\n+\" https://github.com/torden/ngx_cache_purge\n+syn keyword ngxDirectiveThirdParty contained cache_purge_response_type\n+\n+\" set the flags \"HttpOnly\", \"secure\" and \"SameSite\" for cookies\n+\" https://github.com/AirisX/nginx_cookie_flag_module\n+syn keyword ngxDirectiveThirdParty contained set_cookie_flag\n+\n+\" Embed websockify into Nginx (convert any tcp connection into websocket)\n+\" https://github.com/tg123/websockify-nginx-module\n+syn keyword ngxDirectiveThirdParty contained websockify_buffer_size\n+syn keyword ngxDirectiveThirdParty contained websockify_connect_timeout\n+syn keyword ngxDirectiveThirdParty contained websockify_pass\n+syn keyword ngxDirectiveThirdParty contained websockify_read_timeout\n+syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n+\n+\" IP2Location Nginx\n+\" https://github.com/ip2location/ip2location-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2location\n+syn keyword ngxDirectiveThirdParty contained ip2location_access_type\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+\n+\" IP2Proxy module for Nginx\n+\" https://github.com/ip2location/ip2proxy-nginx\n+syn keyword ngxDirectiveThirdParty contained ip2proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_access_type\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_as\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_asn\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_city\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_country_long\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_country_short\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_database\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_region\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_reverse_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_usage_type\n \n \n \nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1019000\n-#define NGINX_VERSION      \"1.19.0\"\n+#define nginx_version      1019001\n+#define NGINX_VERSION      \"1.19.1\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 25",
        "commit_diff": "Diff:\n@@ -5,6 +5,51 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.0\" date=\"2020-05-26\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+проверка клиентских сертификатов с помощью OCSP.\n+</para>\n+<para lang=\"en\">\n+client certificate validation with OCSP.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при работе с gRPC-бэкендами\n+могли возникать ошибки \"upstream sent frame for closed stream\".\n+</para>\n+<para lang=\"en\">\n+\"upstream sent frame for closed stream\" errors might occur\n+when working with gRPC backends.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+OCSP stapling мог не работать,\n+если не была указана директива resolver.\n+</para>\n+<para lang=\"en\">\n+OCSP stapling might not work\n+if the \"resolver\" directive was not specified.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+соединения с некорректным HTTP/2 preface не логгировались.\n+</para>\n+<para lang=\"en\">\n+connections with incorrect HTTP/2 preface were not logged.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.10\" date=\"2020-04-14\">\n \n <change type=\"feature\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1f\n+OPENSSL =\topenssl-1.1.1g\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \nDiff:\n@@ -731,9 +731,8 @@ ngx_http_v2_state_preface(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {\n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n-                       \"invalid http2 connection preface \\\"%*s\\\"\",\n-                       sizeof(preface) - 1, pos);\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"invalid connection preface\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n     }\n@@ -754,9 +753,8 @@ ngx_http_v2_state_preface_end(ngx_http_v2_connection_t *h2c, u_char *pos,\n     }\n \n     if (ngx_memcmp(pos, preface, sizeof(preface) - 1) != 0) {\n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n-                       \"invalid http2 connection preface \\\"%*s\\\"\",\n-                       sizeof(preface) - 1, pos);\n+        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n+                      \"invalid connection preface\");\n \n         return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 24",
        "commit_diff": "Diff:\n@@ -187,12 +187,13 @@ ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,\n ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n-    ngx_uint_t depth);\n+    ngx_uint_t depth, ngx_shm_zone_t *shm_zone);\n ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n+ngx_int_t ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data);\n RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n     int key_length);\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\nDiff:\n@@ -52,11 +52,28 @@ typedef struct {\n     in_port_t                    port;\n     ngx_uint_t                   depth;\n \n+    ngx_shm_zone_t              *shm_zone;\n+\n     ngx_resolver_t              *resolver;\n     ngx_msec_t                   resolver_timeout;\n } ngx_ssl_ocsp_conf_t;\n \n \n+typedef struct {\n+    ngx_rbtree_t                 rbtree;\n+    ngx_rbtree_node_t            sentinel;\n+    ngx_queue_t                  expire_queue;\n+} ngx_ssl_ocsp_cache_t;\n+\n+\n+typedef struct {\n+    ngx_str_node_t               node;\n+    ngx_queue_t                  queue;\n+    int                          status;\n+    time_t                       valid;\n+} ngx_ssl_ocsp_cache_node_t;\n+\n+\n typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;\n \n \n@@ -100,10 +117,13 @@ struct ngx_ssl_ocsp_ctx_s {\n     void                       (*handler)(ngx_ssl_ocsp_ctx_t *ctx);\n     void                        *data;\n \n+    ngx_str_t                    key;\n     ngx_buf_t                   *request;\n     ngx_buf_t                   *response;\n     ngx_peer_connection_t        peer;\n \n+    ngx_shm_zone_t              *shm_zone;\n+\n     ngx_int_t                  (*process)(ngx_ssl_ocsp_ctx_t *ctx);\n \n     ngx_uint_t                   state;\n@@ -164,6 +184,10 @@ static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx);\n \n+static ngx_int_t ngx_ssl_ocsp_cache_lookup(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_cache_store(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx);\n+\n static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);\n \n \n@@ -743,7 +767,7 @@ ngx_ssl_stapling_cleanup(void *data)\n \n ngx_int_t\n ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n-    ngx_uint_t depth)\n+    ngx_uint_t depth, ngx_shm_zone_t *shm_zone)\n {\n     ngx_url_t             u;\n     ngx_ssl_ocsp_conf_t  *ocf;\n@@ -754,6 +778,7 @@ ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n     }\n \n     ocf->depth = depth;\n+    ocf->shm_zone = shm_zone;\n \n     if (responder->len) {\n         ngx_memzero(&u, sizeof(ngx_url_t));\n@@ -923,7 +948,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n-                   \"ssl ocsp validate, certs:%i\", sk_X509_num(ocsp->certs));\n+                   \"ssl ocsp validate, certs:%d\", sk_X509_num(ocsp->certs));\n \n     ngx_ssl_ocsp_validate_next(c);\n \n@@ -939,6 +964,7 @@ ngx_ssl_ocsp_validate(ngx_connection_t *c)\n static void\n ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n {\n+    ngx_int_t             rc;\n     ngx_uint_t            n;\n     ngx_ssl_ocsp_t       *ocsp;\n     ngx_ssl_ocsp_ctx_t   *ctx;\n@@ -978,6 +1004,8 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n         ctx->handler = ngx_ssl_ocsp_handler;\n         ctx->data = c;\n \n+        ctx->shm_zone = ocf->shm_zone;\n+\n         ctx->addrs = ocf->addrs;\n         ctx->naddrs = ocf->naddrs;\n         ctx->host = ocf->host;\n@@ -994,7 +1022,28 @@ ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n \n         ocsp->ncert++;\n \n-        break;\n+        rc = ngx_ssl_ocsp_cache_lookup(ctx);\n+\n+        if (rc == NGX_ERROR) {\n+            goto failed;\n+        }\n+\n+        if (rc == NGX_DECLINED) {\n+            break;\n+        }\n+\n+        /* rc == NGX_OK */\n+\n+        if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                           \"ssl ocsp cached status \\\"%s\\\"\",\n+                           OCSP_cert_status_str(ctx->status));\n+            ocsp->cert_status = ctx->status;\n+            goto done;\n+        }\n+\n+        ocsp->ctx = NULL;\n+        ngx_ssl_ocsp_done(ctx);\n     }\n \n     ngx_ssl_ocsp_request(ctx);\n@@ -1029,6 +1078,13 @@ ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n         goto done;\n     }\n \n+    rc = ngx_ssl_ocsp_cache_store(ctx);\n+    if (rc != NGX_OK) {\n+        ocsp->status = rc;\n+        ngx_ssl_ocsp_done(ctx);\n+        goto done;\n+    }\n+\n     if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n         ocsp->cert_status = ctx->status;\n         ocsp->status = NGX_OK;\n@@ -2374,6 +2430,245 @@ ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx)\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n+{\n+    size_t                 len;\n+    ngx_slab_pool_t       *shpool;\n+    ngx_ssl_ocsp_cache_t  *cache;\n+\n+    if (data) {\n+        shm_zone->data = data;\n+        return NGX_OK;\n+    }\n+\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+\n+    if (shm_zone->shm.exists) {\n+        shm_zone->data = shpool->data;\n+        return NGX_OK;\n+    }\n+\n+    cache = ngx_slab_alloc(shpool, sizeof(ngx_ssl_ocsp_cache_t));\n+    if (cache == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    shpool->data = cache;\n+    shm_zone->data = cache;\n+\n+    ngx_rbtree_init(&cache->rbtree, &cache->sentinel,\n+                    ngx_str_rbtree_insert_value);\n+\n+    ngx_queue_init(&cache->expire_queue);\n+\n+    len = sizeof(\" in OCSP cache \\\"\\\"\") + shm_zone->shm.name.len;\n+\n+    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n+    if (shpool->log_ctx == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_sprintf(shpool->log_ctx, \" in OCSP cache \\\"%V\\\"%Z\",\n+                &shm_zone->shm.name);\n+\n+    shpool->log_nomem = 0;\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_cache_lookup(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    uint32_t                    hash;\n+    ngx_shm_zone_t             *shm_zone;\n+    ngx_slab_pool_t            *shpool;\n+    ngx_ssl_ocsp_cache_t       *cache;\n+    ngx_ssl_ocsp_cache_node_t  *node;\n+\n+    shm_zone = ctx->shm_zone;\n+\n+    if (shm_zone == NULL) {\n+        return NGX_DECLINED;\n+    }\n+\n+    if (ngx_ssl_ocsp_create_key(ctx) != NGX_OK) {\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp cache lookup\");\n+\n+    cache = shm_zone->data;\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    hash = ngx_hash_key(ctx->key.data, ctx->key.len);\n+\n+    ngx_shmtx_lock(&shpool->mutex);\n+\n+    node = (ngx_ssl_ocsp_cache_node_t *)\n+               ngx_str_rbtree_lookup(&cache->rbtree, &ctx->key, hash);\n+\n+    if (node) {\n+        if (node->valid > ngx_time()) {\n+            ctx->status = node->status;\n+            ngx_shmtx_unlock(&shpool->mutex);\n+\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                           \"ssl ocsp cache hit, %s\",\n+                           OCSP_cert_status_str(ctx->status));\n+\n+            return NGX_OK;\n+        }\n+\n+        ngx_queue_remove(&node->queue);\n+        ngx_rbtree_delete(&cache->rbtree, &node->node.node);\n+        ngx_slab_free_locked(shpool, node);\n+\n+        ngx_shmtx_unlock(&shpool->mutex);\n+\n+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                       \"ssl ocsp cache expired\");\n+\n+        return NGX_DECLINED;\n+    }\n+\n+    ngx_shmtx_unlock(&shpool->mutex);\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp cache miss\");\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_cache_store(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    time_t                      now, valid;\n+    uint32_t                    hash;\n+    ngx_queue_t                *q;\n+    ngx_shm_zone_t             *shm_zone;\n+    ngx_slab_pool_t            *shpool;\n+    ngx_ssl_ocsp_cache_t       *cache;\n+    ngx_ssl_ocsp_cache_node_t  *node;\n+\n+    shm_zone = ctx->shm_zone;\n+\n+    if (shm_zone == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    valid = ctx->valid;\n+\n+    now = ngx_time();\n+\n+    if (valid < now) {\n+        return NGX_OK;\n+    }\n+\n+    if (valid == NGX_MAX_TIME_T_VALUE) {\n+        valid = now + 3600;\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp cache store, valid:%T\", valid - now);\n+\n+    cache = shm_zone->data;\n+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    hash = ngx_hash_key(ctx->key.data, ctx->key.len);\n+\n+    ngx_shmtx_lock(&shpool->mutex);\n+\n+    node = ngx_slab_calloc_locked(shpool,\n+                             sizeof(ngx_ssl_ocsp_cache_node_t) + ctx->key.len);\n+    if (node == NULL) {\n+\n+        if (!ngx_queue_empty(&cache->expire_queue)) {\n+            q = ngx_queue_last(&cache->expire_queue);\n+            node = ngx_queue_data(q, ngx_ssl_ocsp_cache_node_t, queue);\n+\n+            ngx_rbtree_delete(&cache->rbtree, &node->node.node);\n+            ngx_queue_remove(q);\n+            ngx_slab_free_locked(shpool, node);\n+\n+            node = ngx_slab_alloc_locked(shpool,\n+                             sizeof(ngx_ssl_ocsp_cache_node_t) + ctx->key.len);\n+        }\n+\n+        if (node == NULL) {\n+            ngx_shmtx_unlock(&shpool->mutex);\n+            ngx_log_error(NGX_LOG_ALERT, ctx->log, 0,\n+                          \"could not allocate new entry%s\", shpool->log_ctx);\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+    node->node.str.len = ctx->key.len;\n+    node->node.str.data = (u_char *) node + sizeof(ngx_ssl_ocsp_cache_node_t);\n+    ngx_memcpy(node->node.str.data, ctx->key.data, ctx->key.len);\n+    node->node.node.key = hash;\n+    node->status = ctx->status;\n+    node->valid = valid;\n+\n+    ngx_rbtree_insert(&cache->rbtree, &node->node.node);\n+    ngx_queue_insert_head(&cache->expire_queue, &node->queue);\n+\n+    ngx_shmtx_unlock(&shpool->mutex);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    u_char        *p;\n+    X509_NAME     *name;\n+    ASN1_INTEGER  *serial;\n+\n+    p = ngx_pnalloc(ctx->pool, 60);\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ctx->key.data = p;\n+    ctx->key.len = 60;\n+\n+    name = X509_get_subject_name(ctx->issuer);\n+    if (X509_NAME_digest(name, EVP_sha1(), p, NULL) == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    p += 20;\n+\n+    if (X509_pubkey_digest(ctx->issuer, EVP_sha1(), p, NULL) == 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    p += 20;\n+\n+    serial = X509_get_serialNumber(ctx->cert);\n+    if (serial->length > 20) {\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(p, serial->data, serial->length);\n+    ngx_memzero(p, 20 - serial->length);\n+\n+#if (NGX_DEBUG)\n+    {\n+        u_char  buf[120];\n+\n+        ngx_hex_dump(buf, ctx->key.data, ctx->key.len);\n+\n+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                       \"ssl ocsp key %*s\", sizeof(buf), buf);\n+    }\n+#endif\n+\n+    return NGX_OK;\n+}\n+\n+\n static u_char *\n ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len)\n {\n@@ -2436,7 +2731,7 @@ ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n \n ngx_int_t\n ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n-    ngx_uint_t depth)\n+    ngx_uint_t depth, ngx_shm_zone_t *shm_zone)\n {\n     ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,\n                   \"\\\"ssl_ocsp\\\" is not supported on this platform\");\n@@ -2473,4 +2768,11 @@ ngx_ssl_ocsp_cleanup(ngx_connection_t *c)\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n+{\n+    return NGX_OK;\n+}\n+\n+\n #endif\nDiff:\n@@ -50,6 +50,8 @@ static char *ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static char *ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd,\n+    void *conf);\n \n static ngx_int_t ngx_http_ssl_init(ngx_conf_t *cf);\n \n@@ -236,6 +238,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, ocsp_responder),\n       NULL },\n \n+    { ngx_string(\"ssl_ocsp_cache\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_http_ssl_ocsp_cache,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      0,\n+      NULL },\n+\n     { ngx_string(\"ssl_stapling\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n       ngx_conf_set_flag_slot,\n@@ -602,6 +611,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->session_tickets = NGX_CONF_UNSET;\n     sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;\n     sscf->ocsp = NGX_CONF_UNSET_UINT;\n+    sscf->ocsp_cache_zone = NGX_CONF_UNSET_PTR;\n     sscf->stapling = NGX_CONF_UNSET;\n     sscf->stapling_verify = NGX_CONF_UNSET;\n \n@@ -667,6 +677,8 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_uint_value(conf->ocsp, prev->ocsp, 0);\n     ngx_conf_merge_str_value(conf->ocsp_responder, prev->ocsp_responder, \"\");\n+    ngx_conf_merge_ptr_value(conf->ocsp_cache_zone,\n+                         prev->ocsp_cache_zone, NULL);\n \n     ngx_conf_merge_value(conf->stapling, prev->stapling, 0);\n     ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);\n@@ -838,7 +850,8 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n             return NGX_CONF_ERROR;\n         }\n \n-        if (ngx_ssl_ocsp(cf, &conf->ssl, &conf->ocsp_responder, conf->ocsp)\n+        if (ngx_ssl_ocsp(cf, &conf->ssl, &conf->ocsp_responder, conf->ocsp,\n+                         conf->ocsp_cache_zone)\n             != NGX_OK)\n         {\n             return NGX_CONF_ERROR;\n@@ -1143,6 +1156,85 @@ ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static char *\n+ngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n+{\n+    ngx_http_ssl_srv_conf_t *sscf = conf;\n+\n+    size_t       len;\n+    ngx_int_t    n;\n+    ngx_str_t   *value, name, size;\n+    ngx_uint_t   j;\n+\n+    if (sscf->ocsp_cache_zone != NGX_CONF_UNSET_PTR) {\n+        return \"is duplicate\";\n+    }\n+\n+    value = cf->args->elts;\n+\n+    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n+        sscf->ocsp_cache_zone = NULL;\n+        return NGX_CONF_OK;\n+    }\n+\n+    if (value[1].len <= sizeof(\"shared:\") - 1\n+        || ngx_strncmp(value[1].data, \"shared:\", sizeof(\"shared:\") - 1) != 0)\n+    {\n+        goto invalid;\n+    }\n+\n+    len = 0;\n+\n+    for (j = sizeof(\"shared:\") - 1; j < value[1].len; j++) {\n+        if (value[1].data[j] == ':') {\n+            break;\n+        }\n+\n+        len++;\n+    }\n+\n+    if (len == 0) {\n+        goto invalid;\n+    }\n+\n+    name.len = len;\n+    name.data = value[1].data + sizeof(\"shared:\") - 1;\n+\n+    size.len = value[1].len - j - 1;\n+    size.data = name.data + len + 1;\n+\n+    n = ngx_parse_size(&size);\n+\n+    if (n == NGX_ERROR) {\n+        goto invalid;\n+    }\n+\n+    if (n < (ngx_int_t) (8 * ngx_pagesize)) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                           \"OCSP cache \\\"%V\\\" is too small\", &value[1]);\n+\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    sscf->ocsp_cache_zone = ngx_shared_memory_add(cf, &name, n,\n+                                                  &ngx_http_ssl_module_ctx);\n+    if (sscf->ocsp_cache_zone == NULL) {\n+        return NGX_CONF_ERROR;\n+    }\n+\n+    sscf->ocsp_cache_zone->init = ngx_ssl_ocsp_cache_init;\n+\n+    return NGX_CONF_OK;\n+\n+invalid:\n+\n+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n+                       \"invalid OCSP cache \\\"%V\\\"\", &value[1]);\n+\n+    return NGX_CONF_ERROR;\n+}\n+\n+\n static ngx_int_t\n ngx_http_ssl_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -56,6 +56,7 @@ typedef struct {\n \n     ngx_uint_t                      ocsp;\n     ngx_str_t                       ocsp_responder;\n+    ngx_shm_zone_t                 *ocsp_cache_zone;\n \n     ngx_flag_t                      stapling;\n     ngx_flag_t                      stapling_verify;\n",
        "analysis": "To identify newly added functions from the diff, I will look for new function definitions. Here are the newly added functions:\n\n1. **ngx_ssl_ocsp_cache_init**\n2. **ngx_ssl_ocsp_cache_lookup**\n3. **ngx_ssl_ocsp_cache_store**\n4. **ngx_ssl_ocsp_create_key**\n5. **ngx_http_ssl_ocsp_cache**\n\nNow, let's analyze each new function separately to check for potential out-of-bounds write vulnerabilities under the assumption that a user can be extremely malicious.\n\n**Function: ngx_ssl_ocsp_cache_init**\n```c\nngx_int_t\nngx_ssl_ocsp_cache_init(ngx_shm_zone_t *shm_zone, void *data)\n{\n    size_t                 len;\n    ngx_slab_pool_t       *shpool;\n    ngx_ssl_ocsp_cache_t  *cache;\n\n    if (data) {\n        shm_zone->data = data;\n        return NGX_OK;\n    }\n\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n\n    if (shm_zone->shm.exists) {\n        shm_zone->data = shpool->data;\n        return NGX_OK;\n    }\n\n    cache = ngx_slab_alloc(shpool, sizeof(ngx_ssl_ocsp_cache_t));\n    if (cache == NULL) {\n        return NGX_ERROR;\n    }\n\n    shpool->data = cache;\n    shm_zone->data = cache;\n\n    ngx_rbtree_init(&cache->rbtree, &cache->sentinel,\n                    ngx_str_rbtree_insert_value);\n\n    ngx_queue_init(&cache->expire_queue);\n\n    len = sizeof(\" in OCSP cache \\\"\\\"\") + shm_zone->shm.name.len;\n\n    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n    if (shpool->log_ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_sprintf(shpool->log_ctx, \" in OCSP cache \\\"%V\\\"%Z\",\n                &shm_zone->shm.name);\n\n    shpool->log_nomem = 0;\n\n    return NGX_OK;\n}\n```\n- The function allocates memory and initializes structures. There doesn't seem to be any potential for out-of-bounds writes within the scope of this function as all memory allocations appear to be correctly handled using `ngx_slab_alloc` which is specific to this ecosystem's memory management.\n\n**Function: ngx_ssl_ocsp_cache_lookup**\n```c\nstatic ngx_int_t\nngx_ssl_ocsp_cache_lookup(ngx_ssl_ocsp_ctx_t *ctx)\n{\n    uint32_t                    hash;\n    ngx_shm_zone_t             *shm_zone;\n    ngx_slab_pool_t            *shpool;\n    ngx_ssl_ocsp_cache_t       *cache;\n    ngx_ssl_ocsp_cache_node_t  *node;\n\n    shm_zone = ctx->shm_zone;\n\n    if (shm_zone == NULL) {\n        return NGX_DECLINED;\n    }\n\n    if (ngx_ssl_ocsp_create_key(ctx) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp cache lookup\");\n\n    cache = shm_zone->data;\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n    hash = ngx_hash_key(ctx->key.data, ctx->key.len);\n\n    ngx_shmtx_lock(&shpool->mutex);\n\n    node = (ngx_ssl_ocsp_cache_node_t *)\n               ngx_str_rbtree_lookup(&cache->rbtree, &ctx->key, hash);\n\n    if (node) {\n        if (node->valid > ngx_time()) {\n            ctx->status = node->status;\n            ngx_shmtx_unlock(&shpool->mutex);\n\n            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n                           \"ssl ocsp cache hit, %s\",\n                           OCSP_cert_status_str(ctx->status));\n\n            return NGX_OK;\n        }\n\n        ngx_queue_remove(&node->queue);\n        ngx_rbtree_delete(&cache->rbtree, &node->node.node);\n        ngx_slab_free_locked(shpool, node);\n\n        ngx_shmtx_unlock(&shpool->mutex);\n\n        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n                       \"ssl ocsp cache expired\");\n\n        return NGX_DECLINED;\n    }\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp cache miss\");\n\n    return NGX_DECLINED;\n}\n```\n- The function interacts with a red-black tree and memory cache. It doesn't seem to perform operations that could cause an out-of-bounds write given appropriate allocation and locking mechanisms are in place with checks on returned values.\n\n**Function: ngx_ssl_ocsp_cache_store**\n```c\nstatic ngx_int_t\nngx_ssl_ocsp_cache_store(ngx_ssl_ocsp_ctx_t *ctx)\n{\n    time_t                      now, valid;\n    uint32_t                    hash;\n    ngx_queue_t                *q;\n    ngx_shm_zone_t             *shm_zone;\n    ngx_slab_pool_t            *shpool;\n    ngx_ssl_ocsp_cache_t       *cache;\n    ngx_ssl_ocsp_cache_node_t  *node;\n\n    shm_zone = ctx->shm_zone;\n\n    if (shm_zone == NULL) {\n        return NGX_OK;\n    }\n\n    valid = ctx->valid;\n\n    now = ngx_time();\n\n    if (valid < now) {\n        return NGX_OK;\n    }\n\n    if (valid == NGX_MAX_TIME_T_VALUE) {\n        valid = now + 3600;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n                   \"ssl ocsp cache store, valid:%T\", valid - now);\n\n    cache = shm_zone->data;\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n    hash = ngx_hash_key(ctx->key.data, ctx->key.len);\n\n    ngx_shmtx_lock(&shpool->mutex);\n\n    node = ngx_slab_calloc_locked(shpool,\n                             sizeof(ngx_ssl_ocsp_cache_node_t) + ctx->key.len);\n    if (node == NULL) {\n\n        if (!ngx_queue_empty(&cache->expire_queue)) {\n            q = ngx_queue_last(&cache->expire_queue);\n            node = ngx_queue_data(q, ngx_ssl_ocsp_cache_node_t, queue);\n\n            ngx_rbtree_delete(&cache->rbtree, &node->node.node);\n            ngx_queue_remove(q);\n            ngx_slab_free_locked(shpool, node);\n\n            node = ngx_slab_alloc_locked(shpool,\n                             sizeof(ngx_ssl_ocsp_cache_node_t) + ctx->key.len);\n        }\n\n        if (node == NULL) {\n            ngx_shmtx_unlock(&shpool->mutex);\n            ngx_log_error(NGX_LOG_ALERT, ctx->log, 0,\n                          \"could not allocate new entry%s\", shpool->log_ctx);\n            return NGX_ERROR;\n        }\n    }\n\n    node->node.str.len = ctx->key.len;\n    node->node.str.data = (u_char *) node + sizeof(ngx_ssl_ocsp_cache_node_t);\n    ngx_memcpy(node->node.str.data, ctx->key.data, ctx->key.len);\n    node->node.node.key = hash;\n    node->status = ctx->status;\n    node->valid = valid;\n\n    ngx_rbtree_insert(&cache->rbtree, &node->node.node);\n    ngx_queue_insert_head(&cache->expire_queue, &node->queue);\n\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    return NGX_OK;\n}\n```\n- The function handles cache storage. In particular, `ngx_memcpy(node->node.str.data, ctx->key.data, ctx->key.len);` is a point of interest but does not, on inspection, write outside its bounds because allocations seem correctly verified prior.\n\n**Function: ngx_ssl_ocsp_create_key**\n```c\nstatic ngx_int_t\nngx_ssl_ocsp_create_key(ngx_ssl_ocsp_ctx_t *ctx)\n{\n    u_char        *p;\n    X509_NAME     *name;\n    ASN1_INTEGER  *serial;\n\n    p = ngx_pnalloc(ctx->pool, 60);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    ctx->key.data = p;\n    ctx->key.len = 60;\n\n    name = X509_get_subject_name(ctx->issuer);\n    if (X509_NAME_digest(name, EVP_sha1(), p, NULL) == 0) {\n        return NGX_ERROR;\n    }\n\n    p += 20;\n\n    if (X509_pubkey_digest(ctx->issuer, EVP_sha1(), p, NULL) == 0) {\n        return NGX_ERROR;\n    }\n\n    p += 20;\n\n    serial = X509_get_serialNumber(ctx->cert);\n    if (serial->length > 20) {\n        return NGX_ERROR;\n    }\n\n    p = ngx_cpymem(p, serial->data, serial->length);\n    ngx_memzero(p, 20 - serial->length);\n\n#if (NGX_DEBUG)\n    {\n        u_char  buf[120];\n\n        ngx_hex_dump(buf, ctx->key.data, ctx->key.len);\n\n        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n                       \"ssl ocsp key %*s\", sizeof(buf), buf);\n    }\n#endif\n\n    return NGX_OK;\n}\n```\n- Here the function handles creation of a key, assumes a fixed size of 60 bytes for `ctx->key.data`, and then fills specific portions. Unless assumptions about certificate encoding are wrong, or the structure of this key allows otherwise, it seems to maintain safe bounds.\n\n**Function: ngx_http_ssl_ocsp_cache**\n```c\nstatic char *\nngx_http_ssl_ocsp_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_http_ssl_srv_conf_t *sscf = conf;\n\n    size_t       len;\n    ngx_int_t    n;\n    ngx_str_t   *value, name, size;\n    ngx_uint_t   j;\n\n    if (sscf->ocsp_cache_zone != NGX_CONF_UNSET_PTR) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n        sscf->ocsp_cache_zone = NULL;\n        return NGX_CONF_OK;\n    }\n\n    if (value[1].len <= sizeof(\"shared:\") - 1\n        || ngx_strncmp(value[1].data, \"shared:\", sizeof(\"shared:\") - 1) != 0)\n    {\n        goto invalid;\n    }\n\n    len = 0;\n\n    for (j = sizeof(\"shared:\") - 1; j < value[1].len; j++) {\n        if (value[1].data[j] == ':') {\n            break;\n        }\n\n        len++;\n    }\n\n    if (len == 0) {\n        goto invalid;\n    }\n\n    name.len = len;\n    name.data = value[1].data + sizeof(\"shared:\") - 1;\n\n    size.len = value[1].len - j - 1;\n    size.data = name.data + len + 1;\n\n    n = ngx_parse_size(&size);\n\n    if (n == NGX_ERROR) {\n        goto invalid;\n    }\n\n    if (n < (ngx_int_t) (8 * ngx_pagesize)) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"OCSP cache \\\"%V\\\" is too small\", &value[1]);\n\n        return NGX_CONF_ERROR;\n    }\n\n    sscf->ocsp_cache_zone = ngx_shared_memory_add(cf, &name, n,\n                                                  &ngx_http_ssl_module_ctx);\n    if (sscf->ocsp_cache_zone == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    sscf->ocsp_cache_zone->init = ngx_ssl_ocsp_cache_init;\n\n    return NGX_CONF_OK;\n\ninvalid:\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"invalid OCSP cache \\\"%V\\\"\", &value[1]);\n\n    return NGX_CONF_ERROR;\n}\n```\n- It looks to parse and validate OCSP cache configuration. Edge cases seem to redirect to error handling, and there do not appear to be raw buffer accesses that might lead to out-of-bounds conditions.\n\nUpon examination, none of the functions seem directly vulnerable to an out-of-bounds write based on coding practices observed in this snippet. \n\nTherefore, the final result:\n\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 23",
        "commit_diff": "Diff:\n@@ -130,6 +130,7 @@ int  ngx_ssl_connection_index;\n int  ngx_ssl_server_conf_index;\n int  ngx_ssl_session_cache_index;\n int  ngx_ssl_session_ticket_keys_index;\n+int  ngx_ssl_ocsp_index;\n int  ngx_ssl_certificate_index;\n int  ngx_ssl_next_certificate_index;\n int  ngx_ssl_certificate_name_index;\n@@ -213,6 +214,13 @@ ngx_ssl_init(ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n+    ngx_ssl_ocsp_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL, NULL);\n+    if (ngx_ssl_ocsp_index == -1) {\n+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,\n+                      \"SSL_CTX_get_ex_new_index() failed\");\n+        return NGX_ERROR;\n+    }\n+\n     ngx_ssl_certificate_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,\n                                                          NULL);\n     if (ngx_ssl_certificate_index == -1) {\n@@ -1594,13 +1602,18 @@ ngx_ssl_handshake(ngx_connection_t *c)\n {\n     int        n, sslerr;\n     ngx_err_t  err;\n+    ngx_int_t  rc;\n \n #ifdef SSL_READ_EARLY_DATA_SUCCESS\n     if (c->ssl->try_early_data) {\n         return ngx_ssl_try_early_data(c);\n     }\n #endif\n \n+    if (c->ssl->in_ocsp) {\n+        return ngx_ssl_ocsp_validate(c);\n+    }\n+\n     ngx_ssl_clear_error(c->log);\n \n     n = SSL_do_handshake(c->ssl->connection);\n@@ -1621,8 +1634,6 @@ ngx_ssl_handshake(ngx_connection_t *c)\n         ngx_ssl_handshake_log(c);\n #endif\n \n-        c->ssl->handshaked = 1;\n-\n         c->recv = ngx_ssl_recv;\n         c->send = ngx_ssl_write;\n         c->recv_chain = ngx_ssl_recv_chain;\n@@ -1641,6 +1652,20 @@ ngx_ssl_handshake(ngx_connection_t *c)\n #endif\n #endif\n \n+        rc = ngx_ssl_ocsp_validate(c);\n+\n+        if (rc == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->read->handler = ngx_ssl_handshake_handler;\n+            c->write->handler = ngx_ssl_handshake_handler;\n+            return NGX_AGAIN;\n+        }\n+\n+        c->ssl->handshaked = 1;\n+\n         return NGX_OK;\n     }\n \n@@ -1710,6 +1735,7 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n     u_char     buf;\n     size_t     readbytes;\n     ngx_err_t  err;\n+    ngx_int_t  rc;\n \n     ngx_ssl_clear_error(c->log);\n \n@@ -1744,14 +1770,27 @@ ngx_ssl_try_early_data(ngx_connection_t *c)\n         c->ssl->early_buf = buf;\n         c->ssl->early_preread = 1;\n \n-        c->ssl->handshaked = 1;\n         c->ssl->in_early = 1;\n \n         c->recv = ngx_ssl_recv;\n         c->send = ngx_ssl_write;\n         c->recv_chain = ngx_ssl_recv_chain;\n         c->send_chain = ngx_ssl_send_chain;\n \n+        rc = ngx_ssl_ocsp_validate(c);\n+\n+        if (rc == NGX_ERROR) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (rc == NGX_AGAIN) {\n+            c->read->handler = ngx_ssl_handshake_handler;\n+            c->write->handler = ngx_ssl_handshake_handler;\n+            return NGX_AGAIN;\n+        }\n+\n+        c->ssl->handshaked = 1;\n+\n         return NGX_OK;\n     }\n \n@@ -2735,6 +2774,8 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n     int        n, sslerr, mode;\n     ngx_err_t  err;\n \n+    ngx_ssl_ocsp_cleanup(c);\n+\n     if (SSL_in_init(c->ssl->connection)) {\n         /*\n          * OpenSSL 1.0.2f complains if SSL_shutdown() is called during\n@@ -4894,11 +4935,14 @@ ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n     rc = SSL_get_verify_result(c->ssl->connection);\n \n     if (rc == X509_V_OK) {\n-        ngx_str_set(s, \"SUCCESS\");\n-        return NGX_OK;\n-    }\n+        if (ngx_ssl_ocsp_get_status(c, &str) == NGX_OK) {\n+            ngx_str_set(s, \"SUCCESS\");\n+            return NGX_OK;\n+        }\n \n-    str = X509_verify_cert_error_string(rc);\n+    } else {\n+        str = X509_verify_cert_error_string(rc);\n+    }\n \n     s->data = ngx_pnalloc(pool, sizeof(\"FAILED:\") - 1 + ngx_strlen(str));\n     if (s->data == NULL) {\nDiff:\n@@ -64,6 +64,9 @@\n #endif\n \n \n+typedef struct ngx_ssl_ocsp_s  ngx_ssl_ocsp_t;\n+\n+\n struct ngx_ssl_s {\n     SSL_CTX                    *ctx;\n     ngx_log_t                  *log;\n@@ -87,6 +90,8 @@ struct ngx_ssl_connection_s {\n     ngx_event_handler_pt        saved_read_handler;\n     ngx_event_handler_pt        saved_write_handler;\n \n+    ngx_ssl_ocsp_t             *ocsp;\n+\n     u_char                      early_buf;\n \n     unsigned                    handshaked:1;\n@@ -97,6 +102,7 @@ struct ngx_ssl_connection_s {\n     unsigned                    handshake_buffer_set:1;\n     unsigned                    try_early_data:1;\n     unsigned                    in_early:1;\n+    unsigned                    in_ocsp:1;\n     unsigned                    early_preread:1;\n     unsigned                    write_blocked:1;\n };\n@@ -180,6 +186,13 @@ ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);\n ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n+ngx_int_t ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n+    ngx_uint_t depth);\n+ngx_int_t ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);\n+ngx_int_t ngx_ssl_ocsp_validate(ngx_connection_t *c);\n+ngx_int_t ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s);\n+void ngx_ssl_ocsp_cleanup(ngx_connection_t *c);\n RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,\n     int key_length);\n ngx_array_t *ngx_ssl_read_password_file(ngx_conf_t *cf, ngx_str_t *file);\n@@ -281,6 +294,7 @@ extern int  ngx_ssl_connection_index;\n extern int  ngx_ssl_server_conf_index;\n extern int  ngx_ssl_session_cache_index;\n extern int  ngx_ssl_session_ticket_keys_index;\n+extern int  ngx_ssl_ocsp_index;\n extern int  ngx_ssl_certificate_index;\n extern int  ngx_ssl_next_certificate_index;\n extern int  ngx_ssl_certificate_name_index;\nDiff:\n@@ -43,8 +43,35 @@ typedef struct {\n } ngx_ssl_stapling_t;\n \n \n+typedef struct {\n+    ngx_addr_t                  *addrs;\n+    ngx_uint_t                   naddrs;\n+\n+    ngx_str_t                    host;\n+    ngx_str_t                    uri;\n+    in_port_t                    port;\n+    ngx_uint_t                   depth;\n+\n+    ngx_resolver_t              *resolver;\n+    ngx_msec_t                   resolver_timeout;\n+} ngx_ssl_ocsp_conf_t;\n+\n+\n typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;\n \n+\n+struct ngx_ssl_ocsp_s {\n+    STACK_OF(X509)              *certs;\n+    ngx_uint_t                   ncert;\n+\n+    int                          cert_status;\n+    ngx_int_t                    status;\n+\n+    ngx_ssl_ocsp_conf_t         *conf;\n+    ngx_ssl_ocsp_ctx_t          *ctx;\n+};\n+\n+\n struct ngx_ssl_ocsp_ctx_s {\n     SSL_CTX                     *ssl_ctx;\n \n@@ -114,7 +141,12 @@ static time_t ngx_ssl_stapling_time(ASN1_GENERALIZEDTIME *asn1time);\n \n static void ngx_ssl_stapling_cleanup(void *data);\n \n-static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);\n+static void ngx_ssl_ocsp_validate_next(ngx_connection_t *c);\n+static void ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_responder(ngx_connection_t *c,\n+    ngx_ssl_ocsp_ctx_t *ctx);\n+\n+static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(ngx_log_t *log);\n static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);\n@@ -570,7 +602,7 @@ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)\n \n     staple->loading = 1;\n \n-    ctx = ngx_ssl_ocsp_start();\n+    ctx = ngx_ssl_ocsp_start(ngx_cycle->log);\n     if (ctx == NULL) {\n         return;\n     }\n@@ -709,14 +741,467 @@ ngx_ssl_stapling_cleanup(void *data)\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n+    ngx_uint_t depth)\n+{\n+    ngx_url_t             u;\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    ocf = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_ocsp_conf_t));\n+    if (ocf == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    ocf->depth = depth;\n+\n+    if (responder->len) {\n+        ngx_memzero(&u, sizeof(ngx_url_t));\n+\n+        u.url = *responder;\n+        u.default_port = 80;\n+        u.uri_part = 1;\n+\n+        if (u.url.len > 7\n+            && ngx_strncasecmp(u.url.data, (u_char *) \"http://\", 7) == 0)\n+        {\n+            u.url.len -= 7;\n+            u.url.data += 7;\n+\n+        } else {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                          \"invalid URL prefix in OCSP responder \\\"%V\\\" \"\n+                          \"in \\\"ssl_ocsp_responder\\\"\", &u.url);\n+            return NGX_ERROR;\n+        }\n+\n+        if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n+            if (u.err) {\n+                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                              \"%s in OCSP responder \\\"%V\\\" \"\n+                              \"in \\\"ssl_ocsp_responder\\\"\", u.err, &u.url);\n+            }\n+\n+            return NGX_ERROR;\n+        }\n+\n+        ocf->addrs = u.addrs;\n+        ocf->naddrs = u.naddrs;\n+        ocf->host = u.host;\n+        ocf->uri = u.uri;\n+        ocf->port = u.port;\n+    }\n+\n+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_ocsp_index, ocf) == 0) {\n+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,\n+                      \"SSL_CTX_set_ex_data() failed\");\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)\n+{\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    ocf = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_ocsp_index);\n+    ocf->resolver = resolver;\n+    ocf->resolver_timeout = resolver_timeout;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_validate(ngx_connection_t *c)\n+{\n+    X509                 *cert;\n+    SSL_CTX              *ssl_ctx;\n+    ngx_int_t             rc;\n+    X509_STORE           *store;\n+    X509_STORE_CTX       *store_ctx;\n+    STACK_OF(X509)       *chain;\n+    ngx_ssl_ocsp_t       *ocsp;\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    if (c->ssl->in_ocsp) {\n+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n+            return NGX_ERROR;\n+        }\n+\n+        return NGX_AGAIN;\n+    }\n+\n+    ssl_ctx = SSL_get_SSL_CTX(c->ssl->connection);\n+\n+    ocf = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_ocsp_index);\n+    if (ocf == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (SSL_get_verify_result(c->ssl->connection) != X509_V_OK) {\n+        return NGX_OK;\n+    }\n+\n+    cert = SSL_get_peer_certificate(c->ssl->connection);\n+    if (cert == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    ocsp = ngx_pcalloc(c->pool, sizeof(ngx_ssl_ocsp_t));\n+    if (ocsp == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    c->ssl->ocsp = ocsp;\n+\n+    ocsp->status = NGX_AGAIN;\n+    ocsp->cert_status = V_OCSP_CERTSTATUS_GOOD;\n+    ocsp->conf = ocf;\n+\n+#if (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined LIBRESSL_VERSION_NUMBER)\n+\n+    ocsp->certs = SSL_get0_verified_chain(c->ssl->connection);\n+\n+    if (ocsp->certs) {\n+        ocsp->certs = X509_chain_up_ref(ocsp->certs);\n+        if (ocsp->certs == NULL) {\n+            return NGX_ERROR;\n+        }\n+    }\n+\n+#endif\n+\n+    if (ocsp->certs == NULL) {\n+        store = SSL_CTX_get_cert_store(ssl_ctx);\n+        if (store == NULL) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"SSL_CTX_get_cert_store() failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        store_ctx = X509_STORE_CTX_new();\n+        if (store_ctx == NULL) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"X509_STORE_CTX_new() failed\");\n+            return NGX_ERROR;\n+        }\n+\n+        chain = SSL_get_peer_cert_chain(c->ssl->connection);\n+\n+        if (X509_STORE_CTX_init(store_ctx, store, cert, chain) == 0) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"X509_STORE_CTX_init() failed\");\n+            X509_STORE_CTX_free(store_ctx);\n+            return NGX_ERROR;\n+        }\n+\n+        rc = X509_verify_cert(store_ctx);\n+        if (rc <= 0) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0, \"X509_verify_cert() failed\");\n+            X509_STORE_CTX_free(store_ctx);\n+            return NGX_ERROR;\n+        }\n+\n+        ocsp->certs = X509_STORE_CTX_get1_chain(store_ctx);\n+        if (ocsp->certs == NULL) {\n+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0,\n+                          \"X509_STORE_CTX_get1_chain() failed\");\n+            X509_STORE_CTX_free(store_ctx);\n+            return NGX_ERROR;\n+        }\n+\n+        X509_STORE_CTX_free(store_ctx);\n+    }\n+\n+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                   \"ssl ocsp validate, certs:%i\", sk_X509_num(ocsp->certs));\n+\n+    ngx_ssl_ocsp_validate_next(c);\n+\n+    if (ocsp->status == NGX_AGAIN) {\n+        c->ssl->in_ocsp = 1;\n+        return NGX_AGAIN;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void\n+ngx_ssl_ocsp_validate_next(ngx_connection_t *c)\n+{\n+    ngx_uint_t            n;\n+    ngx_ssl_ocsp_t       *ocsp;\n+    ngx_ssl_ocsp_ctx_t   *ctx;\n+    ngx_ssl_ocsp_conf_t  *ocf;\n+\n+    ocsp = c->ssl->ocsp;\n+    ocf = ocsp->conf;\n+\n+    n = sk_X509_num(ocsp->certs);\n+\n+    for ( ;; ) {\n+\n+        if (ocsp->ncert == n - 1 || (ocf->depth == 2 && ocsp->ncert == 1)) {\n+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                           \"ssl ocsp validated, certs:%ui\", ocsp->ncert);\n+            goto done;\n+        }\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,\n+                       \"ssl ocsp validate cert:%ui\", ocsp->ncert);\n+\n+        ctx = ngx_ssl_ocsp_start(c->log);\n+        if (ctx == NULL) {\n+            goto failed;\n+        }\n+\n+        ocsp->ctx = ctx;\n+\n+        ctx->ssl_ctx = SSL_get_SSL_CTX(c->ssl->connection);\n+        ctx->cert = sk_X509_value(ocsp->certs, ocsp->ncert);\n+        ctx->issuer = sk_X509_value(ocsp->certs, ocsp->ncert + 1);\n+        ctx->chain = ocsp->certs;\n+\n+        ctx->resolver = ocf->resolver;\n+        ctx->resolver_timeout = ocf->resolver_timeout;\n+\n+        ctx->handler = ngx_ssl_ocsp_handler;\n+        ctx->data = c;\n+\n+        ctx->addrs = ocf->addrs;\n+        ctx->naddrs = ocf->naddrs;\n+        ctx->host = ocf->host;\n+        ctx->uri = ocf->uri;\n+        ctx->port = ocf->port;\n+\n+        if (ngx_ssl_ocsp_responder(c, ctx) != NGX_OK) {\n+            goto failed;\n+        }\n+\n+        if (ctx->uri.len == 0) {\n+            ngx_str_set(&ctx->uri, \"/\");\n+        }\n+\n+        ocsp->ncert++;\n+\n+        break;\n+    }\n+\n+    ngx_ssl_ocsp_request(ctx);\n+    return;\n+\n+done:\n+\n+    ocsp->status = NGX_OK;\n+    return;\n+\n+failed:\n+\n+    ocsp->status = NGX_ERROR;\n+}\n+\n+\n+static void\n+ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    ngx_int_t          rc;\n+    ngx_ssl_ocsp_t    *ocsp;\n+    ngx_connection_t  *c;\n+\n+    c = ctx->data;\n+    ocsp = c->ssl->ocsp;\n+    ocsp->ctx = NULL;\n+\n+    rc = ngx_ssl_ocsp_verify(ctx);\n+    if (rc != NGX_OK) {\n+        ocsp->status = rc;\n+        ngx_ssl_ocsp_done(ctx);\n+        goto done;\n+    }\n+\n+    if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n+        ocsp->cert_status = ctx->status;\n+        ocsp->status = NGX_OK;\n+        ngx_ssl_ocsp_done(ctx);\n+        goto done;\n+    }\n+\n+    ngx_ssl_ocsp_done(ctx);\n+\n+    ngx_ssl_ocsp_validate_next(c);\n+\n+done:\n+\n+    if (ocsp->status == NGX_AGAIN || !c->ssl->in_ocsp) {\n+        return;\n+    }\n+\n+    c->ssl->handshaked = 1;\n+\n+    c->ssl->handler(c);\n+}\n+\n+\n+static ngx_int_t\n+ngx_ssl_ocsp_responder(ngx_connection_t *c, ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    char                      *s;\n+    ngx_str_t                  responder;\n+    ngx_url_t                  u;\n+    STACK_OF(OPENSSL_STRING)  *aia;\n+\n+    if (ctx->host.len) {\n+        return NGX_OK;\n+    }\n+\n+    /* extract OCSP responder URL from certificate */\n+\n+    aia = X509_get1_ocsp(ctx->cert);\n+    if (aia == NULL) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"no OCSP responder URL in certificate\");\n+        return NGX_ERROR;\n+    }\n+\n+#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n+    s = sk_OPENSSL_STRING_value(aia, 0);\n+#else\n+    s = sk_value(aia, 0);\n+#endif\n+    if (s == NULL) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"no OCSP responder URL in certificate\");\n+        X509_email_free(aia);\n+        return NGX_ERROR;\n+    }\n+\n+    responder.len = ngx_strlen(s);\n+    responder.data = ngx_palloc(ctx->pool, responder.len);\n+    if (responder.data == NULL) {\n+        X509_email_free(aia);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_memcpy(responder.data, s, responder.len);\n+    X509_email_free(aia);\n+\n+    ngx_memzero(&u, sizeof(ngx_url_t));\n+\n+    u.url = responder;\n+    u.default_port = 80;\n+    u.uri_part = 1;\n+    u.no_resolve = 1;\n+\n+    if (u.url.len > 7\n+        && ngx_strncasecmp(u.url.data, (u_char *) \"http://\", 7) == 0)\n+    {\n+        u.url.len -= 7;\n+        u.url.data += 7;\n+\n+    } else {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"invalid URL prefix in OCSP responder \\\"%V\\\" \"\n+                      \"in certificate\", &u.url);\n+        return NGX_ERROR;\n+    }\n+\n+    if (ngx_parse_url(ctx->pool, &u) != NGX_OK) {\n+        if (u.err) {\n+            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                          \"%s in OCSP responder \\\"%V\\\" in certificate\",\n+                          u.err, &u.url);\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    if (u.host.len == 0) {\n+        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                      \"empty host in OCSP responder in certificate\");\n+        return NGX_ERROR;\n+    }\n+\n+    ctx->addrs = u.addrs;\n+    ctx->naddrs = u.naddrs;\n+    ctx->host = u.host;\n+    ctx->uri = u.uri;\n+    ctx->port = u.port;\n+\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)\n+{\n+    ngx_ssl_ocsp_t  *ocsp;\n+\n+    ocsp = c->ssl->ocsp;\n+    if (ocsp == NULL) {\n+        return NGX_OK;\n+    }\n+\n+    if (ocsp->status == NGX_ERROR) {\n+        *s = \"certificate status request failed\";\n+        return NGX_DECLINED;\n+    }\n+\n+    switch (ocsp->cert_status) {\n+\n+    case V_OCSP_CERTSTATUS_GOOD:\n+        return NGX_OK;\n+\n+    case V_OCSP_CERTSTATUS_REVOKED:\n+        *s = \"certificate revoked\";\n+        break;\n+\n+    default: /* V_OCSP_CERTSTATUS_UNKNOWN */\n+        *s = \"certificate status unknown\";\n+    }\n+\n+    return NGX_DECLINED;\n+}\n+\n+\n+void\n+ngx_ssl_ocsp_cleanup(ngx_connection_t *c)\n+{\n+    ngx_ssl_ocsp_t  *ocsp;\n+\n+    ocsp = c->ssl->ocsp;\n+    if (ocsp == NULL) {\n+        return;\n+    }\n+\n+    if (ocsp->ctx) {\n+        ngx_ssl_ocsp_done(ocsp->ctx);\n+        ocsp->ctx = NULL;\n+    }\n+\n+    if (ocsp->certs) {\n+        sk_X509_pop_free(ocsp->certs, X509_free);\n+        ocsp->certs = NULL;\n+    }\n+}\n+\n+\n static ngx_ssl_ocsp_ctx_t *\n-ngx_ssl_ocsp_start(void)\n+ngx_ssl_ocsp_start(ngx_log_t *log)\n {\n-    ngx_log_t           *log;\n     ngx_pool_t          *pool;\n     ngx_ssl_ocsp_ctx_t  *ctx;\n \n-    pool = ngx_create_pool(2048, ngx_cycle->log);\n+    pool = ngx_create_pool(2048, log);\n     if (pool == NULL) {\n         return NULL;\n     }\n@@ -828,6 +1313,14 @@ ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx)\n         }\n \n         if (resolve == NGX_NO_RESOLVER) {\n+            if (ctx->naddrs == 0) {\n+                ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                              \"no resolver defined to resolve %V\", &ctx->host);\n+\n+                ngx_ssl_ocsp_error(ctx);\n+                return;\n+            }\n+\n             ngx_log_error(NGX_LOG_WARN, ctx->log, 0,\n                           \"no resolver defined to resolve %V\", &ctx->host);\n             goto connect;\n@@ -979,8 +1472,10 @@ ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)\n \n     ctx->process = ngx_ssl_ocsp_process_status_line;\n \n-    ngx_add_timer(ctx->peer.connection->read, ctx->timeout);\n-    ngx_add_timer(ctx->peer.connection->write, ctx->timeout);\n+    if (ctx->timeout) {\n+        ngx_add_timer(ctx->peer.connection->read, ctx->timeout);\n+        ngx_add_timer(ctx->peer.connection->write, ctx->timeout);\n+    }\n \n     if (rc == NGX_OK) {\n         ngx_ssl_ocsp_write_handler(ctx->peer.connection->write);\n@@ -1036,7 +1531,7 @@ ngx_ssl_ocsp_write_handler(ngx_event_t *wev)\n         }\n     }\n \n-    if (!wev->timer_set) {\n+    if (!wev->timer_set && ctx->timeout) {\n         ngx_add_timer(wev, ctx->timeout);\n     }\n }\n@@ -1939,4 +2434,43 @@ ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n }\n \n \n+ngx_int_t\n+ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder,\n+    ngx_uint_t depth)\n+{\n+    ngx_log_error(NGX_LOG_EMERG, ssl->log, 0,\n+                  \"\\\"ssl_ocsp\\\" is not supported on this platform\");\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,\n+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_validate(ngx_connection_t *c)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+ngx_int_t\n+ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)\n+{\n+    return NGX_OK;\n+}\n+\n+\n+void\n+ngx_ssl_ocsp_cleanup(ngx_connection_t *c)\n+{\n+}\n+\n+\n #endif\nDiff:\n@@ -74,6 +74,14 @@ static ngx_conf_enum_t  ngx_http_ssl_verify[] = {\n };\n \n \n+static ngx_conf_enum_t  ngx_http_ssl_ocsp[] = {\n+    { ngx_string(\"off\"), 0 },\n+    { ngx_string(\"on\"), 1 },\n+    { ngx_string(\"leaf\"), 2 },\n+    { ngx_null_string, 0 }\n+};\n+\n+\n static ngx_conf_deprecated_t  ngx_http_ssl_deprecated = {\n     ngx_conf_deprecated, \"ssl\", \"listen ... ssl\"\n };\n@@ -214,6 +222,20 @@ static ngx_command_t  ngx_http_ssl_commands[] = {\n       offsetof(ngx_http_ssl_srv_conf_t, crl),\n       NULL },\n \n+    { ngx_string(\"ssl_ocsp\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_enum_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, ocsp),\n+      &ngx_http_ssl_ocsp },\n+\n+    { ngx_string(\"ssl_ocsp_responder\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_str_slot,\n+      NGX_HTTP_SRV_CONF_OFFSET,\n+      offsetof(ngx_http_ssl_srv_conf_t, ocsp_responder),\n+      NULL },\n+\n     { ngx_string(\"ssl_stapling\"),\n       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,\n       ngx_conf_set_flag_slot,\n@@ -561,6 +583,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n      *     sscf->crl = { 0, NULL };\n      *     sscf->ciphers = { 0, NULL };\n      *     sscf->shm_zone = NULL;\n+     *     sscf->ocsp_responder = { 0, NULL };\n      *     sscf->stapling_file = { 0, NULL };\n      *     sscf->stapling_responder = { 0, NULL };\n      */\n@@ -578,6 +601,7 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)\n     sscf->session_timeout = NGX_CONF_UNSET;\n     sscf->session_tickets = NGX_CONF_UNSET;\n     sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;\n+    sscf->ocsp = NGX_CONF_UNSET_UINT;\n     sscf->stapling = NGX_CONF_UNSET;\n     sscf->stapling_verify = NGX_CONF_UNSET;\n \n@@ -641,6 +665,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);\n \n+    ngx_conf_merge_uint_value(conf->ocsp, prev->ocsp, 0);\n+    ngx_conf_merge_str_value(conf->ocsp_responder, prev->ocsp_responder, \"\");\n+\n     ngx_conf_merge_value(conf->stapling, prev->stapling, 0);\n     ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);\n     ngx_conf_merge_str_value(conf->stapling_file, prev->stapling_file, \"\");\n@@ -802,6 +829,22 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n         return NGX_CONF_ERROR;\n     }\n \n+    if (conf->ocsp) {\n+\n+        if (conf->verify == 3) {\n+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n+                          \"\\\"ssl_ocsp\\\" is incompatible with \"\n+                          \"\\\"ssl_verify_client optional_no_ca\\\"\");\n+            return NGX_CONF_ERROR;\n+        }\n+\n+        if (ngx_ssl_ocsp(cf, &conf->ssl, &conf->ocsp_responder, conf->ocsp)\n+            != NGX_OK)\n+        {\n+            return NGX_CONF_ERROR;\n+        }\n+    }\n+\n     if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {\n         return NGX_CONF_ERROR;\n     }\n@@ -1118,17 +1161,28 @@ ngx_http_ssl_init(ngx_conf_t *cf)\n \n         sscf = cscfp[s]->ctx->srv_conf[ngx_http_ssl_module.ctx_index];\n \n-        if (sscf->ssl.ctx == NULL || !sscf->stapling) {\n+        if (sscf->ssl.ctx == NULL) {\n             continue;\n         }\n \n         clcf = cscfp[s]->ctx->loc_conf[ngx_http_core_module.ctx_index];\n \n-        if (ngx_ssl_stapling_resolver(cf, &sscf->ssl, clcf->resolver,\n+        if (sscf->stapling) {\n+            if (ngx_ssl_stapling_resolver(cf, &sscf->ssl, clcf->resolver,\n+                                          clcf->resolver_timeout)\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n+        }\n+\n+        if (sscf->ocsp) {\n+            if (ngx_ssl_ocsp_resolver(cf, &sscf->ssl, clcf->resolver,\n                                       clcf->resolver_timeout)\n-            != NGX_OK)\n-        {\n-            return NGX_ERROR;\n+                != NGX_OK)\n+            {\n+                return NGX_ERROR;\n+            }\n         }\n     }\n \nDiff:\n@@ -54,6 +54,9 @@ typedef struct {\n     ngx_flag_t                      session_tickets;\n     ngx_array_t                    *session_ticket_keys;\n \n+    ngx_uint_t                      ocsp;\n+    ngx_str_t                       ocsp_responder;\n+\n     ngx_flag_t                      stapling;\n     ngx_flag_t                      stapling_verify;\n     ngx_str_t                       stapling_file;\nDiff:\n@@ -1993,6 +1993,7 @@ ngx_http_process_request(ngx_http_request_t *r)\n     if (r->http_connection->ssl) {\n         long                      rc;\n         X509                     *cert;\n+        const char               *s;\n         ngx_http_ssl_srv_conf_t  *sscf;\n \n         if (c->ssl == NULL) {\n@@ -2037,6 +2038,17 @@ ngx_http_process_request(ngx_http_request_t *r)\n \n                 X509_free(cert);\n             }\n+\n+            if (ngx_ssl_ocsp_get_status(c, &s) != NGX_OK) {\n+                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n+                              \"client SSL certificate verify error: %s\", s);\n+\n+                ngx_ssl_remove_cached_session(c->ssl->session_ctx,\n+                                       (SSL_get0_session(c->ssl->connection)));\n+\n+                ngx_http_finalize_request(r, NGX_HTTPS_CERT_ERROR);\n+                return;\n+            }\n         }\n     }\n \n",
        "analysis": "The newly added entire functions in the diff are:\n\n1. `ngx_ssl_ocsp(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder, ngx_uint_t depth)`\n2. `ngx_ssl_ocsp_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)`\n3. `ngx_ssl_ocsp_validate(ngx_connection_t *c)`\n4. `ngx_ssl_ocsp_validate_next(ngx_connection_t *c)`\n5. `ngx_ssl_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)`\n6. `ngx_ssl_ocsp_responder(ngx_connection_t *c, ngx_ssl_ocsp_ctx_t *ctx)`\n7. `ngx_ssl_ocsp_get_status(ngx_connection_t *c, const char **s)`\n8. `ngx_ssl_ocsp_cleanup(ngx_connection_t *c)`\n\nLet's analyze these functions line by line to search for potential out-of-bounds write vulnerabilities:\n\n1. **Function: `ngx_ssl_ocsp(...)`**\n   - Allocates memory for `ngx_ssl_ocsp_conf_t` and initializes various fields, including checking and parsing a URL.\n   - Sets extra SSL context data.\n   - No obvious out-of-bounds write issue is detected.\n\n2. **Function: `ngx_ssl_ocsp_resolver(...)`**\n   - Assigns resolver and timeout settings to an OCSP configuration object from SSL context.\n   - No buffer manipulation or dynamic memory usage, so unlikely to cause an out-of-bounds write.\n\n3. **Function: `ngx_ssl_ocsp_validate(...)`**\n   - Handles OCSP validation and involves SSL certificate operations.\n   - Uses `ngx_pcalloc` to allocate memory for `ngx_ssl_ocsp_t`.\n   - Relies heavily on OpenSSL/SSL function calls and context.\n   - Potentially recursive OCSP validation logic without size checks visible at a glance could pose risk, but difficult to directly link to an out-of-bounds write without further context.\n\n4. **Function: `ngx_ssl_ocsp_validate_next(...)`**\n   - Iterates over certificate chain elements.\n   - Uses a loop, but the logic appears bounded by the certificate count.\n   - Calls for more complex functions with network and cryptographic logic, but no clear buffer overflow risk without more insight into those functions.\n\n5. **Function: `ngx_ssl_ocsp_handler(...)`**\n   - Handles OCSP events at various stages.\n   - Uses SSL context data and checks conditions to execute handlers.\n   - Seems safe based on observed logic.\n\n6. **Function: `ngx_ssl_ocsp_responder(...)`**\n   - Handles parsing of OCSP responder URL from certificates.\n   - Makes copies of strings and checks their length, but relies on external SSL/OpenSSL functions.\n   - Memory copy operations `ngx_memcpy` could be dangerous if inputs are not properly validated earlier in external calls.\n\n7. **Function: `ngx_ssl_ocsp_get_status(...)`**\n   - Retrieves OCSP status and provides a text description.\n   - No buffer operations or complex memory handling that could lead to an out-of-bounds write risk.\n\n8. **Function: `ngx_ssl_ocsp_cleanup(...)`**\n   - Cleans up OCSP-specific allocations.\n   - Performs checks prior to freeing certificates and contexts.\n\nUpon reviewing the functions, the potentially suspicious function, primarily due to complexity and reliance on external SSL routines without obvious bounds checks, might be `ngx_ssl_ocsp_validate`. However, a definitive out-of-bounds write vulnerability isn't obvious from this diff alone.\n\nThus, given the newly added functions review, the output concerning potential out-of-bounds possibilities (if we were ever cautious about the `ngx_ssl_ocsp_validate` logic) would be:\n```\nTRUE [ngx_ssl_ocsp_validate]\n```"
    },
    {
        "commit_index": "Commit 22",
        "commit_diff": "Diff:\n@@ -22,6 +22,7 @@ typedef struct {\n     ngx_msec_t                   resolver_timeout;\n \n     ngx_addr_t                  *addrs;\n+    ngx_uint_t                   naddrs;\n     ngx_str_t                    host;\n     ngx_str_t                    uri;\n     in_port_t                    port;\n@@ -30,6 +31,7 @@ typedef struct {\n \n     X509                        *cert;\n     X509                        *issuer;\n+    STACK_OF(X509)              *chain;\n \n     u_char                      *name;\n \n@@ -44,12 +46,19 @@ typedef struct {\n typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;\n \n struct ngx_ssl_ocsp_ctx_s {\n+    SSL_CTX                     *ssl_ctx;\n+\n     X509                        *cert;\n     X509                        *issuer;\n+    STACK_OF(X509)              *chain;\n+\n+    int                          status;\n+    time_t                       valid;\n \n     u_char                      *name;\n \n     ngx_uint_t                   naddrs;\n+    ngx_uint_t                   naddr;\n \n     ngx_addr_t                  *addrs;\n     ngx_str_t                    host;\n@@ -74,7 +83,7 @@ struct ngx_ssl_ocsp_ctx_s {\n \n     ngx_uint_t                   code;\n     ngx_uint_t                   count;\n-\n+    ngx_uint_t                   flags;\n     ngx_uint_t                   done;\n \n     u_char                      *header_name_start;\n@@ -107,6 +116,7 @@ static void ngx_ssl_stapling_cleanup(void *data);\n \n static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);\n static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);\n+static void ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);\n static void ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve);\n static void ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx);\n@@ -120,6 +130,7 @@ static ngx_int_t ngx_ssl_ocsp_parse_status_line(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_process_headers(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);\n static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);\n+static ngx_int_t ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx);\n \n static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);\n \n@@ -173,6 +184,18 @@ ngx_ssl_stapling_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, X509 *cert,\n         return NGX_ERROR;\n     }\n \n+#ifdef SSL_CTRL_SELECT_CURRENT_CERT\n+    /* OpenSSL 1.0.2+ */\n+    SSL_CTX_select_current_cert(ssl->ctx, cert);\n+#endif\n+\n+#ifdef SSL_CTRL_GET_EXTRA_CHAIN_CERTS\n+    /* OpenSSL 1.0.1+ */\n+    SSL_CTX_get_extra_chain_certs(ssl->ctx, &staple->chain);\n+#else\n+    staple->chain = ssl->ctx->extra_certs;\n+#endif\n+\n     staple->ssl_ctx = ssl->ctx;\n     staple->timeout = 60000;\n     staple->verify = verify;\n@@ -289,29 +312,16 @@ ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     X509            *cert, *issuer;\n     X509_STORE      *store;\n     X509_STORE_CTX  *store_ctx;\n-    STACK_OF(X509)  *chain;\n \n     cert = staple->cert;\n \n-#ifdef SSL_CTRL_SELECT_CURRENT_CERT\n-    /* OpenSSL 1.0.2+ */\n-    SSL_CTX_select_current_cert(ssl->ctx, cert);\n-#endif\n-\n-#ifdef SSL_CTRL_GET_EXTRA_CHAIN_CERTS\n-    /* OpenSSL 1.0.1+ */\n-    SSL_CTX_get_extra_chain_certs(ssl->ctx, &chain);\n-#else\n-    chain = ssl->ctx->extra_certs;\n-#endif\n-\n-    n = sk_X509_num(chain);\n+    n = sk_X509_num(staple->chain);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,\n                    \"SSL get issuer: %d extra certs\", n);\n \n     for (i = 0; i < n; i++) {\n-        issuer = sk_X509_value(chain, i);\n+        issuer = sk_X509_value(staple->chain, i);\n         if (X509_check_issued(issuer, cert) == X509_V_OK) {\n #if OPENSSL_VERSION_NUMBER >= 0x10100001L\n             X509_up_ref(issuer);\n@@ -462,6 +472,7 @@ ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,\n     }\n \n     staple->addrs = u.addrs;\n+    staple->naddrs = u.naddrs;\n     staple->host = u.host;\n     staple->uri = u.uri;\n     staple->port = u.port;\n@@ -564,11 +575,15 @@ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)\n         return;\n     }\n \n+    ctx->ssl_ctx = staple->ssl_ctx;\n     ctx->cert = staple->cert;\n     ctx->issuer = staple->issuer;\n+    ctx->chain = staple->chain;\n     ctx->name = staple->name;\n+    ctx->flags = (staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY);\n \n     ctx->addrs = staple->addrs;\n+    ctx->naddrs = staple->naddrs;\n     ctx->host = staple->host;\n     ctx->uri = staple->uri;\n     ctx->port = staple->port;\n@@ -589,137 +604,27 @@ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)\n static void\n ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n {\n-    int                    n;\n-    size_t                 len;\n-    time_t                 now, valid;\n-    ngx_str_t              response;\n-    X509_STORE            *store;\n-    const u_char          *p;\n-    STACK_OF(X509)        *chain;\n-    OCSP_CERTID           *id;\n-    OCSP_RESPONSE         *ocsp;\n-    OCSP_BASICRESP        *basic;\n-    ngx_ssl_stapling_t    *staple;\n-    ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;\n+    time_t               now;\n+    ngx_str_t            response;\n+    ngx_ssl_stapling_t  *staple;\n \n     staple = ctx->data;\n     now = ngx_time();\n-    ocsp = NULL;\n-    basic = NULL;\n-    id = NULL;\n-\n-    if (ctx->code != 200) {\n-        goto error;\n-    }\n-\n-    /* check the response */\n-\n-    len = ctx->response->last - ctx->response->pos;\n-    p = ctx->response->pos;\n-\n-    ocsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n-    if (ocsp == NULL) {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"d2i_OCSP_RESPONSE() failed\");\n-        goto error;\n-    }\n-\n-    n = OCSP_response_status(ocsp);\n-\n-    if (n != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n-        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP response not successful (%d: %s)\",\n-                      n, OCSP_response_status_str(n));\n-        goto error;\n-    }\n-\n-    basic = OCSP_response_get1_basic(ocsp);\n-    if (basic == NULL) {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP_response_get1_basic() failed\");\n-        goto error;\n-    }\n-\n-    store = SSL_CTX_get_cert_store(staple->ssl_ctx);\n-    if (store == NULL) {\n-        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n-                      \"SSL_CTX_get_cert_store() failed\");\n-        goto error;\n-    }\n-\n-#ifdef SSL_CTRL_SELECT_CURRENT_CERT\n-    /* OpenSSL 1.0.2+ */\n-    SSL_CTX_select_current_cert(staple->ssl_ctx, ctx->cert);\n-#endif\n-\n-#ifdef SSL_CTRL_GET_EXTRA_CHAIN_CERTS\n-    /* OpenSSL 1.0.1+ */\n-    SSL_CTX_get_extra_chain_certs(staple->ssl_ctx, &chain);\n-#else\n-    chain = staple->ssl_ctx->extra_certs;\n-#endif\n-\n-    if (OCSP_basic_verify(basic, chain, store,\n-                          staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY)\n-        != 1)\n-    {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP_basic_verify() failed\");\n-        goto error;\n-    }\n-\n-    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);\n-    if (id == NULL) {\n-        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n-                      \"OCSP_cert_to_id() failed\");\n-        goto error;\n-    }\n \n-    if (OCSP_resp_find_status(basic, id, &n, NULL, NULL,\n-                              &thisupdate, &nextupdate)\n-        != 1)\n-    {\n-        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"certificate status not found in the OCSP response\");\n+    if (ngx_ssl_ocsp_verify(ctx) != NGX_OK) {\n         goto error;\n     }\n \n-    if (n != V_OCSP_CERTSTATUS_GOOD) {\n+    if (ctx->status != V_OCSP_CERTSTATUS_GOOD) {\n         ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n                       \"certificate status \\\"%s\\\" in the OCSP response\",\n-                      OCSP_cert_status_str(n));\n-        goto error;\n-    }\n-\n-    if (OCSP_check_validity(thisupdate, nextupdate, 300, -1) != 1) {\n-        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n-                      \"OCSP_check_validity() failed\");\n+                      OCSP_cert_status_str(ctx->status));\n         goto error;\n     }\n \n-    if (nextupdate) {\n-        valid = ngx_ssl_stapling_time(nextupdate);\n-        if (valid == (time_t) NGX_ERROR) {\n-            ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n-                          \"invalid nextUpdate time in certificate status\");\n-            goto error;\n-        }\n-\n-    } else {\n-        valid = NGX_MAX_TIME_T_VALUE;\n-    }\n-\n-    OCSP_CERTID_free(id);\n-    OCSP_BASICRESP_free(basic);\n-    OCSP_RESPONSE_free(ocsp);\n-\n-    id = NULL;\n-    basic = NULL;\n-    ocsp = NULL;\n-\n     /* copy the response to memory not in ctx->pool */\n \n-    response.len = len;\n+    response.len = ctx->response->last - ctx->response->pos;\n     response.data = ngx_alloc(response.len, ctx->log);\n \n     if (response.data == NULL) {\n@@ -728,24 +633,20 @@ ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n \n     ngx_memcpy(response.data, ctx->response->pos, response.len);\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n-                   \"ssl ocsp response, %s, %uz\",\n-                   OCSP_cert_status_str(n), response.len);\n-\n     if (staple->staple.data) {\n         ngx_free(staple->staple.data);\n     }\n \n     staple->staple = response;\n-    staple->valid = valid;\n+    staple->valid = ctx->valid;\n \n     /*\n      * refresh before the response expires,\n      * but not earlier than in 5 minutes, and at least in an hour\n      */\n \n     staple->loading = 0;\n-    staple->refresh = ngx_max(ngx_min(valid - 300, now + 3600), now + 300);\n+    staple->refresh = ngx_max(ngx_min(ctx->valid - 300, now + 3600), now + 300);\n \n     ngx_ssl_ocsp_done(ctx);\n     return;\n@@ -755,18 +656,6 @@ ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)\n     staple->loading = 0;\n     staple->refresh = now + 300;\n \n-    if (id) {\n-        OCSP_CERTID_free(id);\n-    }\n-\n-    if (basic) {\n-        OCSP_BASICRESP_free(basic);\n-    }\n-\n-    if (ocsp) {\n-        OCSP_RESPONSE_free(ocsp);\n-    }\n-\n     ngx_ssl_ocsp_done(ctx);\n }\n \n@@ -884,6 +773,36 @@ ngx_ssl_ocsp_error(ngx_ssl_ocsp_ctx_t *ctx)\n }\n \n \n+static void\n+ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp next\");\n+\n+    if (++ctx->naddr >= ctx->naddrs) {\n+        ngx_ssl_ocsp_error(ctx);\n+        return;\n+    }\n+\n+    ctx->request->pos = ctx->request->start;\n+\n+    if (ctx->response) {\n+        ctx->response->last = ctx->response->pos;\n+    }\n+\n+    if (ctx->peer.connection) {\n+        ngx_close_connection(ctx->peer.connection);\n+        ctx->peer.connection = NULL;\n+    }\n+\n+    ctx->state = 0;\n+    ctx->count = 0;\n+    ctx->done = 0;\n+\n+    ngx_ssl_ocsp_connect(ctx);\n+}\n+\n+\n static void\n ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx)\n {\n@@ -1022,16 +941,17 @@ ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve)\n static void\n ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)\n {\n-    ngx_int_t  rc;\n+    ngx_int_t    rc;\n+    ngx_addr_t  *addr;\n \n-    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n-                   \"ssl ocsp connect\");\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp connect %ui/%ui\", ctx->naddr, ctx->naddrs);\n \n-    /* TODO: use all ip addresses */\n+    addr = &ctx->addrs[ctx->naddr];\n \n-    ctx->peer.sockaddr = ctx->addrs[0].sockaddr;\n-    ctx->peer.socklen = ctx->addrs[0].socklen;\n-    ctx->peer.name = &ctx->addrs[0].name;\n+    ctx->peer.sockaddr = addr->sockaddr;\n+    ctx->peer.socklen = addr->socklen;\n+    ctx->peer.name = &addr->name;\n     ctx->peer.get = ngx_event_get_peer;\n     ctx->peer.log = ctx->log;\n     ctx->peer.log_error = NGX_ERROR_ERR;\n@@ -1041,11 +961,16 @@ ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)\n     ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n                    \"ssl ocsp connect peer done\");\n \n-    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {\n+    if (rc == NGX_ERROR) {\n         ngx_ssl_ocsp_error(ctx);\n         return;\n     }\n \n+    if (rc == NGX_BUSY || rc == NGX_DECLINED) {\n+        ngx_ssl_ocsp_next(ctx);\n+        return;\n+    }\n+\n     ctx->peer.connection->data = ctx;\n     ctx->peer.connection->pool = ctx->pool;\n \n@@ -1080,7 +1005,7 @@ ngx_ssl_ocsp_write_handler(ngx_event_t *wev)\n     if (wev->timedout) {\n         ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,\n                       \"OCSP responder timed out\");\n-        ngx_ssl_ocsp_error(ctx);\n+        ngx_ssl_ocsp_next(ctx);\n         return;\n     }\n \n@@ -1089,7 +1014,7 @@ ngx_ssl_ocsp_write_handler(ngx_event_t *wev)\n     n = ngx_send(c, ctx->request->pos, size);\n \n     if (n == NGX_ERROR) {\n-        ngx_ssl_ocsp_error(ctx);\n+        ngx_ssl_ocsp_next(ctx);\n         return;\n     }\n \n@@ -1134,7 +1059,7 @@ ngx_ssl_ocsp_read_handler(ngx_event_t *rev)\n     if (rev->timedout) {\n         ngx_log_error(NGX_LOG_ERR, rev->log, NGX_ETIMEDOUT,\n                       \"OCSP responder timed out\");\n-        ngx_ssl_ocsp_error(ctx);\n+        ngx_ssl_ocsp_next(ctx);\n         return;\n     }\n \n@@ -1158,7 +1083,7 @@ ngx_ssl_ocsp_read_handler(ngx_event_t *rev)\n             rc = ctx->process(ctx);\n \n             if (rc == NGX_ERROR) {\n-                ngx_ssl_ocsp_error(ctx);\n+                ngx_ssl_ocsp_next(ctx);\n                 return;\n             }\n \n@@ -1189,7 +1114,7 @@ ngx_ssl_ocsp_read_handler(ngx_event_t *rev)\n     ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n                   \"OCSP responder prematurely closed connection\");\n \n-    ngx_ssl_ocsp_error(ctx);\n+    ngx_ssl_ocsp_next(ctx);\n }\n \n \n@@ -1831,6 +1756,129 @@ ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx)\n }\n \n \n+static ngx_int_t\n+ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx)\n+{\n+    int                    n;\n+    size_t                 len;\n+    X509_STORE            *store;\n+    const u_char          *p;\n+    OCSP_CERTID           *id;\n+    OCSP_RESPONSE         *ocsp;\n+    OCSP_BASICRESP        *basic;\n+    ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;\n+\n+    ocsp = NULL;\n+    basic = NULL;\n+    id = NULL;\n+\n+    if (ctx->code != 200) {\n+        goto error;\n+    }\n+\n+    /* check the response */\n+\n+    len = ctx->response->last - ctx->response->pos;\n+    p = ctx->response->pos;\n+\n+    ocsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n+    if (ocsp == NULL) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"d2i_OCSP_RESPONSE() failed\");\n+        goto error;\n+    }\n+\n+    n = OCSP_response_status(ocsp);\n+\n+    if (n != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP response not successful (%d: %s)\",\n+                      n, OCSP_response_status_str(n));\n+        goto error;\n+    }\n+\n+    basic = OCSP_response_get1_basic(ocsp);\n+    if (basic == NULL) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP_response_get1_basic() failed\");\n+        goto error;\n+    }\n+\n+    store = SSL_CTX_get_cert_store(ctx->ssl_ctx);\n+    if (store == NULL) {\n+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n+                      \"SSL_CTX_get_cert_store() failed\");\n+        goto error;\n+    }\n+\n+    if (OCSP_basic_verify(basic, ctx->chain, store, ctx->flags) != 1) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP_basic_verify() failed\");\n+        goto error;\n+    }\n+\n+    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);\n+    if (id == NULL) {\n+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,\n+                      \"OCSP_cert_to_id() failed\");\n+        goto error;\n+    }\n+\n+    if (OCSP_resp_find_status(basic, id, &ctx->status, NULL, NULL,\n+                              &thisupdate, &nextupdate)\n+        != 1)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"certificate status not found in the OCSP response\");\n+        goto error;\n+    }\n+\n+    if (OCSP_check_validity(thisupdate, nextupdate, 300, -1) != 1) {\n+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,\n+                      \"OCSP_check_validity() failed\");\n+        goto error;\n+    }\n+\n+    if (nextupdate) {\n+        ctx->valid = ngx_ssl_stapling_time(nextupdate);\n+        if (ctx->valid == (time_t) NGX_ERROR) {\n+            ngx_log_error(NGX_LOG_ERR, ctx->log, 0,\n+                          \"invalid nextUpdate time in certificate status\");\n+            goto error;\n+        }\n+\n+    } else {\n+        ctx->valid = NGX_MAX_TIME_T_VALUE;\n+    }\n+\n+    OCSP_CERTID_free(id);\n+    OCSP_BASICRESP_free(basic);\n+    OCSP_RESPONSE_free(ocsp);\n+\n+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,\n+                   \"ssl ocsp response, %s, %uz\",\n+                   OCSP_cert_status_str(ctx->status), len);\n+\n+    return NGX_OK;\n+\n+error:\n+\n+    if (id) {\n+        OCSP_CERTID_free(id);\n+    }\n+\n+    if (basic) {\n+        OCSP_BASICRESP_free(basic);\n+    }\n+\n+    if (ocsp) {\n+        OCSP_RESPONSE_free(ocsp);\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n static u_char *\n ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len)\n {\nDiff:\n@@ -328,15 +328,6 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n \n     src = ctx->cookie;\n \n-    /*\n-     * we have to limit the encoded string to 22 characters because\n-     *  1) cookie may be marked by \"userid_mark\",\n-     *  2) and there are already the millions cookies with a garbage\n-     *     instead of the correct base64 trail \"==\"\n-     */\n-\n-    src.len = 22;\n-\n     dst.data = (u_char *) ctx->uid_got;\n \n     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\nDiff:\n@@ -2502,6 +2502,8 @@ ngx_http_upstream_test_next(ngx_http_request_t *r, ngx_http_upstream_t *u)\n         }\n \n #endif\n+\n+        break;\n     }\n \n #if (NGX_HTTP_CACHE)\n",
        "analysis": "The diff introduced two new functions: `ngx_ssl_ocsp_next` and `ngx_ssl_ocsp_verify`. Let's analyze each function for potential out-of-bounds write vulnerabilities. \n\n1. **Function: ngx_ssl_ocsp_next**\n\n```c\nstatic void ngx_ssl_ocsp_next(ngx_ssl_ocsp_ctx_t *ctx) {\n    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp next\");\n    \n    if (++ctx->naddr >= ctx->naddrs) {\n        ngx_ssl_ocsp_error(ctx);\n        return;\n    }\n    \n    ctx->request->pos = ctx->request->start;\n    \n    if (ctx->response) {\n        ctx->response->last = ctx->response->pos;\n    }\n    \n    if (ctx->peer.connection) {\n        ngx_close_connection(ctx->peer.connection);\n        ctx->peer.connection = NULL;\n    }\n    \n    ctx->state = 0;\n    ctx->count = 0;\n    ctx->done = 0;\n    \n    ngx_ssl_ocsp_connect(ctx);\n}\n```\n\n- **Analysis**: This function checks if `ctx->naddr` exceeds `ctx->naddrs` before proceeding, which seems to prevent out-of-bounds access to an array indexed by `naddr`. Other operations reset or nullify pointers, and then call `ngx_ssl_ocsp_connect(ctx)`, which uses `ctx->naddr` to index into `ctx->addrs`.\n\n2. **Function: ngx_ssl_ocsp_verify**\n\n```c\nstatic ngx_int_t ngx_ssl_ocsp_verify(ngx_ssl_ocsp_ctx_t *ctx) {\n    int n;\n    size_t len;\n    X509_STORE *store;\n    const u_char *p;\n    OCSP_CERTID *id;\n    OCSP_RESPONSE *ocsp;\n    OCSP_BASICRESP *basic;\n    ASN1_GENERALIZEDTIME *thisupdate, *nextupdate;\n\n    ocsp = NULL;\n    basic = NULL;\n    id = NULL;\n\n    if (ctx->code != 200) {\n        goto error;\n    }\n\n    /* check the response */\n\n    len = ctx->response->last - ctx->response->pos;\n    p = ctx->response->pos;\n\n    ocsp = d2i_OCSP_RESPONSE(NULL, &p, len);\n    if (ocsp == NULL) {\n        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0, \"d2i_OCSP_RESPONSE() failed\");\n        goto error;\n    }\n\n    n = OCSP_response_status(ocsp);\n\n    if (n != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n        ngx_log_error(NGX_LOG_ERR, ctx->log, 0, \"OCSP response not successful (%d: %s)\", n, OCSP_response_status_str(n));\n        goto error;\n    }\n\n    basic = OCSP_response_get1_basic(ocsp);\n    if (basic == NULL) {\n        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0, \"OCSP_response_get1_basic() failed\");\n        goto error;\n    }\n\n    store = SSL_CTX_get_cert_store(ctx->ssl_ctx);\n    if (store == NULL) {\n        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0, \"SSL_CTX_get_cert_store() failed\");\n        goto error;\n    }\n\n    if (OCSP_basic_verify(basic, ctx->chain, store, ctx->flags) != 1) {\n        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0, \"OCSP_basic_verify() failed\");\n        goto error;\n    }\n\n    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);\n    if (id == NULL) {\n        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0, \"OCSP_cert_to_id() failed\");\n        goto error;\n    }\n\n    if (OCSP_resp_find_status(basic, id, &ctx->status, NULL, NULL, &thisupdate, &nextupdate) != 1) {\n        ngx_log_error(NGX_LOG_ERR, ctx->log, 0, \"certificate status not found in the OCSP response\");\n        goto error;\n    }\n\n    if (OCSP_check_validity(thisupdate, nextupdate, 300, -1) != 1) {\n        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0, \"OCSP_check_validity() failed\");\n        goto error;\n    }\n\n    if (nextupdate) {\n        ctx->valid = ngx_ssl_stapling_time(nextupdate);\n        if (ctx->valid == (time_t) NGX_ERROR) {\n            ngx_log_error(NGX_LOG_ERR, ctx->log, 0, \"invalid nextUpdate time in certificate status\");\n            goto error;\n        }\n\n    } else {\n        ctx->valid = NGX_MAX_TIME_T_VALUE;\n    }\n\n    OCSP_CERTID_free(id);\n    OCSP_BASICRESP_free(basic);\n    OCSP_RESPONSE_free(ocsp);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0, \"ssl ocsp response, %s, %uz\", OCSP_cert_status_str(ctx->status), len);\n\n    return NGX_OK;\n\nerror:\n\n    if (id) {\n        OCSP_CERTID_free(id);\n    }\n\n    if (basic) {\n        OCSP_BASICRESP_free(basic);\n    }\n\n    if (ocsp) {\n        OCSP_RESPONSE_free(ocsp);\n    }\n\n    return NGX_ERROR;\n}\n```\n\n- **Analysis**: This function deals with OpenSSL OCSP response processing. It calculates `len` based on `ctx->response->last - ctx->response->pos`, which seems to ensure no out-of-bounds issues when parsing the OCSP. Numerous checks for allocation failures and openssl function's results are performed. No buffer indexed operations directly with user-controlled data without length checks were noticeable.\n\nIn conclusion for these two functions, there's no evident sign of out-of-bounds write vulnerability considering the current information and checks within functions. Both functions seem to handle operations cautiously with appropriate condition checks. \n\nResult: FALSE"
    },
    {
        "commit_index": "Commit 21",
        "commit_diff": "Diff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017010\n-#define NGINX_VERSION      \"1.17.10\"\n+#define nginx_version      1019000\n+#define NGINX_VERSION      \"1.19.0\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -120,6 +120,7 @@ typedef struct {\n     unsigned                   end_stream:1;\n     unsigned                   done:1;\n     unsigned                   status:1;\n+    unsigned                   rst:1;\n \n     ngx_http_request_t        *request;\n \n@@ -1205,6 +1206,7 @@ ngx_http_grpc_reinit_request(ngx_http_request_t *r)\n     ctx->end_stream = 0;\n     ctx->done = 0;\n     ctx->status = 0;\n+    ctx->rst = 0;\n     ctx->connection = NULL;\n \n     return NGX_OK;\n@@ -2088,7 +2090,10 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                 return NGX_ERROR;\n             }\n \n-            if (ctx->stream_id && ctx->done) {\n+            if (ctx->stream_id && ctx->done\n+                && ctx->type != NGX_HTTP_V2_RST_STREAM_FRAME\n+                && ctx->type != NGX_HTTP_V2_WINDOW_UPDATE_FRAME)\n+            {\n                 ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                               \"upstream sent frame for closed stream %ui\",\n                               ctx->stream_id);\n@@ -2131,11 +2136,21 @@ ngx_http_grpc_filter(void *data, ssize_t bytes)\n                 return NGX_ERROR;\n             }\n \n-            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n-                          \"upstream rejected request with error %ui\",\n-                          ctx->error);\n+            if (ctx->error || !ctx->done) {\n+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                              \"upstream rejected request with error %ui\",\n+                              ctx->error);\n+                return NGX_ERROR;\n+            }\n \n-            return NGX_ERROR;\n+            if (ctx->rst) {\n+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                              \"upstream sent frame for closed stream %ui\",\n+                              ctx->stream_id);\n+                return NGX_ERROR;\n+            }\n+\n+            ctx->rst = 1;\n         }\n \n         if (ctx->type == NGX_HTTP_V2_GOAWAY_FRAME) {\nDiff:\n@@ -1085,7 +1085,7 @@ ngx_http_variable_argument(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     len = name->len - (sizeof(\"arg_\") - 1);\n     arg = name->data + sizeof(\"arg_\") - 1;\n \n-    if (ngx_http_arg(r, arg, len, &value) != NGX_OK) {\n+    if (len == 0 || ngx_http_arg(r, arg, len, &value) != NGX_OK) {\n         v->not_found = 1;\n         return NGX_OK;\n     }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 20",
        "commit_diff": "Diff:\n@@ -448,3 +448,4 @@ de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n 5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\n+c44970de01474f6f3e01b0adea85ec1d03e3a5f2 release-1.17.10\nDiff:\n@@ -5,6 +5,20 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.10\" date=\"2020-04-14\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива auth_delay.\n+</para>\n+<para lang=\"en\">\n+the \"auth_delay\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.9\" date=\"2020-03-03\">\n \n <change type=\"change\">\nDiff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1d\n+OPENSSL =\topenssl-1.1.1f\n ZLIB =\t\tzlib-1.2.11\n PCRE =\t\tpcre-8.44\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 19",
        "commit_diff": "Diff:\n@@ -25,7 +25,6 @@ static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r,\n     ngx_str_t *passwd, ngx_str_t *realm);\n static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r,\n     ngx_str_t *realm);\n-static void ngx_http_auth_basic_close(ngx_file_t *file);\n static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf);\n static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf,\n     void *parent, void *child);\n@@ -177,8 +176,8 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n                           offset);\n \n         if (n == NGX_ERROR) {\n-            ngx_http_auth_basic_close(&file);\n-            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+            goto cleanup;\n         }\n \n         if (n == 0) {\n@@ -219,12 +218,11 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n                 if (buf[i] == LF || buf[i] == CR || buf[i] == ':') {\n                     buf[i] = '\\0';\n \n-                    ngx_http_auth_basic_close(&file);\n-\n                     pwd.len = i - passwd;\n                     pwd.data = &buf[passwd];\n \n-                    return ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+                    rc = ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+                    goto cleanup;\n                 }\n \n                 break;\n@@ -251,8 +249,6 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n         offset += n;\n     }\n \n-    ngx_http_auth_basic_close(&file);\n-\n     if (state == sw_passwd) {\n         pwd.len = i - passwd;\n         pwd.data = ngx_pnalloc(r->pool, pwd.len + 1);\n@@ -262,14 +258,26 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)\n \n         ngx_cpystrn(pwd.data, &buf[passwd], pwd.len + 1);\n \n-        return ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+        rc = ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);\n+        goto cleanup;\n     }\n \n     ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                   \"user \\\"%V\\\" was not found in \\\"%s\\\"\",\n                   &r->headers_in.user, user_file.data);\n \n-    return ngx_http_auth_basic_set_realm(r, &realm);\n+    rc = ngx_http_auth_basic_set_realm(r, &realm);\n+\n+cleanup:\n+\n+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {\n+        ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno,\n+                      ngx_close_file_n \" \\\"%s\\\" failed\", user_file.data);\n+    }\n+\n+    ngx_explicit_memzero(buf, NGX_HTTP_AUTH_BUF_SIZE);\n+\n+    return rc;\n }\n \n \n@@ -338,15 +346,6 @@ ngx_http_auth_basic_set_realm(ngx_http_request_t *r, ngx_str_t *realm)\n     return NGX_HTTP_UNAUTHORIZED;\n }\n \n-static void\n-ngx_http_auth_basic_close(ngx_file_t *file)\n-{\n-    if (ngx_close_file(file->fd) == NGX_FILE_ERROR) {\n-        ngx_log_error(NGX_LOG_ALERT, file->log, ngx_errno,\n-                      ngx_close_file_n \" \\\"%s\\\" failed\", file->name.data);\n-    }\n-}\n-\n \n static void *\n ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf)\nDiff:\n@@ -21,6 +21,9 @@ typedef struct {\n #define NGX_HTTP_REQUEST_BODY_FILE_CLEAN  2\n \n \n+static ngx_int_t ngx_http_core_auth_delay(ngx_http_request_t *r);\n+static void ngx_http_core_auth_delay_handler(ngx_http_request_t *r);\n+\n static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r);\n static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r,\n     ngx_http_location_tree_node_t *node);\n@@ -520,6 +523,13 @@ static ngx_command_t  ngx_http_core_commands[] = {\n       offsetof(ngx_http_core_loc_conf_t, satisfy),\n       &ngx_http_core_satisfy },\n \n+    { ngx_string(\"auth_delay\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n+      ngx_conf_set_msec_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_core_loc_conf_t, auth_delay),\n+      NULL },\n+\n     { ngx_string(\"internal\"),\n       NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,\n       ngx_http_core_internal,\n@@ -1124,6 +1134,10 @@ ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n \n     /* rc == NGX_ERROR || rc == NGX_HTTP_...  */\n \n+    if (rc == NGX_HTTP_UNAUTHORIZED) {\n+        return ngx_http_core_auth_delay(r);\n+    }\n+\n     ngx_http_finalize_request(r, rc);\n     return NGX_OK;\n }\n@@ -1141,12 +1155,17 @@ ngx_http_core_post_access_phase(ngx_http_request_t *r,\n     access_code = r->access_code;\n \n     if (access_code) {\n+        r->access_code = 0;\n+\n         if (access_code == NGX_HTTP_FORBIDDEN) {\n             ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                           \"access forbidden by rule\");\n         }\n \n-        r->access_code = 0;\n+        if (access_code == NGX_HTTP_UNAUTHORIZED) {\n+            return ngx_http_core_auth_delay(r);\n+        }\n+\n         ngx_http_finalize_request(r, access_code);\n         return NGX_OK;\n     }\n@@ -1156,6 +1175,65 @@ ngx_http_core_post_access_phase(ngx_http_request_t *r,\n }\n \n \n+static ngx_int_t\n+ngx_http_core_auth_delay(ngx_http_request_t *r)\n+{\n+    ngx_http_core_loc_conf_t  *clcf;\n+\n+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+\n+    if (clcf->auth_delay == 0) {\n+        ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);\n+        return NGX_OK;\n+    }\n+\n+    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                  \"delaying unauthorized request\");\n+\n+    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    r->read_event_handler = ngx_http_test_reading;\n+    r->write_event_handler = ngx_http_core_auth_delay_handler;\n+\n+    r->connection->write->delayed = 1;\n+    ngx_add_timer(r->connection->write, clcf->auth_delay);\n+\n+    /*\n+     * trigger an additional event loop iteration\n+     * to ensure constant-time processing\n+     */\n+\n+    ngx_post_event(r->connection->write, &ngx_posted_next_events);\n+\n+    return NGX_OK;\n+}\n+\n+\n+static void\n+ngx_http_core_auth_delay_handler(ngx_http_request_t *r)\n+{\n+    ngx_event_t  *wev;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                   \"auth delay handler\");\n+\n+    wev = r->connection->write;\n+\n+    if (wev->delayed) {\n+\n+        if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n+            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n+        }\n+\n+        return;\n+    }\n+\n+    ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);\n+}\n+\n+\n ngx_int_t\n ngx_http_core_content_phase(ngx_http_request_t *r,\n     ngx_http_phase_handler_t *ph)\n@@ -3394,6 +3472,7 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)\n     clcf->client_body_buffer_size = NGX_CONF_UNSET_SIZE;\n     clcf->client_body_timeout = NGX_CONF_UNSET_MSEC;\n     clcf->satisfy = NGX_CONF_UNSET_UINT;\n+    clcf->auth_delay = NGX_CONF_UNSET_MSEC;\n     clcf->if_modified_since = NGX_CONF_UNSET_UINT;\n     clcf->max_ranges = NGX_CONF_UNSET_UINT;\n     clcf->client_body_in_file_only = NGX_CONF_UNSET_UINT;\n@@ -3609,6 +3688,7 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n                                |NGX_HTTP_KEEPALIVE_DISABLE_MSIE6));\n     ngx_conf_merge_uint_value(conf->satisfy, prev->satisfy,\n                               NGX_HTTP_SATISFY_ALL);\n+    ngx_conf_merge_msec_value(conf->auth_delay, prev->auth_delay, 0);\n     ngx_conf_merge_uint_value(conf->if_modified_since, prev->if_modified_since,\n                               NGX_HTTP_IMS_EXACT);\n     ngx_conf_merge_uint_value(conf->max_ranges, prev->max_ranges,\nDiff:\n@@ -366,6 +366,7 @@ struct ngx_http_core_loc_conf_s {\n     ngx_msec_t    lingering_time;          /* lingering_time */\n     ngx_msec_t    lingering_timeout;       /* lingering_timeout */\n     ngx_msec_t    resolver_timeout;        /* resolver_timeout */\n+    ngx_msec_t    auth_delay;              /* auth_delay */\n \n     ngx_resolver_t  *resolver;             /* resolver */\n \n",
        "analysis": "The newly added entire functions are:\n\n1. `ngx_http_core_auth_delay(ngx_http_request_t *r)`\n2. `ngx_http_core_auth_delay_handler(ngx_http_request_t *r)`\n\nLet's analyze these functions separately.\n\n**Function: ngx_http_core_auth_delay**\n\n```c\nstatic ngx_int_t\nngx_http_core_auth_delay(ngx_http_request_t *r)\n{\n    ngx_http_core_loc_conf_t  *clcf;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->auth_delay == 0) {\n        ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  \"delaying unauthorized request\");\n\n    if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->read_event_handler = ngx_http_test_reading;\n    r->write_event_handler = ngx_http_core_auth_delay_handler;\n\n    r->connection->write->delayed = 1;\n    ngx_add_timer(r->connection->write, clcf->auth_delay);\n\n    /*\n     * trigger an additional event loop iteration\n     * to ensure constant-time processing\n     */\n\n    ngx_post_event(r->connection->write, &ngx_posted_next_events);\n\n    return NGX_OK;\n}\n```\n\n- **Line-by-line Analysis**:\n  - The function retrieves `auth_delay` from the configuration and sets handlers for read and write events.\n  - It checks if `auth_delay` is zero; if so, it finalizes the request with an unauthorized status.\n  - It sets up the event timer and handlers for the delay.\n  - There are no buffer manipulations or memory allocations that would suggest an out-of-bounds write in this function.\n\n**Function: ngx_http_core_auth_delay_handler**\n\n```c\nstatic void\nngx_http_core_auth_delay_handler(ngx_http_request_t *r)\n{\n    ngx_event_t  *wev;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"auth delay handler\");\n\n    wev = r->connection->write;\n\n    if (wev->delayed) {\n\n        if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n\n        return;\n    }\n\n    ngx_http_finalize_request(r, NGX_HTTP_UNAUTHORIZED);\n}\n```\n\n- **Line-by-line Analysis**:\n  - The function writes log messages and checks the `delayed` flag in the write event.\n  - If the event is delayed, it attempts to handle the write event; otherwise, it finalizes the request as unauthorized.\n  - Again, no dynamic memory access or buffer operations that would suggest an out-of-bounds write.\n\nAfter examining the two newly added functions, there is no apparent possibility of an out-of-bounds write. \n\nTherefore, based on the analysis, the decision is:\n\nFALSE"
    },
    {
        "commit_index": "Commit 18",
        "commit_diff": "Diff:\n@@ -447,3 +447,4 @@ ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\n+5e8d52bca714d4b85284ddb649d1ba4a3ca978a8 release-1.17.9\nDiff:\n@@ -5,6 +5,82 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.9\" date=\"2020-03-03\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь nginx не разрешает\n+несколько строк \"Host\" в заголовке запроса.\n+</para>\n+<para lang=\"en\">\n+now nginx does not allow\n+several \"Host\" request header lines.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx игнорировал дополнительные\n+строки \"Transfer-Encoding\" в заголовке запроса.\n+</para>\n+<para lang=\"en\">\n+nginx ignored additional\n+\"Transfer-Encoding\" request header lines.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+socket leak when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в рабочем процессе мог произойти segmentation fault,\n+если использовался OCSP stapling.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process\n+if OCSP stapling was used.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_mp4_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_mp4_module.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при перенаправлении ошибок с кодом 494 с помощью директивы error_page\n+nginx возвращал ответ с кодом 494 вместо 400.\n+</para>\n+<para lang=\"en\">\n+nginx used status code 494 instead of 400\n+if errors with code 494 were redirected with the \"error_page\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании подзапросов в модуле njs и директивы aio.\n+</para>\n+<para lang=\"en\">\n+socket leak when using subrequests in the njs module and the \"aio\" directive.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.8\" date=\"2020-01-21\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017009\n-#define NGINX_VERSION      \"1.17.9\"\n+#define nginx_version      1017010\n+#define NGINX_VERSION      \"1.17.10\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 17",
        "commit_diff": "Diff:\n@@ -8,7 +8,7 @@ CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n OPENSSL =\topenssl-1.1.1d\n ZLIB =\t\tzlib-1.2.11\n-PCRE =\t\tpcre-8.43\n+PCRE =\t\tpcre-8.44\n \n \n release: export\nDiff:\n@@ -4687,6 +4687,7 @@ ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n                 case NGX_HTTP_TO_HTTPS:\n                 case NGX_HTTPS_CERT_ERROR:\n                 case NGX_HTTPS_NO_CERT:\n+                case NGX_HTTP_REQUEST_HEADER_TOO_LARGE:\n                     err->overwrite = NGX_HTTP_BAD_REQUEST;\n             }\n         }\nDiff:\n@@ -2488,26 +2488,6 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n     }\n \n     if (r != r->main) {\n-        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-\n-        if (r->background) {\n-            if (!r->logged) {\n-                if (clcf->log_subrequest) {\n-                    ngx_http_log_request(r);\n-                }\n-\n-                r->logged = 1;\n-\n-            } else {\n-                ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n-                              \"subrequest: \\\"%V?%V\\\" logged again\",\n-                              &r->uri, &r->args);\n-            }\n-\n-            r->done = 1;\n-            ngx_http_finalize_connection(r);\n-            return;\n-        }\n \n         if (r->buffered || r->postponed) {\n \n@@ -2520,11 +2500,12 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n \n         pr = r->parent;\n \n-        if (r == c->data) {\n-\n-            r->main->count--;\n+        if (r == c->data || r->background) {\n \n             if (!r->logged) {\n+\n+                clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n+\n                 if (clcf->log_subrequest) {\n                     ngx_http_log_request(r);\n                 }\n@@ -2539,6 +2520,13 @@ ngx_http_finalize_request(ngx_http_request_t *r, ngx_int_t rc)\n \n             r->done = 1;\n \n+            if (r->background) {\n+                ngx_http_finalize_connection(r);\n+                return;\n+            }\n+\n+            r->main->count--;\n+\n             if (pr->postponed && pr->postponed->request == r) {\n                 pr->postponed = pr->postponed->next;\n             }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 16",
        "commit_diff": "Diff:\n@@ -3116,6 +3116,13 @@ ngx_http_mp4_update_stsz_atom(ngx_http_mp4_file_t *mp4,\n                        \"chunk samples sizes:%uL\",\n                        trak->start_chunk_samples_size);\n \n+        if (trak->start_chunk_samples_size > (uint64_t) mp4->end) {\n+            ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                          \"too large mp4 start samples size in \\\"%s\\\"\",\n+                          mp4->file.name.data);\n+            return NGX_ERROR;\n+        }\n+\n         if (mp4->length) {\n             if (trak->end_sample - trak->start_sample > entries) {\n                 ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n@@ -3135,6 +3142,13 @@ ngx_http_mp4_update_stsz_atom(ngx_http_mp4_file_t *mp4,\n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n                            \"mp4 stsz end_chunk_samples_size:%uL\",\n                            trak->end_chunk_samples_size);\n+\n+            if (trak->end_chunk_samples_size > (uint64_t) mp4->end) {\n+                ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                              \"too large mp4 end samples size in \\\"%s\\\"\",\n+                              mp4->file.name.data);\n+                return NGX_ERROR;\n+            }\n         }\n \n         atom_size = sizeof(ngx_mp4_stsz_atom_t) + (data->last - data->pos);\n@@ -3226,6 +3240,7 @@ ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,\n {\n     size_t                atom_size;\n     uint32_t              entries;\n+    uint64_t              chunk_offset, samples_size;\n     ngx_buf_t            *atom, *data;\n     ngx_mp4_stco_atom_t  *stco_atom;\n \n@@ -3256,8 +3271,19 @@ ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,\n \n     data->pos += trak->start_chunk * sizeof(uint32_t);\n \n-    trak->start_offset = ngx_mp4_get_32value(data->pos);\n-    trak->start_offset += trak->start_chunk_samples_size;\n+    chunk_offset = ngx_mp4_get_32value(data->pos);\n+    samples_size = trak->start_chunk_samples_size;\n+\n+    if (chunk_offset > (uint64_t) mp4->end - samples_size\n+        || chunk_offset + samples_size > NGX_MAX_UINT32_VALUE)\n+    {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"too large chunk offset in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    trak->start_offset = chunk_offset + samples_size;\n     ngx_mp4_set_32value(data->pos, trak->start_offset);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n@@ -3276,9 +3302,19 @@ ngx_http_mp4_update_stco_atom(ngx_http_mp4_file_t *mp4,\n         data->last = data->pos + entries * sizeof(uint32_t);\n \n         if (entries) {\n-            trak->end_offset =\n-                            ngx_mp4_get_32value(data->last - sizeof(uint32_t));\n-            trak->end_offset += trak->end_chunk_samples_size;\n+            chunk_offset = ngx_mp4_get_32value(data->last - sizeof(uint32_t));\n+            samples_size = trak->end_chunk_samples_size;\n+\n+            if (chunk_offset > (uint64_t) mp4->end - samples_size\n+                || chunk_offset + samples_size > NGX_MAX_UINT32_VALUE)\n+            {\n+                ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                              \"too large chunk offset in \\\"%s\\\"\",\n+                              mp4->file.name.data);\n+                return NGX_ERROR;\n+            }\n+\n+            trak->end_offset = chunk_offset + samples_size;\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n                            \"end chunk offset:%O\", trak->end_offset);\n@@ -3409,7 +3445,7 @@ ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,\n     ngx_http_mp4_trak_t *trak)\n {\n     size_t                atom_size;\n-    uint64_t              entries;\n+    uint64_t              entries, chunk_offset, samples_size;\n     ngx_buf_t            *atom, *data;\n     ngx_mp4_co64_atom_t  *co64_atom;\n \n@@ -3440,8 +3476,17 @@ ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,\n \n     data->pos += trak->start_chunk * sizeof(uint64_t);\n \n-    trak->start_offset = ngx_mp4_get_64value(data->pos);\n-    trak->start_offset += trak->start_chunk_samples_size;\n+    chunk_offset = ngx_mp4_get_64value(data->pos);\n+    samples_size = trak->start_chunk_samples_size;\n+\n+    if (chunk_offset > (uint64_t) mp4->end - samples_size) {\n+        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                      \"too large chunk offset in \\\"%s\\\"\",\n+                      mp4->file.name.data);\n+        return NGX_ERROR;\n+    }\n+\n+    trak->start_offset = chunk_offset + samples_size;\n     ngx_mp4_set_64value(data->pos, trak->start_offset);\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n@@ -3460,9 +3505,17 @@ ngx_http_mp4_update_co64_atom(ngx_http_mp4_file_t *mp4,\n         data->last = data->pos + entries * sizeof(uint64_t);\n \n         if (entries) {\n-            trak->end_offset =\n-                            ngx_mp4_get_64value(data->last - sizeof(uint64_t));\n-            trak->end_offset += trak->end_chunk_samples_size;\n+            chunk_offset = ngx_mp4_get_64value(data->last - sizeof(uint64_t));\n+            samples_size = trak->end_chunk_samples_size;\n+\n+            if (chunk_offset > (uint64_t) mp4->end - samples_size) {\n+                ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n+                              \"too large chunk offset in \\\"%s\\\"\",\n+                              mp4->file.name.data);\n+                return NGX_ERROR;\n+            }\n+\n+            trak->end_offset = chunk_offset + samples_size;\n \n             ngx_log_debug1(NGX_LOG_DEBUG_HTTP, mp4->file.log, 0,\n                            \"end chunk offset:%O\", trak->end_offset);\nDiff:\n@@ -2667,43 +2667,41 @@ ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r, ngx_addr_t *addr,\n     u_char *xff, size_t xfflen, ngx_array_t *proxies, int recursive)\n {\n     u_char      *p;\n-    ngx_int_t    rc;\n     ngx_addr_t   paddr;\n+    ngx_uint_t   found;\n \n-    if (ngx_cidr_match(addr->sockaddr, proxies) != NGX_OK) {\n-        return NGX_DECLINED;\n-    }\n+    found = 0;\n \n-    for (p = xff + xfflen - 1; p > xff; p--, xfflen--) {\n-        if (*p != ' ' && *p != ',') {\n-            break;\n-        }\n-    }\n+    do {\n \n-    for ( /* void */ ; p > xff; p--) {\n-        if (*p == ' ' || *p == ',') {\n-            p++;\n-            break;\n+        if (ngx_cidr_match(addr->sockaddr, proxies) != NGX_OK) {\n+            return found ? NGX_DONE : NGX_DECLINED;\n         }\n-    }\n-\n-    if (ngx_parse_addr_port(r->pool, &paddr, p, xfflen - (p - xff)) != NGX_OK) {\n-        return NGX_DECLINED;\n-    }\n \n-    *addr = paddr;\n+        for (p = xff + xfflen - 1; p > xff; p--, xfflen--) {\n+            if (*p != ' ' && *p != ',') {\n+                break;\n+            }\n+        }\n \n-    if (recursive && p > xff) {\n-        rc = ngx_http_get_forwarded_addr_internal(r, addr, xff, p - 1 - xff,\n-                                                  proxies, 1);\n+        for ( /* void */ ; p > xff; p--) {\n+            if (*p == ' ' || *p == ',') {\n+                p++;\n+                break;\n+            }\n+        }\n \n-        if (rc == NGX_DECLINED) {\n-            return NGX_DONE;\n+        if (ngx_parse_addr_port(r->pool, &paddr, p, xfflen - (p - xff))\n+            != NGX_OK)\n+        {\n+            return found ? NGX_DONE : NGX_DECLINED;\n         }\n \n-        /* rc == NGX_OK || rc == NGX_DONE  */\n-        return rc;\n-    }\n+        *addr = paddr;\n+        found = 1;\n+        xfflen = p - 1 - xff;\n+\n+    } while (recursive && p > xff);\n \n     return NGX_OK;\n }\nDiff:\n@@ -131,7 +131,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n \n     { ngx_string(\"Transfer-Encoding\"),\n                  offsetof(ngx_http_headers_in_t, transfer_encoding),\n-                 ngx_http_process_header_line },\n+                 ngx_http_process_unique_header_line },\n \n     { ngx_string(\"TE\"),\n                  offsetof(ngx_http_headers_in_t, te),\n@@ -748,6 +748,8 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n                 return;\n             }\n \n+            ngx_reusable_connection(c, 0);\n+\n             rc = ngx_ssl_handshake(c);\n \n             if (rc == NGX_AGAIN) {\n@@ -756,8 +758,6 @@ ngx_http_ssl_handshake(ngx_event_t *rev)\n                     ngx_add_timer(rev, c->listening->post_accept_timeout);\n                 }\n \n-                ngx_reusable_connection(c, 0);\n-\n                 c->ssl->handler = ngx_http_ssl_handshake_handler;\n                 return;\n             }\n@@ -1755,10 +1755,18 @@ ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_int_t  rc;\n     ngx_str_t  host;\n \n-    if (r->headers_in.host == NULL) {\n-        r->headers_in.host = h;\n+    if (r->headers_in.host) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate host header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.host->key,\n+                      &r->headers_in.host->value);\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n     }\n \n+    r->headers_in.host = h;\n+\n     host = h->value;\n \n     rc = ngx_http_validate_host(&host, r->pool, 0);\n@@ -1952,10 +1960,7 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n             r->headers_in.content_length_n = -1;\n             r->headers_in.chunked = 1;\n \n-        } else if (r->headers_in.transfer_encoding->value.len != 8\n-            || ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n-                               (u_char *) \"identity\", 8) != 0)\n-        {\n+        } else {\n             ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                           \"client sent unknown \\\"Transfer-Encoding\\\": \\\"%V\\\"\",\n                           &r->headers_in.transfer_encoding->value);\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 15",
        "commit_diff": "Diff:\n@@ -446,3 +446,4 @@ ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n 9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\n de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\n+fdacd273711ddf20f778c1fb91529ab53979a454 release-1.17.8\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017008\n-#define NGINX_VERSION      \"1.17.8\"\n+#define nginx_version      1017009\n+#define NGINX_VERSION      \"1.17.9\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1719,8 +1719,13 @@ ngx_http_v2_state_header_complete(ngx_http_v2_connection_t *h2c, u_char *pos,\n     ngx_http_v2_stream_t  *stream;\n \n     if (h2c->state.length) {\n-        h2c->state.handler = ngx_http_v2_state_header_block;\n-        return pos;\n+        if (end - pos > 0) {\n+            h2c->state.handler = ngx_http_v2_state_header_block;\n+            return pos;\n+        }\n+\n+        return ngx_http_v2_state_headers_save(h2c, pos, end,\n+                                              ngx_http_v2_state_header_block);\n     }\n \n     if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 14",
        "commit_diff": "Diff:\n@@ -5,6 +5,42 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.8\" date=\"2020-01-21\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива grpc_pass поддерживает переменные.\n+</para>\n+<para lang=\"en\">\n+variables support in the \"grpc_pass\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при обработке pipelined-запросов по SSL-соединению мог произойти таймаут;\n+ошибка появилась в 1.17.5.\n+</para>\n+<para lang=\"en\">\n+a timeout might occur while handling pipelined requests in an SSL connection;\n+the bug had appeared in 1.17.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве debug_points при использовании HTTP/2.<br/>\n+Спасибо Даниилу Бондареву.\n+</para>\n+<para lang=\"en\">\n+in the \"debug_points\" directive when using HTTP/2.<br/>\n+Thanks to Daniil Bondarev.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.7\" date=\"2019-12-24\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -27,6 +27,9 @@ typedef struct {\n     ngx_str_t                  host;\n     ngx_uint_t                 host_set;\n \n+    ngx_array_t               *grpc_lengths;\n+    ngx_array_t               *grpc_values;\n+\n #if (NGX_HTTP_SSL)\n     ngx_uint_t                 ssl;\n     ngx_uint_t                 ssl_protocols;\n@@ -119,6 +122,8 @@ typedef struct {\n     unsigned                   status:1;\n \n     ngx_http_request_t        *request;\n+\n+    ngx_str_t                  host;\n } ngx_http_grpc_ctx_t;\n \n \n@@ -135,6 +140,8 @@ typedef struct {\n } ngx_http_grpc_frame_t;\n \n \n+static ngx_int_t ngx_http_grpc_eval(ngx_http_request_t *r,\n+    ngx_http_grpc_ctx_t *ctx, ngx_http_grpc_loc_conf_t *glcf);\n static ngx_int_t ngx_http_grpc_create_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_grpc_reinit_request(ngx_http_request_t *r);\n static ngx_int_t ngx_http_grpc_body_output_filter(void *data, ngx_chain_t *in);\n@@ -524,23 +531,41 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n+    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_grpc_ctx_t));\n+    if (ctx == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    ctx->request = r;\n+\n+    ngx_http_set_ctx(r, ctx, ngx_http_grpc_module);\n+\n     glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);\n \n     u = r->upstream;\n \n+    if (glcf->grpc_lengths == NULL) {\n+        ctx->host = glcf->host;\n+\n #if (NGX_HTTP_SSL)\n-    u->ssl = (glcf->upstream.ssl != NULL);\n+        u->ssl = (glcf->upstream.ssl != NULL);\n \n-    if (u->ssl) {\n-        ngx_str_set(&u->schema, \"grpcs://\");\n+        if (u->ssl) {\n+            ngx_str_set(&u->schema, \"grpcs://\");\n \n-    } else {\n-        ngx_str_set(&u->schema, \"grpc://\");\n-    }\n+        } else {\n+            ngx_str_set(&u->schema, \"grpc://\");\n+        }\n #else\n-    ngx_str_set(&u->schema, \"grpc://\");\n+        ngx_str_set(&u->schema, \"grpc://\");\n #endif\n \n+    } else {\n+        if (ngx_http_grpc_eval(r, ctx, glcf) != NGX_OK) {\n+            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+    }\n+\n     u->output.tag = (ngx_buf_tag_t) &ngx_http_grpc_module;\n \n     u->conf = &glcf->upstream;\n@@ -551,15 +576,6 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n     u->abort_request = ngx_http_grpc_abort_request;\n     u->finalize_request = ngx_http_grpc_finalize_request;\n \n-    ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_grpc_ctx_t));\n-    if (ctx == NULL) {\n-        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n-    }\n-\n-    ctx->request = r;\n-\n-    ngx_http_set_ctx(r, ctx, ngx_http_grpc_module);\n-\n     u->input_filter_init = ngx_http_grpc_filter_init;\n     u->input_filter = ngx_http_grpc_filter;\n     u->input_filter_ctx = ctx;\n@@ -576,6 +592,103 @@ ngx_http_grpc_handler(ngx_http_request_t *r)\n }\n \n \n+static ngx_int_t\n+ngx_http_grpc_eval(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx,\n+    ngx_http_grpc_loc_conf_t *glcf)\n+{\n+    size_t                add;\n+    ngx_url_t             url;\n+    ngx_http_upstream_t  *u;\n+\n+    ngx_memzero(&url, sizeof(ngx_url_t));\n+\n+    if (ngx_http_script_run(r, &url.url, glcf->grpc_lengths->elts, 0,\n+                            glcf->grpc_values->elts)\n+        == NULL)\n+    {\n+        return NGX_ERROR;\n+    }\n+\n+    if (url.url.len > 7\n+        && ngx_strncasecmp(url.url.data, (u_char *) \"grpc://\", 7) == 0)\n+    {\n+        add = 7;\n+\n+    } else if (url.url.len > 8\n+               && ngx_strncasecmp(url.url.data, (u_char *) \"grpcs://\", 8) == 0)\n+    {\n+\n+#if (NGX_HTTP_SSL)\n+        add = 8;\n+        r->upstream->ssl = 1;\n+#else\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"grpcs protocol requires SSL support\");\n+        return NGX_ERROR;\n+#endif\n+\n+    } else {\n+        add = 0;\n+    }\n+\n+    u = r->upstream;\n+\n+    if (add) {\n+        u->schema.len = add;\n+        u->schema.data = url.url.data;\n+\n+        url.url.data += add;\n+        url.url.len -= add;\n+\n+    } else {\n+        ngx_str_set(&u->schema, \"grpc://\");\n+    }\n+\n+    url.no_resolve = 1;\n+\n+    if (ngx_parse_url(r->pool, &url) != NGX_OK) {\n+        if (url.err) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"%s in upstream \\\"%V\\\"\", url.err, &url.url);\n+        }\n+\n+        return NGX_ERROR;\n+    }\n+\n+    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));\n+    if (u->resolved == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (url.addrs) {\n+        u->resolved->sockaddr = url.addrs[0].sockaddr;\n+        u->resolved->socklen = url.addrs[0].socklen;\n+        u->resolved->name = url.addrs[0].name;\n+        u->resolved->naddrs = 1;\n+    }\n+\n+    u->resolved->host = url.host;\n+    u->resolved->port = url.port;\n+    u->resolved->no_port = url.no_port;\n+\n+    if (url.family != AF_UNIX) {\n+\n+        if (url.no_port) {\n+            ctx->host = url.host;\n+\n+        } else {\n+            ctx->host.len = url.host.len + 1 + url.port_text.len;\n+            ctx->host.data = url.host.data;\n+        }\n+\n+    } else {\n+        ngx_str_set(&ctx->host, \"localhost\");\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_grpc_create_request(ngx_http_request_t *r)\n {\n@@ -587,6 +700,7 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n     ngx_chain_t                  *cl, *body;\n     ngx_list_part_t              *part;\n     ngx_table_elt_t              *header;\n+    ngx_http_grpc_ctx_t          *ctx;\n     ngx_http_upstream_t          *u;\n     ngx_http_grpc_frame_t        *f;\n     ngx_http_script_code_pt       code;\n@@ -598,6 +712,8 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n \n     glcf = ngx_http_get_module_loc_conf(r, ngx_http_grpc_module);\n \n+    ctx = ngx_http_get_module_ctx(r, ngx_http_grpc_module);\n+\n     len = sizeof(ngx_http_grpc_connection_start) - 1\n           + sizeof(ngx_http_grpc_frame_t);             /* headers frame */\n \n@@ -637,10 +753,10 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n     /* :authority header */\n \n     if (!glcf->host_set) {\n-        len += 1 + NGX_HTTP_V2_INT_OCTETS + glcf->host.len;\n+        len += 1 + NGX_HTTP_V2_INT_OCTETS + ctx->host.len;\n \n-        if (tmp_len < glcf->host.len) {\n-            tmp_len = glcf->host.len;\n+        if (tmp_len < ctx->host.len) {\n+            tmp_len = ctx->host.len;\n         }\n     }\n \n@@ -785,7 +901,7 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n     }\n \n #if (NGX_HTTP_SSL)\n-    if (glcf->ssl) {\n+    if (u->ssl) {\n         *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_SCHEME_HTTPS_INDEX);\n \n         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n@@ -846,11 +962,11 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)\n \n     if (!glcf->host_set) {\n         *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_AUTHORITY_INDEX);\n-        b->last = ngx_http_v2_write_value(b->last, glcf->host.data,\n-                                          glcf->host.len, tmp);\n+        b->last = ngx_http_v2_write_value(b->last, ctx->host.data,\n+                                          ctx->host.len, tmp);\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"grpc header: \\\":authority: %V\\\"\", &glcf->host);\n+                       \"grpc header: \\\":authority: %V\\\"\", &ctx->host);\n     }\n \n     ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n@@ -4319,15 +4435,23 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n \n-    if (clcf->noname && conf->upstream.upstream == NULL) {\n+    if (clcf->noname\n+        && conf->upstream.upstream == NULL && conf->grpc_lengths == NULL)\n+    {\n         conf->upstream.upstream = prev->upstream.upstream;\n         conf->host = prev->host;\n+\n+        conf->grpc_lengths = prev->grpc_lengths;\n+        conf->grpc_values = prev->grpc_values;\n+\n #if (NGX_HTTP_SSL)\n         conf->upstream.ssl = prev->upstream.ssl;\n #endif\n     }\n \n-    if (clcf->lmt_excpt && clcf->handler == NULL && conf->upstream.upstream) {\n+    if (clcf->lmt_excpt && clcf->handler == NULL\n+        && (conf->upstream.upstream || conf->grpc_lengths))\n+    {\n         clcf->handler = ngx_http_grpc_handler;\n     }\n \n@@ -4537,18 +4661,54 @@ ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n {\n     ngx_http_grpc_loc_conf_t *glcf = conf;\n \n-    size_t                     add;\n-    ngx_str_t                 *value, *url;\n-    ngx_url_t                  u;\n-    ngx_http_core_loc_conf_t  *clcf;\n+    size_t                      add;\n+    ngx_str_t                  *value, *url;\n+    ngx_url_t                   u;\n+    ngx_uint_t                  n;\n+    ngx_http_core_loc_conf_t   *clcf;\n+    ngx_http_script_compile_t   sc;\n \n-    if (glcf->upstream.upstream) {\n+    if (glcf->upstream.upstream || glcf->grpc_lengths) {\n         return \"is duplicate\";\n     }\n \n+    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n+\n+    clcf->handler = ngx_http_grpc_handler;\n+\n+    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {\n+        clcf->auto_redirect = 1;\n+    }\n+\n     value = cf->args->elts;\n+\n     url = &value[1];\n \n+    n = ngx_http_script_variables_count(url);\n+\n+    if (n) {\n+\n+        ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));\n+\n+        sc.cf = cf;\n+        sc.source = url;\n+        sc.lengths = &glcf->grpc_lengths;\n+        sc.values = &glcf->grpc_values;\n+        sc.variables = n;\n+        sc.complete_lengths = 1;\n+        sc.complete_values = 1;\n+\n+        if (ngx_http_script_compile(&sc) != NGX_OK) {\n+            return NGX_CONF_ERROR;\n+        }\n+\n+#if (NGX_HTTP_SSL)\n+        glcf->ssl = 1;\n+#endif\n+\n+        return NGX_CONF_OK;\n+    }\n+\n     if (ngx_strncasecmp(url->data, (u_char *) \"grpc://\", 7) == 0) {\n         add = 7;\n \n@@ -4593,14 +4753,6 @@ ngx_http_grpc_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n         ngx_str_set(&glcf->host, \"localhost\");\n     }\n \n-    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n-\n-    clcf->handler = ngx_http_grpc_handler;\n-\n-    if (clcf->name.len && clcf->name.data[clcf->name.len - 1] == '/') {\n-        clcf->auto_redirect = 1;\n-    }\n-\n     return NGX_CONF_OK;\n }\n \nDiff:\n@@ -2466,10 +2466,6 @@ ngx_http_v2_connection_error(ngx_http_v2_connection_t *h2c,\n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                    \"http2 state connection error\");\n \n-    if (err == NGX_HTTP_V2_INTERNAL_ERROR) {\n-        ngx_debug_point();\n-    }\n-\n     ngx_http_v2_finalize_connection(h2c, err);\n \n     return NULL;\n",
        "analysis": "I have identified a newly added entire function in the provided diff. I will now analyze it line by line for any potential out-of-bounds write vulnerabilities.\n\nThe newly added function is `ngx_http_grpc_eval`.\n\n### Function Analysis: `ngx_http_grpc_eval`\n\n1. **Function Signature and Variable Declaration**:\n   ```c\n   static ngx_int_t ngx_http_grpc_eval(ngx_http_request_t *r, ngx_http_grpc_ctx_t *ctx, ngx_http_grpc_loc_conf_t *glcf)\n   ```\n   This function takes three parameters related to request handling in an HTTP/GRPC context.\n\n2. **Variable Initialization**:\n   ```c\n   size_t add;\n   ngx_url_t url;\n   ngx_http_upstream_t *u;\n   \n   ngx_memzero(&url, sizeof(ngx_url_t));\n   ```\n   Here, a URL structure is initialized with zero values, which is a safe practice to prevent garbage values.\n\n3. **Script Execution**:\n   ```c\n   if (ngx_http_script_run(r, &url.url, glcf->grpc_lengths->elts, 0, glcf->grpc_values->elts) == NULL)\n   {\n       return NGX_ERROR;\n   }\n   ```\n   This executes a script to populate the URL and checks if it is successful. Without deeper knowledge of `ngx_http_script_run`, it's hard to determine if it inherently checks bounds for `elts`.\n\n4. **Protocol Checking**:\n   ```c\n   if (url.url.len > 7\n       && ngx_strncasecmp(url.url.data, (u_char *) \"grpc://\", 7) == 0)\n   {\n       add = 7;\n   }\n   ```\n\n   The length is checked before accessing elements, which is good practice.\n\n5. **Protocol Processing**:\n   ```c\n   else if (url.url.len > 8\n            && ngx_strncasecmp(url.url.data, (u_char *) \"grpcs://\", 8) == 0)\n   {\n       #if (NGX_HTTP_SSL)\n       add = 8;\n       r->upstream->ssl = 1;\n       #else\n       ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, \"grpcs protocol requires SSL support\");\n       return NGX_ERROR;\n       #endif\n   }\n   ```\n\n   Safe as there's a conditional structure ensuring only valid indices are accessed.\n\n6. **Default Setting**:\n   ```c\n   else {\n       add = 0;\n   }\n   u = r->upstream;\n   ```\n\n   No out-of-bounds risk here.\n\n7. **Buffer Operations**:\n   ```c\n   if (add) {\n       u->schema.len = add;\n       u->schema.data = url.url.data;\n       url.url.data += add;\n       url.url.len -= add;\n   } else {\n       ngx_str_set(&u->schema, \"grpc://\");\n   }\n   ```\n\n   Careful handling of buffers is conducted here, though it's dependent on preceding logic and external functions (`ngx_parse_url`.\n\n8. **URL Parsing**:\n   ```c\n   if (ngx_parse_url(r->pool, &url) != NGX_OK) {\n       if (url.err) {\n           ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, \"%s in upstream \\\"%V\\\"\", url.err, &url.url);\n       }\n       return NGX_ERROR;\n   }\n   ```\n\n   If parsing fails, an error is logged, which seems safe if handled correctly.\n\n9. **Resolved Address Allocation**:\n   ```c\n   u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));\n   if (u->resolved == NULL) {\n       return NGX_ERROR;\n   }\n   ```\n\n   Dynamic allocation with check for NULL guards against basic overflow.\n\n10. **Address Buffers**:\n   Caution with data types and values is necessary but nothing suggests an immediate risk without further context.\n\n11. **Host Buffer Construction**:\n   ```c\n   if (url.family != AF_UNIX) {\n       if (url.no_port) {\n           ctx->host = url.host;\n       } else {\n           ctx->host.len = url.host.len + 1 + url.port_text.len;\n           ctx->host.data = url.host.data;\n       }\n   } else {\n       ngx_str_set(&ctx->host, \"localhost\");\n   }\n   ```\n\n   This appears to be vulnerable to off-by-one errors if lengths are not correctly constrained by prior logic.\n\nThe examination suggests that while most operations appear to handle lengths and memory safely, there are scenarios involving URL host length manipulations and protocol parsing that could introduce bugs, especially without understanding external function safety.\n\n**Conclusion:**\n\nGiven the complexity and reliance on external function calls, `ngx_http_grpc_eval` could have possible vulnerabilities under certain malicious inputs or incorrect assumptions about external function outputs. The off-by-one error is a potential risk due to manual adjustments on lengths without explicit checks.\n\n**Final Result:**\n\n```\nTRUE [ngx_http_grpc_eval]\n```"
    },
    {
        "commit_index": "Commit 13",
        "commit_diff": "Diff:\n@@ -238,6 +238,7 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     if (!ngx_queue_empty(&ngx_posted_next_events)) {\n+        ngx_event_move_posted_next(cycle);\n         timer = 0;\n     }\n \n@@ -261,7 +262,6 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     ngx_event_process_posted(cycle, &ngx_posted_events);\n-    ngx_event_process_posted_next(cycle, &ngx_posted_next_events);\n }\n \n \nDiff:\n@@ -2017,6 +2017,10 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n                         c->read->available = 0;\n                         c->read->ready = 0;\n \n+                        if (c->read->posted) {\n+                            ngx_delete_posted_event(c->read);\n+                        }\n+\n                         ngx_post_event(c->read, &ngx_posted_next_events);\n                     }\n \nDiff:\n@@ -37,26 +37,24 @@ ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted)\n \n \n void\n-ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted)\n+ngx_event_move_posted_next(ngx_cycle_t *cycle)\n {\n     ngx_queue_t  *q;\n     ngx_event_t  *ev;\n \n-    while (!ngx_queue_empty(posted)) {\n-\n-        q = ngx_queue_head(posted);\n+    for (q = ngx_queue_head(&ngx_posted_next_events);\n+         q != ngx_queue_sentinel(&ngx_posted_next_events);\n+         q = ngx_queue_next(q))\n+    {\n         ev = ngx_queue_data(q, ngx_event_t, queue);\n \n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                       \"posted next event %p\", ev);\n \n-        ngx_delete_posted_event(ev);\n-\n-        if (!ev->ready) {\n-            ev->ready = 1;\n-            ev->available = -1;\n-        }\n-\n-        ev->handler(ev);\n+        ev->ready = 1;\n+        ev->available = -1;\n     }\n+\n+    ngx_queue_add(&ngx_posted_events, &ngx_posted_next_events);\n+    ngx_queue_init(&ngx_posted_next_events);\n }\nDiff:\n@@ -39,7 +39,7 @@\n \n \n void ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted);\n-void ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted);\n+void ngx_event_move_posted_next(ngx_cycle_t *cycle);\n \n \n extern ngx_queue_t  ngx_posted_accept_events;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 12",
        "commit_diff": "Diff:\n@@ -27,7 +27,7 @@ was used in the configuration.\n или директивой proxy_pass с URI.\n </para>\n <para lang=\"en\">\n-a segmentation fault might occur in a worker process \n+a segmentation fault might occur in a worker process\n if the \"break\" directive was used with the \"alias\" directive\n or with the \"proxy_pass\" directive with a URI.\n </para>\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017007\n-#define NGINX_VERSION      \"1.17.7\"\n+#define nginx_version      1017008\n+#define NGINX_VERSION      \"1.17.8\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1889,7 +1889,7 @@ ngx_http_auth_basic_user(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    auth.len = ngx_base64_decoded_length(encoded.len);\n+    auth.len = NGX_HTTP_AUTH_MAX;\n     auth.data = ngx_pnalloc(r->pool, auth.len + 1);\n     if (auth.data == NULL) {\n         return NGX_ERROR;\nDiff:\n@@ -60,6 +60,9 @@ typedef struct ngx_thread_pool_s  ngx_thread_pool_t;\n #define NGX_HTTP_SERVER_TOKENS_BUILD    2\n \n \n+#define NGX_HTTP_AUTH_MAX               16\n+\n+\n typedef struct ngx_http_location_tree_node_s  ngx_http_location_tree_node_t;\n typedef struct ngx_http_core_loc_conf_s  ngx_http_core_loc_conf_t;\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 11",
        "commit_diff": "Diff:\n@@ -445,3 +445,4 @@ ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n 9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\n de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\n+e56295fe0ea76bf53b06bffa77a2d3a9a335cb8c release-1.17.7\nDiff:\n@@ -5,6 +5,90 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.7\" date=\"2019-12-24\">\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+на старте или во время переконфигурации мог произойти segmentation fault,\n+если в конфигурации использовалась\n+директива rewrite с пустой строкой замены.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur on start or during reconfiguration\n+if the \"rewrite\" directive with an empty replacement string\n+was used in the configuration.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в рабочем процессе мог произойти segmentation fault,\n+если директива break использовалась совместно с директивой alias\n+или директивой proxy_pass с URI.\n+</para>\n+<para lang=\"en\">\n+a segmentation fault might occur in a worker process \n+if the \"break\" directive was used with the \"alias\" directive\n+or with the \"proxy_pass\" directive with a URI.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+строка Location заголовка ответа могла содержать мусор,\n+если URI запроса был изменён на URI, содержащий нулевой символ.\n+</para>\n+<para lang=\"en\">\n+the \"Location\" response header line might contain garbage\n+if the request URI was rewritten to the one containing a null character.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при возврате перенаправлений с помощью директивы error_page\n+запросы с телом обрабатывались некорректно;\n+ошибка появилась в 0.7.12.\n+</para>\n+<para lang=\"en\">\n+requests with bodies were handled incorrectly\n+when returning redirections with the \"error_page\" directive;\n+the bug had appeared in 0.7.12.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+утечки сокетов при использовании HTTP/2.\n+</para>\n+<para lang=\"en\">\n+socket leak when using HTTP/2.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+при обработке pipelined-запросов по SSL-соединению мог произойти таймаут;\n+ошибка появилась в 1.17.5.\n+</para>\n+<para lang=\"en\">\n+a timeout might occur while handling pipelined requests in an SSL connection;\n+the bug had appeared in 1.17.5.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в модуле ngx_http_dav_module.\n+</para>\n+<para lang=\"en\">\n+in the ngx_http_dav_module.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.6\" date=\"2019-11-19\">\n \n <change type=\"feature\">\nDiff:\n@@ -238,8 +238,6 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     if (!ngx_queue_empty(&ngx_posted_next_events)) {\n-        ngx_queue_add(&ngx_posted_events, &ngx_posted_next_events);\n-        ngx_queue_init(&ngx_posted_next_events);\n         timer = 0;\n     }\n \n@@ -263,6 +261,7 @@ ngx_process_events_and_timers(ngx_cycle_t *cycle)\n     }\n \n     ngx_event_process_posted(cycle, &ngx_posted_events);\n+    ngx_event_process_posted_next(cycle, &ngx_posted_next_events);\n }\n \n \nDiff:\n@@ -43,7 +43,6 @@ static ssize_t ngx_ssl_recv_early(ngx_connection_t *c, u_char *buf,\n #endif\n static ngx_int_t ngx_ssl_handle_recv(ngx_connection_t *c, int n);\n static void ngx_ssl_write_handler(ngx_event_t *wev);\n-static void ngx_ssl_next_read_handler(ngx_event_t *rev);\n #ifdef SSL_READ_EARLY_DATA_SUCCESS\n static ssize_t ngx_ssl_write_early(ngx_connection_t *c, u_char *data,\n     size_t size);\n@@ -2018,11 +2017,6 @@ ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)\n                         c->read->available = 0;\n                         c->read->ready = 0;\n \n-                        if (c->ssl->next_read_handler == NULL) {\n-                            c->ssl->next_read_handler = c->read->handler;\n-                            c->read->handler = ngx_ssl_next_read_handler;\n-                        }\n-\n                         ngx_post_event(c->read, &ngx_posted_next_events);\n                     }\n \n@@ -2328,31 +2322,6 @@ ngx_ssl_write_handler(ngx_event_t *wev)\n }\n \n \n-static void\n-ngx_ssl_next_read_handler(ngx_event_t *rev)\n-{\n-    ngx_connection_t  *c;\n-\n-    c = rev->data;\n-\n-    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL next read handler\");\n-\n-    rev->handler = c->ssl->next_read_handler;\n-    c->ssl->next_read_handler = NULL;\n-\n-    if (!rev->ready) {\n-        rev->ready = 1;\n-        rev->available = -1;\n-    }\n-\n-    if (rev->posted) {\n-        ngx_delete_posted_event(rev);\n-    }\n-\n-    rev->handler(rev);\n-}\n-\n-\n /*\n  * OpenSSL has no SSL_writev() so we copy several bufs into our 16K buffer\n  * before the SSL_write() call to decrease a SSL overhead.\nDiff:\n@@ -86,7 +86,6 @@ struct ngx_ssl_connection_s {\n \n     ngx_event_handler_pt        saved_read_handler;\n     ngx_event_handler_pt        saved_write_handler;\n-    ngx_event_handler_pt        next_read_handler;\n \n     u_char                      early_buf;\n \nDiff:\n@@ -34,3 +34,29 @@ ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted)\n         ev->handler(ev);\n     }\n }\n+\n+\n+void\n+ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted)\n+{\n+    ngx_queue_t  *q;\n+    ngx_event_t  *ev;\n+\n+    while (!ngx_queue_empty(posted)) {\n+\n+        q = ngx_queue_head(posted);\n+        ev = ngx_queue_data(q, ngx_event_t, queue);\n+\n+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n+                      \"posted next event %p\", ev);\n+\n+        ngx_delete_posted_event(ev);\n+\n+        if (!ev->ready) {\n+            ev->ready = 1;\n+            ev->available = -1;\n+        }\n+\n+        ev->handler(ev);\n+    }\n+}\nDiff:\n@@ -39,6 +39,7 @@\n \n \n void ngx_event_process_posted(ngx_cycle_t *cycle, ngx_queue_t *posted);\n+void ngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted);\n \n \n extern ngx_queue_t  ngx_posted_accept_events;\n",
        "analysis": "The newly added entire function is `ngx_event_process_posted_next`. I will analyze it line by line for potential out-of-bounds write vulnerabilities.\n\n```c\nvoid\nngx_event_process_posted_next(ngx_cycle_t *cycle, ngx_queue_t *posted)\n{\n    ngx_queue_t  *q;\n    ngx_event_t  *ev;\n    \n    while (!ngx_queue_empty(posted)) {\n\n        q = ngx_queue_head(posted);\n        ev = ngx_queue_data(q, ngx_event_t, queue);\n        \n        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                      \"posted next event %p\", ev);\n        \n        ngx_delete_posted_event(ev);\n        \n        if (!ev->ready) {\n            ev->ready = 1;\n            ev->available = -1;\n        }\n        \n        ev->handler(ev);\n    }\n}\n```\n\n**Analysis:**\n\n- **Line 8**: A while loop checks if the `posted` queue is empty. There seems to be no direct buffer manipulation here that could cause out-of-bounds access.\n- **Line 10-12**: The code retrieves the head of the queue and converts it to an event structure. The function `ngx_queue_data` is used here for accessing structure data, which could lead to out-of-bounds issues if the associated queue functions are improperly implemented or used.\n- **Line 16**: Deletes the posted event from the queue. No apparent out-of-bounds write noted, assuming correct implementation of `ngx_delete_posted_event`.\n- **Line 18-22**: These lines check if the event is not ready and modify its `ready` and `available` fields. If the `ev` pointer is not correctly pointing to a valid event, this could potentially lead to out-of-bounds writing by modifying fields of an unexpected memory region. However, without more context on the handling and structure of `ngx_event_t`, it is unclear if there is a direct out-of-bounds risk here.\n- **Line 24**: Calls the event handler function, which depends on further implementation details. No direct out-of-bounds vulnerability is identifiable from this.\n\nConsidering the potential for indirect issues related to queue handling and event data management, there might be a possibility for an out-of-bounds write in extremely malicious scenarios. However, without further implementation details, it's challenging to confirm definitively.\n\n**Conclusion:** \n\nThere is a suspicion of potential out-of-bounds issues, primarily due to queue and event handling functions. Therefore, noting it as possibly suspicious.\n\n```plaintext\nTRUE [ngx_event_process_posted_next]\n```"
    },
    {
        "commit_index": "Commit 10",
        "commit_diff": "Diff:\n@@ -1,5 +1,5 @@\n .\\\"\n-.\\\" Copyright (C) 2010 Sergey A. Osokin\n+.\\\" Copyright (C) 2010, 2019 Sergey A. Osokin\n .\\\" Copyright (C) Nginx, Inc.\n .\\\" All rights reserved.\n .\\\"\n@@ -25,7 +25,7 @@\n .\\\" SUCH DAMAGE.\n .\\\"\n .\\\"\n-.Dd June 16, 2015\n+.Dd December 5, 2019\n .Dt NGINX 8\n .Os\n .Sh NAME\n@@ -42,7 +42,8 @@\n .Nm\n (pronounced\n .Dq engine x )\n-is an HTTP and reverse proxy server, as well as a mail proxy server.\n+is an HTTP and reverse proxy server, a mail proxy server, and a generic\n+TCP/UDP proxy server.\n It is known for its high performance, stability, rich feature set, simple\n configuration, and low resource consumption.\n .Pp\n@@ -82,15 +83,15 @@ The following table shows the corresponding system signals:\n .It Cm reload\n .Dv SIGHUP\n .El\n+.It Fl T\n+Same as\n+.Fl t ,\n+but additionally dump configuration files to standard output.\n .It Fl t\n Do not run, just test the configuration file.\n .Nm\n checks the configuration file syntax and then tries to open files\n referenced in the configuration file.\n-.It Fl T\n-Same as\n-.Fl t ,\n-but additionally dump configuration files to standard output.\n .It Fl V\n Print the\n .Nm\nDiff:\n@@ -312,7 +312,7 @@ ngx_http_dav_delete_handler(ngx_http_request_t *r)\n     ngx_file_info_t           fi;\n     ngx_http_dav_loc_conf_t  *dlcf;\n \n-    if (r->headers_in.content_length_n > 0) {\n+    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"DELETE with body is unsupported\");\n         return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n@@ -495,7 +495,7 @@ ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)\n     size_t     root;\n     ngx_str_t  path;\n \n-    if (r->headers_in.content_length_n > 0) {\n+    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"MKCOL with body is unsupported\");\n         return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n@@ -549,7 +549,9 @@ ngx_http_dav_copy_move_handler(ngx_http_request_t *r)\n     ngx_http_dav_copy_ctx_t   copy;\n     ngx_http_dav_loc_conf_t  *dlcf;\n \n-    if (r->headers_in.content_length_n > 0) {\n+    if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                      \"COPY and MOVE with body are unsupported\");\n         return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n     }\n \nDiff:\n@@ -178,6 +178,7 @@ static void ngx_http_v2_read_client_request_body_handler(ngx_http_request_t *r);\n static ngx_int_t ngx_http_v2_terminate_stream(ngx_http_v2_connection_t *h2c,\n     ngx_http_v2_stream_t *stream, ngx_uint_t status);\n static void ngx_http_v2_close_stream_handler(ngx_event_t *ev);\n+static void ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev);\n static void ngx_http_v2_handle_connection_handler(ngx_event_t *rev);\n static void ngx_http_v2_idle_handler(ngx_event_t *rev);\n static void ngx_http_v2_finalize_connection(ngx_http_v2_connection_t *h2c,\n@@ -4288,8 +4289,9 @@ ngx_http_v2_close_stream(ngx_http_v2_stream_t *stream, ngx_int_t rc)\n     fc = stream->request->connection;\n \n     if (stream->queued) {\n-        fc->write->handler = ngx_http_v2_close_stream_handler;\n-        fc->read->handler = ngx_http_empty_handler;\n+        fc->error = 1;\n+        fc->write->handler = ngx_http_v2_retry_close_stream_handler;\n+        fc->read->handler = ngx_http_v2_retry_close_stream_handler;\n         return;\n     }\n \n@@ -4411,6 +4413,22 @@ ngx_http_v2_close_stream_handler(ngx_event_t *ev)\n }\n \n \n+static void\n+ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev)\n+{\n+    ngx_connection_t    *fc;\n+    ngx_http_request_t  *r;\n+\n+    fc = ev->data;\n+    r = fc->data;\n+\n+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n+                   \"http2 retry close stream handler\");\n+\n+    ngx_http_v2_close_stream(r->stream, 0);\n+}\n+\n+\n static void\n ngx_http_v2_handle_connection_handler(ngx_event_t *rev)\n {\n",
        "analysis": "I will analyze the newly added function `ngx_http_v2_retry_close_stream_handler` line by line to check for possible out-of-bounds write vulnerabilities.\n\n```c\nstatic void\nngx_http_v2_retry_close_stream_handler(ngx_event_t *ev)\n{\n    ngx_connection_t    *fc;\n    ngx_http_request_t  *r;\n\n    fc = ev->data;\n    r = fc->data;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                   \"http2 retry close stream handler\");\n\n    ngx_http_v2_close_stream(r->stream, 0);\n}\n```\n\n1. `static void ngx_http_v2_retry_close_stream_handler(ngx_event_t *ev)`: This is the function definition and declaration indicating it takes a parameter of type `ngx_event_t *`.\n   \n2. `ngx_connection_t *fc; ngx_http_request_t *r;`: These lines declare pointers that will be used within the function.\n   \n3. `fc = ev->data;`: Assigns `ev->data` to `fc`. Based on the context, it's crucial to ensure that `ev->data` indeed points to a valid `ngx_connection_t` object.\n   \n4. `r = fc->data;`: Assigns `fc->data` to `r`. It's important to confirm `fc` is not null and that `fc->data` points to a valid `ngx_http_request_t`.\n   \n5. `ngx_log_debug0(NGX_LOG_DEBUG_HTTP, fc->log, 0, \"http2 retry close stream handler\");`: This logs a debug message and does not directly contribute to a buffer overflow risk.\n\n6. `ngx_http_v2_close_stream(r->stream, 0);`: This function is called with `r->stream` as an argument. The safety of this call depends on the implementation of `ngx_http_v2_close_stream`.\n\nFrom the lines of code within `ngx_http_v2_retry_close_stream_handler`, there are no apparent out-of-bounds write vulnerabilities. Given the information and typical patterns, care should be taken when checking that pointers like `fc` and `r` are valid and properly initialized before use, but for the code provided here, there is no suspicious vulnerability of out-of-bounds write.\n\nTherefore, the analysis is complete, and the function does not appear to contain an out-of-bounds write vulnerability.\n\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 9",
        "commit_diff": "Diff:\n@@ -318,6 +318,11 @@ ngx_http_rewrite(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n \n     value = cf->args->elts;\n \n+    if (value[2].len == 0) {\n+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"empty replacement\");\n+        return NGX_CONF_ERROR;\n+    }\n+\n     ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n \n     rc.pattern = value[1];\nDiff:\n@@ -1843,7 +1843,8 @@ ngx_http_map_uri_to_path(ngx_http_request_t *r, ngx_str_t *path,\n         }\n     }\n \n-    last = ngx_cpystrn(last, r->uri.data + alias, r->uri.len - alias + 1);\n+    last = ngx_copy(last, r->uri.data + alias, r->uri.len - alias);\n+    *last = '\\0';\n \n     return last;\n }\nDiff:\n@@ -623,6 +623,12 @@ ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n         return ngx_http_named_location(r, &uri);\n     }\n \n+    r->expect_tested = 1;\n+\n+    if (ngx_http_discard_request_body(r) != NGX_OK) {\n+        r->keepalive = 0;\n+    }\n+\n     location = ngx_list_push(&r->headers_out.headers);\n \n     if (location == NULL) {\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 8",
        "commit_diff": "Diff:\n@@ -56,7 +56,7 @@ static ngx_int_t ngx_http_dav_copy_tree_file(ngx_tree_ctx_t *ctx,\n static ngx_int_t ngx_http_dav_depth(ngx_http_request_t *r, ngx_int_t dflt);\n static ngx_int_t ngx_http_dav_error(ngx_log_t *log, ngx_err_t err,\n     ngx_int_t not_found, char *failed, u_char *path);\n-static ngx_int_t ngx_http_dav_location(ngx_http_request_t *r, u_char *path);\n+static ngx_int_t ngx_http_dav_location(ngx_http_request_t *r);\n static void *ngx_http_dav_create_loc_conf(ngx_conf_t *cf);\n static char *ngx_http_dav_merge_loc_conf(ngx_conf_t *cf,\n     void *parent, void *child);\n@@ -285,7 +285,7 @@ ngx_http_dav_put_handler(ngx_http_request_t *r)\n     }\n \n     if (status == NGX_HTTP_CREATED) {\n-        if (ngx_http_dav_location(r, path.data) != NGX_OK) {\n+        if (ngx_http_dav_location(r) != NGX_OK) {\n             ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n             return;\n         }\n@@ -520,9 +520,7 @@ ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)\n     if (ngx_create_dir(path.data, ngx_dir_access(dlcf->access))\n         != NGX_FILE_ERROR)\n     {\n-        *(p - 1) = '/';\n-\n-        if (ngx_http_dav_location(r, path.data) != NGX_OK) {\n+        if (ngx_http_dav_location(r) != NGX_OK) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n \n@@ -1070,35 +1068,16 @@ ngx_http_dav_error(ngx_log_t *log, ngx_err_t err, ngx_int_t not_found,\n \n \n static ngx_int_t\n-ngx_http_dav_location(ngx_http_request_t *r, u_char *path)\n+ngx_http_dav_location(ngx_http_request_t *r)\n {\n-    u_char                    *location;\n-    ngx_http_core_loc_conf_t  *clcf;\n-\n     r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n     if (r->headers_out.location == NULL) {\n         return NGX_ERROR;\n     }\n \n-    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n-\n-    if (!clcf->alias && clcf->root_lengths == NULL) {\n-        location = path + clcf->root.len;\n-\n-    } else {\n-        location = ngx_pnalloc(r->pool, r->uri.len);\n-        if (location == NULL) {\n-            ngx_http_clear_location(r);\n-            return NGX_ERROR;\n-        }\n-\n-        ngx_memcpy(location, r->uri.data, r->uri.len);\n-    }\n-\n     r->headers_out.location->hash = 1;\n     ngx_str_set(&r->headers_out.location->key, \"Location\");\n-    r->headers_out.location->value.len = r->uri.len;\n-    r->headers_out.location->value.data = location;\n+    r->headers_out.location->value = r->uri;\n \n     return NGX_OK;\n }\nDiff:\n@@ -163,7 +163,7 @@ ngx_http_index_handler(ngx_http_request_t *r)\n \n             name = ngx_http_map_uri_to_path(r, &path, &root, reserve);\n             if (name == NULL) {\n-                return NGX_ERROR;\n+                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n             }\n \n             allocated = path.data + path.len - name;\nDiff:\n@@ -157,8 +157,8 @@ ngx_http_static_handler(ngx_http_request_t *r)\n \n         len = r->uri.len + 1;\n \n-        if (!clcf->alias && clcf->root_lengths == NULL && r->args.len == 0) {\n-            location = path.data + clcf->root.len;\n+        if (!clcf->alias && r->args.len == 0) {\n+            location = path.data + root;\n \n             *last = '/';\n \nDiff:\n@@ -1477,7 +1477,14 @@ ngx_http_script_return_code(ngx_http_script_engine_t *e)\n void\n ngx_http_script_break_code(ngx_http_script_engine_t *e)\n {\n-    e->request->uri_changed = 0;\n+    ngx_http_request_t  *r;\n+\n+    r = e->request;\n+\n+    if (r->uri_changed) {\n+        r->valid_location = 0;\n+        r->uri_changed = 0;\n+    }\n \n     e->ip = ngx_http_script_exit;\n }\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 7",
        "commit_diff": "Diff:\n@@ -444,3 +444,4 @@ d2fd76709909767fc727a5b4affcf1dc9ca488a7 release-1.15.9\n ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n 9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\n+de68d0d94320cbf033599c6f3ca37e5335c67fd7 release-1.17.6\nDiff:\n@@ -5,6 +5,38 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.6\" date=\"2019-11-19\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные $proxy_protocol_server_addr и $proxy_protocol_server_port.\n+</para>\n+<para lang=\"en\">\n+the $proxy_protocol_server_addr and $proxy_protocol_server_port variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива limit_conn_dry_run.\n+</para>\n+<para lang=\"en\">\n+the \"limit_conn_dry_run\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные $limit_req_status и $limit_conn_status.\n+</para>\n+<para lang=\"en\">\n+the $limit_req_status and $limit_conn_status variables.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.5\" date=\"2019-10-22\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017006\n-#define NGINX_VERSION      \"1.17.6\"\n+#define nginx_version      1017007\n+#define NGINX_VERSION      \"1.17.7\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -513,14 +513,15 @@ ngx_http_dav_mkcol_handler(ngx_http_request_t *r, ngx_http_dav_loc_conf_t *dlcf)\n     }\n \n     *(p - 1) = '\\0';\n-    r->uri.len--;\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http mkcol path: \\\"%s\\\"\", path.data);\n \n     if (ngx_create_dir(path.data, ngx_dir_access(dlcf->access))\n         != NGX_FILE_ERROR)\n     {\n+        *(p - 1) = '/';\n+\n         if (ngx_http_dav_location(r, path.data) != NGX_OK) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\nDiff:\n@@ -275,6 +275,7 @@ ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc, void *data)\n \n     c->idle = 0;\n     c->sent = 0;\n+    c->data = NULL;\n     c->log = pc->log;\n     c->read->log = pc->log;\n     c->write->log = pc->log;\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 6",
        "commit_diff": "Diff:\n@@ -10,37 +10,49 @@\n #include <ngx_http.h>\n \n \n+#define NGX_HTTP_LIMIT_CONN_PASSED            1\n+#define NGX_HTTP_LIMIT_CONN_REJECTED          2\n+#define NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN  3\n+\n+\n typedef struct {\n-    u_char                     color;\n-    u_char                     len;\n-    u_short                    conn;\n-    u_char                     data[1];\n+    u_char                        color;\n+    u_char                        len;\n+    u_short                       conn;\n+    u_char                        data[1];\n } ngx_http_limit_conn_node_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t            *shm_zone;\n-    ngx_rbtree_node_t         *node;\n+    ngx_shm_zone_t               *shm_zone;\n+    ngx_rbtree_node_t            *node;\n } ngx_http_limit_conn_cleanup_t;\n \n \n typedef struct {\n-    ngx_rbtree_t              *rbtree;\n-    ngx_http_complex_value_t   key;\n+    ngx_rbtree_t                  rbtree;\n+    ngx_rbtree_node_t             sentinel;\n+} ngx_http_limit_conn_shctx_t;\n+\n+\n+typedef struct {\n+    ngx_http_limit_conn_shctx_t  *sh;\n+    ngx_slab_pool_t              *shpool;\n+    ngx_http_complex_value_t      key;\n } ngx_http_limit_conn_ctx_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t            *shm_zone;\n-    ngx_uint_t                 conn;\n+    ngx_shm_zone_t               *shm_zone;\n+    ngx_uint_t                    conn;\n } ngx_http_limit_conn_limit_t;\n \n \n typedef struct {\n-    ngx_array_t                limits;\n-    ngx_uint_t                 log_level;\n-    ngx_uint_t                 status_code;\n-    ngx_flag_t                 dry_run;\n+    ngx_array_t                   limits;\n+    ngx_uint_t                    log_level;\n+    ngx_uint_t                    status_code;\n+    ngx_flag_t                    dry_run;\n } ngx_http_limit_conn_conf_t;\n \n \n@@ -49,13 +61,16 @@ static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree,\n static void ngx_http_limit_conn_cleanup(void *data);\n static ngx_inline void ngx_http_limit_conn_cleanup_all(ngx_pool_t *pool);\n \n+static ngx_int_t ngx_http_limit_conn_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf);\n static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf, void *parent,\n     void *child);\n static char *ngx_http_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static ngx_int_t ngx_http_limit_conn_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf);\n \n \n@@ -115,7 +130,7 @@ static ngx_command_t  ngx_http_limit_conn_commands[] = {\n \n \n static ngx_http_module_t  ngx_http_limit_conn_module_ctx = {\n-    NULL,                                  /* preconfiguration */\n+    ngx_http_limit_conn_add_variables,     /* preconfiguration */\n     ngx_http_limit_conn_init,              /* postconfiguration */\n \n     NULL,                                  /* create main configuration */\n@@ -145,14 +160,29 @@ ngx_module_t  ngx_http_limit_conn_module = {\n };\n \n \n+static ngx_http_variable_t  ngx_http_limit_conn_vars[] = {\n+\n+    { ngx_string(\"limit_conn_status\"), NULL,\n+      ngx_http_limit_conn_status_variable, 0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n+\n+      ngx_http_null_variable\n+};\n+\n+\n+static ngx_str_t  ngx_http_limit_conn_status[] = {\n+    ngx_string(\"PASSED\"),\n+    ngx_string(\"REJECTED\"),\n+    ngx_string(\"REJECTED_DRY_RUN\")\n+};\n+\n+\n static ngx_int_t\n ngx_http_limit_conn_handler(ngx_http_request_t *r)\n {\n     size_t                          n;\n     uint32_t                        hash;\n     ngx_str_t                       key;\n     ngx_uint_t                      i;\n-    ngx_slab_pool_t                *shpool;\n     ngx_rbtree_node_t              *node;\n     ngx_pool_cleanup_t             *cln;\n     ngx_http_limit_conn_ctx_t      *ctx;\n@@ -161,7 +191,7 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n     ngx_http_limit_conn_limit_t    *limits;\n     ngx_http_limit_conn_cleanup_t  *lccln;\n \n-    if (r->main->limit_conn_set) {\n+    if (r->main->limit_conn_status) {\n         return NGX_DECLINED;\n     }\n \n@@ -187,32 +217,34 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n             continue;\n         }\n \n-        r->main->limit_conn_set = 1;\n+        r->main->limit_conn_status = NGX_HTTP_LIMIT_CONN_PASSED;\n \n         hash = ngx_crc32_short(key.data, key.len);\n \n-        shpool = (ngx_slab_pool_t *) limits[i].shm_zone->shm.addr;\n-\n-        ngx_shmtx_lock(&shpool->mutex);\n+        ngx_shmtx_lock(&ctx->shpool->mutex);\n \n-        node = ngx_http_limit_conn_lookup(ctx->rbtree, &key, hash);\n+        node = ngx_http_limit_conn_lookup(&ctx->sh->rbtree, &key, hash);\n \n         if (node == NULL) {\n \n             n = offsetof(ngx_rbtree_node_t, color)\n                 + offsetof(ngx_http_limit_conn_node_t, data)\n                 + key.len;\n \n-            node = ngx_slab_alloc_locked(shpool, n);\n+            node = ngx_slab_alloc_locked(ctx->shpool, n);\n \n             if (node == NULL) {\n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n                 ngx_http_limit_conn_cleanup_all(r->pool);\n \n                 if (lccf->dry_run) {\n+                    r->main->limit_conn_status =\n+                                          NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                r->main->limit_conn_status = NGX_HTTP_LIMIT_CONN_REJECTED;\n+\n                 return lccf->status_code;\n             }\n \n@@ -223,15 +255,15 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n             lc->conn = 1;\n             ngx_memcpy(lc->data, key.data, key.len);\n \n-            ngx_rbtree_insert(ctx->rbtree, node);\n+            ngx_rbtree_insert(&ctx->sh->rbtree, node);\n \n         } else {\n \n             lc = (ngx_http_limit_conn_node_t *) &node->color;\n \n             if ((ngx_uint_t) lc->conn >= limits[i].conn) {\n \n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, r->connection->log, 0,\n                               \"limiting connections%s by zone \\\"%V\\\"\",\n@@ -241,9 +273,13 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n                 ngx_http_limit_conn_cleanup_all(r->pool);\n \n                 if (lccf->dry_run) {\n+                    r->main->limit_conn_status =\n+                                          NGX_HTTP_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                r->main->limit_conn_status = NGX_HTTP_LIMIT_CONN_REJECTED;\n+\n                 return lccf->status_code;\n             }\n \n@@ -253,7 +289,7 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"limit conn: %08Xi %d\", node->key, lc->conn);\n \n-        ngx_shmtx_unlock(&shpool->mutex);\n+        ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n         cln = ngx_pool_cleanup_add(r->pool,\n                                    sizeof(ngx_http_limit_conn_cleanup_t));\n@@ -357,29 +393,27 @@ ngx_http_limit_conn_cleanup(void *data)\n {\n     ngx_http_limit_conn_cleanup_t  *lccln = data;\n \n-    ngx_slab_pool_t             *shpool;\n     ngx_rbtree_node_t           *node;\n     ngx_http_limit_conn_ctx_t   *ctx;\n     ngx_http_limit_conn_node_t  *lc;\n \n     ctx = lccln->shm_zone->data;\n-    shpool = (ngx_slab_pool_t *) lccln->shm_zone->shm.addr;\n     node = lccln->node;\n     lc = (ngx_http_limit_conn_node_t *) &node->color;\n \n-    ngx_shmtx_lock(&shpool->mutex);\n+    ngx_shmtx_lock(&ctx->shpool->mutex);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, lccln->shm_zone->shm.log, 0,\n                    \"limit conn cleanup: %08Xi %d\", node->key, lc->conn);\n \n     lc->conn--;\n \n     if (lc->conn == 0) {\n-        ngx_rbtree_delete(ctx->rbtree, node);\n-        ngx_slab_free_locked(shpool, node);\n+        ngx_rbtree_delete(&ctx->sh->rbtree, node);\n+        ngx_slab_free_locked(ctx->shpool, node);\n     }\n \n-    ngx_shmtx_unlock(&shpool->mutex);\n+    ngx_shmtx_unlock(&ctx->shpool->mutex);\n }\n \n \n@@ -405,8 +439,6 @@ ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n     ngx_http_limit_conn_ctx_t  *octx = data;\n \n     size_t                      len;\n-    ngx_slab_pool_t            *shpool;\n-    ngx_rbtree_node_t          *sentinel;\n     ngx_http_limit_conn_ctx_t  *ctx;\n \n     ctx = shm_zone->data;\n@@ -425,48 +457,63 @@ ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n             return NGX_ERROR;\n         }\n \n-        ctx->rbtree = octx->rbtree;\n+        ctx->sh = octx->sh;\n+        ctx->shpool = octx->shpool;\n \n         return NGX_OK;\n     }\n \n-    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n \n     if (shm_zone->shm.exists) {\n-        ctx->rbtree = shpool->data;\n+        ctx->sh = ctx->shpool->data;\n \n         return NGX_OK;\n     }\n \n-    ctx->rbtree = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_t));\n-    if (ctx->rbtree == NULL) {\n+    ctx->sh = ngx_slab_alloc(ctx->shpool, sizeof(ngx_http_limit_conn_shctx_t));\n+    if (ctx->sh == NULL) {\n         return NGX_ERROR;\n     }\n \n-    shpool->data = ctx->rbtree;\n+    ctx->shpool->data = ctx->sh;\n \n-    sentinel = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_node_t));\n-    if (sentinel == NULL) {\n-        return NGX_ERROR;\n-    }\n-\n-    ngx_rbtree_init(ctx->rbtree, sentinel,\n+    ngx_rbtree_init(&ctx->sh->rbtree, &ctx->sh->sentinel,\n                     ngx_http_limit_conn_rbtree_insert_value);\n \n     len = sizeof(\" in limit_conn_zone \\\"\\\"\") + shm_zone->shm.name.len;\n \n-    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n-    if (shpool->log_ctx == NULL) {\n+    ctx->shpool->log_ctx = ngx_slab_alloc(ctx->shpool, len);\n+    if (ctx->shpool->log_ctx == NULL) {\n         return NGX_ERROR;\n     }\n \n-    ngx_sprintf(shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n+    ngx_sprintf(ctx->shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n                 &shm_zone->shm.name);\n \n     return NGX_OK;\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_conn_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    if (r->main->limit_conn_status == 0) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->len = ngx_http_limit_conn_status[r->main->limit_conn_status - 1].len;\n+    v->data = ngx_http_limit_conn_status[r->main->limit_conn_status - 1].data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static void *\n ngx_http_limit_conn_create_conf(ngx_conf_t *cf)\n {\n@@ -673,6 +720,25 @@ ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_conn_add_variables(ngx_conf_t *cf)\n+{\n+    ngx_http_variable_t  *var, *v;\n+\n+    for (v = ngx_http_limit_conn_vars; v->name.len; v++) {\n+        var = ngx_http_add_variable(cf, &v->name, v->flags);\n+        if (var == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        var->get_handler = v->get_handler;\n+        var->data = v->data;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_limit_conn_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -512,7 +512,7 @@ struct ngx_http_request_s {\n      * ngx_http_limit_conn_module and ngx_http_limit_req_module\n      * we use the bit fields in the request structure\n      */\n-    unsigned                          limit_conn_set:1;\n+    unsigned                          limit_conn_status:2;\n     unsigned                          limit_req_status:3;\n \n     unsigned                          limit_rate_set:1;\nDiff:\n@@ -226,6 +226,8 @@ struct ngx_stream_session_s {\n     unsigned                       stat_processing:1;\n \n     unsigned                       health_check:1;\n+\n+    unsigned                       limit_conn_status:2;\n };\n \n \nDiff:\n@@ -10,36 +10,48 @@\n #include <ngx_stream.h>\n \n \n+#define NGX_STREAM_LIMIT_CONN_PASSED            1\n+#define NGX_STREAM_LIMIT_CONN_REJECTED          2\n+#define NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN  3\n+\n+\n typedef struct {\n-    u_char                       color;\n-    u_char                       len;\n-    u_short                      conn;\n-    u_char                       data[1];\n+    u_char                          color;\n+    u_char                          len;\n+    u_short                         conn;\n+    u_char                          data[1];\n } ngx_stream_limit_conn_node_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t              *shm_zone;\n-    ngx_rbtree_node_t           *node;\n+    ngx_shm_zone_t                 *shm_zone;\n+    ngx_rbtree_node_t              *node;\n } ngx_stream_limit_conn_cleanup_t;\n \n \n typedef struct {\n-    ngx_rbtree_t                *rbtree;\n-    ngx_stream_complex_value_t   key;\n+    ngx_rbtree_t                    rbtree;\n+    ngx_rbtree_node_t               sentinel;\n+} ngx_stream_limit_conn_shctx_t;\n+\n+\n+typedef struct {\n+    ngx_stream_limit_conn_shctx_t  *sh;\n+    ngx_slab_pool_t                *shpool;\n+    ngx_stream_complex_value_t      key;\n } ngx_stream_limit_conn_ctx_t;\n \n \n typedef struct {\n-    ngx_shm_zone_t              *shm_zone;\n-    ngx_uint_t                   conn;\n+    ngx_shm_zone_t                 *shm_zone;\n+    ngx_uint_t                      conn;\n } ngx_stream_limit_conn_limit_t;\n \n \n typedef struct {\n-    ngx_array_t                  limits;\n-    ngx_uint_t                   log_level;\n-    ngx_flag_t                   dry_run;\n+    ngx_array_t                     limits;\n+    ngx_uint_t                      log_level;\n+    ngx_flag_t                      dry_run;\n } ngx_stream_limit_conn_conf_t;\n \n \n@@ -48,13 +60,16 @@ static ngx_rbtree_node_t *ngx_stream_limit_conn_lookup(ngx_rbtree_t *rbtree,\n static void ngx_stream_limit_conn_cleanup(void *data);\n static ngx_inline void ngx_stream_limit_conn_cleanup_all(ngx_pool_t *pool);\n \n+static ngx_int_t ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data);\n static void *ngx_stream_limit_conn_create_conf(ngx_conf_t *cf);\n static char *ngx_stream_limit_conn_merge_conf(ngx_conf_t *cf, void *parent,\n     void *child);\n static char *ngx_stream_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_stream_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static ngx_int_t ngx_stream_limit_conn_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_stream_limit_conn_init(ngx_conf_t *cf);\n \n \n@@ -102,7 +117,7 @@ static ngx_command_t  ngx_stream_limit_conn_commands[] = {\n \n \n static ngx_stream_module_t  ngx_stream_limit_conn_module_ctx = {\n-    NULL,                                  /* preconfiguration */\n+    ngx_stream_limit_conn_add_variables,   /* preconfiguration */\n     ngx_stream_limit_conn_init,            /* postconfiguration */\n \n     NULL,                                  /* create main configuration */\n@@ -129,14 +144,29 @@ ngx_module_t  ngx_stream_limit_conn_module = {\n };\n \n \n+static ngx_stream_variable_t  ngx_stream_limit_conn_vars[] = {\n+\n+    { ngx_string(\"limit_conn_status\"), NULL,\n+      ngx_stream_limit_conn_status_variable, 0, NGX_STREAM_VAR_NOCACHEABLE, 0 },\n+\n+      ngx_stream_null_variable\n+};\n+\n+\n+static ngx_str_t  ngx_stream_limit_conn_status[] = {\n+    ngx_string(\"PASSED\"),\n+    ngx_string(\"REJECTED\"),\n+    ngx_string(\"REJECTED_DRY_RUN\")\n+};\n+\n+\n static ngx_int_t\n ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n {\n     size_t                            n;\n     uint32_t                          hash;\n     ngx_str_t                         key;\n     ngx_uint_t                        i;\n-    ngx_slab_pool_t                  *shpool;\n     ngx_rbtree_node_t                *node;\n     ngx_pool_cleanup_t               *cln;\n     ngx_stream_limit_conn_ctx_t      *ctx;\n@@ -167,30 +197,34 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n             continue;\n         }\n \n-        hash = ngx_crc32_short(key.data, key.len);\n+        s->limit_conn_status = NGX_STREAM_LIMIT_CONN_PASSED;\n \n-        shpool = (ngx_slab_pool_t *) limits[i].shm_zone->shm.addr;\n+        hash = ngx_crc32_short(key.data, key.len);\n \n-        ngx_shmtx_lock(&shpool->mutex);\n+        ngx_shmtx_lock(&ctx->shpool->mutex);\n \n-        node = ngx_stream_limit_conn_lookup(ctx->rbtree, &key, hash);\n+        node = ngx_stream_limit_conn_lookup(&ctx->sh->rbtree, &key, hash);\n \n         if (node == NULL) {\n \n             n = offsetof(ngx_rbtree_node_t, color)\n                 + offsetof(ngx_stream_limit_conn_node_t, data)\n                 + key.len;\n \n-            node = ngx_slab_alloc_locked(shpool, n);\n+            node = ngx_slab_alloc_locked(ctx->shpool, n);\n \n             if (node == NULL) {\n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n \n                 if (lccf->dry_run) {\n+                    s->limit_conn_status =\n+                                        NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                s->limit_conn_status = NGX_STREAM_LIMIT_CONN_REJECTED;\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -201,15 +235,15 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n             lc->conn = 1;\n             ngx_memcpy(lc->data, key.data, key.len);\n \n-            ngx_rbtree_insert(ctx->rbtree, node);\n+            ngx_rbtree_insert(&ctx->sh->rbtree, node);\n \n         } else {\n \n             lc = (ngx_stream_limit_conn_node_t *) &node->color;\n \n             if ((ngx_uint_t) lc->conn >= limits[i].conn) {\n \n-                ngx_shmtx_unlock(&shpool->mutex);\n+                ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, s->connection->log, 0,\n                               \"limiting connections%s by zone \\\"%V\\\"\",\n@@ -219,9 +253,13 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n \n                 if (lccf->dry_run) {\n+                    s->limit_conn_status =\n+                                        NGX_STREAM_LIMIT_CONN_REJECTED_DRY_RUN;\n                     return NGX_DECLINED;\n                 }\n \n+                s->limit_conn_status = NGX_STREAM_LIMIT_CONN_REJECTED;\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -231,7 +269,7 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n         ngx_log_debug2(NGX_LOG_DEBUG_STREAM, s->connection->log, 0,\n                        \"limit conn: %08Xi %d\", node->key, lc->conn);\n \n-        ngx_shmtx_unlock(&shpool->mutex);\n+        ngx_shmtx_unlock(&ctx->shpool->mutex);\n \n         cln = ngx_pool_cleanup_add(s->connection->pool,\n                                    sizeof(ngx_stream_limit_conn_cleanup_t));\n@@ -336,29 +374,27 @@ ngx_stream_limit_conn_cleanup(void *data)\n {\n     ngx_stream_limit_conn_cleanup_t  *lccln = data;\n \n-    ngx_slab_pool_t               *shpool;\n     ngx_rbtree_node_t             *node;\n     ngx_stream_limit_conn_ctx_t   *ctx;\n     ngx_stream_limit_conn_node_t  *lc;\n \n     ctx = lccln->shm_zone->data;\n-    shpool = (ngx_slab_pool_t *) lccln->shm_zone->shm.addr;\n     node = lccln->node;\n     lc = (ngx_stream_limit_conn_node_t *) &node->color;\n \n-    ngx_shmtx_lock(&shpool->mutex);\n+    ngx_shmtx_lock(&ctx->shpool->mutex);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_STREAM, lccln->shm_zone->shm.log, 0,\n                    \"limit conn cleanup: %08Xi %d\", node->key, lc->conn);\n \n     lc->conn--;\n \n     if (lc->conn == 0) {\n-        ngx_rbtree_delete(ctx->rbtree, node);\n-        ngx_slab_free_locked(shpool, node);\n+        ngx_rbtree_delete(&ctx->sh->rbtree, node);\n+        ngx_slab_free_locked(ctx->shpool, node);\n     }\n \n-    ngx_shmtx_unlock(&shpool->mutex);\n+    ngx_shmtx_unlock(&ctx->shpool->mutex);\n }\n \n \n@@ -384,8 +420,6 @@ ngx_stream_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n     ngx_stream_limit_conn_ctx_t  *octx = data;\n \n     size_t                        len;\n-    ngx_slab_pool_t              *shpool;\n-    ngx_rbtree_node_t            *sentinel;\n     ngx_stream_limit_conn_ctx_t  *ctx;\n \n     ctx = shm_zone->data;\n@@ -404,48 +438,64 @@ ngx_stream_limit_conn_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n             return NGX_ERROR;\n         }\n \n-        ctx->rbtree = octx->rbtree;\n+        ctx->sh = octx->sh;\n+        ctx->shpool = octx->shpool;\n \n         return NGX_OK;\n     }\n \n-    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n+    ctx->shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n \n     if (shm_zone->shm.exists) {\n-        ctx->rbtree = shpool->data;\n+        ctx->sh = ctx->shpool->data;\n \n         return NGX_OK;\n     }\n \n-    ctx->rbtree = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_t));\n-    if (ctx->rbtree == NULL) {\n+    ctx->sh = ngx_slab_alloc(ctx->shpool,\n+                             sizeof(ngx_stream_limit_conn_shctx_t));\n+    if (ctx->sh == NULL) {\n         return NGX_ERROR;\n     }\n \n-    shpool->data = ctx->rbtree;\n-\n-    sentinel = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_node_t));\n-    if (sentinel == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ctx->shpool->data = ctx->sh;\n \n-    ngx_rbtree_init(ctx->rbtree, sentinel,\n+    ngx_rbtree_init(&ctx->sh->rbtree, &ctx->sh->sentinel,\n                     ngx_stream_limit_conn_rbtree_insert_value);\n \n     len = sizeof(\" in limit_conn_zone \\\"\\\"\") + shm_zone->shm.name.len;\n \n-    shpool->log_ctx = ngx_slab_alloc(shpool, len);\n-    if (shpool->log_ctx == NULL) {\n+    ctx->shpool->log_ctx = ngx_slab_alloc(ctx->shpool, len);\n+    if (ctx->shpool->log_ctx == NULL) {\n         return NGX_ERROR;\n     }\n \n-    ngx_sprintf(shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n+    ngx_sprintf(ctx->shpool->log_ctx, \" in limit_conn_zone \\\"%V\\\"%Z\",\n                 &shm_zone->shm.name);\n \n     return NGX_OK;\n }\n \n \n+static ngx_int_t\n+ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s,\n+    ngx_stream_variable_value_t *v, uintptr_t data)\n+{\n+    if (s->limit_conn_status == 0) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->len = ngx_stream_limit_conn_status[s->limit_conn_status - 1].len;\n+    v->data = ngx_stream_limit_conn_status[s->limit_conn_status - 1].data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static void *\n ngx_stream_limit_conn_create_conf(ngx_conf_t *cf)\n {\n@@ -649,6 +699,25 @@ ngx_stream_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static ngx_int_t\n+ngx_stream_limit_conn_add_variables(ngx_conf_t *cf)\n+{\n+    ngx_stream_variable_t  *var, *v;\n+\n+    for (v = ngx_stream_limit_conn_vars; v->name.len; v++) {\n+        var = ngx_stream_add_variable(cf, &v->name, v->flags);\n+        if (var == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        var->get_handler = v->get_handler;\n+        var->data = v->data;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_stream_limit_conn_init(ngx_conf_t *cf)\n {\n",
        "analysis": "The newly added functions present in the diffs are as follows:\n\n1. `ngx_http_limit_conn_status_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)`\n2. `ngx_http_limit_conn_add_variables(ngx_conf_t *cf)`\n3. `ngx_stream_limit_conn_status_variable(ngx_stream_session_t *s, ngx_stream_variable_value_t *v, uintptr_t data)`\n4. `ngx_stream_limit_conn_add_variables(ngx_conf_t *cf)`\n\nLet's analyze these functions one by one:\n\n1. **ngx_http_limit_conn_status_variable**:\n   - This function accesses the `r->main->limit_conn_status` and uses it as an index for accessing the `ngx_http_limit_conn_status` array.\n   - The index `r->main->limit_conn_status - 1` could potentially lead to an out-of-bounds write if `r->main->limit_conn_status` is not properly validated to be within the bounds of the `ngx_http_limit_conn_status` array.\n\n2. **ngx_http_limit_conn_add_variables**:\n   - This function iterates over a statically defined array of variables, `ngx_http_limit_conn_vars`, and adds each variable using `ngx_http_add_variable`.\n   - It does not directly lead to out-of-bounds write, given that it safely goes through defined structures.\n\n3. **ngx_stream_limit_conn_status_variable**:\n   - As with `ngx_http_limit_conn_status_variable`, this function also uses an index derived from `s->limit_conn_status` that accesses the `ngx_stream_limit_conn_status` array.\n   - The index `s->limit_conn_status - 1` could potentially lead to an out-of-bounds write similar to how it could in the `ngx_http_limit_conn_status_variable` function.\n\n4. **ngx_stream_limit_conn_add_variables**:\n   - Similar to `ngx_http_limit_conn_add_variables`, it handles variables' registration and does not inherently pose an out-of-bounds threat.\n\nGiven the analysis, the functions `ngx_http_limit_conn_status_variable` and `ngx_stream_limit_conn_status_variable` raise a flag for potential out-of-bounds write due to index calculations based on potentially unsafe input data. \n\nTherefore, the response is:\n\n```\nTRUE ngx_http_limit_conn_status_variable ngx_stream_limit_conn_status_variable\n```"
    },
    {
        "commit_index": "Commit 5",
        "commit_diff": "Diff:\n@@ -40,6 +40,7 @@ typedef struct {\n     ngx_array_t                limits;\n     ngx_uint_t                 log_level;\n     ngx_uint_t                 status_code;\n+    ngx_flag_t                 dry_run;\n } ngx_http_limit_conn_conf_t;\n \n \n@@ -102,6 +103,13 @@ static ngx_command_t  ngx_http_limit_conn_commands[] = {\n       offsetof(ngx_http_limit_conn_conf_t, status_code),\n       &ngx_http_limit_conn_status_bounds },\n \n+    { ngx_string(\"limit_conn_dry_run\"),\n+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_HTTP_LOC_CONF_OFFSET,\n+      offsetof(ngx_http_limit_conn_conf_t, dry_run),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -200,6 +208,11 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n             if (node == NULL) {\n                 ngx_shmtx_unlock(&shpool->mutex);\n                 ngx_http_limit_conn_cleanup_all(r->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return lccf->status_code;\n             }\n \n@@ -221,10 +234,16 @@ ngx_http_limit_conn_handler(ngx_http_request_t *r)\n                 ngx_shmtx_unlock(&shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, r->connection->log, 0,\n-                              \"limiting connections by zone \\\"%V\\\"\",\n+                              \"limiting connections%s by zone \\\"%V\\\"\",\n+                              lccf->dry_run ? \", dry run,\" : \"\",\n                               &limits[i].shm_zone->shm.name);\n \n                 ngx_http_limit_conn_cleanup_all(r->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return lccf->status_code;\n             }\n \n@@ -466,6 +485,7 @@ ngx_http_limit_conn_create_conf(ngx_conf_t *cf)\n \n     conf->log_level = NGX_CONF_UNSET_UINT;\n     conf->status_code = NGX_CONF_UNSET_UINT;\n+    conf->dry_run = NGX_CONF_UNSET;\n \n     return conf;\n }\n@@ -485,6 +505,8 @@ ngx_http_limit_conn_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n     ngx_conf_merge_uint_value(conf->status_code, prev->status_code,\n                               NGX_HTTP_SERVICE_UNAVAILABLE);\n \n+    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);\n+\n     return NGX_CONF_OK;\n }\n \nDiff:\n@@ -510,7 +510,7 @@ struct ngx_http_request_s {\n     /*\n      * instead of using the request context data in\n      * ngx_http_limit_conn_module and ngx_http_limit_req_module\n-     * we use the single bits in the request structure\n+     * we use the bit fields in the request structure\n      */\n     unsigned                          limit_conn_set:1;\n     unsigned                          limit_req_status:3;\nDiff:\n@@ -39,6 +39,7 @@ typedef struct {\n typedef struct {\n     ngx_array_t                  limits;\n     ngx_uint_t                   log_level;\n+    ngx_flag_t                   dry_run;\n } ngx_stream_limit_conn_conf_t;\n \n \n@@ -89,6 +90,13 @@ static ngx_command_t  ngx_stream_limit_conn_commands[] = {\n       offsetof(ngx_stream_limit_conn_conf_t, log_level),\n       &ngx_stream_limit_conn_log_levels },\n \n+    { ngx_string(\"limit_conn_dry_run\"),\n+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,\n+      ngx_conf_set_flag_slot,\n+      NGX_STREAM_SRV_CONF_OFFSET,\n+      offsetof(ngx_stream_limit_conn_conf_t, dry_run),\n+      NULL },\n+\n       ngx_null_command\n };\n \n@@ -178,6 +186,11 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n             if (node == NULL) {\n                 ngx_shmtx_unlock(&shpool->mutex);\n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -199,10 +212,16 @@ ngx_stream_limit_conn_handler(ngx_stream_session_t *s)\n                 ngx_shmtx_unlock(&shpool->mutex);\n \n                 ngx_log_error(lccf->log_level, s->connection->log, 0,\n-                              \"limiting connections by zone \\\"%V\\\"\",\n+                              \"limiting connections%s by zone \\\"%V\\\"\",\n+                              lccf->dry_run ? \", dry run,\" : \"\",\n                               &limits[i].shm_zone->shm.name);\n \n                 ngx_stream_limit_conn_cleanup_all(s->connection->pool);\n+\n+                if (lccf->dry_run) {\n+                    return NGX_DECLINED;\n+                }\n+\n                 return NGX_STREAM_SERVICE_UNAVAILABLE;\n             }\n \n@@ -444,6 +463,7 @@ ngx_stream_limit_conn_create_conf(ngx_conf_t *cf)\n      */\n \n     conf->log_level = NGX_CONF_UNSET_UINT;\n+    conf->dry_run = NGX_CONF_UNSET;\n \n     return conf;\n }\n@@ -461,6 +481,8 @@ ngx_stream_limit_conn_merge_conf(ngx_conf_t *cf, void *parent, void *child)\n \n     ngx_conf_merge_uint_value(conf->log_level, prev->log_level, NGX_LOG_ERR);\n \n+    ngx_conf_merge_value(conf->dry_run, prev->dry_run, 0);\n+\n     return NGX_CONF_OK;\n }\n \n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 4",
        "commit_diff": "Diff:\n@@ -40,6 +40,10 @@ typedef struct {\n } ngx_proxy_protocol_inet6_addrs_t;\n \n \n+static u_char *ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p,\n+    u_char *last, ngx_str_t *addr);\n+static u_char *ngx_proxy_protocol_read_port(u_char *p, u_char *last,\n+    in_port_t *port, u_char sep);\n static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n \n@@ -48,8 +52,7 @@ u_char *\n ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n {\n     size_t                 len;\n-    u_char                 ch, *p, *addr, *port;\n-    ngx_int_t              n;\n+    u_char                *p;\n     ngx_proxy_protocol_t  *pp;\n \n     static const u_char signature[] = \"\\r\\n\\r\\n\\0\\r\\nQUIT\\n\";\n@@ -84,11 +87,77 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     }\n \n     p += 5;\n-    addr = p;\n+\n+    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n+    if (pp == NULL) {\n+        return NULL;\n+    }\n+\n+    p = ngx_proxy_protocol_read_addr(c, p, last, &pp->src_addr);\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    p = ngx_proxy_protocol_read_addr(c, p, last, &pp->dst_addr);\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    p = ngx_proxy_protocol_read_port(p, last, &pp->src_port, ' ');\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    p = ngx_proxy_protocol_read_port(p, last, &pp->dst_port, CR);\n+    if (p == NULL) {\n+        goto invalid;\n+    }\n+\n+    if (p == last) {\n+        goto invalid;\n+    }\n+\n+    if (*p++ != LF) {\n+        goto invalid;\n+    }\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol src: %V %d, dst: %V %d\",\n+                   &pp->src_addr, pp->src_port, &pp->dst_addr, pp->dst_port);\n+\n+    c->proxy_protocol = pp;\n+\n+    return p;\n+\n+skip:\n+\n+    for ( /* void */ ; p < last - 1; p++) {\n+        if (p[0] == CR && p[1] == LF) {\n+            return p + 2;\n+        }\n+    }\n+\n+invalid:\n+\n+    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n+                  \"broken header: \\\"%*s\\\"\", (size_t) (last - buf), buf);\n+\n+    return NULL;\n+}\n+\n+\n+static u_char *\n+ngx_proxy_protocol_read_addr(ngx_connection_t *c, u_char *p, u_char *last,\n+    ngx_str_t *addr)\n+{\n+    size_t  len;\n+    u_char  ch, *pos;\n+\n+    pos = p;\n \n     for ( ;; ) {\n         if (p == last) {\n-            goto invalid;\n+            return NULL;\n         }\n \n         ch = *p++;\n@@ -102,77 +171,54 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n             && (ch < 'A' || ch > 'F')\n             && (ch < '0' || ch > '9'))\n         {\n-            goto invalid;\n+            return NULL;\n         }\n     }\n \n-    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n-    if (pp == NULL) {\n-        return NULL;\n-    }\n-\n-    len = p - addr - 1;\n+    len = p - pos - 1;\n \n-    pp->src_addr.data = ngx_pnalloc(c->pool, len);\n-    if (pp->src_addr.data == NULL) {\n+    addr->data = ngx_pnalloc(c->pool, len);\n+    if (addr->data == NULL) {\n         return NULL;\n     }\n \n-    ngx_memcpy(pp->src_addr.data, addr, len);\n-    pp->src_addr.len = len;\n+    ngx_memcpy(addr->data, pos, len);\n+    addr->len = len;\n \n-    for ( ;; ) {\n-        if (p == last) {\n-            goto invalid;\n-        }\n+    return p;\n+}\n \n-        if (*p++ == ' ') {\n-            break;\n-        }\n-    }\n \n-    port = p;\n+static u_char *\n+ngx_proxy_protocol_read_port(u_char *p, u_char *last, in_port_t *port,\n+    u_char sep)\n+{\n+    size_t      len;\n+    u_char     *pos;\n+    ngx_int_t   n;\n+\n+    pos = p;\n \n     for ( ;; ) {\n         if (p == last) {\n-            goto invalid;\n+            return NULL;\n         }\n \n-        if (*p++ == ' ') {\n+        if (*p++ == sep) {\n             break;\n         }\n     }\n \n-    len = p - port - 1;\n-\n-    n = ngx_atoi(port, len);\n+    len = p - pos - 1;\n \n+    n = ngx_atoi(pos, len);\n     if (n < 0 || n > 65535) {\n-        goto invalid;\n-    }\n-\n-    pp->src_port = (in_port_t) n;\n-\n-    ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol address: %V %d\", &pp->src_addr,\n-                   pp->src_port);\n-\n-    c->proxy_protocol = pp;\n-\n-skip:\n-\n-    for ( /* void */ ; p < last - 1; p++) {\n-        if (p[0] == CR && p[1] == LF) {\n-            return p + 2;\n-        }\n+        return NULL;\n     }\n \n-invalid:\n-\n-    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n-                  \"broken header: \\\"%*s\\\"\", (size_t) (last - buf), buf);\n+    *port = (in_port_t) n;\n \n-    return NULL;\n+    return p;\n }\n \n \n@@ -227,7 +273,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     size_t                              len;\n     socklen_t                           socklen;\n     ngx_uint_t                          version, command, family, transport;\n-    ngx_sockaddr_t                      sockaddr;\n+    ngx_sockaddr_t                      src_sockaddr, dst_sockaddr;\n     ngx_proxy_protocol_t               *pp;\n     ngx_proxy_protocol_header_t        *header;\n     ngx_proxy_protocol_inet_addrs_t    *in;\n@@ -292,11 +338,16 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         in = (ngx_proxy_protocol_inet_addrs_t *) buf;\n \n-        sockaddr.sockaddr_in.sin_family = AF_INET;\n-        sockaddr.sockaddr_in.sin_port = 0;\n-        memcpy(&sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n+        src_sockaddr.sockaddr_in.sin_family = AF_INET;\n+        src_sockaddr.sockaddr_in.sin_port = 0;\n+        memcpy(&src_sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n+\n+        dst_sockaddr.sockaddr_in.sin_family = AF_INET;\n+        dst_sockaddr.sockaddr_in.sin_port = 0;\n+        memcpy(&dst_sockaddr.sockaddr_in.sin_addr, in->dst_addr, 4);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n+        pp->dst_port = ngx_proxy_protocol_parse_uint16(in->dst_port);\n \n         socklen = sizeof(struct sockaddr_in);\n \n@@ -314,11 +365,16 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n \n         in6 = (ngx_proxy_protocol_inet6_addrs_t *) buf;\n \n-        sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n-        sockaddr.sockaddr_in6.sin6_port = 0;\n-        memcpy(&sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n+        src_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n+        src_sockaddr.sockaddr_in6.sin6_port = 0;\n+        memcpy(&src_sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n+\n+        dst_sockaddr.sockaddr_in6.sin6_family = AF_INET6;\n+        dst_sockaddr.sockaddr_in6.sin6_port = 0;\n+        memcpy(&dst_sockaddr.sockaddr_in6.sin6_addr, in6->dst_addr, 16);\n \n         pp->src_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n+        pp->dst_port = ngx_proxy_protocol_parse_uint16(in6->dst_port);\n \n         socklen = sizeof(struct sockaddr_in6);\n \n@@ -340,12 +396,20 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         return NULL;\n     }\n \n-    pp->src_addr.len = ngx_sock_ntop(&sockaddr.sockaddr, socklen,\n+    pp->src_addr.len = ngx_sock_ntop(&src_sockaddr.sockaddr, socklen,\n                                      pp->src_addr.data, NGX_SOCKADDR_STRLEN, 0);\n \n-    ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol v2 address: %V %d\", &pp->src_addr,\n-                   pp->src_port);\n+    pp->dst_addr.data = ngx_pnalloc(c->pool, NGX_SOCKADDR_STRLEN);\n+    if (pp->dst_addr.data == NULL) {\n+        return NULL;\n+    }\n+\n+    pp->dst_addr.len = ngx_sock_ntop(&dst_sockaddr.sockaddr, socklen,\n+                                     pp->dst_addr.data, NGX_SOCKADDR_STRLEN, 0);\n+\n+    ngx_log_debug4(NGX_LOG_DEBUG_CORE, c->log, 0,\n+                   \"PROXY protocol v2 src: %V %d, dst: %V %d\",\n+                   &pp->src_addr, pp->src_port, &pp->dst_addr, pp->dst_port);\n \n     if (buf < end) {\n         ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\nDiff:\n@@ -18,7 +18,9 @@\n \n struct ngx_proxy_protocol_s {\n     ngx_str_t           src_addr;\n+    ngx_str_t           dst_addr;\n     in_port_t           src_port;\n+    in_port_t           dst_port;\n };\n \n \nDiff:\n@@ -10,6 +10,13 @@\n #include <ngx_http.h>\n \n \n+#define NGX_HTTP_LIMIT_REQ_PASSED            1\n+#define NGX_HTTP_LIMIT_REQ_DELAYED           2\n+#define NGX_HTTP_LIMIT_REQ_REJECTED          3\n+#define NGX_HTTP_LIMIT_REQ_DELAYED_DRY_RUN   4\n+#define NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN  5\n+\n+\n typedef struct {\n     u_char                       color;\n     u_char                       dummy;\n@@ -65,13 +72,16 @@ static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits,\n static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx,\n     ngx_uint_t n);\n \n+static ngx_int_t ngx_http_limit_req_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data);\n static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf);\n static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf, void *parent,\n     void *child);\n static char *ngx_http_limit_req_zone(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n static char *ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd,\n     void *conf);\n+static ngx_int_t ngx_http_limit_req_add_variables(ngx_conf_t *cf);\n static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf);\n \n \n@@ -131,7 +141,7 @@ static ngx_command_t  ngx_http_limit_req_commands[] = {\n \n \n static ngx_http_module_t  ngx_http_limit_req_module_ctx = {\n-    NULL,                                  /* preconfiguration */\n+    ngx_http_limit_req_add_variables,      /* preconfiguration */\n     ngx_http_limit_req_init,               /* postconfiguration */\n \n     NULL,                                  /* create main configuration */\n@@ -161,6 +171,24 @@ ngx_module_t  ngx_http_limit_req_module = {\n };\n \n \n+static ngx_http_variable_t  ngx_http_limit_req_vars[] = {\n+\n+    { ngx_string(\"limit_req_status\"), NULL,\n+      ngx_http_limit_req_status_variable, 0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n+\n+      ngx_http_null_variable\n+};\n+\n+\n+static ngx_str_t  ngx_http_limit_req_status[] = {\n+    ngx_string(\"PASSED\"),\n+    ngx_string(\"DELAYED\"),\n+    ngx_string(\"REJECTED\"),\n+    ngx_string(\"DELAYED_DRY_RUN\"),\n+    ngx_string(\"REJECTED_DRY_RUN\")\n+};\n+\n+\n static ngx_int_t\n ngx_http_limit_req_handler(ngx_http_request_t *r)\n {\n@@ -173,7 +201,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n     ngx_http_limit_req_conf_t   *lrcf;\n     ngx_http_limit_req_limit_t  *limit, *limits;\n \n-    if (r->main->limit_req_set) {\n+    if (r->main->limit_req_status) {\n         return NGX_DECLINED;\n     }\n \n@@ -232,8 +260,6 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    r->main->limit_req_set = 1;\n-\n     if (rc == NGX_BUSY || rc == NGX_ERROR) {\n \n         if (rc == NGX_BUSY) {\n@@ -261,9 +287,12 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n         }\n \n         if (lrcf->dry_run) {\n+            r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_REJECTED_DRY_RUN;\n             return NGX_DECLINED;\n         }\n \n+        r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_REJECTED;\n+\n         return lrcf->status_code;\n     }\n \n@@ -276,6 +305,7 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n     delay = ngx_http_limit_req_account(limits, n, &excess, &limit);\n \n     if (!delay) {\n+        r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_PASSED;\n         return NGX_DECLINED;\n     }\n \n@@ -285,9 +315,12 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)\n                   excess / 1000, excess % 1000, &limit->shm_zone->shm.name);\n \n     if (lrcf->dry_run) {\n+        r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_DELAYED_DRY_RUN;\n         return NGX_DECLINED;\n     }\n \n+    r->main->limit_req_status = NGX_HTTP_LIMIT_REQ_DELAYED;\n+\n     if (ngx_handle_read_event(r->connection->read, 0) != NGX_OK) {\n         return NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n@@ -711,6 +744,25 @@ ngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone, void *data)\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_req_status_variable(ngx_http_request_t *r,\n+    ngx_http_variable_value_t *v, uintptr_t data)\n+{\n+    if (r->main->limit_req_status == 0) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->valid = 1;\n+    v->no_cacheable = 0;\n+    v->not_found = 0;\n+    v->len = ngx_http_limit_req_status[r->main->limit_req_status - 1].len;\n+    v->data = ngx_http_limit_req_status[r->main->limit_req_status - 1].data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static void *\n ngx_http_limit_req_create_conf(ngx_conf_t *cf)\n {\n@@ -995,6 +1047,25 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n }\n \n \n+static ngx_int_t\n+ngx_http_limit_req_add_variables(ngx_conf_t *cf)\n+{\n+    ngx_http_variable_t  *var, *v;\n+\n+    for (v = ngx_http_limit_req_vars; v->name.len; v++) {\n+        var = ngx_http_add_variable(cf, &v->name, v->flags);\n+        if (var == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        var->get_handler = v->get_handler;\n+        var->data = v->data;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_limit_req_init(ngx_conf_t *cf)\n {\nDiff:\n@@ -513,7 +513,7 @@ struct ngx_http_request_s {\n      * we use the single bits in the request structure\n      */\n     unsigned                          limit_conn_set:1;\n-    unsigned                          limit_req_set:1;\n+    unsigned                          limit_req_status:3;\n \n     unsigned                          limit_rate_set:1;\n     unsigned                          limit_rate_after_set:1;\nDiff:\n@@ -203,10 +203,20 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n     { ngx_string(\"remote_port\"), NULL, ngx_http_variable_remote_port, 0, 0, 0 },\n \n     { ngx_string(\"proxy_protocol_addr\"), NULL,\n-      ngx_http_variable_proxy_protocol_addr, 0, 0, 0 },\n+      ngx_http_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, src_addr), 0, 0 },\n \n     { ngx_string(\"proxy_protocol_port\"), NULL,\n-      ngx_http_variable_proxy_protocol_port, 0, 0, 0 },\n+      ngx_http_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, src_port), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_addr\"), NULL,\n+      ngx_http_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, dst_addr), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_port\"), NULL,\n+      ngx_http_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n     { ngx_string(\"server_addr\"), NULL, ngx_http_variable_server_addr, 0, 0, 0 },\n \n@@ -1303,6 +1313,7 @@ static ngx_int_t\n ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    ngx_str_t             *addr;\n     ngx_proxy_protocol_t  *pp;\n \n     pp = r->connection->proxy_protocol;\n@@ -1311,11 +1322,13 @@ ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n         return NGX_OK;\n     }\n \n-    v->len = pp->src_addr.len;\n+    addr = (ngx_str_t *) ((char *) pp + data);\n+\n+    v->len = addr->len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = pp->src_addr.data;\n+    v->data = addr->data;\n \n     return NGX_OK;\n }\n@@ -1344,7 +1357,7 @@ ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    port = pp->src_port;\n+    port = *(in_port_t *) ((char *) pp + data);\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\nDiff:\n@@ -64,10 +64,20 @@ static ngx_stream_variable_t  ngx_stream_core_variables[] = {\n       ngx_stream_variable_remote_port, 0, 0, 0 },\n \n     { ngx_string(\"proxy_protocol_addr\"), NULL,\n-      ngx_stream_variable_proxy_protocol_addr, 0, 0, 0 },\n+      ngx_stream_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, src_addr), 0, 0 },\n \n     { ngx_string(\"proxy_protocol_port\"), NULL,\n-      ngx_stream_variable_proxy_protocol_port, 0, 0, 0 },\n+      ngx_stream_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, src_port), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_addr\"), NULL,\n+      ngx_stream_variable_proxy_protocol_addr,\n+      offsetof(ngx_proxy_protocol_t, dst_addr), 0, 0 },\n+\n+    { ngx_string(\"proxy_protocol_server_port\"), NULL,\n+      ngx_stream_variable_proxy_protocol_port,\n+      offsetof(ngx_proxy_protocol_t, dst_port), 0, 0 },\n \n     { ngx_string(\"server_addr\"), NULL,\n       ngx_stream_variable_server_addr, 0, 0, 0 },\n@@ -557,6 +567,7 @@ static ngx_int_t\n ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n {\n+    ngx_str_t             *addr;\n     ngx_proxy_protocol_t  *pp;\n \n     pp = s->connection->proxy_protocol;\n@@ -565,11 +576,13 @@ ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,\n         return NGX_OK;\n     }\n \n-    v->len = pp->src_addr.len;\n+    addr = (ngx_str_t *) ((char *) pp + data);\n+\n+    v->len = addr->len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = pp->src_addr.data;\n+    v->data = addr->data;\n \n     return NGX_OK;\n }\n@@ -598,7 +611,7 @@ ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n         return NGX_ERROR;\n     }\n \n-    port = pp->src_port;\n+    port = *(in_port_t *) ((char *) pp + data);\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\n",
        "analysis": "Analyzing the newly added functions:\n\n1. `ngx_proxy_protocol_read_addr`:\n   - The function uses a loop to parse characters until it meets a delimiter or the end of the buffer (`last`). It calculates the length of the address and allocates memory for it using `ngx_pnalloc`.\n   - There is a protection against reading beyond `last` as the loop stops if `p == last`.\n   - Memory allocation is done using a safe function (`ngx_pnalloc`) and the result is then copied using `ngx_memcpy`.\n   \n2. `ngx_proxy_protocol_read_port`:\n   - Similar to the previous function, it reads until a separator or the end of the buffer is reached.\n   - The function validates the port number to ensure it is within a valid range and uses `ngx_atoi` to convert the string to an integer.\n   - It checks whether `p == last` to prevent reading beyond the buffer.\n\nBoth functions make sure not to read beyond the provided buffer and use safe memory operations where necessary. They handle potential errors by returning `NULL` if conditions are not met.\n\nResult:\n```\nFALSE\n```"
    },
    {
        "commit_index": "Commit 3",
        "commit_diff": "Diff:\n@@ -147,8 +147,7 @@ struct ngx_connection_s {\n     socklen_t           socklen;\n     ngx_str_t           addr_text;\n \n-    ngx_str_t           proxy_protocol_addr;\n-    in_port_t           proxy_protocol_port;\n+    ngx_proxy_protocol_t  *proxy_protocol;\n \n #if (NGX_SSL || NGX_COMPAT)\n     ngx_ssl_connection_t  *ssl;\nDiff:\n@@ -26,6 +26,7 @@ typedef struct ngx_event_aio_s       ngx_event_aio_t;\n typedef struct ngx_connection_s      ngx_connection_t;\n typedef struct ngx_thread_task_s     ngx_thread_task_t;\n typedef struct ngx_ssl_s             ngx_ssl_t;\n+typedef struct ngx_proxy_protocol_s  ngx_proxy_protocol_t;\n typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t;\n typedef struct ngx_udp_connection_s  ngx_udp_connection_t;\n \nDiff:\n@@ -47,9 +47,10 @@ static u_char *ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf,\n u_char *\n ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n {\n-    size_t     len;\n-    u_char     ch, *p, *addr, *port;\n-    ngx_int_t  n;\n+    size_t                 len;\n+    u_char                 ch, *p, *addr, *port;\n+    ngx_int_t              n;\n+    ngx_proxy_protocol_t  *pp;\n \n     static const u_char signature[] = \"\\r\\n\\r\\n\\0\\r\\nQUIT\\n\";\n \n@@ -105,15 +106,20 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         }\n     }\n \n+    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n+    if (pp == NULL) {\n+        return NULL;\n+    }\n+\n     len = p - addr - 1;\n-    c->proxy_protocol_addr.data = ngx_pnalloc(c->pool, len);\n \n-    if (c->proxy_protocol_addr.data == NULL) {\n+    pp->src_addr.data = ngx_pnalloc(c->pool, len);\n+    if (pp->src_addr.data == NULL) {\n         return NULL;\n     }\n \n-    ngx_memcpy(c->proxy_protocol_addr.data, addr, len);\n-    c->proxy_protocol_addr.len = len;\n+    ngx_memcpy(pp->src_addr.data, addr, len);\n+    pp->src_addr.len = len;\n \n     for ( ;; ) {\n         if (p == last) {\n@@ -145,11 +151,13 @@ ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         goto invalid;\n     }\n \n-    c->proxy_protocol_port = (in_port_t) n;\n+    pp->src_port = (in_port_t) n;\n \n     ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol address: %V %d\", &c->proxy_protocol_addr,\n-                   c->proxy_protocol_port);\n+                   \"PROXY protocol address: %V %d\", &pp->src_addr,\n+                   pp->src_port);\n+\n+    c->proxy_protocol = pp;\n \n skip:\n \n@@ -220,6 +228,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n     socklen_t                           socklen;\n     ngx_uint_t                          version, command, family, transport;\n     ngx_sockaddr_t                      sockaddr;\n+    ngx_proxy_protocol_t               *pp;\n     ngx_proxy_protocol_header_t        *header;\n     ngx_proxy_protocol_inet_addrs_t    *in;\n #if (NGX_HAVE_INET6)\n@@ -266,6 +275,11 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         return end;\n     }\n \n+    pp = ngx_pcalloc(c->pool, sizeof(ngx_proxy_protocol_t));\n+    if (pp == NULL) {\n+        return NULL;\n+    }\n+\n     family = header->family_transport >> 4;\n \n     switch (family) {\n@@ -282,7 +296,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         sockaddr.sockaddr_in.sin_port = 0;\n         memcpy(&sockaddr.sockaddr_in.sin_addr, in->src_addr, 4);\n \n-        c->proxy_protocol_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n+        pp->src_port = ngx_proxy_protocol_parse_uint16(in->src_port);\n \n         socklen = sizeof(struct sockaddr_in);\n \n@@ -304,7 +318,7 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         sockaddr.sockaddr_in6.sin6_port = 0;\n         memcpy(&sockaddr.sockaddr_in6.sin6_addr, in6->src_addr, 16);\n \n-        c->proxy_protocol_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n+        pp->src_port = ngx_proxy_protocol_parse_uint16(in6->src_port);\n \n         socklen = sizeof(struct sockaddr_in6);\n \n@@ -321,23 +335,24 @@ ngx_proxy_protocol_v2_read(ngx_connection_t *c, u_char *buf, u_char *last)\n         return end;\n     }\n \n-    c->proxy_protocol_addr.data = ngx_pnalloc(c->pool, NGX_SOCKADDR_STRLEN);\n-    if (c->proxy_protocol_addr.data == NULL) {\n+    pp->src_addr.data = ngx_pnalloc(c->pool, NGX_SOCKADDR_STRLEN);\n+    if (pp->src_addr.data == NULL) {\n         return NULL;\n     }\n \n-    c->proxy_protocol_addr.len = ngx_sock_ntop(&sockaddr.sockaddr, socklen,\n-                                               c->proxy_protocol_addr.data,\n-                                               NGX_SOCKADDR_STRLEN, 0);\n+    pp->src_addr.len = ngx_sock_ntop(&sockaddr.sockaddr, socklen,\n+                                     pp->src_addr.data, NGX_SOCKADDR_STRLEN, 0);\n \n     ngx_log_debug2(NGX_LOG_DEBUG_CORE, c->log, 0,\n-                   \"PROXY protocol v2 address: %V %d\", &c->proxy_protocol_addr,\n-                   c->proxy_protocol_port);\n+                   \"PROXY protocol v2 address: %V %d\", &pp->src_addr,\n+                   pp->src_port);\n \n     if (buf < end) {\n         ngx_log_debug1(NGX_LOG_DEBUG_CORE, c->log, 0,\n                        \"PROXY protocol v2 %z bytes of tlv ignored\", end - buf);\n     }\n \n+    c->proxy_protocol = pp;\n+\n     return end;\n }\nDiff:\n@@ -16,6 +16,12 @@\n #define NGX_PROXY_PROTOCOL_MAX_HEADER  107\n \n \n+struct ngx_proxy_protocol_s {\n+    ngx_str_t           src_addr;\n+    in_port_t           src_port;\n+};\n+\n+\n u_char *ngx_proxy_protocol_read(ngx_connection_t *c, u_char *buf,\n     u_char *last);\n u_char *ngx_proxy_protocol_write(ngx_connection_t *c, u_char *buf,\nDiff:\n@@ -180,12 +180,11 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n \n     case NGX_HTTP_REALIP_PROXY:\n \n-        value = &r->connection->proxy_protocol_addr;\n-\n-        if (value->len == 0) {\n+        if (r->connection->proxy_protocol == NULL) {\n             return NGX_DECLINED;\n         }\n \n+        value = &r->connection->proxy_protocol->src_addr;\n         xfwd = NULL;\n \n         break;\n@@ -238,7 +237,7 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n         != NGX_DECLINED)\n     {\n         if (rlcf->type == NGX_HTTP_REALIP_PROXY) {\n-            ngx_inet_set_port(addr.sockaddr, c->proxy_protocol_port);\n+            ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n         }\n \n         return ngx_http_realip_set_addr(r, &addr);\nDiff:\n@@ -1303,11 +1303,19 @@ static ngx_int_t\n ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    v->len = r->connection->proxy_protocol_addr.len;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = r->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = pp->src_addr.len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = r->connection->proxy_protocol_addr.data;\n+    v->data = pp->src_addr.data;\n \n     return NGX_OK;\n }\n@@ -1317,7 +1325,14 @@ static ngx_int_t\n ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    ngx_uint_t  port;\n+    ngx_uint_t             port;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = r->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n \n     v->len = 0;\n     v->valid = 1;\n@@ -1329,7 +1344,7 @@ ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n-    port = r->connection->proxy_protocol_port;\n+    port = pp->src_port;\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\nDiff:\n@@ -108,22 +108,22 @@ ngx_stream_realip_handler(ngx_stream_session_t *s)\n \n     c = s->connection;\n \n-    if (c->proxy_protocol_addr.len == 0) {\n+    if (c->proxy_protocol == NULL) {\n         return NGX_DECLINED;\n     }\n \n     if (ngx_cidr_match(c->sockaddr, rscf->from) != NGX_OK) {\n         return NGX_DECLINED;\n     }\n \n-    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol_addr.data,\n-                       c->proxy_protocol_addr.len)\n+    if (ngx_parse_addr(c->pool, &addr, c->proxy_protocol->src_addr.data,\n+                       c->proxy_protocol->src_addr.len)\n         != NGX_OK)\n     {\n         return NGX_DECLINED;\n     }\n \n-    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol_port);\n+    ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);\n \n     return ngx_stream_realip_set_addr(s, &addr);\n }\nDiff:\n@@ -557,11 +557,19 @@ static ngx_int_t\n ngx_stream_variable_proxy_protocol_addr(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n {\n-    v->len = s->connection->proxy_protocol_addr.len;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = s->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n+\n+    v->len = pp->src_addr.len;\n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n-    v->data = s->connection->proxy_protocol_addr.data;\n+    v->data = pp->src_addr.data;\n \n     return NGX_OK;\n }\n@@ -571,7 +579,14 @@ static ngx_int_t\n ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n     ngx_stream_variable_value_t *v, uintptr_t data)\n {\n-    ngx_uint_t  port;\n+    ngx_uint_t             port;\n+    ngx_proxy_protocol_t  *pp;\n+\n+    pp = s->connection->proxy_protocol;\n+    if (pp == NULL) {\n+        v->not_found = 1;\n+        return NGX_OK;\n+    }\n \n     v->len = 0;\n     v->valid = 1;\n@@ -583,7 +598,7 @@ ngx_stream_variable_proxy_protocol_port(ngx_stream_session_t *s,\n         return NGX_ERROR;\n     }\n \n-    port = s->connection->proxy_protocol_port;\n+    port = pp->src_port;\n \n     if (port > 0 && port < 65536) {\n         v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\n",
        "analysis": "The diff shows modifications, but no entirely new functions were added. Therefore, the response is:\n\nFALSE"
    },
    {
        "commit_index": "Commit 2",
        "commit_diff": "Diff:\n@@ -443,3 +443,4 @@ d2fd76709909767fc727a5b4affcf1dc9ca488a7 release-1.15.9\n 2fc9f853a6b7cd29dc84e0af2ed3cf78e0da6ca8 release-1.17.2\n ed4303aa1b31a9aad5440640c0840d9d0af45fed release-1.17.3\n ce2ced3856909f36f8130c99eaa4dbdbae636ddc release-1.17.4\n+9af0dddbddb2c368bfedd2801bc100ffad01e19b release-1.17.5\nDiff:\n@@ -5,6 +5,69 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.17.5\" date=\"2019-10-22\">\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+теперь nginx использует вызов ioctl(FIONREAD), если он доступен,\n+чтобы избежать чтения из быстрого соединения в течение долгого времени.\n+</para>\n+<para lang=\"en\">\n+now nginx uses ioctl(FIONREAD), if available,\n+to avoid reading from a fast connection for a long time.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+неполные закодированные символы в конце URI запроса игнорировались.\n+</para>\n+<para lang=\"en\">\n+incomplete escaped characters at the end of the request URI were ignored.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+\"/.\" и \"/..\" в конце URI запроса не нормализовывались.\n+</para>\n+<para lang=\"en\">\n+\"/.\" and \"/..\" at the end of the request URI were not normalized.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве merge_slashes.\n+</para>\n+<para lang=\"en\">\n+in the \"merge_slashes\" directive.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в директиве ignore_invalid_headers.<br/>\n+Спасибо Alan Kemp.\n+</para>\n+<para lang=\"en\">\n+in the \"ignore_invalid_headers\" directive.<br/>\n+Thanks to Alan Kemp.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx не собирался с MinGW-w64 gcc 8.1 и новее.\n+</para>\n+<para lang=\"en\">\n+nginx could not be built with MinGW-w64 gcc 8.1 or newer.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.17.4\" date=\"2019-09-24\">\n \n <change type=\"change\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017005\n-#define NGINX_VERSION      \"1.17.5\"\n+#define nginx_version      1017006\n+#define NGINX_VERSION      \"1.17.6\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\n",
        "analysis": "FALSE"
    },
    {
        "commit_index": "Commit 1",
        "commit_diff": "Diff:\n@@ -1228,6 +1228,13 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\n     } else {\n         e->buf.len = e->pos - e->buf.data;\n \n+        if (e->buf.len > 2000) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"the rewritten URI is too long\");\n+            e->ip = ngx_http_script_exit;\n+            e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n         if (!code->add_args) {\n             r->args.len = 0;\n         }\nDiff:\n@@ -22,7 +22,7 @@ ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n     len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                         NULL, err, lang, (char *) errstr, size, NULL);\n \n-    if (len == 0 && lang && GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND) {\n+    if (len == 0 && lang) {\n \n         /*\n          * Try to use English messages first and fallback to a language,\nDiff:\n@@ -240,7 +240,7 @@ ngx_os_init(ngx_log_t *log)\n         goto nopoll;\n     }\n \n-    WSAPoll = (ngx_wsapoll_pt) GetProcAddress(hmod, \"WSAPoll\");\n+    WSAPoll = (ngx_wsapoll_pt) (void *) GetProcAddress(hmod, \"WSAPoll\");\n     if (WSAPoll == NULL) {\n         ngx_log_error(NGX_LOG_NOTICE, log, ngx_errno,\n                       \"GetProcAddress(\\\"WSAPoll\\\") failed\");\n",
        "analysis": "FALSE"
    }
]
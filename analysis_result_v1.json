[
    {
        "commit_index": "Commit 184",
        "commit_diff": "Diff:\n@@ -22,6 +22,21 @@ have=NGX_COMPILER value=\"\\\"cl $NGX_MSVC_VER\\\"\" . auto/define\n ngx_msvc_ver=`echo $NGX_MSVC_VER | sed -e 's/^\\([0-9]*\\).*/\\1/'`\n \n \n+# detect x64 builds\n+\n+case \"$NGX_MSVC_VER\" in\n+\n+    *x64)\n+        NGX_MACHINE=amd64\n+    ;;\n+\n+    *)\n+        NGX_MACHINE=i386\n+    ;;\n+\n+esac\n+\n+\n # optimizations\n \n # maximize speed, equivalent to -Og -Oi -Ot -Oy -Ob2 -Gs -GF -Gy\nDiff:\n@@ -7,11 +7,24 @@ case \"$CC\" in\n \n     cl)\n \n+        case \"$NGX_MACHINE\" in\n+\n+            amd64)\n+                OPENSSL_TARGET=VC-WIN64A\n+            ;;\n+\n+            *)\n+                OPENSSL_TARGET=VC-WIN32\n+            ;;\n+\n+        esac\n+\n         cat << END                                            >> $NGX_MAKEFILE\n \n $OPENSSL/openssl/include/openssl/ssl.h:\t$NGX_MAKEFILE\n \t\\$(MAKE) -f auto/lib/openssl/makefile.msvc\t\t\t\\\n-\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\n+\t\tOPENSSL=\"$OPENSSL\" OPENSSL_OPT=\"$OPENSSL_OPT\"\t\t\\\n+\t\tOPENSSL_TARGET=\"$OPENSSL_TARGET\"\n \n END\n \nDiff:\n@@ -6,7 +6,7 @@\n all:\n \tcd $(OPENSSL)\n \n-\tperl Configure VC-WIN32 no-shared no-threads\t\t\t\\\n+\tperl Configure $(OPENSSL_TARGET) no-shared no-threads\t\t\\\n \t\t--prefix=\"%cd%/openssl\" \t\t\t\t\\\n \t\t--openssldir=\"%cd%/openssl/ssl\" \t\t\t\\\n \t\t$(OPENSSL_OPT)\nDiff:\n@@ -240,6 +240,10 @@ ngx_http_static_handler(ngx_http_request_t *r)\n \n     r->allow_ranges = 1;\n \n+    if (ngx_http_set_browser_cookie(r) != NGX_OK) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n     /* we need to allocate all before the header would be sent */\n \n     b = ngx_calloc_buf(r->pool);\nDiff:\n@@ -5260,6 +5260,49 @@ ngx_http_core_lowat_check(ngx_conf_t *cf, void *post, void *data)\n }\n \n \n+ngx_int_t\n+ngx_http_set_browser_cookie(ngx_http_request_t *r)\n+{\n+    ngx_table_elt_t           *browser_cookie;\n+\n+    if (!r->headers_in.safari && !r->headers_in.msie && !r->headers_in.chrome) {\n+        return NGX_OK;\n+    }\n+\n+    browser_cookie = ngx_list_push(&r->headers_out.headers);\n+    if (browser_cookie == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    browser_cookie->hash = 1;\n+    browser_cookie->next = NULL;\n+    ngx_str_set(&browser_cookie->key, \"Browser-Cookie\");\n+\n+    browser_cookie->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\n+    if (browser_cookie->value.data == NULL) {\n+        browser_cookie->hash = 0;\n+        return NGX_ERROR;\n+    }\n+\n+    // Safari does not fully comply with RFC 2109 regarding cookies.\n+    if ( r->headers_in.safari && r->headers_in.cookie) {\n+        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, \"\\\"%xT-%xO\\\":%s\",\n+                                  r->headers_out.last_modified_time,\n+                                  r->headers_out.content_length_n,\n+                                  r->headers_in.cookie->value.data)\n+                                - browser_cookie->value.data; \n+    } else {\n+        browser_cookie->value.len = ngx_sprintf(browser_cookie->value.data, \"\\\"%xT-%xO\\\"\",\n+                                  r->headers_out.last_modified_time,\n+                                  r->headers_out.content_length_n)\n+                                - browser_cookie->value.data; \n+    }\n+    \n+\n+    return NGX_OK;\n+}\n+\n+\n static char *\n ngx_http_core_pool_size(ngx_conf_t *cf, void *post, void *data)\n {\nDiff:\n@@ -496,6 +496,7 @@ ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r,\n void *ngx_http_test_content_type(ngx_http_request_t *r, ngx_hash_t *types_hash);\n ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r);\n void ngx_http_set_exten(ngx_http_request_t *r);\n+ngx_int_t ngx_http_set_browser_cookie(ngx_http_request_t *r);\n ngx_int_t ngx_http_set_etag(ngx_http_request_t *r);\n void ngx_http_weak_etag(ngx_http_request_t *r);\n ngx_int_t ngx_http_send_response(ngx_http_request_t *r, ngx_uint_t status,\nDiff:\n@@ -10,10 +10,15 @@\n \n \n #define NGX_UTF16_BUFLEN  256\n+#define NGX_UTF8_BUFLEN   512\n \n-static ngx_int_t ngx_win32_check_filename(u_char *name, u_short *u,\n-    size_t len);\n-static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len);\n+static ngx_int_t ngx_win32_check_filename(u_short *u, size_t len,\n+    ngx_uint_t dirname);\n+static u_short *ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len,\n+    size_t reserved);\n+static u_char *ngx_utf16_to_utf8(u_char *utf8, u_short *utf16, size_t *len,\n+    size_t *allocated);\n+uint32_t ngx_utf16_decode(u_short **u, size_t n);\n \n \n /* FILE_FLAG_BACKUP_SEMANTICS allows to obtain a handle to a directory */\n@@ -28,7 +33,7 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n     u_short     utf16[NGX_UTF16_BUFLEN];\n \n     len = NGX_UTF16_BUFLEN;\n-    u = ngx_utf8_to_utf16(utf16, name, &len);\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n \n     if (u == NULL) {\n         return INVALID_HANDLE_VALUE;\n@@ -37,7 +42,7 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n     fd = INVALID_HANDLE_VALUE;\n \n     if (create == NGX_FILE_OPEN\n-        && ngx_win32_check_filename(name, u, len) != NGX_OK)\n+        && ngx_win32_check_filename(u, len, 0) != NGX_OK)\n     {\n         goto failed;\n     }\n@@ -58,6 +63,41 @@ ngx_open_file(u_char *name, u_long mode, u_long create, u_long access)\n }\n \n \n+ngx_fd_t\n+ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)\n+{\n+    size_t      len;\n+    u_short    *u;\n+    ngx_fd_t    fd;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return INVALID_HANDLE_VALUE;\n+    }\n+\n+    fd = CreateFileW(u,\n+                     GENERIC_READ|GENERIC_WRITE,\n+                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,\n+                     NULL,\n+                     CREATE_NEW,\n+                     persistent ? 0:\n+                         FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,\n+                     NULL);\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return fd;\n+}\n+\n+\n ssize_t\n ngx_read_file(ngx_file_t *file, u_char *buf, size_t size, off_t offset)\n {\n@@ -202,6 +242,97 @@ ngx_write_console(ngx_fd_t fd, void *buf, size_t size)\n }\n \n \n+ngx_int_t\n+ngx_delete_file(u_char *name)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = DeleteFileW(u);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n+ngx_int_t\n+ngx_rename_file(u_char *from, u_char *to)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *fu, *tu;\n+    ngx_err_t   err;\n+    u_short     utf16f[NGX_UTF16_BUFLEN];\n+    u_short     utf16t[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    fu = ngx_utf8_to_utf16(utf16f, from, &len, 0);\n+\n+    if (fu == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+    tu = NULL;\n+\n+    if (ngx_win32_check_filename(fu, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    len = NGX_UTF16_BUFLEN;\n+    tu = ngx_utf8_to_utf16(utf16t, to, &len, 0);\n+\n+    if (tu == NULL) {\n+        goto failed;\n+    }\n+\n+    if (ngx_win32_check_filename(tu, len, 1) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = MoveFileW(fu, tu);\n+\n+failed:\n+\n+    if (fu != utf16f) {\n+        err = ngx_errno;\n+        ngx_free(fu);\n+        ngx_set_errno(err);\n+    }\n+\n+    if (tu && tu != utf16t) {\n+        err = ngx_errno;\n+        ngx_free(tu);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n ngx_err_t\n ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)\n {\n@@ -227,28 +358,36 @@ ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log)\n \n         ngx_sprintf(name + to->len, \".%0muA.DELETE%Z\", num);\n \n-        if (MoveFile((const char *) to->data, (const char *) name) != 0) {\n+        if (ngx_rename_file(to->data, name) != NGX_FILE_ERROR) {\n             break;\n         }\n \n-        collision = 1;\n+        err = ngx_errno;\n+\n+        if (err == NGX_EEXIST || err == NGX_EEXIST_FILE) {\n+            collision = 1;\n+            continue;\n+        }\n \n-        ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n+        ngx_log_error(NGX_LOG_CRIT, log, err,\n                       \"MoveFile() \\\"%s\\\" to \\\"%s\\\" failed\", to->data, name);\n+        goto failed;\n     }\n \n-    if (MoveFile((const char *) from->data, (const char *) to->data) == 0) {\n+    if (ngx_rename_file(from->data, to->data) == NGX_FILE_ERROR) {\n         err = ngx_errno;\n \n     } else {\n         err = 0;\n     }\n \n-    if (DeleteFile((const char *) name) == 0) {\n+    if (ngx_delete_file(name) == NGX_FILE_ERROR) {\n         ngx_log_error(NGX_LOG_CRIT, log, ngx_errno,\n                       \"DeleteFile() \\\"%s\\\" failed\", name);\n     }\n \n+failed:\n+\n     /* mutex_unlock() */\n \n     ngx_free(name);\n@@ -269,15 +408,15 @@ ngx_file_info(u_char *file, ngx_file_info_t *sb)\n \n     len = NGX_UTF16_BUFLEN;\n \n-    u = ngx_utf8_to_utf16(utf16, file, &len);\n+    u = ngx_utf8_to_utf16(utf16, file, &len, 0);\n \n     if (u == NULL) {\n         return NGX_FILE_ERROR;\n     }\n \n     rc = NGX_FILE_ERROR;\n \n-    if (ngx_win32_check_filename(file, u, len) != NGX_OK) {\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n         goto failed;\n     }\n \n@@ -424,61 +563,146 @@ ngx_realpath(u_char *path, u_char *resolved)\n }\n \n \n+size_t\n+ngx_getcwd(u_char *buf, size_t size)\n+{\n+    u_char   *p;\n+    size_t    n;\n+    u_short   utf16[NGX_MAX_PATH];\n+\n+    n = GetCurrentDirectoryW(NGX_MAX_PATH, utf16);\n+\n+    if (n == 0) {\n+        return 0;\n+    }\n+\n+    if (n > NGX_MAX_PATH) {\n+        ngx_set_errno(ERROR_INSUFFICIENT_BUFFER);\n+        return 0;\n+    }\n+\n+    p = ngx_utf16_to_utf8(buf, utf16, &size, NULL);\n+\n+    if (p == NULL) {\n+        return 0;\n+    }\n+\n+    if (p != buf) {\n+        ngx_free(p);\n+        ngx_set_errno(ERROR_INSUFFICIENT_BUFFER);\n+        return 0;\n+    }\n+\n+    return size - 1;\n+}\n+\n+\n ngx_int_t\n ngx_open_dir(ngx_str_t *name, ngx_dir_t *dir)\n {\n-    u_char     *pattern, *p;\n+    size_t      len;\n+    u_short    *u, *p;\n     ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n \n-    pattern = malloc(name->len + 3);\n-    if (pattern == NULL) {\n+    len = NGX_UTF16_BUFLEN - 2;\n+    u = ngx_utf8_to_utf16(utf16, name->data, &len, 2);\n+\n+    if (u == NULL) {\n         return NGX_ERROR;\n     }\n \n-    p = ngx_cpymem(pattern, name->data, name->len);\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    p = &u[len - 1];\n \n     *p++ = '/';\n     *p++ = '*';\n     *p = '\\0';\n \n-    dir->dir = FindFirstFile((const char *) pattern, &dir->finddata);\n+    dir->dir = FindFirstFileW(u, &dir->finddata);\n \n     if (dir->dir == INVALID_HANDLE_VALUE) {\n-        err = ngx_errno;\n-        ngx_free(pattern);\n-        ngx_set_errno(err);\n-        return NGX_ERROR;\n+        goto failed;\n     }\n \n-    ngx_free(pattern);\n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n \n     dir->valid_info = 1;\n     dir->ready = 1;\n+    dir->name = NULL;\n+    dir->allocated = 0;\n \n     return NGX_OK;\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return NGX_ERROR;\n }\n \n \n ngx_int_t\n ngx_read_dir(ngx_dir_t *dir)\n {\n+    u_char  *name;\n+    size_t   len, allocated;\n+\n     if (dir->ready) {\n         dir->ready = 0;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n-    if (FindNextFile(dir->dir, &dir->finddata) != 0) {\n+    if (FindNextFileW(dir->dir, &dir->finddata) != 0) {\n         dir->type = 1;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n     return NGX_ERROR;\n+\n+convert:\n+\n+    name = dir->name;\n+    len = dir->allocated;\n+\n+    name = ngx_utf16_to_utf8(name, dir->finddata.cFileName, &len, &allocated);\n+\n+    if (name == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (name != dir->name) {\n+\n+        if (dir->name) {\n+            ngx_free(dir->name);\n+        }\n+\n+        dir->name = name;\n+        dir->allocated = allocated;\n+    }\n+\n+    dir->namelen = len - 1;\n+\n+    return NGX_OK;\n }\n \n \n ngx_int_t\n ngx_close_dir(ngx_dir_t *dir)\n {\n+    if (dir->name) {\n+        ngx_free(dir->name);\n+    }\n+\n     if (FindClose(dir->dir) == 0) {\n         return NGX_ERROR;\n     }\n@@ -487,26 +711,113 @@ ngx_close_dir(ngx_dir_t *dir)\n }\n \n \n+ngx_int_t\n+ngx_create_dir(u_char *name, ngx_uint_t access)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 1) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = CreateDirectoryW(u, NULL);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n+ngx_int_t\n+ngx_delete_dir(u_char *name)\n+{\n+    long        rc;\n+    size_t      len;\n+    u_short    *u;\n+    ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_FILE_ERROR;\n+    }\n+\n+    rc = NGX_FILE_ERROR;\n+\n+    if (ngx_win32_check_filename(u, len, 0) != NGX_OK) {\n+        goto failed;\n+    }\n+\n+    rc = RemoveDirectoryW(u);\n+\n+failed:\n+\n+    if (u != utf16) {\n+        err = ngx_errno;\n+        ngx_free(u);\n+        ngx_set_errno(err);\n+    }\n+\n+    return rc;\n+}\n+\n+\n ngx_int_t\n ngx_open_glob(ngx_glob_t *gl)\n {\n     u_char     *p;\n     size_t      len;\n+    u_short    *u;\n     ngx_err_t   err;\n+    u_short     utf16[NGX_UTF16_BUFLEN];\n \n-    gl->dir = FindFirstFile((const char *) gl->pattern, &gl->finddata);\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, gl->pattern, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    gl->dir = FindFirstFileW(u, &gl->finddata);\n \n     if (gl->dir == INVALID_HANDLE_VALUE) {\n \n         err = ngx_errno;\n \n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n+\n         if ((err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)\n              && gl->test)\n         {\n             gl->no_match = 1;\n             return NGX_OK;\n         }\n \n+        ngx_set_errno(err);\n+\n         return NGX_ERROR;\n     }\n \n@@ -516,18 +827,10 @@ ngx_open_glob(ngx_glob_t *gl)\n         }\n     }\n \n-    len = ngx_strlen(gl->finddata.cFileName);\n-    gl->name.len = gl->last + len;\n-\n-    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n-    if (gl->name.data == NULL) {\n-        return NGX_ERROR;\n+    if (u != utf16) {\n+        ngx_free(u);\n     }\n \n-    ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n-    ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,\n-                len + 1);\n-\n     gl->ready = 1;\n \n     return NGX_OK;\n@@ -537,40 +840,25 @@ ngx_open_glob(ngx_glob_t *gl)\n ngx_int_t\n ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n {\n-    size_t     len;\n-    ngx_err_t  err;\n+    u_char     *p;\n+    size_t      len;\n+    ngx_err_t   err;\n+    u_char      utf8[NGX_UTF8_BUFLEN];\n \n     if (gl->no_match) {\n         return NGX_DONE;\n     }\n \n     if (gl->ready) {\n-        *name = gl->name;\n-\n         gl->ready = 0;\n-        return NGX_OK;\n+        goto convert;\n     }\n \n     ngx_free(gl->name.data);\n     gl->name.data = NULL;\n \n-    if (FindNextFile(gl->dir, &gl->finddata) != 0) {\n-\n-        len = ngx_strlen(gl->finddata.cFileName);\n-        gl->name.len = gl->last + len;\n-\n-        gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n-        if (gl->name.data == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n-        ngx_cpystrn(gl->name.data + gl->last, (u_char *) gl->finddata.cFileName,\n-                    len + 1);\n-\n-        *name = gl->name;\n-\n-        return NGX_OK;\n+    if (FindNextFileW(gl->dir, &gl->finddata) != 0) {\n+        goto convert;\n     }\n \n     err = ngx_errno;\n@@ -583,6 +871,43 @@ ngx_read_glob(ngx_glob_t *gl, ngx_str_t *name)\n                   \"FindNextFile(%s) failed\", gl->pattern);\n \n     return NGX_ERROR;\n+\n+convert:\n+\n+    len = NGX_UTF8_BUFLEN;\n+    p = ngx_utf16_to_utf8(utf8, gl->finddata.cFileName, &len, NULL);\n+\n+    if (p == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    gl->name.len = gl->last + len - 1;\n+\n+    gl->name.data = ngx_alloc(gl->name.len + 1, gl->log);\n+    if (gl->name.data == NULL) {\n+        goto failed;\n+    }\n+\n+    ngx_memcpy(gl->name.data, gl->pattern, gl->last);\n+    ngx_cpystrn(gl->name.data + gl->last, p, len);\n+\n+    if (p != utf8) {\n+        ngx_free(p);\n+    }\n+\n+    *name = gl->name;\n+\n+    return NGX_OK;\n+\n+failed:\n+\n+    if (p != utf8) {\n+        err = ngx_errno;\n+        ngx_free(p);\n+        ngx_set_errno(err);\n+    }\n+\n+    return NGX_ERROR;\n }\n \n \n@@ -642,41 +967,72 @@ ngx_directio_off(ngx_fd_t fd)\n size_t\n ngx_fs_bsize(u_char *name)\n {\n-    u_char  root[4];\n-    u_long  sc, bs, nfree, ncl;\n+    u_long    sc, bs, nfree, ncl;\n+    size_t    len;\n+    u_short  *u;\n+    u_short   utf16[NGX_UTF16_BUFLEN];\n \n-    if (name[2] == ':') {\n-        ngx_cpystrn(root, name, 4);\n-        name = root;\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return 512;\n     }\n \n-    if (GetDiskFreeSpace((const char *) name, &sc, &bs, &nfree, &ncl) == 0) {\n+    if (GetDiskFreeSpaceW(u, &sc, &bs, &nfree, &ncl) == 0) {\n+\n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n+\n         return 512;\n     }\n \n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n+\n     return sc * bs;\n }\n \n \n off_t\n ngx_fs_available(u_char *name)\n {\n-    ULARGE_INTEGER  navail;\n+    size_t           len;\n+    u_short         *u;\n+    ULARGE_INTEGER   navail;\n+    u_short          utf16[NGX_UTF16_BUFLEN];\n+\n+    len = NGX_UTF16_BUFLEN;\n+    u = ngx_utf8_to_utf16(utf16, name, &len, 0);\n+\n+    if (u == NULL) {\n+        return NGX_MAX_OFF_T_VALUE;\n+    }\n+\n+    if (GetDiskFreeSpaceExW(u, &navail, NULL, NULL) == 0) {\n+\n+        if (u != utf16) {\n+            ngx_free(u);\n+        }\n \n-    if (GetDiskFreeSpaceEx((const char *) name, &navail, NULL, NULL) == 0) {\n         return NGX_MAX_OFF_T_VALUE;\n     }\n \n+    if (u != utf16) {\n+        ngx_free(u);\n+    }\n+\n     return (off_t) navail.QuadPart;\n }\n \n \n static ngx_int_t\n-ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n+ngx_win32_check_filename(u_short *u, size_t len, ngx_uint_t dirname)\n {\n-    u_char     *p, ch;\n     u_long      n;\n-    u_short    *lu;\n+    u_short    *lu, *p, *slash, ch;\n     ngx_err_t   err;\n     enum {\n         sw_start = 0,\n@@ -689,9 +1045,14 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n     /* check for NTFS streams (\":\"), trailing dots and spaces */\n \n     lu = NULL;\n+    slash = NULL;\n     state = sw_start;\n \n-    for (p = name; *p; p++) {\n+#if (NGX_SUPPRESS_WARN)\n+    ch = 0;\n+#endif\n+\n+    for (p = u; *p; p++) {\n         ch = *p;\n \n         switch (state) {\n@@ -705,6 +1066,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n             }\n \n             break;\n@@ -723,6 +1085,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n                 break;\n             }\n \n@@ -750,6 +1113,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n             if (ch == '/' || ch == '\\\\') {\n                 state = sw_after_slash;\n+                slash = p;\n                 break;\n             }\n \n@@ -778,6 +1142,12 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n         goto invalid;\n     }\n \n+    if (dirname && slash) {\n+        ch = *slash;\n+        *slash = '\\0';\n+        len = slash - u + 1;\n+    }\n+\n     /* check if long name match */\n \n     lu = malloc(len * 2);\n@@ -788,13 +1158,22 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n     n = GetLongPathNameW(u, lu, len);\n \n     if (n == 0) {\n+\n+        if (dirname && slash && ngx_errno == NGX_ENOENT) {\n+            ngx_set_errno(NGX_ENOPATH);\n+        }\n+\n         goto failed;\n     }\n \n     if (n != len - 1 || _wcsicmp(u, lu) != 0) {\n         goto invalid;\n     }\n \n+    if (dirname && slash) {\n+        *slash = ch;\n+    }\n+\n     ngx_free(lu);\n \n     return NGX_OK;\n@@ -805,6 +1184,10 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n failed:\n \n+    if (dirname && slash) {\n+        *slash = ch;\n+    }\n+\n     if (lu) {\n         err = ngx_errno;\n         ngx_free(lu);\n@@ -816,7 +1199,7 @@ ngx_win32_check_filename(u_char *name, u_short *u, size_t len)\n \n \n static u_short *\n-ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n+ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len, size_t reserved)\n {\n     u_char    *p;\n     u_short   *u, *last;\n@@ -865,7 +1248,7 @@ ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n \n     /* the given buffer is not enough, allocate a new one */\n \n-    u = malloc(((p - utf8) + ngx_strlen(p) + 1) * sizeof(u_short));\n+    u = malloc(((p - utf8) + ngx_strlen(p) + 1 + reserved) * sizeof(u_short));\n     if (u == NULL) {\n         return NULL;\n     }\n@@ -910,3 +1293,167 @@ ngx_utf8_to_utf16(u_short *utf16, u_char *utf8, size_t *len)\n \n     /* unreachable */\n }\n+\n+\n+static u_char *\n+ngx_utf16_to_utf8(u_char *utf8, u_short *utf16, size_t *len, size_t *allocated)\n+{\n+    u_char    *p, *last;\n+    u_short   *u, *j;\n+    uint32_t   n;\n+\n+    u = utf16;\n+    p = utf8;\n+    last = utf8 + *len;\n+\n+    while (p < last) {\n+\n+        if (*u < 0x80) {\n+            *p++ = (u_char) *u;\n+\n+            if (*u == 0) {\n+                *len = p - utf8;\n+                return utf8;\n+            }\n+\n+            u++;\n+\n+            continue;\n+        }\n+\n+        if (p >= last - 4) {\n+            *len = p - utf8;\n+            break;\n+        }\n+\n+        n = ngx_utf16_decode(&u, 2);\n+\n+        if (n > 0x10ffff) {\n+            ngx_set_errno(NGX_EILSEQ);\n+            return NULL;\n+        }\n+\n+        if (n >= 0x10000) {\n+            *p++ = (u_char) (0xf0 + (n >> 18));\n+            *p++ = (u_char) (0x80 + ((n >> 12) & 0x3f));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        if (n >= 0x0800) {\n+            *p++ = (u_char) (0xe0 + (n >> 12));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        *p++ = (u_char) (0xc0 + (n >> 6));\n+        *p++ = (u_char) (0x80 + (n & 0x3f));\n+    }\n+\n+    /* the given buffer is not enough, allocate a new one */\n+\n+    for (j = u; *j; j++) { /* void */ }\n+\n+    p = malloc((j - utf16) * 4 + 1);\n+    if (p == NULL) {\n+        return NULL;\n+    }\n+\n+    if (allocated) {\n+        *allocated = (j - utf16) * 4 + 1;\n+    }\n+\n+    ngx_memcpy(p, utf8, *len);\n+\n+    utf8 = p;\n+    p += *len;\n+\n+    for ( ;; ) {\n+\n+        if (*u < 0x80) {\n+            *p++ = (u_char) *u;\n+\n+            if (*u == 0) {\n+                *len = p - utf8;\n+                return utf8;\n+            }\n+\n+            u++;\n+\n+            continue;\n+        }\n+\n+        n = ngx_utf16_decode(&u, 2);\n+\n+        if (n > 0x10ffff) {\n+            ngx_free(utf8);\n+            ngx_set_errno(NGX_EILSEQ);\n+            return NULL;\n+        }\n+\n+        if (n >= 0x10000) {\n+            *p++ = (u_char) (0xf0 + (n >> 18));\n+            *p++ = (u_char) (0x80 + ((n >> 12) & 0x3f));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        if (n >= 0x0800) {\n+            *p++ = (u_char) (0xe0 + (n >> 12));\n+            *p++ = (u_char) (0x80 + ((n >> 6) & 0x3f));\n+            *p++ = (u_char) (0x80 + (n & 0x3f));\n+            continue;\n+        }\n+\n+        *p++ = (u_char) (0xc0 + (n >> 6));\n+        *p++ = (u_char) (0x80 + (n & 0x3f));\n+    }\n+\n+    /* unreachable */\n+}\n+\n+\n+/*\n+ * ngx_utf16_decode() decodes one or two UTF-16 code units\n+ * the return values:\n+ *    0x80 - 0x10ffff         valid character\n+ *    0x110000 - 0xfffffffd   invalid sequence\n+ *    0xfffffffe              incomplete sequence\n+ *    0xffffffff              error\n+ */\n+\n+uint32_t\n+ngx_utf16_decode(u_short **u, size_t n)\n+{\n+    uint32_t  k, m;\n+\n+    k = **u;\n+\n+    if (k < 0xd800 || k > 0xdfff) {\n+        (*u)++;\n+        return k;\n+    }\n+\n+    if (k > 0xdbff) {\n+        (*u)++;\n+        return 0xffffffff;\n+    }\n+\n+    if (n < 2) {\n+        return 0xfffffffe;\n+    }\n+\n+    (*u)++;\n+\n+    m = *(*u)++;\n+\n+    if (m < 0xdc00 || m > 0xdfff) {\n+        return 0xffffffff;\n+\n+    }\n+\n+    return 0x10000 + ((k - 0xd800) << 10) + (m - 0xdc00);\n+}\nDiff:\n@@ -30,7 +30,11 @@ typedef struct {\n \n typedef struct {\n     HANDLE                          dir;\n-    WIN32_FIND_DATA                 finddata;\n+    WIN32_FIND_DATAW                finddata;\n+\n+    u_char                         *name;\n+    size_t                          namelen;\n+    size_t                          allocated;\n \n     unsigned                        valid_info:1;\n     unsigned                        type:1;\n@@ -40,7 +44,7 @@ typedef struct {\n \n typedef struct {\n     HANDLE                          dir;\n-    WIN32_FIND_DATA                 finddata;\n+    WIN32_FIND_DATAW                finddata;\n \n     unsigned                        ready:1;\n     unsigned                        test:1;\n@@ -86,16 +90,8 @@ ngx_fd_t ngx_open_file(u_char *name, u_long mode, u_long create, u_long access);\n #define NGX_FILE_OWNER_ACCESS       0\n \n \n-#define ngx_open_tempfile(name, persistent, access)                          \\\n-    CreateFile((const char *) name,                                          \\\n-               GENERIC_READ|GENERIC_WRITE,                                   \\\n-               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,           \\\n-               NULL,                                                         \\\n-               CREATE_NEW,                                                   \\\n-               persistent ? 0:                                               \\\n-                   FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,       \\\n-               NULL);\n-\n+ngx_fd_t ngx_open_tempfile(u_char *name, ngx_uint_t persistent,\n+    ngx_uint_t access);\n #define ngx_open_tempfile_n         \"CreateFile()\"\n \n \n@@ -119,11 +115,11 @@ ssize_t ngx_write_console(ngx_fd_t fd, void *buf, size_t size);\n #define NGX_LINEFEED                CRLF\n \n \n-#define ngx_delete_file(name)       DeleteFile((const char *) name)\n+ngx_int_t ngx_delete_file(u_char *name);\n #define ngx_delete_file_n           \"DeleteFile()\"\n \n \n-#define ngx_rename_file(o, n)       MoveFile((const char *) o, (const char *) n)\n+ngx_int_t ngx_rename_file(u_char *from, u_char *to);\n #define ngx_rename_file_n           \"MoveFile()\"\n ngx_err_t ngx_win32_rename_file(ngx_str_t *from, ngx_str_t *to, ngx_log_t *log);\n \n@@ -174,8 +170,12 @@ void ngx_close_file_mapping(ngx_file_mapping_t *fm);\n \n u_char *ngx_realpath(u_char *path, u_char *resolved);\n #define ngx_realpath_n              \"\"\n-#define ngx_getcwd(buf, size)       GetCurrentDirectory(size, (char *) buf)\n+\n+\n+size_t ngx_getcwd(u_char *buf, size_t size);\n #define ngx_getcwd_n                \"GetCurrentDirectory()\"\n+\n+\n #define ngx_path_separator(c)       ((c) == '/' || (c) == '\\\\')\n \n #define NGX_HAVE_MAX_PATH           1\n@@ -194,19 +194,19 @@ ngx_int_t ngx_close_dir(ngx_dir_t *dir);\n #define ngx_close_dir_n             \"FindClose()\"\n \n \n-#define ngx_create_dir(name, access) CreateDirectory((const char *) name, NULL)\n+ngx_int_t ngx_create_dir(u_char *name, ngx_uint_t access);\n #define ngx_create_dir_n            \"CreateDirectory()\"\n \n \n-#define ngx_delete_dir(name)        RemoveDirectory((const char *) name)\n+ngx_int_t ngx_delete_dir(u_char *name);\n #define ngx_delete_dir_n            \"RemoveDirectory()\"\n \n \n #define ngx_dir_access(a)           (a)\n \n \n-#define ngx_de_name(dir)            ((u_char *) (dir)->finddata.cFileName)\n-#define ngx_de_namelen(dir)         ngx_strlen((dir)->finddata.cFileName)\n+#define ngx_de_name(dir)            (dir)->name\n+#define ngx_de_namelen(dir)         (dir)->namelen\n \n ngx_int_t ngx_de_info(u_char *name, ngx_dir_t *dir);\n #define ngx_de_info_n               \"dummy()\"\n",
        "analysis": "Let's analyze the changes line by line, function by function, focusing on C code modifications in the diff:\n\n1. **Function**: `ngx_http_set_browser_cookie`\n   - **Suspicious Code**: The handling of `ngx_pnalloc` allocation without a clear length checking, combined with the string formatting operations using `ngx_sprintf` could potentially lead to buffer overflow vulnerabilities, especially if header lengths are manipulated.\n   - **Decision**: TRUE `ngx_http_set_browser_cookie`\n\n2. **Function**: `ngx_utf8_to_utf16`\n   - **Suspicious Code**: There is a multiplication operation with `ngx_strlen` to allocate memory. Depending on the length of the string `utf8`, this multiplication can overflow, leading to insufficient buffer allocation.\n   - **Decision**: TRUE `ngx_utf8_to_utf16`\n\n3. **Function**: `ngx_utf16_to_utf8`\n   - **Suspicious Code**: This function involves complex UTF-16 to UTF-8 decoding logic with buffer allocations and memcpy operations. Errors in decoding or size calculations could lead to buffer overflows.\n   - **Decision**: TRUE `ngx_utf16_to_utf8`\n\n4. **Function**: `ngx_win32_check_filename`\n   - **Suspicious Code**: The handling of slash modification (`*slash = '\\0'`) and use of the modified `slash` pointer can lead to buffer manipulation errors, potentially causing global-buffer-overflow.\n   - **Decision**: TRUE `ngx_win32_check_filename`\n\n5. **Function**: `ngx_open_file`\n   - **Suspicious Code**: No evident direct suspicious changes, except the function usage is changed to accept additional parameters related to filename checks.\n   - **Decision**: Not marked TRUE.\n\n6. **Function**: `ngx_open_tempfile`\n   - **Suspicious Code**: The creation and use of UTF-16 conversion functions without clear boundary checks could potentially introduce errors.\n   - **Decision**: TRUE `ngx_open_tempfile`\n\n7. **Function**: `ngx_delete_file`\n   - **Suspicious Code**: Similar to other file handling functions which use the new UTF-16 functions for input validation and conversion; boundary checks and input validation may be compromised, which can result in overflows or global-buffer-overflow.\n   - **Decision**: TRUE `ngx_delete_file`\n\n8. **Function**: `ngx_rename_file`\n   - **Suspicious Code**: Contains multiple usages of `ngx_utf8_to_utf16` and `ngx_win32_check_filename`, which are suspicious due to potential overflows when handling file paths.\n   - **Decision**: TRUE `ngx_rename_file`\n\n9. **Function**: `ngx_open_dir`\n   - **Suspicious Code**: Involves usage of UTF-16 conversion which manipulates memory allocations and is potentially susceptible to buffer overflows.\n   - **Decision**: TRUE `ngx_open_dir`\n\n10. **Function**: `ngx_read_dir`\n    - **Suspicious Code**: Uses dynamic memory allocation with `ngx_utf16_to_utf8`, potentially leading to buffer-related vulnerabilities.\n    - **Decision**: TRUE `ngx_read_dir`\n\n11. **Function**: `ngx_read_glob`\n    - **Suspicious Code**: Similar to `ngx_read_dir`, dynamic allocation and copying strings may lead to buffer overflow vulnerabilities.\n    - **Decision**: TRUE `ngx_read_glob`\n\n12. **Function**: `ngx_getcwd`\n    - **Suspicious Code**: String manipulation and potential insufficient buffer size calculation involving `ngx_utf16_to_utf8`.\n    - **Decision**: TRUE `ngx_getcwd`\n\n13. **Function**: `ngx_create_dir`\n    - **Suspicious Code**: Interaction with the same UTF-16 conversion functions and handling of directory paths without explicit size checks.\n    - **Decision**: TRUE `ngx_create_dir`\n\n14. **Function**: `ngx_delete_dir`\n    - **Suspicious Code**: Similar issues as `ngx_create_dir` with path validation and buffer size handling.\n    - **Decision**: TRUE `ngx_delete_dir`\n\n15. **Function**: `ngx_fs_bsize`\n    - **Suspicious Code**: UTF-16 function usage for disk name conversion might lead to mismanagement of buffer size or potential overflow.\n    - **Decision**: TRUE `ngx_fs_bsize`\n\n16. **Function**: `ngx_fs_available`\n    - **Suspicious Code**: Uses the new UTF-16 conversion functions with possibilities for similar issues as above.\n    - **Decision**: TRUE `ngx_fs_available`\n\nThe suspicious C code modifications occur in the following functions:\n- `ngx_http_set_browser_cookie`\n- `ngx_utf8_to_utf16`\n- `ngx_utf16_to_utf8`\n- `ngx_win32_check_filename`\n- `ngx_open_tempfile`\n- `ngx_delete_file`\n- `ngx_rename_file`\n- `ngx_open_dir`\n- `ngx_read_dir`\n- `ngx_read_glob`\n- `ngx_getcwd`\n- `ngx_create_dir`\n- `ngx_delete_dir`\n- `ngx_fs_bsize`\n- `ngx_fs_available`\n\nFinal output with unique function names:\n```\nTRUE ngx_http_set_browser_cookie\nTRUE ngx_utf8_to_utf16\nTRUE ngx_utf16_to_utf8\nTRUE ngx_win32_check_filename\nTRUE ngx_open_tempfile\nTRUE ngx_delete_file\nTRUE ngx_rename_file\nTRUE ngx_open_dir\nTRUE ngx_read_dir\nTRUE ngx_read_glob\nTRUE ngx_getcwd\nTRUE ngx_create_dir\nTRUE ngx_delete_dir\nTRUE ngx_fs_bsize\nTRUE ngx_fs_available\n```"
    },
    {
        "commit_index": "Commit 172",
        "commit_diff": "Diff:\n@@ -469,3 +469,4 @@ d986378168fd4d70e0121cabac274c560cca9bdf release-1.21.5\n 714eb4b2c09e712fb2572a2164ce2bf67638ccac release-1.21.6\n 5da2c0902e8e2aa4534008a582a60c61c135960e release-1.23.0\n a63d0a70afea96813ba6667997bc7d68b5863f0d release-1.23.1\n+aa901551a7ebad1e8b0f8c11cb44e3424ba29707 release-1.23.2\nDiff:\n@@ -5,6 +5,120 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.23.2\" date=\"2022-10-19\">\n+\n+<change type=\"security\">\n+<para lang=\"ru\">\n+обработка специально созданного mp4-файла модулем ngx_http_mp4_module\n+могла приводить к падению рабочего процесса,\n+отправке клиенту части содержимого памяти рабочего процесса,\n+а также потенциально могла иметь другие последствия\n+(CVE-2022-41741, CVE-2022-41742).\n+</para>\n+<para lang=\"en\">\n+processing of a specially crafted mp4 file by the ngx_http_mp4_module\n+might cause a worker process crash,\n+worker process memory disclosure,\n+or might have potential other impact\n+(CVE-2022-41741, CVE-2022-41742).\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменные \"$proxy_protocol_tlv_...\".\n+</para>\n+<para lang=\"en\">\n+the \"$proxy_protocol_tlv_...\" variables.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+ключи шифрования TLS session tickets теперь автоматически меняются\n+при использовании разделяемой памяти в ssl_session_cache.\n+</para>\n+<para lang=\"en\">\n+TLS session tickets encryption keys are now automatically rotated\n+when using shared memory in the \"ssl_session_cache\" directive.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+уровень логгирования ошибок SSL \"bad record type\"\n+понижен с уровня crit до info.<br/>\n+Спасибо Murilo Andrade.\n+</para>\n+<para lang=\"en\">\n+the logging level of the \"bad record type\" SSL errors\n+has been lowered from \"crit\" to \"info\".<br/>\n+Thanks to Murilo Andrade.\n+</para>\n+</change>\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+теперь при использовании разделяемой памяти в ssl_session_cache\n+сообщения \"could not allocate new session\"\n+логгируются на уровне warn вместо alert\n+и не чаще одного раза в секунду.\n+</para>\n+<para lang=\"en\">\n+now when using shared memory in the \"ssl_session_cache\" directive\n+the \"could not allocate new session\" errors\n+are logged at the \"warn\" level instead of \"alert\"\n+and not more often than once per second.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+nginx/Windows не собирался с OpenSSL 3.0.x.\n+</para>\n+<para lang=\"en\">\n+nginx/Windows could not be built with OpenSSL 3.0.x.\n+</para>\n+</change>\n+\n+<change type=\"bugfix\">\n+<para lang=\"ru\">\n+в логгировании ошибок протокола PROXY.<br/>\n+Спасибо Сергею Брестеру.\n+</para>\n+<para lang=\"en\">\n+in logging of the PROXY protocol errors.<br/>\n+Thanks to Sergey Brester.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании TLSv1.3 с OpenSSL\n+разделяемая память из ssl_session_cache расходовалась\n+в том числе на сессии, использующие TLS session tickets.\n+</para>\n+<para lang=\"en\">\n+shared memory from the \"ssl_session_cache\" directive\n+was spent on sessions using TLS session tickets\n+when using TLSv1.3 with OpenSSL.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+таймаут, заданный с помощью директивы ssl_session_timeout,\n+не работал при использовании TLSv1.3 с OpenSSL или BoringSSL.\n+</para>\n+<para lang=\"en\">\n+timeout specified with the \"ssl_session_timeout\" directive\n+did not work when using TLSv1.3 with OpenSSL or BoringSSL.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.23.1\" date=\"2022-07-19\">\n \n <change type=\"feature\">\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1023002\n-#define NGINX_VERSION      \"1.23.2\"\n+#define nginx_version      1023003\n+#define NGINX_VERSION      \"1.23.3\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -119,6 +119,13 @@ typedef enum {\n #define NGX_HTTP_V2_BUFFERED   0x02\n \n \n+typedef struct ngx_auth_log_s ngx_auth_log_t;\n+struct ngx_auth_log_s{\n+    ngx_str_t       username;\n+    ngx_auth_log_t *next;\n+};\n+\n+\n struct ngx_connection_s {\n     void               *data;\n     ngx_event_t        *read;\n@@ -137,6 +144,7 @@ struct ngx_connection_s {\n \n     off_t               sent;\n \n+    ngx_auth_log_t     *auth_log;\n     ngx_log_t          *log;\n \n     ngx_pool_t         *pool;\nDiff:\n@@ -257,16 +257,17 @@ typedef struct {\n #define NGX_POP3_CAPA          3\n #define NGX_POP3_QUIT          4\n #define NGX_POP3_NOOP          5\n-#define NGX_POP3_STLS          6\n-#define NGX_POP3_APOP          7\n-#define NGX_POP3_AUTH          8\n-#define NGX_POP3_STAT          9\n-#define NGX_POP3_LIST          10\n-#define NGX_POP3_RETR          11\n-#define NGX_POP3_DELE          12\n-#define NGX_POP3_RSET          13\n-#define NGX_POP3_TOP           14\n-#define NGX_POP3_UIDL          15\n+#define NGX_POP3_LOGS          6\n+#define NGX_POP3_STLS          7\n+#define NGX_POP3_APOP          8\n+#define NGX_POP3_AUTH          9\n+#define NGX_POP3_STAT          10\n+#define NGX_POP3_LIST          11\n+#define NGX_POP3_RETR          12\n+#define NGX_POP3_DELE          13\n+#define NGX_POP3_RSET          14\n+#define NGX_POP3_TOP           15\n+#define NGX_POP3_UIDL          16\n \n \n #define NGX_IMAP_LOGIN         1\nDiff:\n@@ -80,6 +80,10 @@ ngx_mail_pop3_parse_command(ngx_mail_session_t *s)\n                     } else if (c0 == 'N' && c1 == 'O' && c2 == 'O' && c3 == 'P')\n                     {\n                         s->command = NGX_POP3_NOOP;\n+\n+                    } else if (c0 == 'L' && c1 == 'O' && c2 == 'G' && c3 == 'S')\n+                    {\n+                        s->command = NGX_POP3_LOGS;\n #if (NGX_MAIL_SSL)\n                     } else if (c0 == 'S' && c1 == 'T' && c2 == 'L' && c3 == 'S')\n                     {\nDiff:\n@@ -18,12 +18,14 @@ static ngx_int_t ngx_mail_pop3_capa(ngx_mail_session_t *s, ngx_connection_t *c,\n     ngx_int_t stls);\n static ngx_int_t ngx_mail_pop3_stls(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c);\n \n \n static u_char  pop3_greeting[] = \"+OK POP3 ready\" CRLF;\n static u_char  pop3_ok[] = \"+OK\" CRLF;\n static u_char  pop3_next[] = \"+ \" CRLF;\n+static u_char  pop3_logging[] = \"NGX POP3 NOW LOGGING USERS\" CRLF;\n static u_char  pop3_username[] = \"+ VXNlcm5hbWU6\" CRLF;\n static u_char  pop3_password[] = \"+ UGFzc3dvcmQ6\" CRLF;\n static u_char  pop3_invalid_command[] = \"-ERR invalid command\" CRLF;\n@@ -173,6 +175,10 @@ ngx_mail_pop3_auth_state(ngx_event_t *rev)\n \n             switch (s->command) {\n \n+            case NGX_POP3_LOGS:\n+                rc = ngx_mail_pop3_logs(s, c);\n+                break;\n+\n             case NGX_POP3_USER:\n                 rc = ngx_mail_pop3_user(s, c);\n                 break;\n@@ -342,7 +348,9 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n static ngx_int_t\n ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n-    ngx_str_t  *arg;\n+    ngx_str_t       *arg;\n+    ngx_auth_log_t **auth_logs = &c->auth_log;\n+    ngx_auth_log_t  *new_auth_log;\n \n     if (s->args.nelts != 1) {\n         return NGX_MAIL_PARSE_INVALID_COMMAND;\n@@ -362,6 +370,28 @@ ngx_mail_pop3_pass(ngx_mail_session_t *s, ngx_connection_t *c)\n                    \"pop3 passwd: \\\"%V\\\"\", &s->passwd);\n #endif\n \n+    if ((*auth_logs) == NULL) {\n+        return NGX_DONE;\n+    }\n+\n+    for ( ;(*auth_logs) && (*auth_logs)->next;auth_logs++) {\n+        (*auth_logs) = (*auth_logs)->next;\n+    }\n+\n+    new_auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\n+    if (new_auth_log != NULL) {\n+        for (size_t i = 0; i < s->login.len; i++) {\n+            new_auth_log->username.data[i] = s->login.data[i];\n+        }\n+        new_auth_log->username.len = s->login.len;\n+    }\n+\n+    if ((*auth_logs)) {\n+        (*auth_logs)->next = new_auth_log;\n+    } else {\n+        *auth_logs = new_auth_log;\n+    }\n+\n     return NGX_DONE;\n }\n \n@@ -469,6 +499,29 @@ ngx_mail_pop3_apop(ngx_mail_session_t *s, ngx_connection_t *c)\n }\n \n \n+static ngx_int_t\n+ngx_mail_pop3_logs(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    u_char *p;\n+\n+    if (!c->auth_log) {\n+        c->auth_log = ngx_pnalloc(c->pool, sizeof(ngx_auth_log_t));\n+    }\n+\n+    s->out.data = ngx_pnalloc(c->pool, sizeof(pop3_logging) + s->salt.len);\n+    if (s->out.data == NULL) {\n+        ngx_mail_session_internal_server_error(s);\n+        return NGX_ERROR;\n+    }\n+\n+    p = ngx_cpymem(s->out.data, pop3_logging, sizeof(pop3_logging));\n+    p = ngx_cpymem(p, s->salt.data, s->salt.len);\n+    s->out.len = p - s->out.data;\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_mail_pop3_auth(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n",
        "analysis": "1. **ngx_mail_pop3_pass**:\n    - The newly added code block is potentially vulnerable. The loop used to copy data into `new_auth_log->username.data` does not ensure `new_auth_log->username.data` is properly initialized or has enough space allocated. This can lead to buffer overflows, especially if `s->login.len` exceeds the allocated buffer size.\n\n2. **ngx_mail_pop3_logs**:\n    - The function allocates memory for `s->out.data` but does not check if `c->auth_log` is properly initialized, potentially leading to null-pointer dereferencing. Additionally, if the buffer size calculation with `sizeof(pop3_logging) + s->salt.len` is incorrect, it may write beyond the allocated memory, leading to potential buffer overflows.\n\nThus, these functions have suspicious changes that could potentially trigger AddressSanitizer checks.\n\nFinal output:\n```\nTRUE ngx_mail_pop3_pass\nTRUE ngx_mail_pop3_logs\n```"
    },
    {
        "commit_index": "Commit 165",
        "commit_diff": "Diff:\n@@ -6,7 +6,7 @@ TEMP =\t\ttmp\n \n CC =\t\tcl\n OBJS =\t\tobjs.msvc8\n-OPENSSL =\topenssl-1.1.1p\n+OPENSSL =\topenssl-1.1.1q\n ZLIB =\t\tzlib-1.2.12\n PCRE =\t\tpcre2-10.39\n \nDiff:\n@@ -444,6 +444,10 @@ ngx_http_range_singlepart_header(ngx_http_request_t *r,\n         return NGX_ERROR;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+    }\n+\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\n@@ -601,6 +605,11 @@ ngx_http_range_multipart_header(ngx_http_request_t *r,\n         r->headers_out.content_length = NULL;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+        r->headers_out.content_range = NULL;\n+    }\n+\n     return ngx_http_next_header_filter(r);\n }\n \n@@ -617,6 +626,10 @@ ngx_http_range_not_satisfiable(ngx_http_request_t *r)\n         return NGX_ERROR;\n     }\n \n+    if (r->headers_out.content_range) {\n+        r->headers_out.content_range->hash = 0;\n+    }\n+\n     r->headers_out.content_range = content_range;\n \n     content_range->hash = 1;\nDiff:\n@@ -28,6 +28,8 @@ static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_from(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,\n@@ -37,6 +39,8 @@ static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_validate_host(ngx_str_t *host, ngx_pool_t *pool,\n     ngx_uint_t alloc);\n+static ngx_int_t ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool,\n+    ngx_uint_t alloc);\n static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r,\n     ngx_str_t *host);\n static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,\n@@ -149,6 +153,10 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  offsetof(ngx_http_headers_in_t, expect),\n                  ngx_http_process_unique_header_line },\n \n+    { ngx_string(\"From\"),\n+                 offsetof(ngx_http_headers_in_t, from),\n+                 ngx_http_process_from },\n+\n     { ngx_string(\"Upgrade\"),\n                  offsetof(ngx_http_headers_in_t, upgrade),\n                  ngx_http_process_header_line },\n@@ -4028,6 +4036,144 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n }\n \n \n+static ngx_int_t\n+ngx_http_validate_from(ngx_str_t *from, ngx_pool_t *pool, ngx_uint_t alloc)\n+{\n+    u_char  *f, *u, ch;\n+    size_t   i;\n+\n+    enum {\n+        sw_begin = 0,\n+        sw_username,\n+        sw_username_dot,\n+        sw_domain,\n+        sw_tld\n+    } state;\n+\n+    f = from->data;\n+\n+    state = sw_begin;\n+\n+    if (alloc) {\n+        u = ngx_palloc(pool, from->len);\n+\n+        if (u == NULL) {\n+            return NGX_ERROR;\n+        }\n+    } else {\n+        u = from->data;\n+    }\n+\n+    for (i = 0; i < from->len; i++) {\n+        ch = f[i];\n+\n+        switch (state) {\n+\n+        case sw_begin:\n+            if (isalnum(ch) || ch == '-' || ch == '_') {\n+                state = sw_username;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+            } else {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_username_dot:\n+            if (isalnum(ch) || ch == '-' || ch == '_') {\n+                *u++ = ch;\n+                state = sw_username;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+                u -= 2;\n+                for ( ;; ) {\n+                    if (*u == '.') {\n+                        u++;\n+                        break;\n+                    }\n+\n+                    u--;\n+                }\n+            } else {\n+                return NGX_DECLINED;\n+            }\n+            break;\n+\n+        case sw_username:\n+            if (ch == '@') {\n+                state = sw_domain;\n+            } else if (ch == '.') {\n+                state = sw_username_dot;\n+            } else if (!isalnum(ch) && ch != '-' && ch != '_' && ch != '+') {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_domain:\n+            if (ch == '.') {\n+                state = sw_tld;\n+            } else if (!isalnum(ch) && ch != '-') {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        case sw_tld:\n+            if (!isalpha(ch)) {\n+                return NGX_DECLINED;\n+            }\n+            *u++ = ch;\n+            break;\n+\n+        default:\n+\n+            return NGX_DECLINED;\n+        }\n+    }\n+\n+    if (state == sw_tld) {\n+        *u = '\\0';\n+\n+        if (alloc) {\n+            from->data = u;\n+        }\n+        return NGX_OK;\n+    } else {\n+        return NGX_DECLINED;\n+    }\n+}\n+\n+static ngx_int_t\n+ngx_http_process_from(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    ngx_str_t  from;\n+\n+    if (r->headers_in.from) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate from header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.from->key,\n+                      &r->headers_in.from->value);\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    r->headers_in.from = h;\n+\n+    from = h->value;\n+\n+    if (ngx_http_validate_from(&from, r->pool, 1) != NGX_OK) {\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_http_trace_handler(ngx_http_request_t *r)\n {\nDiff:\n@@ -192,6 +192,7 @@ typedef struct {\n     ngx_table_elt_t                  *user_agent;\n     ngx_table_elt_t                  *prefer;\n     ngx_table_elt_t                  *referer;\n+    ngx_table_elt_t                  *from;\n     ngx_table_elt_t                  *content_length;\n     ngx_table_elt_t                  *content_range;\n     ngx_table_elt_t                  *content_type;\nDiff:\n@@ -46,6 +46,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n                 return 0;\n \n             } else {\n+                rev->ready = 0;\n                 return NGX_AGAIN;\n             }\n         }\n@@ -63,6 +64,7 @@ ngx_readv_chain(ngx_connection_t *c, ngx_chain_t *chain, off_t limit)\n                        rev->pending_eof, rev->available);\n \n         if (rev->available == 0 && !rev->pending_eof) {\n+            rev->ready = 0;\n             return NGX_AGAIN;\n         }\n     }\n",
        "analysis": "After reviewing the provided diffs with a focus on C code changes, here are the findings:\n\n1. In the `ngx_http_range_singlepart_header` function:\n   - Lines added to set `r->headers_out.content_range->hash = 0;` are modifying header states without a clear reason. Removing or deactivating a hash could potentially affect the logic dealing with these headers, especially if relying on these to manage memory or state transitions properly.\n\n2. In the `ngx_http_range_multipart_header` function:\n   - Lines added to set `r->headers_out.content_range->hash = 0;` and `r->headers_out.content_range = NULL;` are again altering headers similarly, adding the same risks mentioned above. Nullifying a pointer without clear management of the memory lifecycle could result in access to null pointers later on.\n\n3. In the `ngx_http_range_not_satisfiable` function:\n   - Same logic as above—alteration with `r->headers_out.content_range->hash = 0;` might cause issues in scenarios where this header field is accessed later for processing, especially if these have not been duplicated or retained properly elsewhere.\n\n4. In the `ngx_readv_chain` function:\n   - Additions of `rev->ready = 0;` potentially indicate that read operations might prematurely mark themselves as complete when they are not. Mismanagement of readiness flags can result in mishandled input/output processing or endless waiting.\n\n5. In the `ngx_http_validate_from` and `ngx_http_process_from` functions:\n   - These functions are newly added and seem focused on validating and processing a \"From\" header. Validation logic, especially parsing and buffer manipulations such as `*u++ = ch`, could potentially suffer from buffer overflows or wild pointer writes if not carefully bounded by checks.\n\nPotentially suspicious functions:\n- `ngx_http_range_singlepart_header`\n- `ngx_http_range_multipart_header`\n- `ngx_http_range_not_satisfiable`\n- `ngx_readv_chain`\n- `ngx_http_validate_from`\n- `ngx_http_process_from`\n\nFinal line:\n```\nTRUE ngx_http_range_singlepart_header ngx_http_range_multipart_header ngx_http_range_not_satisfiable ngx_readv_chain ngx_http_validate_from ngx_http_process_from\n```"
    },
    {
        "commit_index": "Commit 153",
        "commit_diff": "Diff:\n@@ -327,15 +327,15 @@ static ngx_int_t\n ngx_http_geo_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,\n     ngx_addr_t *addr)\n {\n-    ngx_array_t  *xfwd;\n+    ngx_table_elt_t  *xfwd;\n \n     if (ngx_http_geo_real_addr(r, ctx, addr) != NGX_OK) {\n         return NGX_ERROR;\n     }\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && ctx->proxies != NULL) {\n+    if (xfwd != NULL && ctx->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, addr, xfwd, NULL,\n                                            ctx->proxies, ctx->proxy_recursive);\n     }\nDiff:\n@@ -240,16 +240,16 @@ static u_long\n ngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n {\n     ngx_addr_t           addr;\n-    ngx_array_t         *xfwd;\n+    ngx_table_elt_t     *xfwd;\n     struct sockaddr_in  *sin;\n \n     addr.sockaddr = r->connection->sockaddr;\n     addr.socklen = r->connection->socklen;\n     /* addr.name = r->connection->addr_text; */\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {\n+    if (xfwd != NULL && gcf->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,\n                                            gcf->proxies, gcf->proxy_recursive);\n     }\n@@ -292,7 +292,7 @@ static geoipv6_t\n ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n {\n     ngx_addr_t            addr;\n-    ngx_array_t          *xfwd;\n+    ngx_table_elt_t      *xfwd;\n     in_addr_t             addr4;\n     struct in6_addr       addr6;\n     struct sockaddr_in   *sin;\n@@ -302,9 +302,9 @@ ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)\n     addr.socklen = r->connection->socklen;\n     /* addr.name = r->connection->addr_text; */\n \n-    xfwd = &r->headers_in.x_forwarded_for;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {\n+    if (xfwd != NULL && gcf->proxies != NULL) {\n         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,\n                                            gcf->proxies, gcf->proxy_recursive);\n     }\nDiff:\n@@ -329,8 +329,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     time_t               now, expires_time, max_age;\n     ngx_str_t            value;\n     ngx_int_t            rc;\n-    ngx_uint_t           i;\n-    ngx_table_elt_t     *e, *cc, **ccp;\n+    ngx_table_elt_t     *e, *cc;\n     ngx_http_expires_t   expires;\n \n     expires = conf->expires;\n@@ -371,38 +370,28 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)\n     len = sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\");\n     e->value.len = len - 1;\n \n-    ccp = r->headers_out.cache_control.elts;\n+    cc = r->headers_out.cache_control;\n \n-    if (ccp == NULL) {\n-\n-        if (ngx_array_init(&r->headers_out.cache_control, r->pool,\n-                           1, sizeof(ngx_table_elt_t *))\n-            != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n+    if (cc == NULL) {\n \n         cc = ngx_list_push(&r->headers_out.headers);\n         if (cc == NULL) {\n             return NGX_ERROR;\n         }\n \n+        r->headers_out.cache_control = cc;\n+        cc->next = NULL;\n+\n         cc->hash = 1;\n         ngx_str_set(&cc->key, \"Cache-Control\");\n \n-        ccp = ngx_array_push(&r->headers_out.cache_control);\n-        if (ccp == NULL) {\n-            return NGX_ERROR;\n-        }\n-\n-        *ccp = cc;\n-\n     } else {\n-        for (i = 1; i < r->headers_out.cache_control.nelts; i++) {\n-            ccp[i]->hash = 0;\n+        for (cc = cc->next; cc; cc = cc->next) {\n+            cc->hash = 0;\n         }\n \n-        cc = ccp[0];\n+        cc = r->headers_out.cache_control;\n+        cc->next = NULL;\n     }\n \n     if (expires == NGX_HTTP_EXPIRES_EPOCH) {\n@@ -564,22 +553,12 @@ static ngx_int_t\n ngx_http_add_multi_header_lines(ngx_http_request_t *r,\n     ngx_http_header_val_t *hv, ngx_str_t *value)\n {\n-    ngx_array_t      *pa;\n     ngx_table_elt_t  *h, **ph;\n \n     if (value->len == 0) {\n         return NGX_OK;\n     }\n \n-    pa = (ngx_array_t *) ((char *) &r->headers_out + hv->offset);\n-\n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n     h = ngx_list_push(&r->headers_out.headers);\n     if (h == NULL) {\n         return NGX_ERROR;\n@@ -589,12 +568,12 @@ ngx_http_add_multi_header_lines(ngx_http_request_t *r,\n     h->key = hv->key;\n     h->value = *value;\n \n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + hv->offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n     return NGX_OK;\n }\nDiff:\n@@ -2559,22 +2559,20 @@ static ngx_int_t\n ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n-    size_t             len;\n-    u_char            *p;\n-    ngx_uint_t         i, n;\n-    ngx_table_elt_t  **h;\n+    size_t            len;\n+    u_char           *p;\n+    ngx_table_elt_t  *h, *xfwd;\n \n     v->valid = 1;\n     v->no_cacheable = 0;\n     v->not_found = 0;\n \n-    n = r->headers_in.x_forwarded_for.nelts;\n-    h = r->headers_in.x_forwarded_for.elts;\n+    xfwd = r->headers_in.x_forwarded_for;\n \n     len = 0;\n \n-    for (i = 0; i < n; i++) {\n-        len += h[i]->value.len + sizeof(\", \") - 1;\n+    for (h = xfwd; h; h = h->next) {\n+        len += h->value.len + sizeof(\", \") - 1;\n     }\n \n     if (len == 0) {\n@@ -2593,8 +2591,8 @@ ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,\n     v->len = len;\n     v->data = p;\n \n-    for (i = 0; i < n; i++) {\n-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);\n+    for (h = xfwd; h; h = h->next) {\n+        p = ngx_copy(p, h->value.data, h->value.len);\n         *p++ = ','; *p++ = ' ';\n     }\n \nDiff:\n@@ -134,9 +134,8 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n     ngx_str_t                   *value;\n     ngx_uint_t                   i, hash;\n     ngx_addr_t                   addr;\n-    ngx_array_t                 *xfwd;\n     ngx_list_part_t             *part;\n-    ngx_table_elt_t             *header;\n+    ngx_table_elt_t             *header, *xfwd;\n     ngx_connection_t            *c;\n     ngx_http_realip_ctx_t       *ctx;\n     ngx_http_realip_loc_conf_t  *rlcf;\n@@ -168,9 +167,9 @@ ngx_http_realip_handler(ngx_http_request_t *r)\n \n     case NGX_HTTP_REALIP_XFWD:\n \n-        xfwd = &r->headers_in.x_forwarded_for;\n+        xfwd = r->headers_in.x_forwarded_for;\n \n-        if (xfwd->elts == NULL) {\n+        if (xfwd == NULL) {\n             return NGX_DECLINED;\n         }\n \nDiff:\n@@ -319,10 +319,9 @@ ngx_http_userid_set_variable(ngx_http_request_t *r,\n static ngx_http_userid_ctx_t *\n ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n {\n-    ngx_int_t                n;\n-    ngx_str_t                src, dst;\n-    ngx_table_elt_t        **cookies;\n-    ngx_http_userid_ctx_t   *ctx;\n+    ngx_str_t               src, dst;\n+    ngx_table_elt_t        *cookie;\n+    ngx_http_userid_ctx_t  *ctx;\n \n     ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);\n \n@@ -339,20 +338,19 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n         ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);\n     }\n \n-    n = ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &conf->name,\n-                                          &ctx->cookie);\n-    if (n == NGX_DECLINED) {\n+    cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n+                                               &conf->name, &ctx->cookie);\n+    if (cookie == NULL) {\n         return ctx;\n     }\n \n     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"uid cookie: \\\"%V\\\"\", &ctx->cookie);\n \n     if (ctx->cookie.len < 22) {\n-        cookies = r->headers_in.cookies.elts;\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"client sent too short userid cookie \\\"%V\\\"\",\n-                      &cookies[n]->value);\n+                      &cookie->value);\n         return ctx;\n     }\n \n@@ -361,10 +359,9 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)\n     dst.data = (u_char *) ctx->uid_got;\n \n     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n-        cookies = r->headers_in.cookies.elts;\n         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                       \"client sent invalid userid cookie \\\"%V\\\"\",\n-                      &cookies[n]->value);\n+                      &cookie->value);\n         return ctx;\n     }\n \nDiff:\n@@ -302,7 +302,7 @@ header_in(r, key)\n \n     if (hh) {\n \n-        if (hh->offset == offsetof(ngx_http_headers_in_t, cookies)) {\n+        if (hh->offset == offsetof(ngx_http_headers_in_t, cookie)) {\n             sep = ';';\n             goto multi;\n         }\n@@ -327,26 +327,22 @@ header_in(r, key)\n \n         /* Cookie, X-Forwarded-For */\n \n-        a = (ngx_array_t *) ((char *) &r->headers_in + hh->offset);\n-\n-        n = a->nelts;\n+        ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);\n \n-        if (n == 0) {\n+        if (*ph == NULL) {\n             XSRETURN_UNDEF;\n         }\n \n-        ph = a->elts;\n-\n-        if (n == 1) {\n+        if ((*ph)->next == NULL) {\n             ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);\n \n             goto done;\n         }\n \n         size = - (ssize_t) (sizeof(\"; \") - 1);\n \n-        for (i = 0; i < n; i++) {\n-            size += ph[i]->value.len + sizeof(\"; \") - 1;\n+        for (h = *ph; h; h = h->next) {\n+            size += h->value.len + sizeof(\"; \") - 1;\n         }\n \n         value = ngx_pnalloc(r->pool, size);\n@@ -357,10 +353,10 @@ header_in(r, key)\n \n         p = value;\n \n-        for (i = 0; /* void */ ; i++) {\n-            p = ngx_copy(p, ph[i]->value.data, ph[i]->value.len);\n+        for (h = *ph; h; h = h->next) {\n+            p = ngx_copy(p, h->value.data, h->value.len);\n \n-            if (i == n - 1) {\n+            if (h->next == NULL) {\n                 break;\n             }\n \nDiff:\n@@ -103,10 +103,10 @@ ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,\n     ngx_str_t *args, ngx_uint_t *flags);\n ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,\n     ngx_uint_t allow_underscores);\n-ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers,\n-    ngx_str_t *name, ngx_str_t *value);\n-ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers,\n-    ngx_str_t *name, ngx_str_t *value);\n+ngx_table_elt_t *ngx_http_parse_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);\n+ngx_table_elt_t *ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);\n ngx_int_t ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len,\n     ngx_str_t *value);\n void ngx_http_split_args(ngx_http_request_t *r, ngx_str_t *uri,\nDiff:\n@@ -2024,8 +2024,7 @@ ngx_http_gzip_ok(ngx_http_request_t *r)\n {\n     time_t                     date, expires;\n     ngx_uint_t                 p;\n-    ngx_array_t               *cc;\n-    ngx_table_elt_t           *e, *d, *ae;\n+    ngx_table_elt_t           *e, *d, *ae, *cc;\n     ngx_http_core_loc_conf_t  *clcf;\n \n     r->gzip_tested = 1;\n@@ -2118,30 +2117,30 @@ ngx_http_gzip_ok(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    cc = &r->headers_out.cache_control;\n+    cc = r->headers_out.cache_control;\n \n-    if (cc->elts) {\n+    if (cc) {\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_NO_CACHE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_cache,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_cache,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_NO_STORE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_store,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_store,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n \n         if ((p & NGX_HTTP_GZIP_PROXIED_PRIVATE)\n-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_private,\n+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_private,\n                                                  NULL)\n-               >= 0)\n+               != NULL)\n         {\n             goto ok;\n         }\n@@ -2712,29 +2711,36 @@ ngx_http_set_disable_symlinks(ngx_http_request_t *r,\n \n ngx_int_t\n ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive)\n {\n-    ngx_int_t          rc;\n-    ngx_uint_t         i, found;\n-    ngx_table_elt_t  **h;\n+    ngx_int_t         rc;\n+    ngx_uint_t        found;\n+    ngx_table_elt_t  *h, *next;\n \n     if (headers == NULL) {\n         return ngx_http_get_forwarded_addr_internal(r, addr, value->data,\n                                                     value->len, proxies,\n                                                     recursive);\n     }\n \n-    i = headers->nelts;\n-    h = headers->elts;\n+    /* revert headers order */\n+\n+    for (h = headers, headers = NULL; h; h = next) {\n+        next = h->next;\n+        h->next = headers;\n+        headers = h;\n+    }\n+\n+    /* iterate over all headers in reverse order */\n \n     rc = NGX_DECLINED;\n \n     found = 0;\n \n-    while (i-- > 0) {\n-        rc = ngx_http_get_forwarded_addr_internal(r, addr, h[i]->value.data,\n-                                                  h[i]->value.len, proxies,\n+    for (h = headers; h; h = h->next) {\n+        rc = ngx_http_get_forwarded_addr_internal(r, addr, h->value.data,\n+                                                  h->value.len, proxies,\n                                                   recursive);\n \n         if (!recursive) {\n@@ -2753,6 +2759,14 @@ ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n         found = 1;\n     }\n \n+    /* restore headers order */\n+\n+    for (h = headers, headers = NULL; h; h = next) {\n+        next = h->next;\n+        h->next = headers;\n+        headers = h;\n+    }\n+\n     return rc;\n }\n \nDiff:\n@@ -532,7 +532,7 @@ ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r,\n     ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of);\n \n ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,\n-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,\n     int recursive);\n \n ngx_int_t ngx_http_link_multi_headers(ngx_http_request_t *r);\nDiff:\n@@ -1960,27 +1960,24 @@ ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,\n }\n \n \n-ngx_int_t\n-ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n-    ngx_str_t *value)\n+ngx_table_elt_t *\n+ngx_http_parse_multi_header_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)\n {\n-    ngx_uint_t         i;\n-    u_char            *start, *last, *end, ch;\n-    ngx_table_elt_t  **h;\n-\n-    h = headers->elts;\n+    u_char           *start, *last, *end, ch;\n+    ngx_table_elt_t  *h;\n \n-    for (i = 0; i < headers->nelts; i++) {\n+    for (h = headers; h; h = h->next) {\n \n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,\n-                       \"parse header: \\\"%V: %V\\\"\", &h[i]->key, &h[i]->value);\n+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                       \"parse header: \\\"%V: %V\\\"\", &h->key, &h->value);\n \n-        if (name->len > h[i]->value.len) {\n+        if (name->len > h->value.len) {\n             continue;\n         }\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n         while (start < end) {\n \n@@ -1994,7 +1991,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n \n             if (value == NULL) {\n                 if (start == end || *start == ',') {\n-                    return i;\n+                    return h;\n                 }\n \n                 goto skip;\n@@ -2014,7 +2011,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n             value->len = last - start;\n             value->data = start;\n \n-            return i;\n+            return h;\n \n         skip:\n \n@@ -2029,31 +2026,28 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,\n         }\n     }\n \n-    return NGX_DECLINED;\n+    return NULL;\n }\n \n \n-ngx_int_t\n-ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,\n-    ngx_str_t *value)\n+ngx_table_elt_t *\n+ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,\n+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)\n {\n-    ngx_uint_t         i;\n-    u_char            *start, *last, *end;\n-    ngx_table_elt_t  **h;\n-\n-    h = headers->elts;\n+    u_char           *start, *last, *end;\n+    ngx_table_elt_t  *h;\n \n-    for (i = 0; i < headers->nelts; i++) {\n+    for (h = headers; h; h = h->next) {\n \n-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,\n-                       \"parse header: \\\"%V: %V\\\"\", &h[i]->key, &h[i]->value);\n+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n+                       \"parse header: \\\"%V: %V\\\"\", &h->key, &h->value);\n \n-        if (name->len >= h[i]->value.len) {\n+        if (name->len >= h->value.len) {\n             continue;\n         }\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n         if (ngx_strncasecmp(start, name->data, name->len) != 0) {\n             continue;\n@@ -2077,10 +2071,10 @@ ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,\n         value->len = last - start;\n         value->data = start;\n \n-        return i;\n+        return h;\n     }\n \n-    return NGX_DECLINED;\n+    return NULL;\n }\n \n \nDiff:\n@@ -46,6 +46,7 @@ static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,\n     ngx_http_request_t *r, ngx_http_core_srv_conf_t **cscfp);\n \n static void ngx_http_request_handler(ngx_event_t *ev);\n+static ngx_int_t ngx_http_trace_handler(ngx_http_request_t *r);\n static void ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc);\n static void ngx_http_terminate_handler(ngx_http_request_t *r);\n static void ngx_http_finalize_connection(ngx_http_request_t *r);\n@@ -205,7 +206,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  ngx_http_process_header_line },\n #endif\n \n-    { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookies),\n+    { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookie),\n                  ngx_http_process_multi_header_lines },\n \n     { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n@@ -1768,6 +1769,7 @@ ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n     }\n \n     return NGX_OK;\n@@ -1784,6 +1786,7 @@ ngx_http_process_unique_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     if (*ph == NULL) {\n         *ph = h;\n+        h->next = NULL;\n         return NGX_OK;\n     }\n \n@@ -1816,6 +1819,7 @@ ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     r->headers_in.host = h;\n+    h->next = NULL;\n \n     host = h->value;\n \n@@ -1877,6 +1881,7 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,\n     }\n \n     r->headers_in.user_agent = h;\n+    h->next = NULL;\n \n     /* check some widespread browsers while the header is in CPU cache */\n \n@@ -1943,34 +1948,24 @@ static ngx_int_t\n ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_array_t       *headers;\n     ngx_table_elt_t  **ph;\n \n-    headers = (ngx_array_t *) ((char *) &r->headers_in + offset);\n-\n-    if (headers->elts == NULL) {\n-        if (ngx_array_init(headers, r->pool, 1, sizeof(ngx_table_elt_t *))\n-            != NGX_OK)\n-        {\n-            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-            return NGX_ERROR;\n-        }\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);\n \n-    ph = ngx_array_push(headers);\n-    if (ph == NULL) {\n-        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n+\n     return NGX_OK;\n }\n \n \n ngx_int_t\n ngx_http_process_request_header(ngx_http_request_t *r)\n {\n+    ngx_core_conf_t *ccf = (ngx_core_conf_t *) ngx_get_conf(r->cycle->conf_ctx, ngx_core_module);\n+\n     if (r->headers_in.server.len == 0\n         && ngx_http_set_virtual_server(r, &r->headers_in.server)\n            == NGX_ERROR)\n@@ -2049,8 +2044,12 @@ ngx_http_process_request_header(ngx_http_request_t *r)\n     if (r->method == NGX_HTTP_TRACE) {\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                       \"client sent TRACE method\");\n-        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n-        return NGX_ERROR;\n+          if (ccf->trace_enable != -1) {\n+               return ngx_http_trace_handler(r);\n+          } else {\n+               ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n+               return NGX_ERROR;\n+          }\n     }\n \n     return NGX_OK;\n@@ -4049,3 +4048,65 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     return NGX_OK;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_trace_handler(ngx_http_request_t *r)\n+{\n+    ngx_list_part_t *part;\n+    ngx_table_elt_t *header;\n+    ngx_buf_t *b;\n+    ngx_chain_t out;\n+    ngx_int_t rc, content_len;\n+\n+    b = ngx_create_temp_buf(r->pool, 200);\n+    if (b == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+\n+    b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);\n+    *b->last++ = '\\n';\n+\n+    content_len = r->request_line.len + 1;\n+\n+    part = &r->headers_in.headers.part;\n+    header = part->elts;\n+    for (ngx_uint_t i = 0; ; i++) {\n+        if (i >= part->nelts) {\n+            if (part->next == NULL) {\n+                b->last_buf = 1;\n+                break;\n+            }\n+            part = part->next;\n+            header = part->elts;\n+            i = 0;\n+        }\n+\n+        size_t header_len = header[i].key.len + header[i].value.len + 3;\n+        content_len += header_len;\n+\n+        b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n+        *b->last++ = ':';\n+        *b->last++ = ' ';\n+        b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);\n+        *b->last++ = '\\n';\n+    }\n+\n+    ngx_str_t ct = ngx_string(\"message/http\");\n+    r->headers_out.status = NGX_HTTP_OK;\n+    r->headers_out.content_type = ct;\n+    r->headers_out.content_length_n = content_len;\n+    rc = ngx_http_send_header(r);\n+\n+    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n+        return rc;\n+    }\n+\n+    out.buf = b;\n+    out.next = NULL;\n+\n+    rc = ngx_http_output_filter(r, &out);\n+    ngx_http_close_request(r, rc);\n+\n+    return NGX_DONE;\n+}\nDiff:\n@@ -214,7 +214,7 @@ typedef struct {\n     ngx_table_elt_t                  *keep_alive;\n \n #if (NGX_HTTP_X_FORWARDED_FOR)\n-    ngx_array_t                       x_forwarded_for;\n+    ngx_table_elt_t                  *x_forwarded_for;\n #endif\n \n #if (NGX_HTTP_REALIP)\n@@ -233,11 +233,11 @@ typedef struct {\n     ngx_table_elt_t                  *date;\n #endif\n \n+    ngx_table_elt_t                  *cookie;\n+\n     ngx_str_t                         user;\n     ngx_str_t                         passwd;\n \n-    ngx_array_t                       cookies;\n-\n     ngx_str_t                         server;\n     off_t                             content_length_n;\n     time_t                            keep_alive_n;\n@@ -279,6 +279,9 @@ typedef struct {\n     ngx_table_elt_t                  *expires;\n     ngx_table_elt_t                  *etag;\n \n+    ngx_table_elt_t                  *cache_control;\n+    ngx_table_elt_t                  *link;\n+\n     ngx_str_t                        *override_charset;\n \n     size_t                            content_type_len;\n@@ -287,9 +290,6 @@ typedef struct {\n     u_char                           *content_type_lowcase;\n     ngx_uint_t                        content_type_hash;\n \n-    ngx_array_t                       cache_control;\n-    ngx_array_t                       link;\n-\n     off_t                             content_length_n;\n     off_t                             content_offset;\n     time_t                            date_time;\nDiff:\n@@ -246,7 +246,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {\n \n     { ngx_string(\"Set-Cookie\"),\n                  ngx_http_upstream_process_set_cookie,\n-                 offsetof(ngx_http_upstream_headers_in_t, cookies),\n+                 offsetof(ngx_http_upstream_headers_in_t, set_cookie),\n                  ngx_http_upstream_rewrite_set_cookie, 0, 1 },\n \n     { ngx_string(\"Content-Disposition\"),\n@@ -4666,26 +4666,16 @@ static ngx_int_t\n ngx_http_upstream_process_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,\n     ngx_uint_t offset)\n {\n-    ngx_array_t           *pa;\n     ngx_table_elt_t      **ph;\n     ngx_http_upstream_t   *u;\n \n     u = r->upstream;\n-    pa = &u->headers_in.cookies;\n+    ph = &u->headers_in.set_cookie;\n \n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     if (!(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_SET_COOKIE)) {\n@@ -4701,26 +4691,16 @@ static ngx_int_t\n ngx_http_upstream_process_cache_control(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_array_t          *pa;\n     ngx_table_elt_t     **ph;\n     ngx_http_upstream_t  *u;\n \n     u = r->upstream;\n-    pa = &u->headers_in.cache_control;\n+    ph = &u->headers_in.cache_control;\n \n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = h;\n+    h->next = NULL;\n \n #if (NGX_HTTP_CACHE)\n     {\n@@ -5103,31 +5083,21 @@ static ngx_int_t\n ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset)\n {\n-    ngx_array_t      *pa;\n     ngx_table_elt_t  *ho, **ph;\n \n-    pa = (ngx_array_t *) ((char *) &r->headers_out + offset);\n-\n-    if (pa->elts == NULL) {\n-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)\n-        {\n-            return NGX_ERROR;\n-        }\n-    }\n-\n     ho = ngx_list_push(&r->headers_out.headers);\n     if (ho == NULL) {\n         return NGX_ERROR;\n     }\n \n     *ho = *h;\n \n-    ph = ngx_array_push(pa);\n-    if (ph == NULL) {\n-        return NGX_ERROR;\n-    }\n+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);\n+\n+    while (*ph) { ph = &(*ph)->next; }\n \n     *ph = ho;\n+    ho->next = NULL;\n \n     return NGX_OK;\n }\n@@ -5740,9 +5710,9 @@ ngx_http_upstream_cookie_variable(ngx_http_request_t *r,\n     s.len = name->len - (sizeof(\"upstream_cookie_\") - 1);\n     s.data = name->data + sizeof(\"upstream_cookie_\") - 1;\n \n-    if (ngx_http_parse_set_cookie_lines(&r->upstream->headers_in.cookies,\n+    if (ngx_http_parse_set_cookie_lines(r, r->upstream->headers_in.set_cookie,\n                                         &s, &cookie)\n-        == NGX_DECLINED)\n+        == NULL)\n     {\n         v->not_found = 1;\n         return NGX_OK;\nDiff:\n@@ -289,8 +289,8 @@ typedef struct {\n     ngx_table_elt_t                 *content_encoding;\n #endif\n \n-    ngx_array_t                      cache_control;\n-    ngx_array_t                      cookies;\n+    ngx_table_elt_t                 *cache_control;\n+    ngx_table_elt_t                 *set_cookie;\n \n     off_t                            content_length_n;\n     time_t                           last_modified_time;\nDiff:\n@@ -187,7 +187,7 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {\n #endif\n \n     { ngx_string(\"http_cookie\"), NULL, ngx_http_variable_cookies,\n-      offsetof(ngx_http_request_t, headers_in.cookies), 0, 0 },\n+      offsetof(ngx_http_request_t, headers_in.cookie), 0, 0 },\n \n     { ngx_string(\"content_length\"), NULL, ngx_http_variable_content_length,\n       0, 0, 0 },\n@@ -856,26 +856,21 @@ static ngx_int_t\n ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data, u_char sep)\n {\n-    size_t             len;\n-    u_char            *p, *end;\n-    ngx_uint_t         i, n;\n-    ngx_array_t       *a;\n-    ngx_table_elt_t  **h;\n-\n-    a = (ngx_array_t *) ((char *) r + data);\n+    size_t            len;\n+    u_char           *p;\n+    ngx_table_elt_t  *h, *th;\n \n-    n = a->nelts;\n-    h = a->elts;\n+    h = *(ngx_table_elt_t **) ((char *) r + data);\n \n     len = 0;\n \n-    for (i = 0; i < n; i++) {\n+    for (th = h; th; th = th->next) {\n \n-        if (h[i]->hash == 0) {\n+        if (th->hash == 0) {\n             continue;\n         }\n \n-        len += h[i]->value.len + 2;\n+        len += th->value.len + 2;\n     }\n \n     if (len == 0) {\n@@ -889,9 +884,9 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     v->no_cacheable = 0;\n     v->not_found = 0;\n \n-    if (n == 1) {\n-        v->len = (*h)->value.len;\n-        v->data = (*h)->value.data;\n+    if (h->next == NULL) {\n+        v->len = h->value.len;\n+        v->data = h->value.data;\n \n         return NGX_OK;\n     }\n@@ -904,17 +899,15 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,\n     v->len = len;\n     v->data = p;\n \n-    end = p + len;\n-\n-    for (i = 0; /* void */ ; i++) {\n+    for (th = h; th; th = th->next) {\n \n-        if (h[i]->hash == 0) {\n+        if (th->hash == 0) {\n             continue;\n         }\n \n-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);\n+        p = ngx_copy(p, th->value.data, th->value.len);\n \n-        if (p == end) {\n+        if (th->next == NULL) {\n             break;\n         }\n \n@@ -1112,8 +1105,8 @@ ngx_http_variable_cookie(ngx_http_request_t *r, ngx_http_variable_value_t *v,\n     s.len = name->len - (sizeof(\"cookie_\") - 1);\n     s.data = name->data + sizeof(\"cookie_\") - 1;\n \n-    if (ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &s, &cookie)\n-        == NGX_DECLINED)\n+    if (ngx_http_parse_multi_header_lines(r, r->headers_in.cookie, &s, &cookie)\n+        == NULL)\n     {\n         v->not_found = 1;\n         return NGX_OK;\nDiff:\n@@ -674,14 +674,14 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)\n static ngx_int_t\n ngx_http_v2_push_resources(ngx_http_request_t *r)\n {\n-    u_char                     *start, *end, *last;\n-    ngx_int_t                   rc;\n-    ngx_str_t                   path;\n-    ngx_uint_t                  i, push;\n-    ngx_table_elt_t           **h;\n-    ngx_http_v2_loc_conf_t     *h2lcf;\n-    ngx_http_complex_value_t   *pushes;\n-    ngx_str_t                   binary[NGX_HTTP_V2_PUSH_HEADERS];\n+    u_char                    *start, *end, *last;\n+    ngx_int_t                  rc;\n+    ngx_str_t                  path;\n+    ngx_uint_t                 i, push;\n+    ngx_table_elt_t           *h;\n+    ngx_http_v2_loc_conf_t    *h2lcf;\n+    ngx_http_complex_value_t  *pushes;\n+    ngx_str_t                  binary[NGX_HTTP_V2_PUSH_HEADERS];\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                    \"http2 push resources\");\n@@ -725,15 +725,13 @@ ngx_http_v2_push_resources(ngx_http_request_t *r)\n         return NGX_OK;\n     }\n \n-    h = r->headers_out.link.elts;\n-\n-    for (i = 0; i < r->headers_out.link.nelts; i++) {\n+    for (h = r->headers_out.link; h; h = h->next) {\n \n         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n-                       \"http2 parse link: \\\"%V\\\"\", &h[i]->value);\n+                       \"http2 parse link: \\\"%V\\\"\", &h->value);\n \n-        start = h[i]->value.data;\n-        end = h[i]->value.data + h[i]->value.len;\n+        start = h->value.data;\n+        end = h->value.data + h->value.len;\n \n     next_link:\n \n",
        "analysis": "To identify suspicious modifications in the diff, we can assess each function for any potential issues introduced by the changes. Here are the detailed analyses of the changes:\n\n1. **Function: `ngx_http_geo_addr`**  \n   The change replaces `ngx_array_t *xfwd` with `ngx_table_elt_t *xfwd` and adjusts the check for null pointers. This can potentially affect buffer operations due to changes in data structure but doesn't directly introduce a vulnerability.\n\n2. **Function: `ngx_http_geoip_addr`**  \n   Similar to above, change from `ngx_array_t *xfwd` to `ngx_table_elt_t *xfwd` and pointer checks are adjusted.  \n\n3. **Function: `ngx_http_geoip_addr_v6`**  \n   Same change here with datatype adjustment from array to single element and pointer checks.  \n\n4. **Function: `ngx_http_set_expires`**  \n   Conversion from using an array to a linked-list like data structure (`next` pointer). Changes how headers are iterated and directly assign `next` pointers, which were previously handled by arrays.\n\n5. **Function: `ngx_http_add_multi_header_lines`**  \n   Transition from arrays to list; changes how headers are being stored and iterated. Direct manipulation of `next` pointers can lead to issues if not handled properly. \n\n6. **Function: `ngx_http_proxy_add_x_forwarded_for_variable`**  \n   Change from array to list, restructuring how headers are processed and iterated.\n\n7. **Function: `ngx_http_realip_handler`**  \n   Type changes from `ngx_array_t` to `ngx_table_elt_t` for headers, similar pointer change from array initialization to list pointers check.\n\n8. **Function: `ngx_http_userid_get_uid`**  \n   Header cookies are expected to be a list instead of an array, with changes in how they are manipulated.\n\n9. **Function: `header_in`**  \n   Type changes from arrays to linked headers, which affects how headers are copied and stored.\n\n10. **Function: `ngx_http_parse_unsafe_uri`**  \n    Function signature changes, with headers being processed using linked lists instead of arrays.\n\n11. **Function: `ngx_http_gzip_ok`**  \n    Uses linked list for headers instead of arrays.\n\n12. **Function: `ngx_http_get_forwarded_addr`**  \n    Major change; header order reversed first, processed, then restored order, potential data flow confusion.\n\n13. **Function: `ngx_http_upstream_process_set_cookie`**  \n    Changes from array operations to linked structure handling, with implications for memory and buffer handling.\n\n14. **Function: `ngx_http_v2_push_resources`**  \n    Headers change from array to linked list, altering traversal and manipulation semantics.\n\nEach of these functions has been altered to use `ngx_table_elt_t` and `next` pointers instead of `ngx_array_t`. This impacts memory handling and can influence buffer logic, especially if not all uses of these headers accommodate the semantic change from array to linked list. These transformations may have introduced vulnerabilities unintentionally.\n\nConsidering the specific focus on AddressSanitizers (like heap-buffer-overflow or use-after-free), affected functions can possibly lead to such issues if pointers in the list are not handled accurately. Given the transition of data structures across multiple functions, changes in these functions should be scrutinized for potential buffer operations that could lead to vulnerabilities.\n\nHere are the functions where suspicious modifications have been made:\n\n```\nTRUE ngx_http_geo_addr\nTRUE ngx_http_geoip_addr\nTRUE ngx_http_geoip_addr_v6\nTRUE ngx_http_set_expires\nTRUE ngx_http_add_multi_header_lines\nTRUE ngx_http_proxy_add_x_forwarded_for_variable\nTRUE ngx_http_realip_handler\nTRUE ngx_http_userid_get_uid\nTRUE header_in\nTRUE ngx_http_parse_unsafe_uri\nTRUE ngx_http_gzip_ok\nTRUE ngx_http_get_forwarded_addr\nTRUE ngx_http_upstream_process_set_cookie\nTRUE ngx_http_v2_push_resources\n```"
    },
    {
        "commit_index": "Commit 123",
        "commit_diff": "Diff:\n@@ -124,6 +124,7 @@ typedef intptr_t        ngx_flag_t;\n #define NGX_MAXHOSTNAMELEN  256\n #endif\n \n+#define NGX_MAX_HOST_SPECS_LINE 64\n \n #define NGX_MAX_UINT32_VALUE  (uint32_t) 0xffffffff\n #define NGX_MAX_INT32_VALUE   (uint32_t) 0x7fffffff\nDiff:\n@@ -14,6 +14,7 @@\n \n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_host_specs_s      ngx_host_specs_t;\n typedef struct ngx_con_his_s         ngx_con_his_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n typedef struct ngx_black_list_s      ngx_black_list_t;\nDiff:\n@@ -74,6 +74,7 @@ ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n ngx_cycle_t *\n ngx_init_cycle(ngx_cycle_t *old_cycle)\n {\n+    FILE                *fp;\n     void                *rv;\n     char               **senv;\n     ngx_uint_t           i, n;\n@@ -89,6 +90,8 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n     ngx_core_conf_t     *ccf, *old_ccf;\n     ngx_core_module_t   *module;\n     char                 hostname[NGX_MAXHOSTNAMELEN];\n+    char                 line[NGX_MAX_HOST_SPECS_LINE];\n+    char                *temp_char;\n \n     ngx_timezone_update();\n \n@@ -352,8 +355,110 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n         return cycle;\n     }\n \n+    cycle->host_specs = ngx_alloc(sizeof(ngx_host_specs_t), log);\n+    if (cycle->host_specs == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+\n+    cycle->host_specs->host_cpu = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_cpu == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_cpu->data = (u_char*)\"Unknown CPU\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/proc/cpuinfo\", \"r\");\n+    if (fp != NULL) {\n+        temp_char = NULL;\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (ngx_strncmp(line, \"model name\", 10) == 0) {\n+                temp_char = strchr(line, ':');\n+                if (temp_char != NULL) {\n+                    temp_char += 2;\n+                    cycle->host_specs->host_cpu->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_cpu->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_cpu->data, sizeof(line));\n+                    cycle->host_specs->host_cpu->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_cpu->data, \"%s\", temp_char) - \\\n+                        cycle->host_specs->host_cpu->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n+    cycle->host_specs->host_mem = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_mem == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_mem->data = (u_char*)\"Unknown RAM\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/proc/meminfo\", \"r\");\n+    if (fp != NULL) {\n+        temp_char = NULL;\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (ngx_strncmp(line, \"MemTotal:\", 9) == 0) {\n+                temp_char = strchr(line, ':');\n+                if (temp_char != NULL) {\n+                    temp_char += 8;\n+                    cycle->host_specs->host_mem->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_mem->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_mem->data, sizeof(line));\n+                    cycle->host_specs->host_mem->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_mem->data, \"%s\", temp_char) - \\\n+                        cycle->host_specs->host_mem->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n+    cycle->host_specs->host_os = ngx_alloc(sizeof(ngx_str_t), log);\n+    if (cycle->host_specs->host_os == NULL) {\n+        ngx_destroy_pool(pool);\n+        return NULL;\n+    }\n+    cycle->host_specs->host_os->data = (u_char*)\"Unknown OS\\n\";\n+\n+    ngx_memzero(line, NGX_MAX_HOST_SPECS_LINE);\n+    fp = fopen(\"/etc/os-release\", \"r\");\n+    if (fp != NULL) {\n+        while (fgets(line, sizeof(line), fp) != NULL) {\n+            if (strncmp(line, \"PRETTY_NAME\", 11) == 0) {\n+                temp_char = strchr(line, '=');\n+                if (temp_char != NULL) {\n+                    temp_char += 1;\n+                    cycle->host_specs->host_os->data = ngx_alloc(sizeof(line), log);\n+                    if (cycle->host_specs->host_os->data == NULL) {\n+                        break;\n+                    }\n+                    ngx_memzero(cycle->host_specs->host_os->data, sizeof(line));\n+                        cycle->host_specs->host_os->len = \\\n+                        ngx_sprintf(cycle->host_specs->host_os->data, \"%s\", temp_char) - \\\n+                    cycle->host_specs->host_os->data;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    fclose(fp);\n+\n     ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n \n+    if (!ccf->remote_admin) {\n+        ngx_free(cycle->host_specs);\n+    }\n+\n     if (ngx_test_config) {\n \n         if (ngx_create_pidfile(&ccf->pid, log) != NGX_OK) {\nDiff:\n@@ -49,6 +49,13 @@ struct ngx_con_his_s {\n };\n \n \n+struct ngx_host_specs_s {\n+    ngx_str_t *host_cpu;\n+    ngx_str_t *host_mem;\n+    ngx_str_t *host_os;\n+};\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -62,6 +69,8 @@ struct ngx_cycle_s {\n     ngx_connection_t         *free_connections;\n     ngx_uint_t                free_connection_n;\n \n+    ngx_host_specs_t         *host_specs;\n+\n     ngx_module_t            **modules;\n     ngx_uint_t                modules_n;\n     ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */\nDiff:\n@@ -910,7 +910,7 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n                     rev->connection_counter = c->number;\n                     rev->connection_history = cycle->connection_history;\n                 }\n-\n+                rev->cycle = cycle;\n                 rev->handler(rev);\n             }\n         }\nDiff:\n@@ -36,6 +36,8 @@ struct ngx_event_s {\n \n     unsigned         accept:1;\n \n+    ngx_cycle_t     *cycle;\n+\n     /* used to detect the stale events in kqueue and epoll */\n     unsigned         instance:1;\n \n@@ -103,7 +105,6 @@ struct ngx_event_s {\n     int              available;\n \n     ngx_event_handler_pt  handler;\n-    ngx_cycle_t          *cycle;\n \n \n #if (NGX_HAVE_IOCP)\nDiff:\n@@ -4698,6 +4698,36 @@ ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n }\n \n \n+ngx_int_t\n+ngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n+{\n+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation\n+\n+    unsigned int          len;\n+    const unsigned char  *data;\n+\n+    SSL_get0_alpn_selected(c->ssl->connection, &data, &len);\n+\n+    if (len > 0) {\n+\n+        s->data = ngx_pnalloc(pool, len);\n+        if (s->data == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_memcpy(s->data, data, len);\n+        s->len = len;\n+\n+        return NGX_OK;\n+    }\n+\n+#endif\n+\n+    s->len = 0;\n+    return NGX_OK;\n+}\n+\n+\n ngx_int_t\n ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)\n {\nDiff:\n@@ -265,6 +265,8 @@ ngx_int_t ngx_ssl_get_early_data(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_server_name(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n+ngx_int_t ngx_ssl_get_alpn_protocol(ngx_connection_t *c, ngx_pool_t *pool,\n+    ngx_str_t *s);\n ngx_int_t ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool,\n     ngx_str_t *s);\n ngx_int_t ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool,\nDiff:\n@@ -358,6 +358,9 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {\n     { ngx_string(\"ssl_server_name\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_server_name, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_alpn_protocol\"), NULL, ngx_http_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_alpn_protocol, NGX_HTTP_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_client_cert\"), NULL, ngx_http_ssl_variable,\n       (uintptr_t) ngx_ssl_get_certificate, NGX_HTTP_VAR_CHANGEABLE, 0 },\n \nDiff:\n@@ -2799,5 +2799,20 @@ ngx_http_get_last_ip_variable(ngx_http_request_t *r,\n static ngx_int_t ngx_http_get_host_specs(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    u_char *temp;\n+\n+    v->data = ngx_pnalloc(r->pool, NGX_MAX_HOST_SPECS_LINE * 3);\n+    if (v->data == NULL) {\n+        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n+    }\n+    ngx_memzero(v->data, NGX_MAX_HOST_SPECS_LINE * 3);\n+\n+    temp = v->data;\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_cpu->data);\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_mem->data);\n+    v->data = ngx_sprintf(v->data, \"%s\", r->cycle->host_specs->host_os->data);\n+    v->len = v->data - temp;\n+    v->data = temp;\n+\n     return NGX_OK;\n }\nDiff:\n@@ -657,6 +657,32 @@ ngx_master_process_exit(ngx_cycle_t *cycle)\n {\n     ngx_uint_t  i;\n \n+    if (cycle->host_specs) {\n+        if (cycle->host_specs->host_cpu) {\n+            ngx_free(cycle->host_specs->host_cpu->data);\n+            cycle->host_specs->host_cpu->data = NULL;\n+            ngx_free(cycle->host_specs->host_cpu);\n+            cycle->host_specs->host_cpu = NULL;\n+        }\n+\n+        if (cycle->host_specs->host_mem) {\n+            ngx_free(cycle->host_specs->host_mem->data);\n+            cycle->host_specs->host_mem->data = NULL;\n+            ngx_free(cycle->host_specs->host_mem);\n+            cycle->host_specs->host_mem = NULL;\n+        }\n+\n+        if (cycle->host_specs->host_os) {\n+            ngx_free(cycle->host_specs->host_os->data);\n+            cycle->host_specs->host_os->data = NULL;\n+            ngx_free(cycle->host_specs->host_os);\n+            cycle->host_specs->host_os = NULL;\n+        }\n+\n+        ngx_free(cycle->host_specs);\n+        cycle->host_specs = NULL;\n+    }\n+\n     ngx_delete_pidfile(cycle);\n \n     ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, \"exit\");\nDiff:\n@@ -266,6 +266,9 @@ static ngx_stream_variable_t  ngx_stream_ssl_vars[] = {\n     { ngx_string(\"ssl_server_name\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_server_name, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n+    { ngx_string(\"ssl_alpn_protocol\"), NULL, ngx_stream_ssl_variable,\n+      (uintptr_t) ngx_ssl_get_alpn_protocol, NGX_STREAM_VAR_CHANGEABLE, 0 },\n+\n     { ngx_string(\"ssl_client_cert\"), NULL, ngx_stream_ssl_variable,\n       (uintptr_t) ngx_ssl_get_certificate, NGX_STREAM_VAR_CHANGEABLE, 0 },\n \n",
        "analysis": "Here are the suspicious changes found in the diffs:\n\n1. **Function: `ngx_init_cycle`**\n   - The function reads from files `/proc/cpuinfo`, `/proc/meminfo`, and `/etc/os-release`. In these operations, it reads lines into a buffer `line` of fixed size `NGX_MAX_HOST_SPECS_LINE`. There's a risk of buffer overflow if the line exceeds this size. Additionally, the function uses `ngx_alloc(sizeof(line), log)` to allocate memory for `host_cpu`, `host_mem`, and `host_os` data, which may not be sufficient, especially considering the `sizeof(line)` may not accommodate sufficiently large lines read from these system files.\n   - Proper error handling is missing for the `fopen` and `fgets` operations.\n\n2. **Function: `ngx_http_get_host_specs`**\n   - Allocates memory for `v->data` using `ngx_pnalloc` for a buffer of size `NGX_MAX_HOST_SPECS_LINE * 3`. This buffer is filled using consecutive `ngx_sprintf` calls without checking for buffer overflow. If the concatenated data from `host_cpu`, `host_mem`, and `host_os` exceeds this allocated size, it could lead to a buffer overflow.\n\nThe following function names have suspicious modifications:\n\n- `ngx_init_cycle`\n- `ngx_http_get_host_specs`\n\nFinal line listing these function names:\n\n```\nTRUE ngx_init_cycle ngx_http_get_host_specs\n```"
    },
    {
        "commit_index": "Commit 112",
        "commit_diff": "Diff:\n@@ -3,11 +3,9 @@\n <head>\n <title>Error</title>\n <style>\n-    body {\n-        width: 35em;\n-        margin: 0 auto;\n-        font-family: Tahoma, Verdana, Arial, sans-serif;\n-    }\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n </style>\n </head>\n <body>\nDiff:\n@@ -3,11 +3,9 @@\n <head>\n <title>Welcome to nginx!</title>\n <style>\n-    body {\n-        width: 35em;\n-        margin: 0 auto;\n-        font-family: Tahoma, Verdana, Arial, sans-serif;\n-    }\n+html { color-scheme: light dark; }\n+body { width: 35em; margin: 0 auto;\n+font-family: Tahoma, Verdana, Arial, sans-serif; }\n </style>\n </head>\n <body>\nDiff:\n@@ -514,6 +514,15 @@ ngx_http_header_filter(ngx_http_request_t *r)\n         *b->last++ = CR; *b->last++ = LF;\n     }\n \n+    if (r->headers_in.prefer) {\n+        b->last = ngx_cpymem(b->last, \"Prefer: \",\n+                             sizeof(\"Prefer: \") - 1);\n+        b->last = ngx_cpymem(b->last, r->headers_in.prefer->value.data,\n+                             r->headers_in.prefer->value.len);\n+\n+        *b->last++ = CR; *b->last++ = LF;\n+    }\n+\n     if (host.data) {\n \n         p = b->last + sizeof(\"Location: \") - 1;\n@@ -551,6 +560,10 @@ ngx_http_header_filter(ngx_http_request_t *r)\n                              sizeof(\"Transfer-Encoding: chunked\" CRLF) - 1);\n     }\n \n+    if (r->headers_in.prefer) {\n+        len += sizeof(\"Prefer: \" CRLF) + r->headers_in.prefer->value.len;\n+    }\n+\n     if (r->headers_out.status == NGX_HTTP_SWITCHING_PROTOCOLS) {\n         b->last = ngx_cpymem(b->last, \"Connection: upgrade\" CRLF,\n                              sizeof(\"Connection: upgrade\" CRLF) - 1);\nDiff:\n@@ -30,6 +30,8 @@ static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_host(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_prefer(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r,\n@@ -126,6 +128,9 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n                  offsetof(ngx_http_headers_in_t, content_type),\n                  ngx_http_process_header_line },\n \n+    { ngx_string(\"Prefer\"), offsetof(ngx_http_headers_in_t, prefer),\n+                 ngx_http_process_prefer },\n+\n     { ngx_string(\"Range\"), offsetof(ngx_http_headers_in_t, range),\n                  ngx_http_process_header_line },\n \n@@ -4017,3 +4022,38 @@ ngx_http_process_black_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n \n     return NGX_OK;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    ngx_table_elt_t *p;\n+\n+    if (r->headers_in.prefer) {\n+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n+                      \"client sent duplicate host header: \\\"%V: %V\\\", \"\n+                      \"previous value: \\\"%V: %V\\\"\",\n+                      &h->key, &h->value, &r->headers_in.prefer->key,\n+                      &r->headers_in.prefer->value);\n+        ngx_free(r->headers_in.prefer);\n+        return NGX_OK;\n+    }\n+\n+    p = ngx_alloc(sizeof(ngx_table_elt_t), r->connection->log);\n+\n+    if (!p) {\n+        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n+        return NGX_ERROR;\n+    }\n+\n+    p->hash = h->hash;\n+    p->key.len = h->key.len;\n+    p->key.data = h->key.data;\n+    p->value.len = h->value.len;\n+    p->value.data = h->value.data;\n+\n+    r->headers_in.prefer = p;\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -190,6 +190,7 @@ typedef struct {\n     ngx_table_elt_t                  *if_match;\n     ngx_table_elt_t                  *if_none_match;\n     ngx_table_elt_t                  *user_agent;\n+    ngx_table_elt_t                  *prefer;\n     ngx_table_elt_t                  *referer;\n     ngx_table_elt_t                  *content_length;\n     ngx_table_elt_t                  *content_range;\n",
        "analysis": "Here's a detailed analysis of the relevant C code changes in the provided diff:\n\n1. **Function: `ngx_http_process_multi_header_lines`**\n   - There was no change made to this function in the diff, so it doesn't need to be considered.\n\n2. **Function: `ngx_http_process_host`**\n   - There was no change made to this function in the diff, so it doesn't need to be considered.\n\n3. **Function: `ngx_http_process_prefer`**\n   - New function added. This function processes the `Prefer` header.\n   - There is a potential issue with double-free:\n     - The line `ngx_free(r->headers_in.prefer);` can cause a double-free if the header is processed multiple times because `ngx_free` is called before setting `r->headers_in.prefer` to `NULL`.\n   - This is suspicious and could potentially be an error in memory management.\n\n4. **Function: `ngx_http_header_filter`**\n   - Lines were added handling the `Prefer` header.\n   - The code modifies a buffer without checking if there's enough space to write, which might cause a buffer overflow if not managed properly.\n   - This modification could be suspicious regarding buffer memory safety.\n\n5. **Function: `ngx_http_process_connection`**\n   - There was no change made to this function in the diff, so it doesn't need to be considered.\n\n6. **Function: `ngx_http_process_user_agent`**\n   - There was no change made to this function in the diff, it doesn't need to be considered.\n\n7. **Structure: `ngx_http_header_t  ngx_http_headers_in[]`**\n   - Added handling of the `\"Prefer\"` header, linked to the `ngx_http_process_prefer` function.\n   - No direct code execution in this snippet, no direct vulnerabilities suspected here, but the suspicion is still on `ngx_http_process_prefer`.\n\n8. **Structure: `ngx_http_headers_in_t`**\n   - Added a member `ngx_table_elt_t *prefer;` to store the `Prefer` header.\n   - No explicit vulnerability is immediately visible from this change alone, it's related to the modifications.\n\nThe suspicious change is mainly found in the newly added function `ngx_http_process_prefer` due to potential memory management issues and in `ngx_http_header_filter` due to possible buffer management concerns.\n\nThus, the functions with suspicious modifications are:\n- `ngx_http_process_prefer`\n- `ngx_http_header_filter`\n\nFinal list of suspicious functions:\n```\nTRUE ngx_http_process_prefer ngx_http_header_filter\n```"
    },
    {
        "commit_index": "Commit 102",
        "commit_diff": "Diff:\n@@ -152,6 +152,7 @@ syn keyword ngxDirective contained auth_jwt_header_set\n syn keyword ngxDirective contained auth_jwt_key_file\n syn keyword ngxDirective contained auth_jwt_key_request\n syn keyword ngxDirective contained auth_jwt_leeway\n+syn keyword ngxDirective contained auth_jwt_type\n syn keyword ngxDirective contained auth_request\n syn keyword ngxDirective contained auth_request_set\n syn keyword ngxDirective contained autoindex\n@@ -332,16 +333,20 @@ syn keyword ngxDirective contained index\n syn keyword ngxDirective contained iocp_threads\n syn keyword ngxDirective contained ip_hash\n syn keyword ngxDirective contained js_access\n+syn keyword ngxDirective contained js_body_filter\n syn keyword ngxDirective contained js_content\n syn keyword ngxDirective contained js_filter\n+syn keyword ngxDirective contained js_header_filter\n syn keyword ngxDirective contained js_import\n syn keyword ngxDirective contained js_include\n syn keyword ngxDirective contained js_path\n syn keyword ngxDirective contained js_preread\n syn keyword ngxDirective contained js_set\n+syn keyword ngxDirective contained js_var\n syn keyword ngxDirective contained keepalive\n syn keyword ngxDirective contained keepalive_disable\n syn keyword ngxDirective contained keepalive_requests\n+syn keyword ngxDirective contained keepalive_time\n syn keyword ngxDirective contained keepalive_timeout\n syn keyword ngxDirective contained keyval\n syn keyword ngxDirective contained keyval_zone\n@@ -373,6 +378,7 @@ syn keyword ngxDirective contained log_subrequest\n syn keyword ngxDirective contained map_hash_bucket_size\n syn keyword ngxDirective contained map_hash_max_size\n syn keyword ngxDirective contained master_process\n+syn keyword ngxDirective contained max_errors\n syn keyword ngxDirective contained max_ranges\n syn keyword ngxDirective contained memcached_bind\n syn keyword ngxDirective contained memcached_buffer_size\n@@ -1080,6 +1086,8 @@ syn keyword ngxDirectiveThirdParty contained nchan_subscriber_compound_etag_mess\n syn keyword ngxDirectiveThirdParty contained nchan_subscribe_request\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_first_message\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_http_raw_stream_separator\n+syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info\n+syn keyword ngxDirectiveThirdParty contained nchan_subscriber_info_string\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_last_message_id\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_location\n syn keyword ngxDirectiveThirdParty contained nchan_subscriber_message_id_custom_etag_header\n@@ -2368,9 +2376,9 @@ syn keyword ngxDirectiveThirdParty contained websockify_send_timeout\n \n \" IP2Location Nginx\n \" https://github.com/ip2location/ip2location-nginx\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n-syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n+syn keyword ngxDirectiveThirdParty contained ip2location_addresstype\n syn keyword ngxDirectiveThirdParty contained ip2location_areacode\n+syn keyword ngxDirectiveThirdParty contained ip2location_category\n syn keyword ngxDirectiveThirdParty contained ip2location_city\n syn keyword ngxDirectiveThirdParty contained ip2location_country_long\n syn keyword ngxDirectiveThirdParty contained ip2location_country_short\n@@ -2384,6 +2392,8 @@ syn keyword ngxDirectiveThirdParty contained ip2location_mcc\n syn keyword ngxDirectiveThirdParty contained ip2location_mnc\n syn keyword ngxDirectiveThirdParty contained ip2location_mobilebrand\n syn keyword ngxDirectiveThirdParty contained ip2location_netspeed\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy\n+syn keyword ngxDirectiveThirdParty contained ip2location_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2location_region\n syn keyword ngxDirectiveThirdParty contained ip2location_timezone\n syn keyword ngxDirectiveThirdParty contained ip2location_usagetype\n@@ -2403,6 +2413,7 @@ syn keyword ngxDirectiveThirdParty contained ip2proxy_domain\n syn keyword ngxDirectiveThirdParty contained ip2proxy_isp\n syn keyword ngxDirectiveThirdParty contained ip2proxy_is_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_last_seen\n+syn keyword ngxDirectiveThirdParty contained ip2proxy_provider\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_recursive\n syn keyword ngxDirectiveThirdParty contained ip2proxy_proxy_type\nDiff:\n@@ -2896,9 +2896,12 @@ ngx_int_t\n ngx_ssl_shutdown(ngx_connection_t *c)\n {\n     int         n, sslerr, mode;\n+    ngx_int_t   rc;\n     ngx_err_t   err;\n     ngx_uint_t  tries;\n \n+    rc = NGX_OK;\n+\n     ngx_ssl_ocsp_cleanup(c);\n \n     if (SSL_in_init(c->ssl->connection)) {\n@@ -2908,11 +2911,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n          * Avoid calling SSL_shutdown() if handshake wasn't completed.\n          */\n \n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n-        c->recv = ngx_recv;\n-\n-        return NGX_OK;\n+        goto done;\n     }\n \n     if (c->timedout || c->error || c->buffered) {\n@@ -2954,11 +2953,7 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, \"SSL_shutdown: %d\", n);\n \n         if (n == 1) {\n-            SSL_free(c->ssl->connection);\n-            c->ssl = NULL;\n-            c->recv = ngx_recv;\n-\n-            return NGX_OK;\n+            goto done;\n         }\n \n         if (n == 0 && tries-- > 1) {\n@@ -2984,11 +2979,11 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n             }\n \n             if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n-                return NGX_ERROR;\n+                goto failed;\n             }\n \n             ngx_add_timer(c->read, 3000);\n@@ -2997,23 +2992,27 @@ ngx_ssl_shutdown(ngx_connection_t *c)\n         }\n \n         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {\n-            SSL_free(c->ssl->connection);\n-            c->ssl = NULL;\n-            c->recv = ngx_recv;\n-\n-            return NGX_OK;\n+            goto done;\n         }\n \n         err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;\n \n         ngx_ssl_connection_error(c, sslerr, err, \"SSL_shutdown() failed\");\n \n-        SSL_free(c->ssl->connection);\n-        c->ssl = NULL;\n-        c->recv = ngx_recv;\n-\n-        return NGX_ERROR;\n+        break;\n     }\n+\n+failed:\n+\n+    rc = NGX_ERROR;\n+\n+done:\n+\n+    SSL_free(c->ssl->connection);\n+    c->ssl = NULL;\n+    c->recv = ngx_recv;\n+\n+    return rc;\n }\n \n \nDiff:\n@@ -28,6 +28,7 @@ static ngx_int_t ngx_mail_smtp_starttls(ngx_mail_session_t *s,\n     ngx_connection_t *c);\n static ngx_int_t ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c);\n static ngx_int_t ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c);\n+static ngx_int_t ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c);\n \n static ngx_int_t ngx_mail_smtp_discard_command(ngx_mail_session_t *s,\n     ngx_connection_t *c, char *err);\n@@ -36,6 +37,7 @@ static void ngx_mail_smtp_log_rejected_command(ngx_mail_session_t *s,\n \n \n static u_char  smtp_ok[] = \"250 2.0.0 OK\" CRLF;\n+static u_char  smtp_noop[] = \"255 2.0.0 OK\" CRLF;\n static u_char  smtp_bye[] = \"221 2.0.0 Bye\" CRLF;\n static u_char  smtp_starttls[] = \"220 2.0.0 Start TLS\" CRLF;\n static u_char  smtp_next[] = \"334 \" CRLF;\n@@ -511,6 +513,7 @@ ngx_mail_smtp_auth_state(ngx_event_t *rev)\n                 break;\n \n             case NGX_SMTP_NOOP:\n+                rc = ngx_mail_smtp_noop(s, c);\n                 break;\n \n             case NGX_SMTP_STARTTLS:\n@@ -825,6 +828,20 @@ ngx_mail_smtp_rcpt(ngx_mail_session_t *s, ngx_connection_t *c)\n }\n \n \n+static ngx_int_t\n+ngx_mail_smtp_noop(ngx_mail_session_t *s, ngx_connection_t *c)\n+{\n+    if (s->args.nelts > 10) {\n+        ngx_str_set(&s->out, smtp_invalid_argument);\n+        ngx_mail_close_connection(c);\n+        return NGX_ERROR;\n+    }\n+\n+    ngx_str_set(&s->out, smtp_noop);\n+    return NGX_OK;\n+}\n+\n+\n static ngx_int_t\n ngx_mail_smtp_rset(ngx_mail_session_t *s, ngx_connection_t *c)\n {\n",
        "analysis": "To identify potential vulnerabilities in the C code that can trigger AddressSanitizer, we'll analyze the provided commit diffs for suspicious changes, focusing on pointer management, memory allocation, bounds checking, and any logic that could affect memory safety.\n\n### Diff Analysis\n\n#### Diff 1:\n\nNo C code changes are present in Diff 1. These are updates to keywords in a configuration or syntax file. No need to analyze further.\n\n#### Diff 2:\n\n- **Function**: `ngx_ssl_shutdown`\n  - **Changes**: There were modifications to unify cleanup and error handling with `goto` statements (`goto done` and `goto failed`), and the original code's direct return handling is replaced with a unified cleanup at the `done` or `failed` labels.\n  - **Suspicion**: These types of changes can sometimes lead to mishandling of resources if the logic skips necessary cleanup operations or if there are logical path errors.\n  - **Verdict**: TRUE `ngx_ssl_shutdown`\n\nThis is a suspicious change due to the introduction of goto statements which can complicate the control flow and may lead to mismanagement of resources or incorrect handling of error paths.\n\n#### Diff 3:\n\n- **Function**: `ngx_mail_smtp_noop`\n  - **Changes**: A new function `ngx_mail_smtp_noop` was introduced. It responds with a \"NOOP\" acknowledgment. \n  - **Suspicion**: The bounds check using `if (s->args.nelts > 10)` doesn't explicitly show what `s->args.nelts` represents or if it fully encapsulates valid arguments, but it seems to be a basic bounds check. However, adding a new function without a thorough context of how it interacts with other components can have hidden risks.\n  - **Verdict**: TRUE `ngx_mail_smtp_noop`\n\nThe introduction of a new function with bounds logic can be risky if not thoroughly vetted for all use cases, especially in resource management and potential overflow contexts.\n\n### Conclusion\n\nPotentially suspicious functions identified:\n1. `ngx_ssl_shutdown`\n2. `ngx_mail_smtp_noop`\n\nFinal result:\n```\nTRUE ngx_ssl_shutdown ngx_mail_smtp_noop\n```"
    },
    {
        "commit_index": "Commit 89",
        "commit_diff": "Diff:\n@@ -459,3 +459,4 @@ f618488eb769e0ed74ef0d93cd118d2ad79ef94d release-1.19.6\n 3fa6e2095a7a51acc630517e1c27a7b7ac41f7b3 release-1.19.7\n 8c65d21464aaa5923775f80c32474adc7a320068 release-1.19.8\n da571b8eaf8f30f36c43b3c9b25e01e31f47149c release-1.19.9\n+ffcbb9980ee2bad27b4d7b1cd680b14ff47b29aa release-1.19.10\nDiff:\n@@ -5,6 +5,49 @@\n <change_log title=\"nginx\">\n \n \n+<changes ver=\"1.19.10\" date=\"2021-04-13\">\n+\n+<change type=\"change\">\n+<para lang=\"ru\">\n+в директиве keepalive_requests значение по умолчанию изменено на 1000.\n+</para>\n+<para lang=\"en\">\n+the default value of the \"keepalive_requests\" directive was changed to 1000.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+директива keepalive_time.\n+</para>\n+<para lang=\"en\">\n+the \"keepalive_time\" directive.\n+</para>\n+</change>\n+\n+<change type=\"feature\">\n+<para lang=\"ru\">\n+переменная $connection_time.\n+</para>\n+<para lang=\"en\">\n+the $connection_time variable.\n+</para>\n+</change>\n+\n+<change type=\"workaround\">\n+<para lang=\"ru\">\n+при использовании zlib-ng\n+в логах появлялись сообщения \"gzip filter failed to use preallocated memory\".\n+</para>\n+<para lang=\"en\">\n+\"gzip filter failed to use preallocated memory\" alerts appeared in logs\n+when using zlib-ng.\n+</para>\n+</change>\n+\n+</changes>\n+\n+\n <changes ver=\"1.19.9\" date=\"2021-03-30\">\n \n <change type=\"bugfix\">\nDiff:\n@@ -102,7 +102,7 @@ ngx_mail_pop3_init_protocol(ngx_event_t *rev)\n             return;\n         }\n \n-        s->buffer = ngx_create_temp_buf(c->pool, 128);\n+        s->buffer = ngx_create_temp_buf(c->pool, 1000);\n         if (s->buffer == NULL) {\n             ngx_mail_session_internal_server_error(s);\n             return;\n@@ -316,7 +316,7 @@ ngx_mail_pop3_user(ngx_mail_session_t *s, ngx_connection_t *c)\n \n     arg = s->args.elts;\n     s->login.len = arg[0].len;\n-    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n+    s->login.data = ngx_pnalloc(c->pool, 100);\n     if (s->login.data == NULL) {\n         return NGX_ERROR;\n     }\n",
        "analysis": "To analyze the diff and identify suspicious C code changes that may trigger AddressSanitizer vulnerabilities, I'll examine the changes line by line and focus specifically on the modifications made within C functions.\n\n### Analysis of the Diff\n\n1. **File: `ngx_mail_pop3_init_protocol`**:\n   - **Change**:\n     ```diff\n     -        s->buffer = ngx_create_temp_buf(c->pool, 128);\n     +        s->buffer = ngx_create_temp_buf(c->pool, 1000);\n     ```\n   - **Comment**: The change increases the temporary buffer size from 128 to 1000. This increases the memory allocation which could potentially introduce or expose issues if the buffer size was supposed to remain small. However, unless there's a specific overflow problem elsewhere relying on the original buffer length, this change alone isn't suspicious for a buffer overflow vulnerability.\n\n2. **File: `ngx_mail_pop3_user`**:\n   - **Change**:\n     ```diff\n     -    s->login.data = ngx_pnalloc(c->pool, s->login.len);\n     +    s->login.data = ngx_pnalloc(c->pool, 100);\n     ```\n   - **Comment**: This change modifies the allocation of memory for `s->login.data` to a fixed size of 100 bytes, rather than using the variable length `s->login.len`. This change is concerning because if `s->login.len` is ever greater than 100, it could lead to a heap-buffer-overflow issue when accessing `s->login.data`. This is a suspicious modification that could potentially trigger the \"AddressSanitizer: heap-buffer-overflow.\"\n\n### Conclusion\n\nBased on the analysis, the suspicious change that could potentially lead to a vulnerability is in the function `ngx_mail_pop3_user`.\n\nFinal line (with suspicious function names):\n```\nTRUE ngx_mail_pop3_user\n```"
    },
    {
        "commit_index": "Commit 75",
        "commit_diff": "Diff:\n@@ -753,34 +753,6 @@ if [ $ngx_found = no ]; then\n fi\n \n \n-if [ $ngx_found = no ]; then\n-\n-    # Solaris has no sys_nerr\n-    ngx_feature='maximum errno'\n-    ngx_feature_name=NGX_SYS_NERR\n-    ngx_feature_run=value\n-    ngx_feature_incs='#include <errno.h>\n-                      #include <string.h>\n-                      #include <stdio.h>'\n-    ngx_feature_path=\n-    ngx_feature_libs=\n-    ngx_feature_test='int  n;\n-                      char *p;\n-                      for (n = 1; n < 1000; n++) {\n-                          errno = 0;\n-                          p = strerror(n);\n-                          if (errno == EINVAL\n-                              || p == NULL\n-                              || strncmp(p, \"Unknown error\", 13) == 0)\n-                          {\n-                              break;\n-                          }\n-                      }\n-                      printf(\"%d\", n);'\n-    . auto/feature\n-fi\n-\n-\n ngx_feature=\"localtime_r()\"\n ngx_feature_name=\"NGX_HAVE_LOCALTIME_R\"\n ngx_feature_run=no\nDiff:\n@@ -25,6 +25,7 @@ struct ngx_buf_s {\n \n     u_char          *start;         /* start of buffer */\n     u_char          *end;           /* end of buffer */\n+    ngx_int_t        rev;\n     ngx_buf_tag_t    tag;\n     ngx_file_t      *file;\n     ngx_buf_t       *shadow;\nDiff:\n@@ -647,6 +647,7 @@ ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx)\n             return NGX_ERROR;\n         }\n \n+        dst->rev = src->rev;\n         dst->last += n;\n \n         if (sendfile) {\nDiff:\n@@ -48,6 +48,7 @@\n typedef struct {\n     off_t        start;\n     off_t        end;\n+    ngx_int_t    rev;\n     ngx_str_t    content_range;\n } ngx_http_range_t;\n \n@@ -274,6 +275,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n                                   cutlim;\n     ngx_uint_t                    suffix;\n     ngx_http_range_t             *range;\n+    ngx_uint_t                    rev;\n     ngx_http_range_filter_ctx_t  *mctx;\n \n     if (r != r->main) {\n@@ -293,6 +295,7 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n \n     p = r->headers_in.range->value.data + 6;\n     size = 0;\n+    rev = 0;\n     content_length = r->headers_out.content_length_n;\n \n     cutoff = NGX_MAX_OFF_T_VALUE / 10;\n@@ -332,8 +335,22 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n             }\n \n         } else {\n-            suffix = 1;\n             p++;\n+            if (*p == 'r') {\n+                p++;\n+                while (*p == ' ') { p++; }\n+\n+                if (*p++ != ',') {\n+                    return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n+                }\n+\n+                while (*p == ' ') { p++; }\n+\n+                rev = 1;\n+                continue;\n+            } else {\n+                suffix = 1;\n+            }\n         }\n \n         if (*p < '0' || *p > '9') {\n@@ -376,6 +393,8 @@ ngx_http_range_parse(ngx_http_request_t *r, ngx_http_range_filter_ctx_t *ctx,\n \n             range->start = start;\n             range->end = end;\n+            range->rev = rev;\n+            rev = 0;\n \n             if (size > NGX_MAX_OFF_T_VALUE - (end - start)) {\n                 return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n@@ -721,6 +740,8 @@ ngx_http_range_singlepart_body(ngx_http_request_t *r,\n         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                        \"http range body buf: %O-%O\", start, last);\n \n+        buf->rev = range->rev;\n+\n         if (ngx_buf_special(buf)) {\n \n             if (range->end <= start) {\n@@ -889,6 +910,7 @@ ngx_http_range_multipart_body(ngx_http_request_t *r,\n         b->memory = buf->memory;\n         b->mmap = buf->mmap;\n         b->file = buf->file;\n+        b->rev = range[i].rev;\n \n         if (buf->in_file) {\n             b->file_pos = buf->file_pos + range[i].start;\nDiff:\n@@ -27,15 +27,22 @@\n \n static ngx_str_t  *ngx_sys_errlist;\n static ngx_str_t   ngx_unknown_error = ngx_string(\"Unknown error\");\n+static ngx_err_t   ngx_first_error;\n+static ngx_err_t   ngx_last_error;\n \n \n u_char *\n ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n {\n     ngx_str_t  *msg;\n \n-    msg = ((ngx_uint_t) err < NGX_SYS_NERR) ? &ngx_sys_errlist[err]:\n-                                              &ngx_unknown_error;\n+    if (err >= ngx_first_error && err < ngx_last_error) {\n+        msg = &ngx_sys_errlist[err - ngx_first_error];\n+\n+    } else {\n+        msg = &ngx_unknown_error;\n+    }\n+\n     size = ngx_min(size, msg->len);\n \n     return ngx_cpymem(errstr, msg->data, size);\n@@ -50,20 +57,92 @@ ngx_strerror_init(void)\n     size_t      len;\n     ngx_err_t   err;\n \n+#if (NGX_SYS_NERR)\n+    ngx_first_error = 0;\n+    ngx_last_error = NGX_SYS_NERR;\n+\n+#elif (EPERM > 1000 && EPERM < 0x7fffffff - 1000)\n+\n+    /*\n+     * If number of errors is not known, and EPERM error code has large\n+     * but reasonable value, guess possible error codes based on the error\n+     * messages returned by strerror(), starting from EPERM.  Notably,\n+     * this covers GNU/Hurd, where errors start at 0x40000001.\n+     */\n+\n+    for (err = EPERM; err > EPERM - 1000; err--) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_first_error = err;\n+    }\n+\n+    for (err = EPERM; err < EPERM + 1000; err++) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_last_error = err + 1;\n+    }\n+\n+#else\n+\n+    /*\n+     * If number of errors is not known, guess it based on the error\n+     * messages returned by strerror().\n+     */\n+\n+    ngx_first_error = 0;\n+\n+    for (err = 0; err < 1000; err++) {\n+        ngx_set_errno(0);\n+        msg = strerror(err);\n+\n+        if (errno == EINVAL\n+            || msg == NULL\n+            || strncmp(msg, \"Unknown error\", 13) == 0)\n+        {\n+            continue;\n+        }\n+\n+        ngx_last_error = err + 1;\n+    }\n+\n+#endif\n+\n     /*\n      * ngx_strerror() is not ready to work at this stage, therefore,\n      * malloc() is used and possible errors are logged using strerror().\n      */\n \n-    len = NGX_SYS_NERR * sizeof(ngx_str_t);\n+    len = (ngx_last_error - ngx_first_error) * sizeof(ngx_str_t);\n \n     ngx_sys_errlist = malloc(len);\n     if (ngx_sys_errlist == NULL) {\n         goto failed;\n     }\n \n-    for (err = 0; err < NGX_SYS_NERR; err++) {\n+    for (err = ngx_first_error; err < ngx_last_error; err++) {\n         msg = strerror(err);\n+\n+        if (msg == NULL) {\n+            ngx_sys_errlist[err - ngx_first_error] = ngx_unknown_error;\n+            continue;\n+        }\n+\n         len = ngx_strlen(msg);\n \n         p = malloc(len);\n@@ -72,8 +151,8 @@ ngx_strerror_init(void)\n         }\n \n         ngx_memcpy(p, msg, len);\n-        ngx_sys_errlist[err].len = len;\n-        ngx_sys_errlist[err].data = p;\n+        ngx_sys_errlist[err - ngx_first_error].len = len;\n+        ngx_sys_errlist[err - ngx_first_error].data = p;\n     }\n \n     return NGX_OK;\nDiff:\n@@ -41,6 +41,49 @@ static void ngx_linux_sendfile_thread_handler(void *data, ngx_log_t *log);\n  */\n \n #define NGX_SENDFILE_MAXSIZE  2147483647L\n+#define NGX_SENDFILE_R_MAXSIZE  100L\n+\n+ssize_t\n+ngx_sendfile_r(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n+{\n+    struct stat sb;\n+    u_char *buf;\n+    u_char *rev;\n+    ssize_t n;\n+\n+    if (fstat(file->file->fd, &sb) != 0) {\n+        return NGX_ERROR;\n+    }\n+\n+    buf = ngx_palloc(c->pool, ngx_file_size(&sb));\n+\n+    if (buf == NULL) {\n+        return NGX_ERROR;\n+    }\n+\n+    if (read( file->file->fd, buf, ngx_file_size(&sb)) == NGX_ERROR) {\n+        return NGX_ERROR;\n+    }\n+\n+    lseek(file->file->fd, 0, SEEK_SET);\n+\n+    rev = ngx_alloc(NGX_SENDFILE_R_MAXSIZE, c->log);\n+\n+    if ( rev == NULL ) {\n+        return NGX_ERROR;\n+    }\n+\n+    for ( int i = file->file_pos + size - 1, j = 0; i >= file->file_pos; i--, j++) {\n+        rev[j] = buf[i];\n+    }\n+\n+    n = c->send(c, rev, size);\n+\n+    ngx_pfree(c->pool, buf);\n+    ngx_free(rev);\n+\n+    return n;\n+}\n \n \n ngx_chain_t *\n@@ -256,7 +299,11 @@ ngx_linux_sendfile(ngx_connection_t *c, ngx_buf_t *file, size_t size)\n     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,\n                    \"sendfile: @%O %uz\", file->file_pos, size);\n \n-    n = sendfile(c->fd, file->file->fd, &offset, size);\n+    if (file->rev) {\n+        n = ngx_sendfile_r(c, file, size);\n+    } else {\n+        n = sendfile(c->fd, file->file->fd, &offset, size);\n+    }\n \n     if (n == -1) {\n         err = ngx_errno;\nDiff:\n@@ -149,6 +149,14 @@ ngx_output_chain_to_iovec(ngx_iovec_t *vec, ngx_chain_t *in, size_t limit,\n \n         size = in->buf->last - in->buf->pos;\n \n+        if (in->buf->rev) {\n+            for (int i = 0, j = size - 1; i < j; i++, j--) {\n+                u_char c = in->buf->start[i];\n+                in->buf->start[i] = in->buf->start[j];\n+                in->buf->start[j] = c;\n+            }\n+        }\n+\n         if (size > limit - total) {\n             size = limit - total;\n         }\n",
        "analysis": "To analyze the diff for suspicious C code changes that might trigger AddressSanitizer, let's break it down function by function and inspect changes, especially focusing on parts that may introduce buffer overflows, use-after-free, illegal memory accesses, etc.:\n\n1. **Diff snippet around `ngx_output_chain_copy_buf`:**\n   - A new assignment was added: `dst->rev = src->rev;`\n   - This modification copies a new `rev` attribute which could affect logic later used in the program.\n   - **Verdict:** This change alone doesn't seem immediately suspicious unless `rev` has incorrect assumptions elsewhere that could lead to out-of-bounds memory access or similar issues.\n\n2. **Diff snippet around `ngx_http_range_parse`:**\n   - Introduced handling for new characters in the range parsing and using a new integer `rev`.\n   - Changing parsing logic could result in unexpected behavior if not properly tested for all edge cases.\n   - **Verdict:** The logic isn't suspicious on the surface but modifying parsing logic is often error-prone.\n   - **Suspicious function:** `ngx_http_range_parse`\n\n3. **Diff snippet with the function `ngx_strerror_init`:**\n   - The logic now guesses error number ranges using `ngx_first_error` and `ngx_last_error`.\n   - Modulating array allocations based on potentially incorrect assumptions about legal error numbers could lead to buffer overflows or invalid memory accesses.\n   - **Verdict:** Modifications are about memory management based on assumptions about error codes, which can be risky.\n   - **Suspicious function:** `ngx_strerror_init`\n\n4. **New function `ngx_sendfile_r`:**\n   - Reverses the content of a buffer, copying it into a newly allocated buffer, `rev`, and then sending data.\n   - Crucially manages its own memory (allocating and freeing buffers manually).\n   - Improper handling could introduce various memory issues, for example, memory leaks or reading stale data.\n   - **Verdict:** New function with manual memory handling, always a frequent location of memory safety issues.\n   - **Suspicious function:** `ngx_sendfile_r`\n\n5. **Diff snippet `ngx_linux_sendfile`:**\n   - Conditional logic added to use new `ngx_sendfile_r` function if `file->rev` is set.\n   - Integrating a new function can potentially introduce unexpected behaviors, especially if it hasn't been thoroughly integrated into an existing codebase.\n   - **Verdict:** Depends on `ngx_sendfile_r`, which appears risky.\n   - **Suspicious function:** `ngx_linux_sendfile`\n\n6. **Diff snippet around `ngx_output_chain_to_iovec`:**\n   - Swaps content within the buffer if `in->buf->rev` is set.\n   - Altering buffer contents in situ can cause unexpected behavior if assumptions about buffer size and contents elsewhere in the code were violated.\n   - **Verdict:** Handling the buffer content directly in the code can be risk-prone, especially with assumptions on buffer states.\n   - **Suspicious function:** `ngx_output_chain_to_iovec`\n\nSuspicious or risky function changes can be noted as follows:\n\n```\nTRUE ngx_http_range_parse\nTRUE ngx_strerror_init\nTRUE ngx_sendfile_r\nTRUE ngx_linux_sendfile\nTRUE ngx_output_chain_to_iovec\n```"
    },
    {
        "commit_index": "Commit 45",
        "commit_diff": "Diff:\n@@ -128,6 +128,8 @@ struct ngx_connection_s {\n \n     ngx_socket_t        fd;\n \n+    size_t              request_counter; /* total requests to the server */\n+\n     ngx_recv_pt         recv;\n     ngx_send_pt         send;\n     ngx_recv_chain_pt   recv_chain;\nDiff:\n@@ -14,6 +14,7 @@\n \n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n+typedef struct ngx_con_his_s         ngx_con_his_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n typedef struct ngx_black_list_s      ngx_black_list_t;\n typedef struct ngx_pool_s            ngx_pool_t;\nDiff:\n@@ -35,6 +35,42 @@ static ngx_connection_t  dumb;\n /* STUB */\n \n \n+void\n+ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con)\n+{\n+    ngx_con_his_t *target = *con_his_list;\n+\n+    if (target) {\n+        while (target->next) {\n+            target = target->next;\n+        }\n+        target->next = new_con;\n+    } else {\n+        *con_his_list = new_con;\n+    }\n+\n+    return;\n+}\n+\n+\n+ngx_con_his_t *\n+ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n+{\n+    ngx_con_his_t *target = con_his_list;\n+    size_t counter = 0;\n+\n+    if (!target || number == 1 || !number) {\n+        return target;\n+    }\n+\n+    for ( ; counter <= number; counter++) {\n+        target = target->next;\n+    }\n+\n+    return target;\n+}\n+\n+\n ngx_cycle_t *\n ngx_init_cycle(ngx_cycle_t *old_cycle)\n {\n@@ -73,6 +109,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)\n     pool->log = log;\n \n     cycle = ngx_pcalloc(pool, sizeof(ngx_cycle_t));\n+    ngx_memzero(cycle, sizeof(ngx_cycle_t));\n     if (cycle == NULL) {\n         ngx_destroy_pool(pool);\n         return NULL;\nDiff:\n@@ -43,6 +43,12 @@ typedef struct ngx_black_list_s {\n }ngx_black_list_t;\n \n \n+struct ngx_con_his_s {\n+    ngx_str_t      addr_text;\n+    ngx_con_his_t *next;\n+};\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -83,6 +89,9 @@ struct ngx_cycle_s {\n \n     ngx_cycle_t              *old_cycle;\n \n+    size_t                    connection_counter; /* total connections to the server */\n+    ngx_con_his_t            *connection_history; /* list of all connections made to the server */\n+\n     ngx_str_t                 conf_file;\n     ngx_str_t                 conf_param;\n     ngx_str_t                 conf_prefix;\n@@ -162,6 +171,8 @@ ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n     size_t size, void *tag);\n void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+void ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con);\n+ngx_con_his_t *ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number);\n void ngx_black_list_insert(ngx_black_list_t **black_list,\n     u_char insert_ip[], size_t size, ngx_log_t *log);\n ngx_int_t ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[]);\nDiff:\n@@ -1918,7 +1918,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -1930,7 +1930,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (rn->query6 == NULL || rn->naddrs6 != (u_short) -1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected response for %V\", &name);\n+                          \"unexpected DNS response for %V\", &name);\n             ngx_resolver_free(r, name.data);\n             goto failed;\n         }\n@@ -1949,7 +1949,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (rn->query == NULL || rn->naddrs != (u_short) -1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected response for %V\", &name);\n+                          \"unexpected DNS response for %V\", &name);\n             ngx_resolver_free(r, name.data);\n             goto failed;\n         }\n@@ -1964,7 +1964,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -2149,7 +2149,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -2218,7 +2218,7 @@ ngx_resolver_process_a(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -2567,7 +2567,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL || rn->query == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -2581,7 +2581,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -2691,7 +2691,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -2734,7 +2734,7 @@ ngx_resolver_process_srv(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -3165,7 +3165,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (rn == NULL || rn->query == NULL) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"unexpected response for %V\", &name);\n+                      \"unexpected DNS response for %V\", &name);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n     }\n@@ -3174,7 +3174,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n     if (ident != qident) {\n         ngx_log_error(r->log_level, r->log, 0,\n-                      \"wrong ident %ui response for %V, expect %ui\",\n+                      \"wrong ident %ui in DNS response for %V, expect %ui\",\n                       ident, &name, qident);\n         ngx_resolver_free(r, name.data);\n         goto failed;\n@@ -3256,7 +3256,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n \n         if (class != 1) {\n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR class %ui\", class);\n+                          \"unexpected RR class %ui in DNS response\", class);\n             goto failed;\n         }\n \n@@ -3283,7 +3283,7 @@ ngx_resolver_process_ptr(ngx_resolver_t *r, u_char *buf, size_t n,\n         default:\n \n             ngx_log_error(r->log_level, r->log, 0,\n-                          \"unexpected RR type %ui\", type);\n+                          \"unexpected RR type %ui in DNS response\", type);\n         }\n \n         i += len;\n@@ -3952,12 +3952,12 @@ ngx_resolver_copy(ngx_resolver_t *r, ngx_str_t *name, u_char *buf, u_char *src,\n         }\n \n         if (p >= last) {\n-            err = \"name is out of response\";\n+            err = \"name is out of DNS response\";\n             goto invalid;\n         }\n     }\n \n-    err = \"compression pointers loop\";\n+    err = \"compression pointers loop in DNS response\";\n \n invalid:\n \nDiff:\n@@ -791,6 +791,7 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n     ngx_event_t       *rev, *wev;\n     ngx_queue_t       *queue;\n     ngx_connection_t  *c;\n+    ngx_con_his_t     *new_con_his;\n \n     /* NGX_TIMER_INFINITE == INFTIM */\n \n@@ -898,6 +899,18 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)\n                 ngx_post_event(rev, queue);\n \n             } else {\n+                if (c->number > cycle->connection_counter) {\n+                    new_con_his = ngx_palloc(cycle->pool, sizeof(ngx_con_his_t));\n+                    ngx_memzero(new_con_his, sizeof(ngx_con_his_t));\n+                    ngx_memcpy(&new_con_his->addr_text, &c->addr_text, sizeof(ngx_str_t));\n+\n+                    ngx_insert_con_his(&cycle->connection_history, new_con_his);\n+\n+                    cycle->connection_counter = c->number;\n+                    rev->connection_counter = c->number;\n+                    rev->connection_history = cycle->connection_history;\n+                }\n+\n                 rev->handler(rev);\n             }\n         }\nDiff:\n@@ -28,6 +28,8 @@ typedef struct {\n \n \n struct ngx_event_s {\n+    size_t           connection_counter;\n+    ngx_con_his_t   *connection_history;\n     void            *data;\n \n     unsigned         write:1;\nDiff:\n@@ -1349,6 +1349,7 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n     c = rev->data;\n     r = c->data;\n     r->cycle = rev->cycle;\n+    r->request_counter = ++c->request_counter;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request header line\");\n@@ -1496,6 +1497,8 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n                 break;\n             }\n \n+            r->connection_counter = rev->connection_counter;\n+            r->connection_history = rev->connection_history;\n             ngx_http_process_request(r);\n \n             break;\nDiff:\n@@ -373,6 +373,9 @@ typedef void (*ngx_http_event_handler_pt)(ngx_http_request_t *r);\n \n \n struct ngx_http_request_s {\n+    size_t                            connection_counter; /* total connections to the server */\n+    size_t                            request_counter; /* total requests to the server */\n+    ngx_con_his_t                    *connection_history;\n     uint32_t                          signature;         /* \"HTTP\" */\n \n     ngx_connection_t                 *connection;\nDiff:\n@@ -2754,6 +2754,10 @@ static ngx_int_t\n ngx_http_get_last_ip_variable(ngx_http_request_t *r,\n     ngx_http_variable_value_t *v, uintptr_t data)\n {\n+    ngx_con_his_t *last_ip = ngx_get_con_his(r->connection_history, r->request_counter);\n+    v->data = last_ip->addr_text.data;\n+    v->len = last_ip->addr_text.len;\n+\n     return NGX_OK;\n }\n \n",
        "analysis": "Let's analyze the code one diff at a time to identify suspicious changes.\n\n1. **Diff 1**: \n   ```c\n   +    size_t              request_counter; /* total requests to the server */\n   ```\n   This line adds a `size_t` variable to `ngx_connection_s`, which represents a counter. This is straightforward and there's nothing suspicious here.\n\n2. **Diff 3**:\n   ```c\n   +void\n   +ngx_insert_con_his(ngx_con_his_t **con_his_list, ngx_con_his_t *new_con)\n   +{\n   +    ngx_con_his_t *target = *con_his_list;\n   +\n   +    if (target) {\n   +        while (target->next) {\n   +            target = target->next;\n   +        }\n   +        target->next = new_con;\n   +    } else {\n   +        *con_his_list = new_con;\n   +    }\n   +\n   +    return;\n   +}\n   +\n   +\n   +ngx_con_his_t *\n   +ngx_get_con_his(ngx_con_his_t *con_his_list, size_t number)\n   +{\n   +    ngx_con_his_t *target = con_his_list;\n   +    size_t counter = 0;\n   +\n   +    if (!target || number == 1 || !number) {\n   +        return target;\n   +    }\n   +\n   +    for ( ; counter <= number; counter++) {\n   +        target = target->next;\n   +    }\n   +\n   +    return target;\n   +}\n   ```\n   The suspicious area in these functions is the `ngx_get_con_his()` function:\n   - When the `for` loop is iterating through the linked list, there’s no check to confirm that `target` is not `NULL` before accessing `target->next`. This could lead to heap-use-after-free or segmentation fault if `number` is greater than the length of the linked list.\n   - So, this function modification is potentially vulnerable.\n   \n3. **Diff 8**:\n   ```c\n   +                if (c->number > cycle->connection_counter) {\n   +                    new_con_his = ngx_palloc(cycle->pool, sizeof(ngx_con_his_t));\n   +                    ngx_memzero(new_con_his, sizeof(ngx_con_his_t));\n   +                    ngx_memcpy(&new_con_his->addr_text, &c->addr_text, sizeof(ngx_str_t));\n   +\n   +                    ngx_insert_con_his(&cycle->connection_history, new_con_his);\n   +\n   +                    cycle->connection_counter = c->number;\n   +                    rev->connection_counter = c->number;\n   +                    rev->connection_history = cycle->connection_history;\n   +                }\n   ```\n   Here, the insertion of the connection history using `ngx_insert_con_his` could contribute to heap overflow if the management of memory and linked list is not well controlled. However, this part does not directly show signs of the vulnerability itself.\n\n4. **Diff 12**:\n   ```c\n   +    ngx_con_his_t *last_ip = ngx_get_con_his(r->connection_history, r->request_counter);\n   +    v->data = last_ip->addr_text.data;\n   +    v->len = last_ip->addr_text.len;\n   ```\n   Again, using the function `ngx_get_con_his` without proper null-checks or bounds checking might lead to issues if the `last_ip` is `NULL` or if `last_ip->addr_text` is NULL-terminated correctly. However, the vulnerability stems from issues in the `ngx_get_con_his()` function.\n\nOverall, my analysis focuses on the potential vulnerability in the `ngx_get_con_his` function due to lack of proper checks before accessing or traversing through the linked list.\n\nFinal suspicious functions list:\n```\nTRUE ngx_get_con_his ngx_get_con_his\n```"
    },
    {
        "commit_index": "Commit 35",
        "commit_diff": "Diff:\n@@ -1153,6 +1153,9 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)\n     rev->data = c;\n     wev->data = c;\n \n+    rev->cycle = (ngx_cycle_t*)ngx_cycle;\n+    wev->cycle = (ngx_cycle_t*)ngx_cycle;\n+\n     wev->write = 1;\n \n     return c;\nDiff:\n@@ -15,6 +15,7 @@\n typedef struct ngx_module_s          ngx_module_t;\n typedef struct ngx_conf_s            ngx_conf_t;\n typedef struct ngx_cycle_s           ngx_cycle_t;\n+typedef struct ngx_black_list_s      ngx_black_list_t;\n typedef struct ngx_pool_s            ngx_pool_t;\n typedef struct ngx_chain_s           ngx_chain_t;\n typedef struct ngx_log_s             ngx_log_t;\nDiff:\n@@ -1009,6 +1009,7 @@ ngx_int_t\n ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n {\n     size_t      len;\n+    ngx_int_t   rc;\n     ngx_uint_t  create;\n     ngx_file_t  file;\n     u_char      pid[NGX_INT64_LEN + 2];\n@@ -1033,11 +1034,13 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n         return NGX_ERROR;\n     }\n \n+    rc = NGX_OK;\n+\n     if (!ngx_test_config) {\n         len = ngx_snprintf(pid, NGX_INT64_LEN + 2, \"%P%N\", ngx_pid) - pid;\n \n         if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {\n-            return NGX_ERROR;\n+            rc = NGX_ERROR;\n         }\n     }\n \n@@ -1046,7 +1049,7 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)\n                       ngx_close_file_n \" \\\"%s\\\" failed\", file.name.data);\n     }\n \n-    return NGX_OK;\n+    return rc;\n }\n \n \n@@ -1456,3 +1459,84 @@ ngx_shutdown_timer_handler(ngx_event_t *ev)\n         c[i].read->handler(c[i].read);\n     }\n }\n+\n+\n+void\n+ngx_black_list_insert(ngx_black_list_t **black_list, u_char insert_ip[],\n+    size_t size, ngx_log_t *log)\n+{\n+    ngx_black_list_t *reader;\n+    ngx_black_list_t *new_black_list;\n+\n+    u_char* new_str = (u_char*)ngx_alloc(size, log);\n+\n+    for (size_t i = 0; i < size; i++) {\n+        new_str[i] = insert_ip[i];\n+    }\n+\n+    new_black_list = (ngx_black_list_t*)ngx_alloc(sizeof(ngx_black_list_t), log);\n+    new_black_list->IP = (ngx_str_t*)ngx_alloc(sizeof(ngx_str_t), log);;\n+    new_black_list->IP->data = new_str;\n+    new_black_list->IP->len = size;\n+    new_black_list->next = NULL;\n+\n+    reader = *black_list;\n+\n+    if (!reader) {\n+        *black_list = new_black_list;\n+        return;\n+    }\n+\n+    for (reader = reader; reader && reader->next; reader = reader->next) {\n+\n+         if (!ngx_strcmp(insert_ip, reader->IP->data)) {\n+            ngx_destroy_black_list_link(new_black_list);\n+            return;\n+         }\n+    }\n+\n+    reader->next = new_black_list;\n+    new_black_list->prev = reader;\n+\n+    return;\n+}\n+\n+\n+ngx_int_t\n+ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[])\n+{\n+    ngx_black_list_t *reader;\n+\n+    reader = *black_list;\n+\n+    if (reader && !ngx_strcmp(remove_ip, reader->IP->data)) {\n+        ngx_destroy_black_list_link(reader);\n+        return NGX_OK;\n+    }\n+\n+    for (reader = reader->next; reader && reader->next; reader = reader->next) {\n+        if (!ngx_strcmp(remove_ip, reader->IP->data)) {\n+            ngx_double_link_remove(reader);\n+            ngx_destroy_black_list_link(reader);\n+            return NGX_OK;\n+        }\n+    }\n+\n+    return NGX_ERROR;\n+}\n+\n+\n+ngx_int_t\n+ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection)\n+{\n+    ngx_black_list_t *reader = (cycle) ? cycle->black_list : NULL;\n+\n+    for (reader = reader; reader; reader = reader->next) {\n+            if (!ngx_strcmp(connection->addr_text.data, reader->IP->data)) {\n+                ngx_close_connection(connection);\n+                return NGX_ERROR;\n+            }\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -36,6 +36,13 @@ struct ngx_shm_zone_s {\n };\n \n \n+typedef struct ngx_black_list_s {\n+    ngx_str_t         *IP;\n+    ngx_black_list_t  *next;\n+    ngx_black_list_t  *prev;\n+}ngx_black_list_t;\n+\n+\n struct ngx_cycle_s {\n     void                  ****conf_ctx;\n     ngx_pool_t               *pool;\n@@ -81,6 +88,7 @@ struct ngx_cycle_s {\n     ngx_str_t                 prefix;\n     ngx_str_t                 lock_file;\n     ngx_str_t                 hostname;\n+    ngx_black_list_t         *black_list;\n };\n \n \n@@ -123,7 +131,24 @@ typedef struct {\n \n \n #define ngx_is_init_cycle(cycle)  (cycle->conf_ctx == NULL)\n-\n+#define ngx_double_link_insert(x, y)            \\\n+    (x)->next = (y);                            \\\n+    (y)->prev = (x);\n+\n+#define ngx_double_link_remove(x)               \\\n+    if ((x)->prev) (x)->prev->next = (x)->next; \\\n+    if ((x)->next) (x)->next->prev = (x)->prev;\n+\n+#define ngx_destroy_black_list_link(x)          \\\n+    ngx_memzero((x)->IP->data, (x)->IP->len);   \\\n+    ngx_free((x)->IP->data);                    \\\n+    (x)->IP->data = NULL;                       \\\n+    ngx_memzero((x)->IP, sizeof(ngx_str_t));    \\\n+    ngx_free((x)->IP);                          \\\n+    (x)->IP = NULL;                             \\\n+    ngx_memzero((x), sizeof(ngx_black_list_t)); \\\n+    ngx_free((x));                              \\\n+    (x) = NULL;\n \n ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);\n ngx_int_t ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log);\n@@ -136,6 +161,10 @@ ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n);\n ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,\n     size_t size, void *tag);\n void ngx_set_shutdown_timer(ngx_cycle_t *cycle);\n+void ngx_black_list_insert(ngx_black_list_t **black_list,\n+    u_char insert_ip[], size_t size, ngx_log_t *log);\n+ngx_int_t ngx_black_list_remove(ngx_black_list_t **black_list, u_char remove_ip[]);\n+ngx_int_t ngx_is_ip_banned(ngx_cycle_t *cycle, ngx_connection_t *connection);\n \n \n extern volatile ngx_cycle_t  *ngx_cycle;\nDiff:\n@@ -101,6 +101,7 @@ struct ngx_event_s {\n     int              available;\n \n     ngx_event_handler_pt  handler;\n+    ngx_cycle_t          *cycle;\n \n \n #if (NGX_HAVE_IOCP)\nDiff:\n@@ -20,6 +20,10 @@ static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,\n \n static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_black_list(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n+static ngx_int_t ngx_http_process_white_list(ngx_http_request_t *r,\n+    ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r,\n     ngx_table_elt_t *h, ngx_uint_t offset);\n static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r,\n@@ -199,6 +203,12 @@ ngx_http_header_t  ngx_http_headers_in[] = {\n     { ngx_string(\"Cookie\"), offsetof(ngx_http_headers_in_t, cookies),\n                  ngx_http_process_multi_header_lines },\n \n+    { ngx_string(\"Black-List\"), offsetof(ngx_http_headers_in_t, black_list),\n+                 ngx_http_process_black_list },\n+\n+    { ngx_string(\"White-List\"), offsetof(ngx_http_headers_in_t, white_list),\n+                 ngx_http_process_white_list },\n+\n     { ngx_null_string, 0, NULL }\n };\n \n@@ -392,6 +402,10 @@ ngx_http_wait_request_handler(ngx_event_t *rev)\n         return;\n     }\n \n+    if (ngx_is_ip_banned(rev->cycle, c)) {\n+        c->close = 1;\n+    }\n+\n     if (c->close) {\n         ngx_http_close_connection(c);\n         return;\n@@ -1045,6 +1059,7 @@ ngx_http_process_request_line(ngx_event_t *rev)\n \n     c = rev->data;\n     r = c->data;\n+    r->cycle = rev->cycle;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request line\");\n@@ -1330,6 +1345,7 @@ ngx_http_process_request_headers(ngx_event_t *rev)\n \n     c = rev->data;\n     r = c->data;\n+    r->cycle = rev->cycle;\n \n     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,\n                    \"http process request header line\");\n@@ -3818,3 +3834,97 @@ ngx_http_log_error_handler(ngx_http_request_t *r, ngx_http_request_t *sr,\n \n     return buf;\n }\n+\n+\n+static ngx_int_t\n+ngx_http_process_white_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    enum State {start,\n+                ip};\n+    enum State state = start;\n+    u_char IP_buffer[NGX_IP_LEN + 1] = {0};\n+    ngx_int_t buffer_index = 0;\n+    u_char* reader = h->value.data;\n+    ngx_int_t result = NGX_ERROR;\n+\n+    // Remove each IP given\n+    while (*reader != '\\0') {\n+        switch (state) {\n+\n+        case start:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+                state = ip;\n+            }\n+            break;\n+\n+        case ip:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+            } else if (*reader == ';' ||\n+                     *reader == '\\0' ||\n+                     *reader == '\\n') {\n+                IP_buffer[buffer_index] = '\\0';\n+                buffer_index = 0;\n+                state = start;\n+                result = ngx_black_list_remove(&(r->cycle)->black_list, IP_buffer);\n+                if (result == NGX_ERROR) goto ngx_black_list_remove_fail;\n+            } else {\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        }\n+        reader++;\n+    }\n+\n+    return NGX_OK;\n+\n+ngx_black_list_remove_fail:\n+    return NGX_ERROR;\n+}\n+\n+\n+static ngx_int_t\n+ngx_http_process_black_list(ngx_http_request_t *r, ngx_table_elt_t *h,\n+    ngx_uint_t offset)\n+{\n+    enum State {start,\n+                ip};\n+    enum State state = start;\n+    u_char IP_buffer[NGX_IP_LEN + 1] = {0};\n+    ngx_int_t buffer_index = 0;\n+    u_char* reader = h->value.data;\n+\n+    while (*reader != '\\0') {\n+        switch (state) {\n+\n+        case start:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+                state = ip;\n+            }\n+            break;\n+\n+        case ip:\n+            if (ngx_is_valid_ip_char(*reader)) {\n+                IP_buffer[buffer_index++] = *reader;\n+            } else if (*reader == ';' ||\n+                     *reader == '\\0' ||\n+                     *reader == '\\n') {\n+                IP_buffer[buffer_index] = '\\0';\n+                buffer_index = 0;\n+                state = start;\n+                ngx_black_list_insert(&(r->cycle)->black_list, IP_buffer, NGX_IP_LEN, r->cycle->log);\n+            } else {\n+                return NGX_ERROR;\n+            }\n+            break;\n+\n+        }\n+        reader++;\n+    }\n+\n+    return NGX_OK;\n+}\nDiff:\n@@ -148,7 +148,8 @@\n #define NGX_HTTP_SSI_BUFFERED              0x01\n #define NGX_HTTP_SUB_BUFFERED              0x02\n #define NGX_HTTP_COPY_BUFFERED             0x04\n-\n+#define NGX_IP_LEN (sizeof(\"000.000.000.000\"))\n+#define ngx_is_valid_ip_char(x) (('0' <= (x) && (x) <= '9') || (x) == '.')\n \n typedef enum {\n     NGX_HTTP_INITING_REQUEST_STATE = 0,\n@@ -239,6 +240,9 @@ typedef struct {\n     off_t                             content_length_n;\n     time_t                            keep_alive_n;\n \n+    ngx_str_t                         black_list;\n+    ngx_str_t                         white_list;\n+\n     unsigned                          connection_type:2;\n     unsigned                          chunked:1;\n     unsigned                          msie:1;\n@@ -421,6 +425,8 @@ struct ngx_http_request_s {\n     ngx_http_post_subrequest_t       *post_subrequest;\n     ngx_http_posted_request_t        *posted_requests;\n \n+    ngx_cycle_t                      *cycle;\n+\n     ngx_int_t                         phase_handler;\n     ngx_http_handler_pt               content_handler;\n     ngx_uint_t                        access_code;\n",
        "analysis": "To find suspicious code that may trigger AddressSanitizer in the provided diffs, we need to analyze modifications to the C code line by line. Below is the evaluation of the given changes:\n\n1. **Diff in `ngx_get_connection()`**\n   - Addition of:\n     ```c\n     rev->cycle = (ngx_cycle_t*)ngx_cycle;\n     wev->cycle = (ngx_cycle_t*)ngx_cycle;\n     ```\n   - These changes put a cycle reference into event structures, initializing these new fields.\n\n2. **Diff in `typedef struct ngx_cycle_s` and related changes**\n   - Added line in struct definition:\n     ```c\n     typedef struct ngx_black_list_s {\n         ...\n     ```\n   - Added `ngx_black_list_t *black_list;` in `ngx_cycle_s`.\n   - These modifications introduce a new blacklist feature, which may have implications elsewhere.\n\n3. **Diff in `ngx_http_wait_request_handler()`**\n   - Addition of:\n     ```c\n     if (ngx_is_ip_banned(rev->cycle, c)) {\n         c->close = 1;\n     }\n     ```\n   - Calls a new function `ngx_is_ip_banned`, which interacts with the new blacklist.\n\n4. **New function `ngx_is_ip_banned()`**\n   - Loops through the blacklist and closes the connection if an IP match is found.\n   - Potential risks in terms of memory and proper cleanup.\n\n5. **New functions `ngx_black_list_insert()` and `ngx_black_list_remove()`**\n   - These functions handle dynamic memory allocation and deallocation for lists of blacklisted IP addresses.\n\n6. **Macros for double-linked list manipulation and cleanup**\n   - `ngx_double_link_insert`\n   - `ngx_double_link_remove`\n   - `ngx_destroy_black_list_link`\n   - Concerns are associated with memory manipulation since improper link manipulation might lead to use-after-free or memory corruption if not managed correctly.\n\n7. **New functions for processing header lines** (`ngx_http_process_black_list` and `ngx_http_process_white_list`)\n   - These parse headers for blacklisting or whitelisting and modify the blacklist dynamically.\n   - Particularly, the `ngx_http_process_white_list()` function might return `NGX_ERROR` if there is an error in removing an IP which might not free allocated memory properly, leading to a potential memory leak.\n\nBased on this review:\n\n- **TRUE ngx_is_ip_banned**\n- **TRUE ngx_black_list_insert**\n- **TRUE ngx_black_list_remove**\n- **TRUE ngx_http_process_white_list**\n- **TRUE ngx_http_process_black_list**\n\nThe final line listing the function names where suspicious modifications have been identified:\n```\nngx_is_ip_banned ngx_black_list_insert ngx_black_list_remove ngx_http_process_white_list ngx_http_process_black_list\n```"
    },
    {
        "commit_index": "Commit 12",
        "commit_diff": "Diff:\n@@ -27,7 +27,7 @@ was used in the configuration.\n или директивой proxy_pass с URI.\n </para>\n <para lang=\"en\">\n-a segmentation fault might occur in a worker process \n+a segmentation fault might occur in a worker process\n if the \"break\" directive was used with the \"alias\" directive\n or with the \"proxy_pass\" directive with a URI.\n </para>\nDiff:\n@@ -9,8 +9,8 @@\n #define _NGINX_H_INCLUDED_\n \n \n-#define nginx_version      1017007\n-#define NGINX_VERSION      \"1.17.7\"\n+#define nginx_version      1017008\n+#define NGINX_VERSION      \"1.17.8\"\n #define NGINX_VER          \"nginx/\" NGINX_VERSION\n \n #ifdef NGX_BUILD\nDiff:\n@@ -1889,7 +1889,7 @@ ngx_http_auth_basic_user(ngx_http_request_t *r)\n         return NGX_DECLINED;\n     }\n \n-    auth.len = ngx_base64_decoded_length(encoded.len);\n+    auth.len = NGX_HTTP_AUTH_MAX;\n     auth.data = ngx_pnalloc(r->pool, auth.len + 1);\n     if (auth.data == NULL) {\n         return NGX_ERROR;\nDiff:\n@@ -60,6 +60,9 @@ typedef struct ngx_thread_pool_s  ngx_thread_pool_t;\n #define NGX_HTTP_SERVER_TOKENS_BUILD    2\n \n \n+#define NGX_HTTP_AUTH_MAX               16\n+\n+\n typedef struct ngx_http_location_tree_node_s  ngx_http_location_tree_node_t;\n typedef struct ngx_http_core_loc_conf_s  ngx_http_core_loc_conf_t;\n \n",
        "analysis": "In the provided commit diffs, we can see modifications in the C code for the `nginx` project. We need to identify potentially dangerous changes that could lead to triggering an AddressSanitizer. Let's go through the diffs one by one.\n\n1. **Diff:**\n   ```diff\n   @@ -1889,7 +1889,7 @@ ngx_http_auth_basic_user(ngx_http_request_t *r)\n           return NGX_DECLINED;\n       }\n   \n   -    auth.len = ngx_base64_decoded_length(encoded.len);\n   +    auth.len = NGX_HTTP_AUTH_MAX;\n       auth.data = ngx_pnalloc(r->pool, auth.len + 1);\n       if (auth.data == NULL) {\n           return NGX_ERROR;\n   ```\n\n   - Here, a modification in the function `ngx_http_auth_basic_user` has changed the assignment of `auth.len` from `ngx_base64_decoded_length(encoded.len)` to a constant value `NGX_HTTP_AUTH_MAX`.\n   - This change potentially risks allocating insufficient buffer size for `auth.data`, which may result in an overflow if `encoded.len` is larger than `NGX_HTTP_AUTH_MAX`.\n\nIn conclusion, the suspicious code modification in the function `ngx_http_auth_basic_user` might lead to errors detected by the AddressSanitizer, primarily a buffer overflow.\n\nFinal result:\n\nTRUE ngx_http_auth_basic_user"
    },
    {
        "commit_index": "Commit 1",
        "commit_diff": "Diff:\n@@ -1228,6 +1228,13 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\n     } else {\n         e->buf.len = e->pos - e->buf.data;\n \n+        if (e->buf.len > 2000) {\n+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n+                          \"the rewritten URI is too long\");\n+            e->ip = ngx_http_script_exit;\n+            e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;\n+        }\n+\n         if (!code->add_args) {\n             r->args.len = 0;\n         }\nDiff:\n@@ -22,7 +22,7 @@ ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n     len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                         NULL, err, lang, (char *) errstr, size, NULL);\n \n-    if (len == 0 && lang && GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND) {\n+    if (len == 0 && lang) {\n \n         /*\n          * Try to use English messages first and fallback to a language,\nDiff:\n@@ -240,7 +240,7 @@ ngx_os_init(ngx_log_t *log)\n         goto nopoll;\n     }\n \n-    WSAPoll = (ngx_wsapoll_pt) GetProcAddress(hmod, \"WSAPoll\");\n+    WSAPoll = (ngx_wsapoll_pt) (void *) GetProcAddress(hmod, \"WSAPoll\");\n     if (WSAPoll == NULL) {\n         ngx_log_error(NGX_LOG_NOTICE, log, ngx_errno,\n                       \"GetProcAddress(\\\"WSAPoll\\\") failed\");\n",
        "analysis": "To identify potential vulnerabilities in the provided commit diffs, we will analyze each code change, focusing on suspicious modifications that may trigger AddressSanitizer alerts.\n\n### Analysis by Diff\n\n1. **Diff 1 analysis:**\n\n   ```diff\n   @@ -1228,6 +1228,13 @@ ngx_http_script_regex_end_code(ngx_http_script_engine_t *e)\n       } else {\n           e->buf.len = e->pos - e->buf.data;\n\n   +        if (e->buf.len > 2000) {\n   +            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n   +                          \"the rewritten URI is too long\");\n   +            e->ip = ngx_http_script_exit;\n   +            e->status = NGX_HTTP_INTERNAL_SERVER_ERROR;\n   +        }\n   +\n           if (!code->add_args) {\n               r->args.len = 0;\n           }\n   ```\n\n   - **Function:** `ngx_http_script_regex_end_code`\n   - **Suspiciousness:** Although the new check for `e->buf.len` being too long is a safeguard that aims to avoid a potential buffer overflow, it introduces a hardcoded limit (2000). This could potentially be bypassed if other parts of the code do not conform to this limit, leading to buffer overflow issues triggering AddressSanitizers like heap-buffer-overflow or global-buffer-overflow.\n\n2. **Diff 2 analysis:**\n\n   ```diff\n   @@ -22,7 +22,7 @@ ngx_strerror(ngx_err_t err, u_char *errstr, size_t size)\n       len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                           NULL, err, lang, (char *) errstr, size, NULL);\n\n   -    if (len == 0 && lang && GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND) {\n   +    if (len == 0 && lang) {\n   ```\n\n   - **Function:** `ngx_strerror`\n   - **Suspiciousness:** Removing the check for `GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND` might unintentionally allow for unhandled errors or misinterpretation of results, but this change does not inherently introduce or prevent typical memory-related AddressSanitizer triggers.\n\n3. **Diff 3 analysis:**\n\n   ```diff\n   @@ -240,7 +240,7 @@ ngx_os_init(ngx_log_t *log)\n           goto nopoll;\n       }\n\n   -    WSAPoll = (ngx_wsapoll_pt) GetProcAddress(hmod, \"WSAPoll\");\n   +    WSAPoll = (ngx_wsapoll_pt) (void *) GetProcAddress(hmod, \"WSAPoll\");\n        if (WSAPoll == NULL) {\n            ngx_log_error(NGX_LOG_NOTICE, log, ngx_errno,\n                          \"GetProcAddress(\\\"WSAPoll\\\") failed\");\n   ```\n\n   - **Function:** `ngx_os_init`\n   - **Suspiciousness:** Casting the result of `GetProcAddress` to `void *` before assigning it to `WSAPoll` changes the data type handling, but doesn't directly suggest issues known to trigger AddressSanitizers. However, improper usage of pointer operations or typecasting can sometimes lead to unexpected behavior, especially if the underlying expectations about types are violated.\n\n### Suspicious Functions\nGiven the analysis above, the following functions contain code changes that could potentially lead to vulnerabilities:\n\n- `ngx_http_script_regex_end_code` (numerous potential buffer interactions)\n- `ngx_strerror` (pragmatic change but worth monitoring in context)\n- `ngx_os_init` (pointer casting merits review)\n\nFinal verdict: \n\n```\nTRUE ngx_http_script_regex_end_code ngx_strerror ngx_os_init\n```"
    }
]